<!DOCTYPE html>
<html lang="ja">

<head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# article: http://ogp.me/ns/article#">

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Dockerを使ってHaskellアプリをHerokuにデプロイする">
    <meta name="author" content="Haskell-jp">

    <!-- OGP Settings -->
    <meta property="og:title" content="Dockerを使ってHaskellアプリをHerokuにデプロイする - Haskell-jp" />
    <meta property="og:type" content="article" />
    <meta property="og:url" content="/posts/2017/02-haskell-on-heroku.html" />
    <meta property="og:image" content="https://haskell.jp/blog/img/logo-black-frame.png" />
    <meta property="og:site_name" content="Haskell-jp Blog" />
    <meta property="og:description" content="---これまで、HaskellのコードをHerokuで実行しようとすると、コンパイルがHerokuの制約時間内に終わらず、面倒なハックが必要でつらい状態でした。でも、Herokuが[Docker](https://www.docker.com/)をサポートするようになった今なら、Haskell製のウェブアプリケーションをHeroku上で公開するのはずっと簡単です。この記事では、Servant(Ha" />

    <!-- Twitter Card Settings -->
    <meta name="twitter:card" content="summary" />

    

    <title>Dockerを使ってHaskellアプリをHerokuにデプロイする - Haskell-jp</title>

    <!-- Bootstrap Core CSS -->
    <link href="../../css/bootstrap.css" rel="stylesheet">
    <!-- <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css" rel="stylesheet"> -->

    <!-- Pandoc syntax highlighting CSS -->
    <link href="../../css/syntax.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="../../css/clean-blog.css" rel="stylesheet">

    <!-- Our original CSS -->
    <link href="../../css/style.css" rel="stylesheet">

    <!-- Custom Fonts -->
    <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="https://haskell.jp"><img height="30px" src="../../img/logo.svg"></a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="https://haskell.jp">Home</a>
                    </li>
                    <li>
                        <a href="../../">Blog</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Header -->
    <header class="intro-header" style="background-image: url('../../img/post-bg.jpg')">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                  <div class="post-heading">
                    <h1>Dockerを使ってHaskellアプリをHerokuにデプロイする</h1>
                    <h2 class="subheading">コンパイル時間に制限されないデプロイ方法</h2><span class="meta">Posted by <a href="https://arow.info#arowM">Kadzuya Okamoto</a></span>
                  </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <article>
    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>これまで、<span class="ascii">Haskell</span>のコードを<span class="ascii">Heroku</span>で実行しようとすると、コンパイルが<span class="ascii">Heroku</span>の制約時間内に終わらず、面倒なハックが必要でつらい状態でした。 でも、<span class="ascii">Heroku</span>が<a href="https://www.docker.com/"><span class="ascii">Docker</span></a>をサポートするようになった今なら、<span class="ascii">Haskell</span>製のウェブアプリケーションを<span class="ascii">Heroku</span>上で公開するのはずっと簡単です。 この記事では、<span class="ascii">Servant(Haskell</span>の<span class="ascii">Web</span>フレームワークの<span class="ascii">1</span>つ<span class="ascii">)</span>で作ったアプリケーションを、<span class="ascii">Docker</span>の力を借りて<span class="ascii">Heroku</span>にデプロイする方法について、具体的なプログラムを使って順を追って説明していきます。</p>
<h2 id="本記事について">本記事について</h2>
<p>この記事は、<a href="https://arow.info/blog/posts/2017-03-30-servant-on-heroku.html"><span class="ascii">Releasing a Haskell Web App on Heroku with Docker</span></a>として<span class="ascii">Haskell-jp</span>オフィシャルスポンサーである<a href="http://arow.info/">株式会社<span class="ascii">ARoW</span></a>公式ブログに公開されている英語の記事を、許可を得て日本版にローカライズしたものです<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>。</p>
<h2 id="はじめに">はじめに</h2>
<p>今回、実際に<span class="ascii">Heroku</span>にデプロイして試せるように、<a href="https://github.com/cdepillabout/servant-on-heroku">サンプルアプリ</a>を用意しました。 この記事の<a href="#dockerを-使わずに-サンプルアプリを実行してみる">最初の章</a>では、このサンプルアプリをローカル環境で動かす方法について述べます。 <a href="#今度はdockerをつかってアプリを動かしてみよう">「今度は<span class="ascii">Docker</span>をつかってアプリを動かしてみよう！」</a>では、同じくローカル環境において、<span class="ascii">Docker</span>を使って動かす方法について触れます。 <a href="#herokuで動かす">「<span class="ascii">Heroku</span>で動かす」</a>で、ついに<span class="ascii">Heroku</span>にこのサンプルアプリを<span class="ascii">Heroku</span>にデプロイする方法についてお伝えします。</p>
<p>もし、ローカル環境で動かしたりするのが面倒で、「いきなり<span class="ascii">Heroku</span>にデプロイしたい！」という方は、 <a href="#herokuで動かす">「<span class="ascii">Heroku</span>で動かす」</a>から読んでいただいても問題ないように構成しているつもりです。</p>
<h2 id="dockerを-使わずに-サンプルアプリを実行してみる"><span class="ascii">Docker</span>を <strong>使わずに</strong> サンプルアプリを実行してみる</h2>
<p>今回用意したサンプルアプリは、以下の通り<span class="ascii">API</span>を<span class="ascii">2</span>つだけ提供する、とても単純なものです。</p>
<ul>
<li>かんたんなコメントのようなものを送信するための<span class="ascii">API</span></li>
<li>これまでに送信された全コメントを表示するための<span class="ascii">API</span></li>
</ul>
<p>このサンプルアプリでは、コメントを保存するのに<span class="ascii">PostgreSQL</span>を利用しています。</p>
<p>では、まずは<span class="ascii">Docker</span>や<span class="ascii">Heroku</span>をつかわないで、実際にローカルな環境でこのアプリをビルドして実行する手順を追っていきましょう。</p>
<h3 id="ローカル環境でサンプルアプリをビルドする">ローカル環境でサンプルアプリをビルドする</h3>
<p>まず最初に、このサンプルアプリを公開している<span class="ascii">github</span>レポジトリを<span class="ascii">clone</span>して、アプリをビルドしてみましょう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> clone https://github.com/cdepillabout/servant-on-heroku
$ <span class="bu">cd</span> servant-on-heroku/
$ <span class="ex">stack</span> setup  # このアプリが使っているバージョンのGHCをインストールします
$ <span class="ex">stack</span> build  # 依存パッケージをインストールし、ビルドします</code></pre></div>
<p>もしかしたら、<span class="ascii">PostgreSQL</span>のライブラリが入っていなくて、ビルドに失敗してしまうかもしれません。</p>
<p><span class="ascii">Arch Linux</span>の場合は、以下のコマンドで必要なライブラリをインストールできます。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">sudo</span> pacman -Ss postgresql-libs</code></pre></div>
<p><span class="ascii">Ubuntu</span>ユーザの方は、以下のコマンドで大丈夫です。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">sudo</span> apt-get install libpq-dev</code></pre></div>
<p>上記以外のプラットフォームでは別のコマンドを使うことになると思うので、いい感じにググってください。</p>
<p>では、<span class="ascii">PostgreSQL</span>の必要なライブラリを入れたところで、<code>stack build</code>をもう一度試してみましょう。今度はうまくいきましたよね？</p>
<p>うまくビルドできたら、アプリの実行をしてみます。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">stack</span> exec -- servant-on-heroku-api</code></pre></div>
<p>わーお！なにかエラーが出ちゃいますね…</p>
<pre><code>servant-on-heroku-api: libpq: failed (could not connect to server: Connection refused
        Is the server running on host &quot;localhost&quot; (::1) and accepting
        TCP/IP connections on port 5432?
        could not connect to server: Connection refused
        Is the server running on host &quot;localhost&quot; (127.0.0.1) and accepting
        TCP/IP connections on port 5432?
)</code></pre>
<p>サンプルアプリが<span class="ascii">PostgreSQL</span>に接続しようとして失敗しているようです。 このアプリは、コメントを<span class="ascii">PostgreSQL</span>に保存しているので、<span class="ascii">PostgreSQL</span>がローカルな環境で動いていないと、うまく動きません。</p>
<h3 id="postgresqlのセットアップ"><span class="ascii">PostgreSQL</span>のセットアップ</h3>
<p>お使いの環境によって、<span class="ascii">PostgreSQL</span>のインストール方法はまちまちなので、 そのプラットフォームが提供しているドキュメントにしたがって、<span class="ascii">PostgreSQL</span>のインストールを行ってください。</p>
<p>たとえば、<span class="ascii">Arch Linux</span>の場合は<a href="https://wiki.archlinux.org/index.php/PostgreSQL#Installing_PostgreSQL">このドキュメント</a>です。 <span class="ascii">Ubuntu</span>なら<a href="https://help.ubuntu.com/community/PostgreSQL#Installation">ここ</a>にドキュメントがあります。</p>
<p>さて、<span class="ascii">PostgreSQL</span>をインストールして、動いているのが確認できたら、もう一度アプリを起動してみましょう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">stack</span> exec -- servant-on-heroku-api</code></pre></div>
<p>わーお… またもやエラーです…</p>
<pre><code>servant-on-heroku-api: libpq: failed (FATAL:  role &quot;mydbuser&quot; does not exist
)</code></pre>
<p>どうやら、このサンプルアプリ用に、<span class="ascii">PostgreSQL</span>のユーザとデータベースを用意しないといけないようですね。 実際にサンプルアプリのソースコード<span class="ascii">(</span><code>src/Lib.hs</code><span class="ascii">)</span>を見てみると、<code>DATABASE_URL</code>という環境変数の値を見て<span class="ascii">PostgreSQL</span>サーバに接続しているのがわかります。</p>
<p><code>DATABASE_URL</code>環境変数が指定されていない場合は、以下のデフォルト値が使われます。</p>
<pre><code>postgres://mydbuser:mydbpass@localhost:5432/mydb</code></pre>
<p><code>mydbuser</code>というユーザ名で、<code>mydbpass</code>というパスワードを使って<code>mydb</code>という名前のデータベースにアクセスしようとしているということですね。 では、実際にこのユーザとデータベースを<span class="ascii">PostgreSQL</span>で作成してみましょう。 次のコマンドは<span class="ascii">Arch Linux</span>でしか動かないかもしれません。 もし動かないようであれば、お使いのプラットフォームが提供するドキュメントを参照してください。</p>
<p>最初に、<code>mydbuser</code>という名前のユーザを、<code>mydbpass</code>というパスワードで作成しましょう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">sudo</span> -u postgres -- psql --command <span class="st">&quot;CREATE ROLE mydbuser NOSUPERUSER NOCREATEDB NOCREATEROLE INHERIT LOGIN ENCRYPTED PASSWORD 'mydbpass'&quot;</span></code></pre></div>
<p>次に<code>mydb</code>という名前のデータベースを作成します。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">sudo</span> -u postgres -- createdb mydb</code></pre></div>
<p><code>mydbuser</code>が<code>mydb</code>データベースにアクセスできるようにするのも忘れちゃいけませんね。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">sudo</span> -u postgres -- psql --command <span class="st">&quot;GRANT ALL PRIVILEGES ON DATABASE mydb TO mydbuser&quot;</span></code></pre></div>
<p>ここで、<span class="ascii">PostgreSQL</span>の再起動をしておいた方が無難でしょう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">sudo</span> systemctl restart postgresql</code></pre></div>
<p>これで、実際に<code>mydb</code>データベースに、<code>mydbuser</code>としてログインすることができるようになったはずです。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">psql</span> -U mydbuser -d mydb -h 127.0.0.1</code></pre></div>
<h3 id="apiを実際にたたいてみる"><span class="ascii">API</span>を実際にたたいてみる</h3>
<p>では、<span class="ascii">PostgreSQL</span>のセットアップが無事終了したところで、次のコマンドでアプリケーションを立ち上げてみましょう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">stack</span> exec -- servant-on-heroku-api
<span class="ex">running</span> servant-on-heroku on port 8080...</code></pre></div>
<p>無事に立ち上がったら、コメントを送ってみます。 アプリが立ち上がった状態で、別のターミナルなどを開いて次のコマンドを打ってみてください。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">curl</span> --request POST \
    --header <span class="st">'Content-Type: application/json'</span> \
    --data <span class="st">'{&quot;author&quot;: &quot;DG&quot;, &quot;text&quot;: &quot;Pretty good&quot;}'</span> \
    <span class="st">'http://localhost:8080/add-comment'</span>
<span class="kw">{</span> <span class="st">&quot;text&quot;</span>: <span class="st">&quot;Pretty good&quot;</span>, <span class="st">&quot;author&quot;</span>: <span class="st">&quot;DG&quot;</span> <span class="kw">}</span></code></pre></div>
<p>よさそうですね！</p>
<p>では、全コメントを取得してみます。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">curl</span> --request GET \
    --header <span class="st">'Content-Type: application/json'</span> \
    <span class="st">'http://localhost:8080/get-comments'</span>
[{<span class="st">&quot;text&quot;</span>:<span class="st">&quot;Pretty good&quot;</span>,<span class="st">&quot;author&quot;</span>:<span class="st">&quot;DG&quot;</span>} ]</code></pre></div>
<p>いいですね！ <span class="ascii">DG (Dennis Gosnell /</span> 原著者<span class="ascii">)</span>さんが「チョベリグ！」と言っています。 以上で、ローカル環境でアプリを動かすことができたので、次は<span class="ascii">Docker</span>を使ってみましょう！</p>
<h2 id="今度はdockerをつかってアプリを動かしてみよう">今度は<strong><span class="ascii">Docker</span>をつかって</strong>アプリを動かしてみよう！</h2>
<p><a href="https://www.docker.com/"><span class="ascii">Docker</span></a>はコンテナ技術を用いたプログラムで、これを使うと仮想環境下でアプリをビルドしたり実際に動かしたりすることができます。 以降では、読者のみなさまがある程度<span class="ascii">Docker</span>について知っている前提で進めていきますが、たぶんそんなによく知らなくても「まぁそんなもんなんだろう」と思いながら読んでいただければ差し支えないと思います。 実際、日本語ローカライズ版を作ってる僕だって、そんなに<span class="ascii">Docker</span>に詳しいわけではありません。</p>
<h3 id="dockerをインストールする"><span class="ascii">Docker</span>をインストールする</h3>
<p><span class="ascii">Docker</span>のインストール方法は環境によってまちまちなので、ご自身の環境に合わせて信用できるドキュメントを参照してください。 <a href="https://wiki.archlinux.org/index.php/Docker#Installation"><span class="ascii">Arch Linux</span>の場合</a>や<a href="https://docs.docker.com/engine/installation/linux/ubuntu/"><span class="ascii">Ubuntu</span>の場合</a>はリンク先を読めばなんとかなると思います。</p>
<p><span class="ascii">Docker</span>のインストールが終わったら、以下のコマンドを実行して<span class="ascii">Docker</span>がちゃんと動いているか確認してみてください。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">docker</span> info</code></pre></div>
<h3 id="dockerを使ってビルドする"><span class="ascii">Docker</span>を使ってビルドする</h3>
<p>では、実際に<span class="ascii">Docker</span>を使ってサンプルアプリをビルドし、そのアプリを動かすための<span class="ascii">Docker</span>イメージを作成します。</p>
<p>アプリケーションをビルドするには、<code>docker build</code>コマンドを使います。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">docker</span> build -t servant-on-heroku .</code></pre></div>
<p>このコマンドを実行すると、実行したディレクトリ内に存在する<a href="https://github.com/cdepillabout/servant-on-heroku/blob/master/Dockerfile"><code>Dockerfile</code></a>という名前のファイルにしたがってアプリをビルドしてくれます。 この<code>Dockerfile</code>には、アプリをビルドするための具体的な手順がすべて記述されており、その手続きにしたがって、まったく別の環境でも<span class="ascii">Docker</span>さえあればアプリを実行できる「イメージ」を作成できます。</p>
<p>ためしに、このサンプルアプリに含まれる<code>Dockerfile</code>の中身を見てみましょう。 以下の各処理を実行するようになっています。</p>
<ol style="list-style-type: decimal">
<li><code>apt-get</code>コマンドを使って、依存パッケージをインストール</li>
<li><code>stack</code>をインストール</li>
<li><code>stack.yaml</code>を見て、実際に必要なバージョンの<span class="ascii">GHC</span>を<code>stack</code>を使ってインストールする</li>
<li><code>*.cabal</code>ファイルの記述にしたがって、アプリが使っている<span class="ascii">Haskell</span>パッケージをインストールする</li>
<li><code>stack</code>を使って実際にアプリをビルドする</li>
<li><span class="ascii">root</span>ユーザでアプリを実行したくないので、<span class="ascii">root</span>権限をもつ別のユーザを作成しておく</li>
<li>実際にアプリを実行する</li>
</ol>
<p>前述した<code>docker build</code>コマンドを実行して<code>servant-on-heroku</code>という名前のイメージを作成するには<span class="ascii">1</span>時間近くかかるので<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>、その間にご飯を食べたり録画しておいたアニメを<span class="ascii">2</span>本見れます。</p>
<h3 id="dockerをつかってapiをテストする"><span class="ascii">Docker</span>をつかって<span class="ascii">API</span>をテストする</h3>
<p><code>docker build</code>が終わったら、<code>docker images</code>でローカル環境に存在する全イメージを一覧表示してみましょう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">docker</span> images
<span class="ex">REPOSITORY</span>           TAG       IMAGE ID       CREATED         SIZE
<span class="ex">servant-on-heroku</span>    latest    ff591d372461   30 seconds ago  3.92 GB
<span class="ex">...</span></code></pre></div>
<p>さきほど作成した<code>servant-on-heroku</code>のイメージが作成されているのがわかりますね？</p>
<p>では、<code>servant-on-heroku</code>のイメージを走らせてみましょう。次のコマンドを実行すれば、<span class="ascii">Docker</span>内でこのサンプルアプリが動くはずです。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">docker</span> run --interactive --tty --rm servant-on-heroku</code></pre></div>
<p>あぁ… また<span class="ascii">PostgreSQL</span>の例の問題が出てしまったみたいですね…</p>
<pre><code>servant-on-heroku-api: libpq: failed (could not connect to server: Connection refused
        Is the server running on host &quot;localhost&quot; (::1) and accepting
        TCP/IP connections on port 5432?
could not connect to server: Connection refused
        Is the server running on host &quot;localhost&quot; (127.0.0.1) and accepting
        TCP/IP connections on port 5432?
)</code></pre>
<p>これはどういうことでしょうか。 <code>servant-on-heroku</code>コンテナは<span class="ascii">Docker</span>コンテナとして動いているため、初期設定では我々のローカル環境が見えず、もちろんローカル環境にセットアップして<code>localhost:5432</code>で動いている<span class="ascii">PostgreSQL</span>も見えないのです。</p>
<p>では、ちょっとしたワザを使ってこの問題を解決してみましょう。 <code>servant-on-heroku</code>コンテナを動かしている時に、<span class="ascii">Docker</span>に我々のローカル環境のネットワークインタフェースを使うように指示することができます。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">docker</span> run --interactive --tty --rm --network host servant-on-heroku
<span class="ex">running</span> servant-on-heroku on port 8080...</code></pre></div>
<p>ほら、こうすれば、確かに<span class="ascii">Docker</span>コンテナから<span class="ascii">PostgreSQL</span>にアクセスできているようです。</p>
<p><code>servant-on-heroku</code>コンテナが動いている状態で別のシェルを立ち上げて、前の章でやったように<code>curl</code>コマンドで<span class="ascii">API</span>が動いているか確かめてみましょう。 まずはコメントの投稿です。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">curl</span> --request POST \
    --header <span class="st">'Content-Type: application/json'</span> \
    --data <span class="st">'{&quot;author&quot;: &quot;EK&quot;, &quot;text&quot;: &quot;Not enough CT&quot;}'</span> \
    <span class="st">'http://localhost:8080/add-comment'</span>
<span class="kw">{</span> <span class="st">&quot;text&quot;</span>: <span class="st">&quot;Not enough CT&quot;</span>, <span class="st">&quot;author&quot;</span>: <span class="st">&quot;EK&quot;</span> <span class="kw">}</span></code></pre></div>
<p>今度はコメントの取得をしてみます。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">curl</span> --request GET \
    --header <span class="st">'Content-Type: application/json'</span> \
    <span class="st">'http://localhost:8080/get-comments'</span>
[{<span class="st">&quot;text&quot;</span>:<span class="st">&quot;Pretty good&quot;</span>,<span class="st">&quot;author&quot;</span>: <span class="st">&quot;DG&quot;</span>},{<span class="st">&quot;text&quot;</span>:<span class="st">&quot;Not enough CT&quot;</span>,<span class="st">&quot;author&quot;</span>:<span class="st">&quot;EK&quot;</span>}]</code></pre></div>
<p>この通り、無事に<span class="ascii">EK (Edward Kmett / Haskell</span>界のすごい人<span class="ascii">)</span>さんが「圏論を、圏論をもっとくれぇええええい！」と言っているコメントが追加されました。</p>
<p>ちなみに、<span class="ascii">Docker</span>内でシェルを開いて、手動で<span class="ascii">Docker</span>イメージをいじりながらいろいろ確かめてみるには、次のコメントのようにすれば<span class="ascii">OK</span>です。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">docker</span> run --interactive --tty --rm --network host servant-on-heroku /bin/bash</code></pre></div>
<p>では、<span class="ascii">Docker</span>上でアプリがちゃんと動いたことを確認したところで、ようやく<span class="ascii">Heroku</span>の出番です。</p>
<h2 id="herokuで動かす"><span class="ascii">Heroku</span>で動かす</h2>
<p><span class="ascii">Docker</span>上でビルドと実行ができていさえすれば、<span class="ascii">Heroku</span>にデプロイするのは難しくありません。 まず最初に<span class="ascii">Heroku</span>のアカウントを作りましょう。</p>
<h3 id="herokuアカウントを作成する"><span class="ascii">Heroku</span>アカウントを作成する</h3>
<p><span class="ascii">Heroku</span>の<a href="https://signup.heroku.com">アカウント作成ページ</a>でアカウントを作成してください。 もちろん、すでにアカウントを持っているのであればあえて別のアカウントを作りなおす必要はないですよ！</p>
<p>今回は<span class="ascii">Heroku</span>の無料枠を使ってアプリをデプロイするので、クレジットカードの登録は必要ないです。 こわくないですね！</p>
<p>ここで説明する内容は、ほとんど<span class="ascii">Heroku</span>の<a href="https://devcenter.heroku.com/articles/container-registry-and-runtime">公式ドキュメント</a>を参照しているので、なにかわからないところがあったらそちらをチェックしてみてください。</p>
<h3 id="herokuのコマンドラインプログラムをインストールする"><span class="ascii">Heroku</span>のコマンドラインプログラムをインストールする</h3>
<p><span class="ascii">Heroku</span>は<span class="ascii">CLI</span>で操作するためのコマンドを用意してくれているので、これを使って便利に<span class="ascii">Heroku</span>を使い倒せます。 ちょうど、<a href="https://aws.amazon.com/cli"><span class="ascii">AWS</span>の<span class="ascii">CLI</span></a>とか、<a href="https://github.com/digitalocean/doctl"><span class="ascii">Digital Ocean</span>の<span class="ascii">CLI</span></a>プログラムと同じような感じです。</p>
<p><span class="ascii">Arch Linux</span>使いの方は、下記のコマンドで<span class="ascii">Heroku</span>の<span class="ascii">CLI</span>プログラムをインストールできます。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">yaourt</span> -S heroku-toolbelt</code></pre></div>
<p>このコマンドは、<code>heroku</code>コマンドのバイナリを直接取得してインストールしてくれます。</p>
<p>他の環境の方は、<a href="https://devcenter.heroku.com/articles/heroku-cli"><span class="ascii">Heroku</span>の公式ドキュメント</a>をご覧ください。</p>
<p><span class="ascii">CLI</span>プログラムのインストールができたら、コマンドライン上でログインして、権限を必要とする操作ができる状態にしておきましょう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> login</code></pre></div>
<p>このコマンドを実行すると、ユーザ名とパスワードをたずねられるので、事前に作成しておいたアカウントの情報を入力してください。</p>
<h3 id="heroku上でアプリケーションを登録する"><span class="ascii">Heroku</span>上でアプリケーションを登録する</h3>
<p>今回のサンプルアプリを<span class="ascii">Heroku</span>で公開するには、まず<span class="ascii">Heroku</span>上でアプリケーションの登録をする必要があります。</p>
<p>以下のコマンドを実行すると、<code>servant-on-heroku</code>という名前のアプリケーションを<span class="ascii">Heroku</span>に登録できます。 必要に応じて<code>servant-on-heroku</code>の部分を別の名前に変更してアプリケーションを登録してください。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> apps:create servant-on-heroku</code></pre></div>
<p>以下のコマンドで、いま新規登録されたアプリケーションについての情報を一応取得できます。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> apps:info servant-on-heroku
=== <span class="ex">servant-on-heroku</span>
<span class="ex">Auto</span> Cert Mgmt: false
<span class="ex">Dynos</span>:
<span class="ex">Git</span> URL:        https://git.heroku.com/servant-on-heroku.git
<span class="ex">Owner</span>:          me@gmail.com
<span class="ex">Region</span>:         us
<span class="ex">Repo</span> Size:      0 B
<span class="ex">Slug</span> Size:      0 B
<span class="ex">Stack</span>:          cedar-14
<span class="ex">Web</span> URL:        https://servant-on-heroku.herokuapp.com/</code></pre></div>
<p><code>Web URL</code>の項目だけ、あとで使うのでどこかにメモしておいてください。 他の項目は、いまは特に気にしなくて大丈夫です。</p>
<h3 id="heroku-docker-pluginをインストールする"><span class="ascii">Heroku Docker Plugin</span>をインストールする</h3>
<p><span class="ascii">Heroku</span>のコマンドラインプログラムは、プラグインを追加することで、どんどん便利な機能を使えるようにできます。</p>
<p>今回は、<a href="https://devcenter.heroku.com/articles/container-registry-and-runtime"><span class="ascii">Heroku Container Registry</span></a>というプラグインを使いましょう。</p>
<p>以下のコマンドで、このプラグインがインストールされます。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> plugins:install heroku-container-registry</code></pre></div>
<p>インストールが終わったら、次のコマンドを実行して、ちゃんと動いているか確認してください。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> container
<span class="ex">4.1.1</span></code></pre></div>
<p>きっと、このプラグインのバージョンナンバーが表示されたはずです。</p>
<p>実際にプラグインを使うためには、以下のコマンドで<span class="ascii">Heroku Container Registry</span>にログインする必要があります。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> container:login</code></pre></div>
<p>このコマンドによって、<span class="ascii">Container Registry</span>のログイン情報が、<code>~/.docker/config.json</code>というファイルに追加されます。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">cat</span> ~/.docker/config.json
<span class="kw">{</span>
  <span class="st">&quot;auths&quot;</span>: <span class="kw">{</span>
    <span class="st">&quot;registry.heroku.com&quot;</span>: <span class="kw">{</span>
      <span class="st">&quot;auth&quot;</span>: <span class="st">&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx=&quot;</span>
    <span class="kw">}</span>
  <span class="kw">}</span>
<span class="kw">}</span></code></pre></div>
<h3 id="アプリケーションをheroku上で動かす">アプリケーションを<span class="ascii">Heroku</span>上で動かす</h3>
<p>実際にアプリを<span class="ascii">Heroku</span>上で動かすには、以下のコマンドを使います。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> container:push web</code></pre></div>
<p>これを実行すると、実行したディレクトリ内にある<code>Dockerfile</code>の設定にしたがって<span class="ascii">Docker</span>イメージを作成します。 内部では、ローカル環境で<code>Docker</code>イメージを作成するときに使ったのと同じ<code>docker build</code>を呼んでいます。 前の章で実際に<code>docker build</code>を実行した方は、その際に作成したイメージがそのまま<span class="ascii">Docker Container Registry</span>に送られるので安心してください。また<span class="ascii">1</span>時間も待つなんてイヤですよね。</p>
<p>では、<code>heroku apps:info</code>をもう一度実行して確認してみましょう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> apps:info servant-on-heroku
=== <span class="ex">servant-on-heroku</span>
<span class="ex">Auto</span> Cert Mgmt: false
<span class="ex">Dynos</span>:
<span class="ex">Git</span> URL:        https://git.heroku.com/servant-on-heroku.git
<span class="ex">Owner</span>:          me@gmail.com
<span class="ex">Region</span>:         us
<span class="ex">Repo</span> Size:      0 B
<span class="ex">Slug</span> Size:      0 B
<span class="ex">Stack</span>:          cedar-14
<span class="ex">Web</span> URL:        https://servant-on-heroku.herokuapp.com/</code></pre></div>
<p>あれ？ なにかおかしいですね… <code>Dynos:</code>のところになにも書いてありません。 <code>dyno</code>というのは<span class="ascii">Heroku</span>が独自に使っている用語で、ウェブアプリを実行する<span class="ascii">1</span>台のサーバのことを意味します。ここになにも書かれていないということは、アプリを実行しているサーバがいないということになります。</p>
<p>これをどうにかするためには、<code>heroku ps:scale</code>を使います。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> ps:scale web=1</code></pre></div>
<p>これで、“<span class="ascii">web</span>” <span class="ascii">dyno</span>が<span class="ascii">1</span>台分作成され、その上で今回のサンプルアプリが動くようになります。<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a></p>
<p>では、次のコマンドを実行して、<span class="ascii">dyno</span>がちゃんと動いていることを確認しましょう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> ps
<span class="ex">Free</span> dyno hours quota remaining this month: 549h 2m (99%)
<span class="ex">For</span> more information on dyno sleeping and how to upgrade, see:
<span class="ex">https</span>://devcenter.heroku.com/articles/dyno-sleeping

=== <span class="ex">web</span> (Free)<span class="bu">:</span> /bin/sh -c /opt/servant-on-heroku/bin/servant-on-heroku-api (1)
<span class="ex">web.1</span>: starting 2017/03/22 19:05:04 +0900 (~ 8s ago)</code></pre></div>
<p>なんだか余計な情報もだらだら出てきますが、<span class="ascii">web dyno</span>が<span class="ascii">1</span>台分動いていることが確認できます。</p>
<p>これで、サンプルアプリが動くようになったので、<code>curl</code>を使って、<code>Web URL</code>にアクセスしてみましょう。 <span class="ascii">(</span>サンプルアプリの<code>Web URL</code>は、<code>heroku apps:info</code>に書いてありましたよね？<span class="ascii">)</span></p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">curl</span> --request POST \
    --header <span class="st">'Content-Type: application/json'</span> \
    --data <span class="st">'{&quot;author&quot;: &quot;MS&quot;, &quot;text&quot;: &quot;Gotta make it professional&quot;}'</span> \
    <span class="st">'https://servant-on-heroku.herokuapp.com/add-comment'</span></code></pre></div>
<p>なにかおかしいですね… なにもレスポンスが返ってきません。 なにかエラーが出ているはずなので、<span class="ascii">Heroku</span>上で起こったエラーを実際に見てみたいです。</p>
<h3 id="heroku上で動いているアプリのエラーを見てみる"><span class="ascii">Heroku</span>上で動いているアプリのエラーを見てみる</h3>
<p><span class="ascii">Heroku</span>には、とってもすばらしいログ機能があり、アプリの標準エラーや標準出力を簡単にチェックできます。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> logs
<span class="ex">2017-03-22T10</span>:05:49 heroku[web.1]: proc start <span class="kw">`</span><span class="ex">/opt/servant-on-heroku/bin/servant-on-heroku-api</span><span class="kw">`</span>
<span class="ex">2017-03-22T10</span>:05:52 app[web.1]: servant-on-heroku-api: libpq: failed (could not connect to server: Connection refused
<span class="ex">2017-03-22T10</span>:05:52 app[web.1]:    Is the server running on host <span class="st">&quot;localhost&quot;</span> (127.0.0.1) <span class="ex">and</span> accepting
<span class="ex">2017-03-22T10</span>:05:52 app[web.1]:    TCP/IP connections on port 5432?
<span class="ex">2017-03-22T10</span>:05:52 app[web.1]: )
<span class="ex">2017-03-22T10</span>:05:52 heroku[web.1]: State changed from starting to crashed</code></pre></div>
<p>とても便利ですね！ どうやらこれまで何度も見てきた例のエラーがまた出ているようです…</p>
<p>今回は、<span class="ascii">Heroku</span>上で動いている<span class="ascii">PostgreSQL</span>データベースをちゃんとセットアップしていないのが理由です。</p>
<h3 id="herokuのpostgresqlサポート"><span class="ascii">Heroku</span>の<span class="ascii">PostgreSQL</span>サポート</h3>
<p><span class="ascii">Heroku</span>は<span class="ascii">PostgreSQL</span>について<a href="https://devcenter.heroku.com/articles/heroku-postgresql">しっかりサポート</a>してくれている上に、なんと無料枠まで設けてくれています。</p>
<p>以下のコマンドを実行すれば、<span class="ascii">PostgreSQL</span>のアドオンが使えるようになります。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> addons:create heroku-postgresql:hobby-dev</code></pre></div>
<p>これで、<code>heroku-postgresql</code>アドオンを、無料で使える<code>hobby-dev</code>利用枠で使えるようになりました。</p>
<p>では、本当に<span class="ascii">PostgreSQL</span>が作成されたか、以下のコマンドを使って確認してみましょう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> addons:info heroku-postgresql
=== <span class="ex">postgresql-tetrahedral-44549</span>
<span class="ex">Attachments</span>:  servant-on-heroku::DATABASE
<span class="ex">Installed</span> at: Wed Mar 22 2017 19:22:14 GMT+0900 (JST)
<span class="ex">Owning</span> app:   servant-on-heroku
<span class="ex">Plan</span>:         heroku-postgresql:hobby-dev
<span class="ex">Price</span>:        free
<span class="ex">State</span>:        created</code></pre></div>
<p>データベースの詳細情報については、<code>pg:info</code>コマンドを使って見れます。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> pg:info
=== <span class="ex">DATABASE_URL</span>
<span class="ex">Plan</span>:        Hobby-dev
<span class="ex">Status</span>:      Available
<span class="ex">Connections</span>: 0/20
<span class="ex">PG</span> Version:  9.6.1
<span class="ex">Created</span>:     2017-03-22 10:22 UTC
<span class="ex">Data</span> Size:   7.2 MB
<span class="ex">Tables</span>:      1
<span class="ex">Rows</span>:        0/10000 (In compliance)
<span class="ex">Fork</span>/Follow: <span class="ex">Unsupported</span>
<span class="ex">Rollback</span>:    Unsupported
<span class="ex">Add-on</span>:      postgresql-tetrahedral-44549</code></pre></div>
<h3 id="アプリケーションを再起動する">アプリケーションを再起動する</h3>
<p>これで<span class="ascii">PostgreSQL</span>のデータベースが動くようになったので、アプリを再起動しましょう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> ps:restart</code></pre></div>
<p>もう一度ログを見て、本当にこれでエラーが出なくなったか確かめてみます。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> logs
<span class="ex">2017-03-22T10</span>:22:15 heroku[web.1]: State changed from crashed to starting
<span class="ex">2017-03-22T10</span>:22:54 heroku[web.1]: proc start <span class="kw">`</span><span class="ex">/opt/servant-on-heroku/bin/servant-on-heroku-api</span><span class="kw">`</span>
<span class="ex">2017-03-22T10</span>:22:56 app[web.1]: Migrating: CREATe TABLE <span class="st">&quot;comment&quot;</span>(<span class="st">&quot;id&quot;</span> SERIAL8  PRIMARY KEY UNIQUE,<span class="st">&quot;author&quot;</span> VARCHAR NOT NULL,<span class="st">&quot;text&quot;</span> VARCHAR NOT NULL)
<span class="ex">2017-03-22T10</span>:22:57 heroku[web.1]: State changed from starting to up</code></pre></div>
<p>すごーい！ついに、ついにちゃんと動いたみたいです！！</p>
<p>もう一度<code>curl</code>コマンドを使って<span class="ascii">API</span>がちゃんと動いているか確認してみます。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">curl</span> --request POST \
    --header <span class="st">'Content-Type: application/json'</span> \
    --data <span class="st">'{&quot;author&quot;: &quot;SPJ&quot;, &quot;text&quot;: &quot;Avoid heroku-at-all-costs&quot;}'</span> \
    <span class="st">'https://servant-on-heroku.herokuapp.com/add-comment'</span>
{<span class="st">&quot;text&quot;</span>:<span class="st">&quot;Avoid heroku-at-all-costs&quot;</span>,<span class="st">&quot;author&quot;</span>:<span class="st">&quot;SPJ&quot;</span>}</code></pre></div>
<p>ちゃんとレスポンスが返ってきています！ 今度はコメントを取得してみましょう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">curl</span> --request GET \
    --header <span class="st">'Content-Type: application/json'</span> \
    <span class="st">'https://servant-on-heroku.herokuapp.com/get-comments'</span>
[{<span class="st">&quot;text&quot;</span>:<span class="st">&quot;Avoid heroku-at-all-costs&quot;</span>,<span class="st">&quot;author&quot;</span>:<span class="st">&quot;SPJ&quot;</span>}]</code></pre></div>
<p>いいですね！ <span class="ascii">SPJ(Simon Peyton Jones / Haskell</span>の父<span class="ascii">)</span>さんが「目先の便利さにとらわれて<span class="ascii">Heroku</span>に余計な機能をいれるのは、ダメ。ゼッタイ。」<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>と言っています。 これで全てうまくいったようです。</p>
<h3 id="heroku上のアプリは接続先のdbをどうやって見つけているのか"><span class="ascii">Heroku</span>上のアプリは接続先の<span class="ascii">DB</span>をどうやって見つけているのか</h3>
<p>賢明な読者のみなさんは、「<span class="ascii">Heroku</span>上のアプリはどうやってデータベースを見つけているんだろう？」と疑問に思ったかもしれません。 実は、<span class="ascii">Heroku</span>にはアプリに環境変数を与える仕組みがあります。</p>
<p>この環境変数の設定値を確かめるには、以下のコマンドが使えます。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> config
=== <span class="ex">servant-on-heroku</span> Config Vars
<span class="ex">DATABASE_URL</span>: postgres://someusername:somepassword@ec2-12-12-234-123.compute-1.amazonaws.com:5432/databasename</code></pre></div>
<p><code>heroku-postgresql</code>アドオンで<span class="ascii">PostgreSQL</span>のデータベースを作成した際に、<code>DATABASE_URL</code>という名前の設定値が追加されます。 <span class="ascii">Heroku</span>はアプリの起動時にこの設定値を環境変数として与えているのです。 先に述べたとおり、今回のサンプルアプリは、<code>DATABASE_URL</code>という環境変数を接続先<span class="ascii">DB</span>の情報として受け取るようになっています<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>。</p>
<p><span class="ascii">Heroku</span>に設定されている環境変数は、<code>heroku config:get VAR_NAME</code>で取得できるので、次のコマンドを使って<span class="ascii">DB</span>に接続することもできます。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">psql</span> <span class="st">&quot;</span><span class="va">$(</span><span class="ex">heroku</span> config:get DATABASE_URL<span class="va">)</span><span class="st">&quot;</span>
<span class="ex">psql</span> (9.6.1)
<span class="ex">SSL</span> connection (protocol: TLSv1.2, cipher: ECDHE-RSA-AES256-GCM-SHA384, bits: 256, compression: off)

<span class="va">databasename=</span><span class="op">&gt;</span> <span class="kw">select</span> <span class="ex">*</span> from comment<span class="kw">;</span>
 <span class="fu">id</span> <span class="kw">|</span> <span class="ex">author</span> <span class="kw">|</span>           <span class="ex">text</span>
<span class="ex">----</span><span class="kw">|</span><span class="ex">--------</span><span class="kw">|</span><span class="ex">---------------------------</span>
  <span class="ex">1</span> <span class="kw">|</span> <span class="ex">SPJ</span>    <span class="kw">|</span> <span class="ex">Avoid</span> Heroku at all costs
<span class="kw">(</span><span class="ex">1</span> row<span class="kw">)</span></code></pre></div>
<h3 id="アプリのアップデート">アプリのアップデート</h3>
<p><span class="ascii">Heroku</span>上で動いているアプリをアップデートするのは、とっても簡単です。 単に以下のコマンドを実行するだけで大丈夫です。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> container:push web</code></pre></div>
<p>このコマンドは、<span class="ascii">Docker</span>イメージをビルドしなおして<span class="ascii">Heroku container registry</span>にアップします。 その後関係する<span class="ascii">dyno</span>を全て再起動して、アップデート後のアプリを実行するようにします。</p>
<h2 id="もっと良くするために">もっと良くするために</h2>
<p>このサンプルアプリは、いまのままでもいい感じですが、いくつかまだ改善の余地があります。 一番手っ取り早い改善箇所は、<code>Dockerfile</code>でしょう。 <code>Dockerfile</code>をもっと良くするためのアイディアをいくつか挙げてみます。</p>
<ul>
<li><p><code>Dockerfile</code>のベースイメージに、もっとファイルサイズが小さいものを使う</p>
<p>現状では、<a href="https://hub.docker.com/r/heroku/heroku/"><span class="ascii">Heroku</span>のイメージ</a>を使っていますが、 たぶんもっと軽い<a href="https://hub.docker.com/_/alpine/"><span class="ascii">Alpine Linux</span></a>を使っても問題はないと思います。</p></li>
<li><p><code>stack</code>や<span class="ascii">GHC</span>、その他よく使う<span class="ascii">Haskell</span>ライブラリが最初から入っているイメージをベースにする</p>
<p>こうすることで、一番最初の<code>docker build</code>に要する時間をガッツリ削ることができます。</p></li>
<li><p><code>Dockerfile</code>の一番最後で、<code>stack</code>や<span class="ascii">GHC</span>、全<span class="ascii">Haskell</span>ライブラリを削除するようにする</p>
<p>こうすることで、<span class="ascii">Docker</span>イメージのサイズを少し減らせる可能性があります。 <span class="ascii">Heroku container registry</span>にイメージをアップロードするのが、いくらか早くなるでしょう。</p></li>
</ul>
<p>また、<code>docker-compose</code>などを使って、ローカルで実行する際にも<span class="ascii">Docker</span>を使って<span class="ascii">PostgreSQL DB</span>をセットアップするのも良いかもしれません。</p>
<h2 id="まとめ">まとめ</h2>
<p>ローカル環境上で<span class="ascii">Docker</span>が動いていれば、<span class="ascii">Heroku</span>上で<span class="ascii">Haskell</span>のコードを動かすのはとても簡単です。 <span class="ascii">Heroku</span>の無料枠はアプリのプロトタイプを他の人に試してもらったりするのに最適です。 もちろん、そのままリリースしたら負荷にたえられないかもしれませんが、アプリ開発の最初期段階にコンセプトを検証したりするのには十分でしょう。</p>
<p>もし、検証の結果うまくいきそうだと分かったら、クレジットカードを登録して、 もっと負荷にたえられる有料利用枠でアプリを動かすようにするのだって簡単です。</p>
<h2 id="脚注">脚注</h2>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>僕が自分で許可して、原著者に日本語の内容をチェックしてもらいました。また、翻訳ではなくローカライズなので、原文の逐語訳ではなく、日本語話者にとって理解しやすいように一部加筆修正してあります。<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>ここで挙げた<span class="ascii">7</span>ステップはちょっと複雑です。 もちろん、<span class="ascii">1</span>コマンドだけで<span class="ascii">GHC</span>のインストールから依存ライブラリのインストール、 アプリ自体のビルドまで完了することもできますが、ここでは<span class="ascii">Docker</span>のキャッシュ機構を活用するために いくつものコマンドに分けて記述してあります。 <span class="ascii">Docker</span>のキャッシュ機構によって、<code>docker build</code>を再実行するときには、入力値が変わったコマンドだけが実行されるようになっています。 たとえば、<code>servant-on-heroku.cabal</code>のファイルを変更して<code>docker build</code>を再実行すると、 <code>.cabal</code>ファイルに書かれた依存ライブラリをインストールする<span class="ascii">(4)</span>のステップからイメージを再ビルドし始めます。 キャッシュされているデータを利用するので、<span class="ascii">(1)</span>から<span class="ascii">(3)</span>までのステップを省略できるのです。</p>
<p>同じように、<code>src</code>下のファイルだけを変更して<code>docker build</code>を再実行すると、 <span class="ascii">(5)</span>のステップ以降のみが実行されます。 <span class="ascii">GHC</span>や依存ライブラリをわざわざ再インストールする必要はないからです。</p>
<p>このように、ステップをいくつかに分割することで、ビルド時間を大きく節約することができ、 <span class="ascii">2</span>回目以降のビルドが数分で終わるようになります。最初のビルドは<span class="ascii">1</span>時間もかかっていたのに、ちょろいですね。<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p><span class="ascii">dyno</span>には<a href="https://devcenter.heroku.com/articles/dynos#dyno-configurations">いろいろな種類のもの</a>がありますが、 今回のような単純な<span class="ascii">Web API</span>であれば別にこだわる必要はないです。<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>元ネタは同氏の<a href="https://www.reddit.com/r/haskell/comments/39qx15/is_this_the_right_way_to_understand_haskells/">“<span class="ascii">Avoid success at all costs</span>”</a>という言葉で、「目先の便利さにとらわれて、<span class="ascii">Haskell</span>に余計な機能をいれるのは、ダメ。ゼッタイ。」みたいな意味。<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p><span class="ascii">Heroku</span>は、他にも<code>PORT</code>という環境変数も使っていて、アプリケーションにどのポートでリクエストを待ち受けるかを指定できます。<a href="#fnref5">↩</a></p></li>
</ol>
</div>
            </div>
        </div>
    </div>
</article>



    <hr>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <ul class="list-inline text-center">
                        <li>
                            <a href="https://github.com/haskell-jp/blog">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    </ul>
                    <p class="copyright text-muted">&copy; Haskell-jp 2017</p>
                    <small class="text-muted notice-ga">当ウェブサイトでは<a href="https://support.google.com/analytics/answer/6004245?hl=ja">Google Analytics</a>でアクセス情報を収集しています。集めた情報は統計的に処理した上で、当ウェブサイトの改善のための参考情報としてのみ使用します。</small>
                </div>
            </div>
        </div>
    </footer>

    <!-- jQuery -->
    <script src="../../js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../../js/bootstrap.min.js"></script>

    <!-- Custom Theme JavaScript -->
    <script src="../../js/clean-blog.js"></script>

    <!-- Google Analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-94110610-1', 'auto');
      ga('send', 'pageview');
    </script>
</body>

</html>
