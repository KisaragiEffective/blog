<!DOCTYPE html>
<html lang="ja">

<head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# article: http://ogp.me/ns/article#">

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="About kind system of Haskell (Part 1)">
    <meta name="author" content="Haskell-jp">

    <!-- OGP Settings -->
    <meta property="og:title" content="About kind system of Haskell (Part 1) - Haskell-jp" />
    <meta property="og:type" content="article" />
    <meta property="og:url" content="/posts/2017/10-about-kind-system-part1.html" />
    <meta property="og:image" content="https://haskell.jp/blog/img/logo-black-frame.png" />
    <meta property="og:site_name" content="Haskell-jp Blog" />
    <meta property="og:description" content="---Haskellには種(kind)という仕組みがあります。大雑把に言ってしまえば、「型の型」を実現する仕組みです。この仕組みについて、あまり情報が出回っていないようなので、解説記事を残しておこうと思います。この記事は、[Ladder of Functional Programming](http://lambdaconf.us/downloads/documents/lambdaconf_sl" />

    <!-- Twitter Card Settings -->
    <meta name="twitter:card" content="summary" />

    

    <title>About kind system of Haskell (Part 1) - Haskell-jp</title>

    <!-- Bootstrap Core CSS -->
    <link href="../../css/bootstrap.css" rel="stylesheet">
    <!-- <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css" rel="stylesheet"> -->

    <!-- Pandoc syntax highlighting CSS -->
    <link href="../../css/syntax.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="../../css/clean-blog.css" rel="stylesheet">

    <!-- Our original CSS -->
    <link href="../../css/style.css" rel="stylesheet">

    <!-- Custom Fonts -->
    <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="https://haskell.jp"><img height="30px" src="../../img/logo.svg"></a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="https://haskell.jp">Home</a>
                    </li>
                    <li>
                        <a href="../../">Blog</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Header -->
    <header class="intro-header" style="background-image: url('../../img/post-bg.jpg')">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                  <div class="post-heading">
                    <h1>About kind system of Haskell (Part 1)</h1>
                    <h2 class="subheading">種の仕組みとそれに付随する言語拡張について</h2><span class="meta">Posted by mizunashi-mana</span>
                  </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <article>
    <div class="container">
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p><span class="ascii">Haskell</span>には種<span class="ascii">(kind)</span>という仕組みがあります。大雑把に言ってしまえば、「型の型」を実現する仕組みです。この仕組みについて、あまり情報が出回っていないようなので、解説記事を残しておこうと思います。</p>
<p>この記事は、<a href="http://lambdaconf.us/downloads/documents/lambdaconf_slfp.pdf"><span class="ascii">Ladder of Functional Programming</span></a> <span class="ascii">(</span><a href="http://qiita.com/lotz/items/0d68c8440d1f362d0c32">日本語訳</a><span class="ascii">)</span>の<strong><span class="ascii">FIRE LUBLINE(ADVANCED BEGINNER)</span></strong>を対象に、種の仕組みとそれに付随する<span class="ascii">GHC</span>言語拡張やパッケージを紹介するものです。</p>
<p>なお、特に断らない限り、対象として<span class="ascii">GHC8</span>系を設定しています。<code>stack</code>を使ってる方は<code>resolver</code>を<span class="ascii">LTS Haskell 8</span>以降に設定しておくことを推奨します。</p>
<h2 id="基本的な種の仕組み">基本的な種の仕組み</h2>
<h3 id="種に慣れる">種に慣れる</h3>
<p>私たちは良き<span class="ascii">Haskller</span>なので、トップレベルの関数には以下のように型注釈をつけます<span class="ascii">:</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">increment ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
increment n <span class="fu">=</span> n <span class="fu">+</span> <span class="dv">1</span></code></pre></div>
<p>この<code>increment</code>という関数は、<code>Int</code>型の値を受け取って、<span class="ascii">1</span>を加算した<code>Int</code>型の値を返します。なので、型システムによってそのような型として検証されます<span class="ascii">:</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">increment (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>)            <span class="co">-- ok =&gt; (2 :: Int)</span>
increment (<span class="st">&quot;str&quot;</span><span class="ot"> ::</span> <span class="dt">String</span>)     <span class="co">-- error!</span>
increment (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Double</span>)         <span class="co">-- error!</span>
increment (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>) (<span class="dv">2</span><span class="ot"> ::</span> <span class="dt">Int</span>) <span class="co">-- error!</span></code></pre></div>
<p>種も大体同じようなものですが、種は型の形式が正しいかを検証する仕組みです。例えば、以下のデータ型を見てください<span class="ascii">:</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Id</span> a <span class="fu">=</span> <span class="dt">Id</span> a</code></pre></div>
<p>このデータ型宣言は、</p>
<ul>
<li><strong>型</strong>の名前空間上に、<code>Id</code>という名前の<strong>型</strong>コンストラクタ</li>
<li><strong>値</strong>の名前空間上に、<code>Id</code>という名前の<strong>値</strong>コンストラクタ</li>
</ul>
<p>を作ります<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>。値コンストラクタ<code>Id</code>は<code>a -&gt; Id a</code>という型をしています<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>。つまり、値コンストラクタ<code>Id</code>は、<code>Id a</code>という型の値を作れる唯一のコンストラクタになります。そして、値コンストラクタは、何らかの値を受け取らなければ<code>Id a</code>を構成できないことが、型システムによって保証できます。</p>
<p>さて、型コンストラクタ<code>Id</code>の方はどうでしょうか？ データ型宣言からは、型コンストラクタ<code>Id</code>はそのままでは型になれず、何らかの型を受け取る必要があるように見えます。ですが、それは誰が保証してくれるのでしょうか？ さらには、値コンストラクタは受け取った型<code>a</code>によって、その型が決まります。例えばもし、<code>a</code>に<code>Maybe</code>などの型コンストラクタを入れてしまった場合、値コンストラクタ<code>Id</code>の型は<code>Maybe -&gt; Id Maybe</code>という一見おかしな型になってしまいます。このように<code>a</code>に<code>Maybe</code>を渡すことは実際にはできません。一体どういうメカニズムで、このような一見おかしなものが弾かれるのでしょうか？ もう、みなさんお気付きだと思いますが、これを保証する仕組みが種なのです。</p>
<p>値コンストラクタ<code>Id</code>が型<code>a -&gt; Id a</code>という型を持つように、型コンストラクタ<code>Id</code>は種<code>* -&gt; *</code>を持ちます。この種がどういう意味を持つのかを見る前に、まずは種を分析するためのツールを用いて、型の種を見てみましょう。そのツールとは、<span class="ascii">GHCi</span>の<code>kind</code>コマンドです。では、使ってみます<span class="ascii">:</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;&gt;</span> <span class="kw">data</span> <span class="dt">Id</span> a <span class="fu">=</span> <span class="dt">Id</span> a
<span class="fu">&gt;&gt;&gt;</span> <span class="co">-- 値コンストラクタIdの型を分析</span>
<span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span><span class="kw">type</span> <span class="dt">Id</span>
<span class="dt">Id</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Id</span> a
<span class="fu">&gt;&gt;&gt;</span> <span class="co">-- 型コンストラクタIdの種を分析</span>
<span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span>kind <span class="dt">Id</span>
<span class="dt">Id</span><span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span></code></pre></div>
<p>ここで、<code>type</code>コマンドは<strong>値</strong>の名前空間を、<code>kind</code>は<strong>型</strong>の名前空間を取っていることに注意してください。<code>:kind 1</code>というように<code>kind</code>コマンドに値を分析させることはできませんし、<code>:type Int</code>というように<code>type</code>コマンドに型を分析させることはできません。では、この<code>kind</code>コマンドで、他の幾つかの型の種もみてみます<span class="ascii">:</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span>kind <span class="dt">Int</span>
<span class="dt">Int</span><span class="ot"> ::</span> <span class="fu">*</span>
<span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span>kind <span class="dt">Maybe</span>
<span class="dt">Maybe</span><span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>
<span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span>kind <span class="dt">Either</span>
<span class="dt">Either</span><span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>
<span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span>kind <span class="dt">Either</span> <span class="dt">Int</span>
<span class="dt">Either</span> <span class="dt">Int</span><span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span></code></pre></div>
<p>なんとなく、種の意味が分かってきましたか？ 基本的には、<code>*</code>が型を、<code>* -&gt; *</code>は型をとって型を返す型コンストラクタを、<code>* -&gt; * -&gt; *</code>は型を二つとって型を返す型コンストラクタを表しているようです。型コンストラクタには部分適用もできるようです。ただ、単純に全てが<code>* -&gt; * -&gt; ...</code>という形の種になるわけではありません。次のようなデータ型を見てみてください<span class="ascii">:</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;&gt;</span> <span class="kw">data</span> <span class="dt">AppInt</span> m <span class="fu">=</span> <span class="dt">AppInt</span> (m <span class="dt">Int</span>)
<span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span><span class="kw">type</span> <span class="dt">AppInt</span>
<span class="dt">AppInt</span><span class="ot"> ::</span> m <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">AppInt</span> m
<span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span>kind <span class="dt">AppInt</span>
<span class="dt">AppInt</span><span class="ot"> ::</span> (<span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="ot">-&gt;</span> <span class="fu">*</span></code></pre></div>
<p>種に<code>()</code>が付きました。この型コンストラクタ<code>AppInt</code>は、単純に型をとるようなものではなく、型を一つとる型コンストラクタによって、型が作られます。実際に、値は以下のように作れます<span class="ascii">:</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span><span class="kw">type</span> <span class="dt">AppInt</span> <span class="fu">$</span> <span class="dt">Just</span> <span class="dv">1</span>
<span class="dt">AppInt</span> <span class="fu">$</span> <span class="dt">Just</span> <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">AppInt</span> <span class="dt">Maybe</span>
<span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span><span class="kw">type</span> <span class="dt">AppInt</span> [<span class="dv">1</span>, <span class="dv">2</span>]
<span class="dt">AppInt</span> [<span class="dv">1</span>, <span class="dv">2</span>]<span class="ot"> ::</span> <span class="dt">AppInt</span> []
<span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span><span class="kw">type</span> <span class="dt">AppInt</span> <span class="fu">$</span> <span class="dt">Right</span> <span class="dv">1</span>
<span class="dt">AppInt</span> <span class="fu">$</span> <span class="dt">Right</span> <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">AppInt</span> (<span class="dt">Either</span> a)
<span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span><span class="kw">type</span> <span class="dt">AppInt</span> <span class="fu">$</span> <span class="dt">Left</span> <span class="dt">True</span>
<span class="dt">AppInt</span> <span class="fu">$</span> <span class="dt">Left</span> <span class="st">&quot;str&quot;</span><span class="ot"> ::</span> <span class="dt">AppInt</span> (<span class="dt">Either</span> <span class="dt">Bool</span>)</code></pre></div>
<p>ちょっと不思議な型ですね。型コンストラクタ<code>AppInt</code>は<code>* -&gt; *</code>にマッチする型コンストラクタしか受け取れません。試してみましょう<span class="ascii">:</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span>kind <span class="dt">AppInt</span> <span class="dt">Int</span>

<span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">3</span><span class="fu">:</span> error<span class="fu">:</span>
    • <span class="dt">Expected</span> kind ‘<span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>’, but ‘<span class="dt">Int</span>’ has kind ‘<span class="fu">*</span>’
    • <span class="dt">In</span> the first argument <span class="kw">of</span> ‘<span class="dt">AppInt</span>’, namely ‘<span class="dt">Int</span>’
      <span class="dt">In</span> the <span class="kw">type</span> ‘<span class="dt">AppInt</span> <span class="dt">Int</span>’
<span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span>kind <span class="dt">AppInt</span> <span class="dt">Either</span>

<span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">3</span><span class="fu">:</span> error<span class="fu">:</span>
    • <span class="dt">Expecting</span> one more argument to ‘<span class="dt">Either</span>’
      <span class="dt">Expected</span> kind ‘<span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>’, but ‘<span class="dt">Either</span>’ has kind ‘<span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>’
    • <span class="dt">In</span> the first argument <span class="kw">of</span> ‘<span class="dt">AppInt</span>’, namely ‘<span class="dt">Either</span>’
      <span class="dt">In</span> the <span class="kw">type</span> ‘<span class="dt">AppInt</span> <span class="dt">Either</span>’</code></pre></div>
<p>エラー文がそのままですね。</p>
<ul>
<li><code>AppInt Int</code>の方は「<code>* -&gt; *</code>を期待していたが、受け取った型<code>Int</code>の種は<code>*</code>ですよ」と言っています。</li>
<li><code>AppInt Either</code>の方は「<code>* -&gt; *</code>を期待していたが、受け取った型コンストラクタ<code>Either</code>の種は<code>* -&gt; * -&gt; *</code>ですよ」と言っています。</li>
</ul>
<p>このようにして、型注釈によって受け取る値を制限できるように、種によって受け取る型を制限できるわけです。何となく、種がどういうものかは分かっていただけたでしょうか？ では、種がどのような意味を持っているのかを、ちゃんと見ていきましょう。</p>
<h3 id="種の意味と種推論">種の意味と種推論</h3>
<p><span class="ascii">Haskell</span>には、標準で二種類の種があります。それは</p>
<ul>
<li><code>*</code>という種</li>
<li><code>k1</code>、<code>k2</code>を何かしらの種とした時、<code>k1 -&gt; k2</code>という形をした種</li>
</ul>
<p>の二つです。今まで見てきたように、</p>
<ul>
<li><code>*</code>は、データ型</li>
<li><code>k1 -&gt; k2</code>は、<code>k1</code>の種を持つ型を受け取り<code>k2</code>の種を持つ型を返すような型コンストラクタ</li>
</ul>
<p>をそれぞれ表します。値コンストラクタから作った<code>AppInt [1, 2]</code>が一つの値であったように、型コンストラクタから作った<code>AppInt Maybe</code>なども一つのデータ型です。</p>
<p><code>k1 -&gt; k2</code>は右結合で解釈されます。なので、<code>* -&gt; * -&gt; *</code>は、実際には<code>* -&gt; (* -&gt; *)</code>と同じです。なので、右に括弧が付く場合は省略が可能ですが、左に付く場合は省略ができません。つまり、<code>(* -&gt; *) -&gt; *</code>と<code>* -&gt; * -&gt; *</code>は別物になります。</p>
<p>さて、ここで一つ重要な型コンストラクタを紹介しておきましょう。それは関数型コンストラクタ<code>(-&gt;)</code>です。型コンストラクタが<code>()</code>で囲まれて、新しい表記方法が出てきたように思えますが、どうか落ち着いてください。通常の関数において<span class="ascii">(</span>値の世界において<span class="ascii">)</span>、私たちは中置演算子を<code>()</code>で囲むことで、通常の関数として扱うことができました。型注釈上でも同じようなことができます。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span><span class="kw">type</span><span class="ot"> id ::</span> a <span class="ot">-&gt;</span> a
id<span class="ot"> ::</span> a <span class="ot">-&gt; a ::</span> a <span class="ot">-&gt;</span> a
<span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span><span class="kw">type</span><span class="ot"> id ::</span> (<span class="ot">-&gt;</span>) a a
id<span class="ot"> ::</span> (<span class="ot">-&gt;</span>) a<span class="ot"> a ::</span> a <span class="ot">-&gt;</span> a</code></pre></div>
<p>上の二つの型は、表記は違えど同じ型を表しています。実は私たちは、中置がデフォルトの型コンストラクタを自分で作ることもできます。それには<code>TypeOperators</code>拡張を使わなければいけませんが。ちょっと作ってみましょう<span class="ascii">:</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span>set <span class="fu">-</span><span class="dt">XTypeOperators</span>
<span class="fu">&gt;&gt;&gt;</span> <span class="kw">data</span> a <span class="fu">+</span> b <span class="fu">=</span> <span class="dt">Coproduct</span> (<span class="dt">Either</span> a b)
<span class="fu">&gt;&gt;&gt;</span> <span class="co">-- 型コンストラクタ</span>
<span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span>kind (<span class="fu">+</span>)
<span class="ot">(+) ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>
<span class="fu">&gt;&gt;&gt;</span> <span class="co">-- 値コンストラクタ</span>
<span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span><span class="kw">type</span> <span class="dt">Coproduct</span> 
<span class="dt">Coproduct</span><span class="ot"> ::</span> <span class="dt">Either</span> a b <span class="ot">-&gt;</span> a <span class="fu">+</span> b
<span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span><span class="kw">type</span> <span class="dt">Coproduct</span> <span class="fu">$</span> <span class="dt">Right</span> <span class="dt">True</span>
<span class="dt">Coproduct</span> <span class="fu">$</span> <span class="dt">Right</span> <span class="dt">True</span><span class="ot"> ::</span> a <span class="fu">+</span> <span class="dt">Bool</span>
<span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span><span class="kw">type</span> <span class="dt">Coproduct</span> <span class="fu">$</span> <span class="dt">Left</span> <span class="dt">True</span>
<span class="dt">Coproduct</span> <span class="fu">$</span> <span class="dt">Left</span> <span class="dt">True</span><span class="ot"> ::</span> <span class="dt">Bool</span> <span class="fu">+</span> a
<span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span>kind (<span class="fu">+</span>) <span class="dt">Int</span>
(<span class="fu">+</span>) <span class="dt">Int</span><span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>
<span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span>kind (<span class="fu">+</span>) <span class="dt">Int</span> <span class="dt">Bool</span>
(<span class="fu">+</span>) <span class="dt">Int</span> <span class="dt">Bool</span><span class="ot"> ::</span> <span class="fu">*</span>
<span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span>kind <span class="dt">Int</span> <span class="fu">+</span> <span class="dt">Bool</span>
<span class="dt">Int</span> <span class="fu">+</span> <span class="dt">Bool</span><span class="ot"> ::</span> <span class="fu">*</span></code></pre></div>
<p>残念ながらセクションは使えませんが、その他は大体中置演算子と同じで、部分適用などもできます。関数型コンストラクタ<code>(-&gt;)</code>も、<code>(+)</code>と似たようなものです。種を見てみましょう<span class="ascii">:</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span>kind (<span class="ot">-&gt;</span>)
<span class="ot">(-&gt;) ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>
<span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span>kind (<span class="ot">-&gt;</span>) <span class="dt">Int</span>
(<span class="ot">-&gt;</span>) <span class="dt">Int</span><span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>
<span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span>kind (<span class="ot">-&gt;</span>) <span class="dt">Int</span> <span class="dt">Bool</span>
(<span class="ot">-&gt;</span>) <span class="dt">Int</span> <span class="dt">Bool</span><span class="ot"> ::</span> <span class="fu">*</span>
<span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span>kind <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span><span class="ot"> ::</span> <span class="fu">*</span></code></pre></div>
<p><strong>追記</strong><span class="ascii">: GHC 8.2.1</span>では、<code>:kind (-&gt;)</code>の表示結果が、<code>TYPE q -&gt; TYPE r -&gt; *</code>というものに変更されたようです。この表記に関しては、<a href="12-about-kind-system-part2.html">続編</a>の方で解説します。今は、<code>* -&gt; * -&gt; *</code>と大体同等のものであると思ってもらって構わないので、以降では<code>(-&gt;) :: * -&gt; * -&gt; *</code>であるとして話を進めていきます。宜しくお願いします。</p>
<p><code>(-&gt;)</code>は二つの型を取り、データ型を返します。そのデータ型とは関数型です。例えば、<code>Int -&gt; Maybe Bool</code><span class="ascii">(</span>関数表記では<code>(-&gt;) Int (Maybe Bool)</code><span class="ascii">)</span>は<code>Int</code>型の値を受け取り<code>Maybe Bool</code>型の値を返す関数の型を表しているのでしたね。関数型コンストラクタは二つの引数の種を<code>*</code>に制限しています。なので、<code>Maybe -&gt; Int</code>といったような型注釈は書けません。これは、型コンストラクタが値を持たないことに反しません。</p>
<p>さて、次のようなデータ宣言を考えてみましょう<span class="ascii">:</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Id</span> a <span class="fu">=</span> <span class="dt">Id</span> a
<span class="kw">data</span> <span class="dt">AppInt</span> m <span class="fu">=</span> <span class="dt">AppInt</span> (m <span class="dt">Int</span>)</code></pre></div>
<p>一番最初に見たデータ宣言です。</p>
<ul>
<li>型コンストラクタ<code>Id</code>の種は<code>* -&gt; *</code>、値コンストラクタ<code>Id</code>の型は<code>a -&gt; Id a</code></li>
<li>型コンストラクタ<code>AppInt</code>の種は<code>(* -&gt; *) -&gt; *</code>、値コンストラクタ<code>AppInt</code>の型は<code>m Int -&gt; AppInt m</code></li>
</ul>
<p>になるのでした。このデータ宣言には、特に種に関する情報を書いているわけではありません。<code>Id</code>と<code>AppInt</code>の種は、どうやって定まったのでしょうか？ 実は、種に関する推論によって、これらの種は決定されるのです。</p>
<p><span class="ascii">Haskell</span>では、型注釈なしの関数は、型推論されて型が決まります。種でも同じように、推論が行われます。<code>(-&gt;)</code>の種は<code>* -&gt; * -&gt; *</code>であったことを思い出してください。値コンストラクタは関数ですから、そのパラメータは<code>*</code>という種を持つことになります<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>。</p>
<ul>
<li><code>Id</code>の方を考えてみると、値コンストラクタから<code>a</code>型は<code>*</code>という種であることが分かります。</li>
<li><code>AppInt</code>の方も同じく<code>Int</code>が<code>*</code>という種であることと<code>m Int</code>が<code>*</code>であることから、<code>m</code>は<code>* -&gt; *</code>と推論されます。</li>
</ul>
<p>このようにして、<code>Id</code>と<code>AppInt</code>の種は自動的に決まったわけです。では、推論に頼らず種を指定することはできるのでしょうか？ 残念ながら、<span class="ascii">Haskell</span>の標準システムでは、推論に頼らずデータ型コンストラクタの種を指定することはできません。次のようなデータ宣言を考えてみましょう<span class="ascii">:</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">App</span> f a <span class="fu">=</span> <span class="dt">App</span> (f a)
<span class="kw">data</span> <span class="dt">TaggedData</span> t <span class="fu">=</span> <span class="dt">TaggedData</span></code></pre></div>
<ul>
<li><code>App</code>型コンストラクタのパラメータ<code>f</code>と<code>a</code>は、それぞれ何かしらの種<code>k</code>に対して<code>k -&gt; *</code>、<code>k</code>という形をしていればいいはずですが、実際には<code>* -&gt; *</code>、<code>*</code>という型になります。</li>
<li><code>TaggedData</code>型コンストラクタのパラメータ<code>t</code>も、どのような種であってもいいはずですが、<code>*</code>となります。</li>
</ul>
<p>このように、標準の<span class="ascii">Haskell</span>では、デフォルトで<code>*</code>が設定されており、確定しないような種は<code>*</code>として扱われます。なので、型コンストラクタでタグ付けしたデータ型を作るといったことはできません。</p>
<h3 id="型と種の評価順序">型と種の評価順序</h3>
<p>上では、種の意味と種推論について話しました。種推論は、種を推論してくれるわけですが、正しく私たちが思ったことを推論してくれるわけではなく、表現できない型コンストラクタもありました。さて、その他にも推論が失敗するようなケースもあります。以下をみてください<span class="ascii">:</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Ill</span> m a <span class="fu">=</span> <span class="dt">Ill</span> (m a) m</code></pre></div>
<p>型コンストラクタ<code>Ill</code>のパラメータ<code>m</code>と<code>a</code>の種はどうなるでしょうか？ 実は、このような場合につじつまが合う種はありません。もしこのデータ宣言が成り立つなら、値コンストラクタ<code>Ill</code>の型は<code>Ill :: m a -&gt; m -&gt; Ill m a</code>になりますが、この場合<code>m</code>が型コンストラクタなことは明白なので型コンストラクタに紐づく値が存在することになりますし、<code>(-&gt;)</code>の種にも合いません。もう一つ、推論が失敗する面白いケースがあります。以下のデータ宣言を考えてみましょう<span class="ascii">:</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Inf</span> a b <span class="fu">=</span> <span class="dt">Inf</span> (a b) (b a)</code></pre></div>
<p>ここで、<code>a</code>の種を<code>k0 -&gt; *</code>とおくと、<code>b</code>の種は<code>k0</code>になるわけですが、<code>b</code>も<code>a</code>を受け取っているのでやはり<code>k1 -&gt; *</code>というような形をしているはずです。このように、両方に辻褄が合うような種を探していくと、永遠に同じ操作の繰り返しになり終わりません。このような場合も種の推論は失敗し、コンパイルエラーになります。</p>
<p>また、型コンストラクタに型を渡す場合も、種がちゃんと合うかを確認し、種が合わない場合コンパイルエラーになるのでした。このように、コンパイルする際は、種の推論や種の検証を行い、辻褄が合うかを保障し、種を確定させる必要があります。</p>
<p>さて、<span class="ascii">Haskell</span>ではもう一つコンパイル時に行われる重要な評価があります。それは、型に関する評価です。<span class="ascii">Haskell</span>のプログラム中の型を推論し、ちゃんと型の辻褄が合っているかも評価しなければなりません。これらの二つの評価は<span class="ascii">GHC</span>では別々に行われます。これは当たり前のように思えるかもしれませんが、種に関して考えるときは常に意識しなければなりません。次のプログラムをみてください<span class="ascii">:</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- TestKind.hs</span>

<span class="kw">module</span> <span class="dt">TestKind</span> <span class="kw">where</span>

<span class="ot">f ::</span> <span class="dt">Maybe</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
f _ <span class="fu">=</span> <span class="dv">0</span>

<span class="ot">g ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
g <span class="ch">'0'</span> <span class="fu">=</span> <span class="dt">True</span>
g _   <span class="fu">=</span> <span class="dt">False</span></code></pre></div>
<p>これをコンパイルすると以下のエラーが出されます<span class="ascii">:</span></p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="ex">stack</span> ghc -- -Wall TestKind.hs
[<span class="ex">1</span> of 1] Compiling TestKind         ( TestKind.hs, TestKind.o )

<span class="ex">TestKind.hs</span>:5:6: error:
    • <span class="ex">Expecting</span> one more argument to ‘Maybe’
      <span class="ex">Expected</span> a type, but ‘Maybe’ has kind ‘* -<span class="op">&gt;</span> *’
    • <span class="ex">In</span> the type signature:
        <span class="ex">f</span> :: Maybe -<span class="op">&gt;</span> Int</code></pre></div>
<p>ここでは、「<code>Maybe</code>は<code>* -&gt; *</code>という種を持っているが、<code>(-&gt;)</code>が期待している種は<code>*</code>だ」と言っています。ですが、上のプログラムにはもう一つおかしな点があります。それは関数<code>g</code>の型注釈です。関数<code>g</code>の受け取る値は<code>Int</code>型のはずですが、実際には<code>Char</code>型の値を受け取っています。ただし、関数<code>g</code>の型注釈の種に関しては何の問題もありません。</p>
<p><span class="ascii">GHC</span>では、種と型の検査は別々に行われるという話をしました。実は、さらにこの二つの間には評価順序があります。まず種の検査を行ってから、型の検査が行われるようになっているのです。種の検査に失敗すれば型の検査は行われません。これらは、<code>:type</code>コマンドや<code>:kind</code>コマンドにも影響するので注意が必要です。<code>:kind</code>コマンドは種の評価を行いますが、型の評価は行いません。あまり、<code>:kind</code>コマンド上で種の検査が通って型の検査が通らないといった場面には遭遇しないかもしれないですが、これは心に留めておくと良いでしょう。</p>
<h3 id="この章のまとめ">この章のまとめ</h3>
<p>この章では、基本的な種の仕組みを紹介しました。種というのは、標準では二つ存在するのでした。それは、以下のものです<span class="ascii">:</span></p>
<ul>
<li><code>*</code><span class="ascii">:</span> データ型を表す種</li>
<li><code>k1 -&gt; k2</code><span class="ascii">:</span> <code>k1</code>の種を持つ型を受け取り、<code>k2</code>の種を持つ型を返す、型コンストラクタを表す種</li>
</ul>
<p>また、データ宣言において種は推論され、確定しない場合はデフォルトで<code>*</code>を用いるのでした。また、種と型の評価はそれぞれ別々に行われ、種の評価の後に型の評価が行われることも学びました。</p>
<p>以降では、<span class="ascii">Haskell</span>標準の種の仕組みを拡張する、幾つかの重要な<span class="ascii">GHC</span>拡張について話していきましょう。</p>
<h2 id="種に付随したghc拡張">種に付随した<span class="ascii">GHC</span>拡張</h2>
<h3 id="種注釈">種注釈</h3>
<p><span class="ascii">Haskell</span>標準では、データ宣言において、型コンストラクタの種は種推論によって決定するのでした。このため、表現できない型コンストラクタがあることも話しました。これは、不便な場合があります。<code>* -&gt; *</code>の種を持つ型コンストラクタをタグとした、データ型を表現することができないのはもちろんですが、そもそも複雑なデータ型の場合に注釈としての種が欲しかったり、推論に任せずそもそも型の種を明示的に宣言したい場合があるのです。これは、<span class="ascii">Haskell</span>においてトップレベルの関数の型注釈を行うことが、良い風習とされているのと同じですね。例えば、以下のデータ宣言を考えてみてください<span class="ascii">:</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Complex</span> a b c <span class="fu">=</span> <span class="dt">Complex</span> (a (<span class="dt">Maybe</span> (b c)))</code></pre></div>
<p>このような場合に、パッとそれぞれのパラメータの種を考えることは出来るでしょうか？ 出来る人もいるかもしれませんが、混乱してしまう人もいるでしょう。もし、次のような注釈があればどうでしょうか？</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Complex</span> (<span class="ot">a ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) (<span class="ot">b ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) (<span class="ot">c ::</span> <span class="fu">*</span>) <span class="fu">=</span> <span class="dt">Complex</span> (a (<span class="dt">Maybe</span> (b c)))</code></pre></div>
<p>これならば、値コンストラクタの型について深く考えなくても、それぞれのパラメータがどういう種を持つ型なのかはすぐに分かるようになりますし、どういう意図で書いたのかが明白です。何の注釈もない場合、<code>b</code>には<code>Maybe</code>を渡せばいいのか、それとも具体的な型を渡せばいいのか少し考える必要がありますが、注釈がある場合には種の読み方が分かっていればすぐ分かります。残念ながら、<span class="ascii">Haskell</span>の標準でこのような注釈を書くことはできません。そこで、<code>KindSignatures</code>拡張の出番になります。</p>
<p><code>KindSignatures</code>はその名の通り、種の注釈を可能にする<span class="ascii">GHC</span>拡張です。この拡張により、データ宣言や型シノニムなどでも種注釈が書けるようになります。以下のプログラムをみてください<span class="ascii">:</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE KindSignatures #-}</span>

<span class="kw">data</span> <span class="dt">App</span> f a <span class="fu">=</span> <span class="dt">App</span> (f a)
<span class="kw">type</span> <span class="dt">FlipApp</span> a (<span class="ot">f ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="fu">=</span> <span class="dt">App</span> f a</code></pre></div>
<p>このプログラムでは、<code>App</code>の方の種は見た目からすぐ分かります。しかし、<code>FlipApp</code>の方はどうでしょうか？ 上記の例では、すぐそばに<code>App</code>のデータ宣言があるから分かりますが、<code>App</code>と<code>FlipApp</code>の宣言が別々の場所にあることを想像してみてください。<span class="ascii">Haskell</span>では、型コンストラクタ<span class="ascii">(</span>型関数<span class="ascii">)</span>には<code>f</code>や<code>m</code>、<code>t</code>をメタ変数として使う文化があるので、それから推測することは可能ですが、明確に知りたい場合には実装を見にいく必要が出てくる場合もあるでしょう。しかし、きちんと種注釈が書いてあれば、混乱を避けることができます。これが一つの種注釈の魅力です。</p>
<p>また、種注釈を明示することで、推論に頼らず種の制約を書きたい場合もあります。よくあるケースは<code>GADTs</code>拡張を併用する場合です。<code>GADTs</code>拡張については、今回は詳しく扱いませんので、<code>GADTs</code>を知らない人は以下は読み飛ばしてください。</p>
<p><code>GADTs</code>との併用では、次のような種注釈を書く場合があります<span class="ascii">:</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">GadtsSample</span><span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span>
  <span class="dt">GadtsSample</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">GadtsSample</span> a</code></pre></div>
<p><code>GADTs</code>のスタイルは、値コンストラクタの型を明示的に書くため、型コンストラクタのパラメータ名を明記する必要がありません。型コンストラクタはその種が分かればいいですし、値コンストラクタはその型が分かれば問題ないからです。通常のデータ宣言では、型コンストラクタと値コンストラクタの型がごっちゃになっているため、このように種の注釈と型の注釈を完全に分離することは困難です。もちろん<code>GADTs</code>において、パラメータ名に種注釈をつけていく書き方も許容されています。上の表記は、次の表記と同一です<span class="ascii">:</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">GadtsSample</span> (<span class="ot">a ::</span> <span class="fu">*</span>) <span class="kw">where</span>
  <span class="dt">GadtsSample</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">GadtsSample</span> a</code></pre></div>
<p>ただし、<code>GADTs</code>では型コンストラクタのパラメータ名は特に意味を持たないことに注意してください。値コンストラクタの型注釈は、特に型コンストラクタのパラメータ名に名前を合わせる必要はありません<span class="ascii">:</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">GadtsSample</span> (<span class="ot">a ::</span> <span class="fu">*</span>) <span class="kw">where</span>
  <span class="dt">GadtsSample</span><span class="ot"> ::</span> b <span class="ot">-&gt;</span> <span class="dt">GadtsSample</span> b <span class="co">-- aを使わなくてもいい！</span></code></pre></div>
<p>このため、一番最初に提示したような、型コンストラクタにはその種注釈を、値コンストラクタにはその型注釈をそれぞれ書くというスタイルを好む人も多くいます。これも、一つの<code>KindSignatures</code>拡張の魅力と言えるでしょう。なにより重要なことは、<code>GADTs</code>では値コンストラクタの型を明示しないといけないため、意図しない型コンストラクタへの適用を、誤って型注釈に書いてしまう可能性が、通常のデータ宣言より高くなります。種注釈をつけることで、型コンストラクタの意図している種を明示することにより、意図していなかった型コンストラクタの使用法が、種推論によってすりぬけてしまうことを防ぐことができます。</p>
<h3 id="種多相">種多相</h3>
<p>さて、種注釈を行えるようにする<code>KindSignatures</code>拡張の他に、もう一つ重要な拡張があります。それが、種多相を行えるようにする拡張です。「基本的な種の仕組み」の章で紹介した、以下のデータ宣言を思い出してください<span class="ascii">:</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">App</span> f a <span class="fu">=</span> <span class="dt">App</span> (f a)</code></pre></div>
<p>標準では、型コンストラクタ<code>App</code>は、<code>(* -&gt; *) -&gt; * -&gt; *</code>という種になるのでした。しかしながら、<code>f :: k -&gt; *</code>、<code>a :: k</code>という形をしていれば、どんな種でもいいはずだという話は覚えていますか？ <code>f a :: *</code>になればいいのですから、わざわざ<code>*</code>に強めてしまう必要はありません。そこで、デフォルトの<code>*</code>まで具体化をせずに、抽象的に「何かしらの<code>k</code>の種において、<code>f :: k -&gt; *</code>、<code>a :: k</code>という形をしていれば良い」という情報を残すようにするのが、<code>PolyKinds</code>拡張、種多相の基本的な考え方です。<code>PolyKinds</code>拡張を有効にする前とした後での<code>App</code>型コンストラクタの種を見てみましょう<span class="ascii">:</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;&gt;</span> <span class="kw">data</span> <span class="dt">App</span> f a <span class="fu">=</span> <span class="dt">App</span> (f a)
<span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span>kind <span class="dt">App</span>
<span class="dt">App</span><span class="ot"> ::</span> (<span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>
<span class="fu">&gt;&gt;&gt;</span> <span class="co">-- PolyKinds拡張の有効化</span>
<span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span>set <span class="fu">-</span><span class="dt">XPolyKinds</span>
<span class="fu">&gt;&gt;&gt;</span> <span class="kw">data</span> <span class="dt">App</span> f a <span class="fu">=</span> <span class="dt">App</span> (f a)
<span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span>kind <span class="dt">App</span>
<span class="dt">App</span><span class="ot"> ::</span> (k <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="fu">*</span></code></pre></div>
<p><code>PolyKinds</code>拡張を有効にした後では、デフォルトで具体化が必要ない部分は、<code>k</code>という形のまま残っているのが見て取れます！ 私たち<span class="ascii">Haskeller</span>は、多相関数で、具体化された型ではなく任意の型についてマッチするような関数を書くことに慣れています。多相関数の場合、具体化されていない型を型変数と呼ぶのでした。種の場合は種変数といったところでしょう。種多相は、<span class="ascii">GHC</span>の標準パッケージ<code>base</code>において、様々なところで用いられています。有名なものとしては、<code>Data.Proxy</code>にある<code>Proxy</code>データ型がそうです。その種を見てみましょう<span class="ascii">:</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;&gt;</span> <span class="kw">import </span><span class="dt">Data.Proxy</span>
<span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span>kind <span class="dt">Proxy</span>
<span class="dt">Proxy</span><span class="ot"> ::</span> k <span class="ot">-&gt;</span> <span class="fu">*</span>
<span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span><span class="kw">type</span> <span class="dt">Proxy</span>
<span class="dt">Proxy</span><span class="ot"> ::</span> forall k (<span class="ot">t ::</span> k)<span class="fu">.</span> <span class="dt">Proxy</span> t</code></pre></div>
<p>少し<code>Proxy</code>の値コンストラクタの型注釈が分かりにくいですが、<code>Proxy</code>値コンストラクタは特に引数を取らず<code>Proxy t</code>という値になります。このように実体<span class="ascii">(</span>値<span class="ascii">)</span>を持たない型パラメータを幽霊型と言ったりします。<code>Proxy</code>型コンストラクタは、どんな種でも良いので何かしらの幽霊型<code>t :: k</code>をとり、<code>Proxy t</code>というデータ型に成ります。例えば、型コンストラクタを幽霊型として付属させることも可能です<span class="ascii">:</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span><span class="kw">type</span> <span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">Maybe</span>
<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">Maybe</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">Maybe</span></code></pre></div>
<p>不思議なデータ型ですね。種多相がなくても、<code>Proxy</code>データ型のような幽霊型をパラメータに持つ型コンストラクタを作ることはできます。しかし、種によってそれぞれ型コンストラクタを用意しなければなりません。今回の例のように、種多相を使えば、一つのデータ宣言によって様々な種の型に対応できるようになるのが、魅力的です。また、<code>PolyKinds</code>拡張は、一緒に<code>KindSignatures</code>拡張も有効にします。これらを組み合わせることで、明示的に多相化された種の注釈を書くことも可能です。それは、以下のようになります<span class="ascii">:</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;&gt;</span> <span class="kw">data</span> <span class="dt">BiTagged</span> (<span class="ot">tag1 ::</span> k) (<span class="ot">tag2 ::</span> k) <span class="fu">=</span> <span class="dt">BiTaggedData</span>
<span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span>kind <span class="dt">BiTagged</span>
<span class="dt">BiTagged</span><span class="ot"> ::</span> k <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="fu">*</span>
<span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span><span class="kw">type</span> <span class="dt">BiTaggedData</span>
<span class="dt">BiTaggedData</span><span class="ot"> ::</span> forall k (<span class="ot">tag2 ::</span> k) (<span class="ot">tag1 ::</span> k)<span class="fu">.</span> <span class="dt">BiTagged</span> tag1 tag2 </code></pre></div>
<p>このように種変数を使った種注釈も可能です。これを活用すれば、より強力な型コンストラクタを作ることも可能になるでしょう。</p>
<h3 id="この章のまとめ-1">この章のまとめ</h3>
<p>この章では、種に付随する、二つの重要な<span class="ascii">GHC</span>拡張を紹介しました。</p>
<p><code>KindSignatures</code>拡張は、種注釈を行えるようにする拡張でした。種注釈によってこれまで表現できなかった型コンストラクタが作れるようになるのはもちろんのこと、分かりやすさや種推論による混乱を避けるための明示的な注釈として、この拡張はとても便利でした。</p>
<p>もう一つの<code>PolyKinds</code>拡張は、種多相を可能にしてくれる拡張でした。標準では、全ての種は具体化され、曖昧なところは全て標準の種<code>*</code>によって具体化されます。しかし、この拡張によりデフォルトの動作を、抽象化されたまま型変数として残す動作に切り替えることができるようになります。これによって、それぞれの種に対しての具体的な型コンストラクタを用意する必要も無くなります。また、種注釈を多相的に行うことも可能になるのでした。</p>
<h2 id="まとめ">まとめ</h2>
<p>今回は、種の基本概念と、種に関連する<span class="ascii">GHC</span>拡張を紹介しました。</p>
<p>続編<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>では、<code>*</code>の他の幾つかの種と、種とは別の型の分類についての紹介などを踏まえた、幾つかの種に関連する話題について、話したいと思います。</p>
<p><strong>追記</strong><span class="ascii">:</span> <a href="12-about-kind-system-part2.html">続編</a>を書きました。続きが気になる方は、読んでみてください。</p>
<h2 id="参考文献">参考文献</h2>
<ul>
<li><a href="https://www.haskell.org/onlinereport/haskell2010/haskell.html"><span class="ascii">Haskell2010 Language Report</span></a><span class="ascii">: Haskell2010</span>の仕様書です。主に標準の仕組みを紹介する際に参照しました。
<ul>
<li><a href="https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-640004.1.1"><span class="ascii">4.1.1 Kinds</span></a><span class="ascii">:</span> 種の定義が書いてあります。</li>
<li><a href="https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-970004.6"><span class="ascii">4.6 Kind inference</span></a><span class="ascii">:</span> 種推論について書かれています。</li>
</ul></li>
<li><a href="https://downloads.haskell.org/~ghc/8.0.2/docs/html/users_guide/"><span class="ascii">GHC 8.0.2 Users Guide</span></a><span class="ascii">:</span> 主な種に関する参考資料としてと<span class="ascii">GHC</span>拡張についての資料として参考にしました。
<ul>
<li><a href="https://downloads.haskell.org/~ghc/8.0.2/docs/html/users_guide/glasgow_exts.html#kind-polymorphism-and-type-in-type"><span class="ascii">10.11 Kind polymorphism and Type-in-Type</span></a><span class="ascii">: GHC</span>においての種推論などの、種に関することが総括してあります。</li>
<li><a href="https://downloads.haskell.org/~ghc/8.0.2/docs/html/users_guide/glasgow_exts.html#explicitly-kinded-quantification"><span class="ascii">10.15.4 Explicitly-kinded quantification</span></a><span class="ascii">:</span> <code>KindSignatures</code>拡張の概要が書かれています。</li>
</ul></li>
<li><a href="http://dev.stephendiehl.com/hask/#promotion"><span class="ascii">What I Wish I Knew When Learning Haskell - Promotion</span></a><span class="ascii">:</span> 簡単にですが幾つか種に関する話題がまとまっています。あんまり参考にしていませんが、リンクとして置いておきます。</li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/Kinds"><span class="ascii">GHC Wiki - Commentary/Compiler/Kinds</span></a><span class="ascii">:</span> この記事のストーリーを決める際に参照しました。続編では、このページを元にしたもう少し踏み込んだトピックも扱う予定です。</li>
</ul>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>名前を一緒にする風習がややこしいですが、<span class="ascii">Haskell</span>はそういう文化があるので慣れるしかないですね<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>この型注釈上の<code>Id</code>は型コンストラクタであることに注意してください！<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>データコンストラクタが値から構築されることを考えれば、当たり前ですね<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>多分<span class="ascii">9</span>月中に出す。きっとね！ 続きが気になる人は、期待しないで待っててください。<a href="#fnref4">↩</a></p></li>
</ol>
</div>
            </div>
        </div>
    </div>
</article>



    <hr>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <ul class="list-inline text-center">
                        <li>
                            <a href="https://github.com/haskell-jp/blog">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    </ul>
                    <p class="copyright text-muted">&copy; Haskell-jp 2017</p>
                    <small class="text-muted notice-ga">当ウェブサイトでは<a href="https://support.google.com/analytics/answer/6004245?hl=ja">Google Analytics</a>でアクセス情報を収集しています。集めた情報は統計的に処理した上で、当ウェブサイトの改善のための参考情報としてのみ使用します。</small>
                </div>
            </div>
        </div>
    </footer>

    <!-- jQuery -->
    <script src="../../js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../../js/bootstrap.min.js"></script>

    <!-- Custom Theme JavaScript -->
    <script src="../../js/clean-blog.js"></script>

    <!-- Google Analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-94110610-1', 'auto');
      ga('send', 'pageview');
    </script>
</body>

</html>
