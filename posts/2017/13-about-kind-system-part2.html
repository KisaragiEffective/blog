<!DOCTYPE html>
<html lang="ja">

<head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# article: http://ogp.me/ns/article#">

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Haskellの種(kind)について (Part 2)">
    
      <meta name="author" content="mizunashi-mana">
    
    <link rel="alternate" type="application/atom+xml" title="Haskell-jp Blog" href="https://haskell.jp/blog/feed.xml" />
    <link rel="icon" href="https://haskell.jp/img/favicon.png" />

    <!-- OGP Settings -->
    <meta property="og:title" content="Haskellの種(kind)について (Part 2) - Haskell-jp" />
    <meta property="og:type" content="article" />
    <meta property="og:url" content="/posts/2017/13-about-kind-system-part2.html" />
    <meta property="og:image" content="https://haskell.jp/blog/img/logo-square.png" />
    <meta property="og:site_name" content="Haskell-jp Blog" />
    <meta property="og:description" content="---Haskellには種(kind)という仕組みがあります。大雑把に言ってしまえば、「型の型」を実現する仕組みです。この仕組みについて、あまり情報が出回っていないようなので、解説記事を残しておこうと思います。なお、前編と後編に分かれていて、この記事は後編になります。前編は[こちら][part1-link]になります。この記事は、[Ladder of Functional Programming]" />

    <!-- Twitter Card Settings -->
    <meta name="twitter:card" content="summary" />

    

    <title>Haskellの種(kind)について (Part 2) - Haskell-jp</title>

    <!-- Bootstrap Core CSS -->
    <link href="../../css/bootstrap.css" rel="stylesheet">
    <!-- <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css" rel="stylesheet"> -->

    <!-- Pandoc syntax highlighting CSS -->
    <link href="../../css/syntax.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="../../css/clean-blog.css" rel="stylesheet">

    <!-- Our original CSS -->
    <link href="../../css/style.css" rel="stylesheet">

    <!-- Custom Fonts -->
    <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-default navbar-fixed-top" role="navigation">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="https://haskell.jp"><img src="../../img/logo.svg"></a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    <li>
                        <a href="../../posts/about_us.html">About</a>
                    </li>
                    <li>
                        <a href="../../">Blog</a>
                    </li>
                    <li>
                        <a href="https://haskell.jp/signin-slack.html">Slack Team</a>
                    </li>
                    <li>
                        <a href="https://www.reddit.com/r/haskell_jp/">Reddit</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>
    
    <!-- Page Header -->
    <header class="intro-header" style="background-image: url('../../img/background.png'); background-color: #F3DFBC;">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                  
                  <div lang="ja" class="post-heading">
                  
                    <div class="jumbotron" style="background: #eee;">
                      <h1>Haskellの種(kind)について (Part 2)</h1>
                      <h2 class="subheading">種の仕組みとそれに付随する言語拡張について</h2><span class="meta">Posted by mizunashi-mana on September 18, 2017</span>
                    </div>
                  </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p><span class="ascii">Haskell</span>には種<span class="ascii">(kind)</span>という仕組みがあります。大雑把に言ってしまえば、「型の型」を実現する仕組みです。この仕組みについて、あまり情報が出回っていないようなので、解説記事を残しておこうと思います。なお、前編と後編に分かれていて、この記事は後編になります。前編は<a href="10-about-kind-system-part1.html">こちら</a>になります。</p>
<p>この記事は、<a href="http://lambdaconf.us/downloads/documents/lambdaconf_slfp.pdf"><span class="ascii">Ladder of Functional Programming</span></a> <span class="ascii">(</span><a href="http://qiita.com/lotz/items/0d68c8440d1f362d0c32">日本語訳</a><span class="ascii">)</span>の <strong><span class="ascii">FIRE LUBLINE(ADVANCED BEGINNER)</span></strong> を対象に、<a href="10-about-kind-system-part1.html"><span class="ascii">Part 1</span></a>の続きとして、種に付随する<span class="ascii">GHC</span>言語拡張やパッケージを紹介するものです。</p>
<p>なお、特に断らない限り、対象として<span class="ascii">GHC8</span>系を設定しています。<code>stack</code>を使ってる方は<code>resolver</code>を<span class="ascii">LTS Haskell 7</span>以降に設定しておくことを推奨します。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#様々な種" title="様々な種">様々な種</a>
<ul>
<li><a href="#型制約の種" title="型制約の種">型制約の種</a></li>
<li><a href="#データ型の昇格" title="データ型の昇格">データ型の昇格</a></li>
<li><a href="#型の分類" title="型の分類">型の分類</a></li>
<li><a href="#この章のまとめ" title="この章のまとめ">この章のまとめ</a></li>
</ul></li>
<li><a href="#advanced-topics" title="advanced-topics"><span class="ascii">Advanced Topics</span></a>
<ul>
<li><a href="#もう一つの型の分類" title="もう一つの型の分類">もう一つの型の分類</a></li>
<li><a href="#軽率多相" title="軽率多相">軽率多相</a></li>
<li><a href="#トップレベル種注釈" title="トップレベル種注釈">トップレベル種注釈</a></li>
<li><a href="#unliftedデータ型" title="unliftedデータ型"><span class="ascii">Unlifted</span>データ型</a></li>
<li><a href="#type-in-type" title="type-in-type"><span class="ascii">Type in Type</span></a></li>
<li><a href="#この章のまとめ-1" title="この章のまとめ-1">この章のまとめ</a></li>
</ul></li>
<li><a href="#まとめ" title="まとめ">まとめ</a></li>
<li><a href="#参考文献" title="参考文献">参考文献</a></li>
</ul>
</div>
</div>
<h2 id="様々な種"><span class="link-to-here-outer"><a href="#様々な種" title="様々な種"><span class="link-to-here">Link to<br />
here</span></a></span>様々な種</h2>
<h3 id="型制約の種"><span class="link-to-here-outer"><a href="#型制約の種" title="型制約の種"><span class="link-to-here">Link to<br />
here</span></a></span>型制約の種</h3>
<p><a href="10-about-kind-system-part1.html">前回の記事</a>では、種の基本的な仕組みを紹介しました。全てのデータ型は<code>*</code>という種を持っており、データ宣言は<code>*</code>の種を持つ型を作る型コンストラクタを定義するのでした<span class="ascii">:</span></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">newtype</span> <span class="dt">WrappedInt</span> <span class="ot">=</span> <span class="dt">WrappedInt</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="dt">WrappedInt</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="dt">WrappedInt</span><span class="ot"> ::</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="op">&gt;&gt;&gt;</span> <span class="kw">data</span> <span class="dt">Tag</span> a <span class="ot">=</span> <span class="dt">Tag</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="dt">Tag</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="dt">Tag</span><span class="ot"> ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span></a></code></pre></div>
<p>さて、<span class="ascii">Haskell</span>標準には上のようなデータ型を表す<code>*</code>と、型コンストラクタを表す<code>k1 -&gt; k2</code>という形の種<span class="ascii">(</span>例えば、<code>* -&gt; *</code>や<code>* -&gt; (* -&gt; *)</code>など<span class="ascii">)</span>しかありませんでした。<span class="ascii">GHC</span>では、他にもいくつか種を導入しています。今日は、その幾つかを紹介していきます。一つ目が、型制約を表す種<code>Constraint</code>です。この種を伴う仕組みは<code>ConstraintKinds</code>拡張により導入できます。</p>
<p><span class="ascii">Haskell</span>の型上には、データ型や型コンストラクタの他にも、型制約という登場人物がいます。型制約は名前の通り、型の制約が書けるようにするものです。以下の関数をみてください<span class="ascii">:</span></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="ot">minByOrd ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb2-2" title="2">minByOrd x y <span class="ot">=</span> <span class="kw">if</span> x <span class="op">&lt;</span> y <span class="kw">then</span> x <span class="kw">else</span> y</a></code></pre></div>
<p>この関数<code>minByOrd</code>は、型<code>a</code>が順序を持つ<span class="ascii">(</span><code>Ord</code>クラスのインスタンスである<span class="ascii">)</span>という制約を満たしている時、二つの引数のうち小さい方を<code>Ord</code>のメソッド<code>&lt;</code>を使用して返します。</p>
<p>型制約は、型クラスを使うことで作ることができます。例えば、ある型がデフォルトの値を持つという制約は、以下のように書けます<span class="ascii">:</span></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">class</span> <span class="dt">HasDefault</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="ot">  defaultValue ::</span> a</a></code></pre></div>
<p>この型クラスを使うことで、デフォルトの値を持つ型制約を満たしている型上では、<code>defaultValue</code>メソッドを使用することができるようになります。例えば、以下のようにです<span class="ascii">:</span></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="ot">fromMaybe ::</span> <span class="dt">HasDefault</span> a <span class="ot">=&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb4-2" title="2">fromMaybe (<span class="dt">Just</span> x) <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb4-3" title="3">fromMaybe <span class="dt">Nothing</span>  <span class="ot">=</span> defaultValue</a></code></pre></div>
<p>この関数は、型<code>a</code>が<code>HasDefault a</code>という型制約を満たしているならば、<code>Maybe a</code>の値をパターンマッチし、中身が<code>Just</code>ならそのまま<code>Just</code>を外して値を返し、<code>Nothing</code>ならデフォルト値を<code>defaultValue</code>メソッドを使用して、返します。</p>
<p>ここからが本題です。実は<span class="ascii">GHC</span>上では、型制約にも種が割り当てられています。見てみましょう<span class="ascii">:</span></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="dt">HasDefault</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="dt">HasDefault</span><span class="ot"> ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span></a></code></pre></div>
<p><code>HasDefault</code>型クラスは、<code>*</code>の種を持つ型を受け取り、<code>Constraint</code>の種を持つ型制約を返します。<code>Constraint</code>は<span class="ascii">GHC</span>が導入している、型制約を表す種です。型制約は、<span class="ascii">GHC</span>上ではこの <strong>型制約種<code>Constraint</code></strong> を持ちます。つまり、<code>HasDefault :: * -&gt; Constraint</code>は、<code>*</code>の種の型、つまりデータ型を一つ受け取り、型制約になるような型上の関数になります。実際に、データ型を適用して型制約にしてみましょう<span class="ascii">:</span></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="dt">HasDefault</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="dt">HasDefault</span> <span class="dt">Bool</span><span class="ot"> ::</span> <span class="dt">Constraint</span></a></code></pre></div>
<p>適用結果は、ちゃんと<code>Constraint</code>の種を持っています。ここで、種の計算では型の計算は行われないことに注意してください！ <code>kind</code>コマンドは、型の計算は行わないのでした。私たちは、<code>Bool</code>を<code>HasDefault</code>のインスタンスにしていないため、実際にはこの型制約は満たされません。型の計算を実際に行ってみましょう。上で定義した<code>fromMaybe</code>を実際に<code>Bool</code>型に使ってみます<span class="ascii">:</span></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span><span class="kw">type</span> fromMaybe <span class="op">$</span> <span class="dt">Just</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb7-2" title="2"></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">1</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span></a>
<a class="sourceLine" id="cb7-4" title="4">    • <span class="dt">No</span> <span class="kw">instance</span> for (<span class="dt">HasDefault</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb7-5" title="5">        arising from a use <span class="kw">of</span> ‘fromMaybe’</a>
<a class="sourceLine" id="cb7-6" title="6">    • <span class="dt">In</span> the expression<span class="op">:</span> fromMaybe <span class="op">$</span> <span class="dt">Just</span> <span class="dt">True</span></a></code></pre></div>
<p>「<code>HasDefault</code>は<code>Bool</code>に対してインスタンスを持っていない」と型エラーになっていることが分かります。このように型の計算は<code>type</code>コマンドで確かめることができるのでした。これらの型計算は、もう少し直接的に確かめることもできます。次を見てください<span class="ascii">:</span></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XFlexibleContexts</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span><span class="kw">type</span><span class="ot"> undefined ::</span> <span class="dt">HasDefault</span> <span class="dt">Bool</span> <span class="ot">=&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb8-3" title="3"></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">1</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span></a>
<a class="sourceLine" id="cb8-5" title="5">    <span class="dt">No</span> <span class="kw">instance</span> for (<span class="dt">HasDefault</span> <span class="dt">Bool</span>) arising from a use <span class="kw">of</span> ‘it’</a></code></pre></div>
<p>このように、型の計算だけを行わせる場合、<code>undefined</code>を使用するのが便利です。<span class="ascii">Haskell</span>標準では、型制約はあまり柔軟には書けません。具体的な型を伴う上のような制約も書けないため、<code>FlexibleContexts</code>拡張を使用することで書けるようにしています。上の型表記で登場する、<code>=&gt;</code>という表記は、左で指定された型制約を満たしているならば右で指定された型付けの関数になる、という意味を持っています。つまり、型上の演算子として考えるなら、<code>(=&gt;) :: Constraint -&gt; * -&gt; *</code>という種になります。なので、例えば以下のような型表記は、種の辻褄が合わなくなります<span class="ascii">:</span></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="dt">Int</span> <span class="ot">=&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb9-2" title="2"></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">1</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span></a>
<a class="sourceLine" id="cb9-4" title="4">    • <span class="dt">Expected</span> a constraint, but ‘<span class="dt">Int</span>’ has kind ‘<span class="op">*</span>’</a>
<a class="sourceLine" id="cb9-5" title="5">    • <span class="dt">In</span> the <span class="kw">type</span> ‘<span class="dt">Int</span> <span class="ot">=&gt;</span> <span class="dt">Bool</span>’</a>
<a class="sourceLine" id="cb9-6" title="6"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="dt">HasDefault</span> <span class="ot">=&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb9-7" title="7"></a>
<a class="sourceLine" id="cb9-8" title="8"><span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">1</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span></a>
<a class="sourceLine" id="cb9-9" title="9">    • <span class="dt">Expecting</span> one more argument to ‘<span class="dt">HasDefault</span>’</a>
<a class="sourceLine" id="cb9-10" title="10">      <span class="dt">Expected</span> a constraint, but ‘<span class="dt">HasDefault</span>’ has kind ‘<span class="op">*</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span>’</a>
<a class="sourceLine" id="cb9-11" title="11">    • <span class="dt">In</span> the <span class="kw">type</span> ‘<span class="dt">HasDefault</span> <span class="ot">=&gt;</span> <span class="dt">Bool</span>’</a></code></pre></div>
<p><code>kind</code>コマンドによって、種が合わないとエラーになっていることが分かります。残念ながら、<code>=&gt;</code>は実際には型演算子ではなく、<code>(=&gt;)</code>というように型関数として扱うことはできません。ですが、それは表記上の問題であり、確かに種の計算の際、型制約を受け取る型演算子として、<code>Constraint</code>の種を持つか検査が行われていることは分かるでしょう。</p>
<p>さて、今までは型制約種<code>Constraint</code>について、<span class="ascii">GHCi</span>上で色々試しながら見てきました。型制約種に関しての雰囲気は分かってもらえたと思います。型制約種<code>Constraint</code>をもう少し詳しく見ていきましょう。以下を見てください<span class="ascii">:</span></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">data</span> <span class="dt">SimpleData</span> a <span class="ot">=</span> <span class="dt">SimpleData</span> a</a>
<a class="sourceLine" id="cb10-2" title="2"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="dt">SimpleData</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="dt">SimpleData</span><span class="ot"> ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb10-4" title="4"><span class="op">&gt;&gt;&gt;</span> <span class="kw">class</span> <span class="dt">SimpleClass</span> a <span class="kw">where</span><span class="ot"> simpleMethod ::</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb10-5" title="5"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="dt">SimpleClass</span></a>
<a class="sourceLine" id="cb10-6" title="6"><span class="dt">SimpleClass</span><span class="ot"> ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span></a></code></pre></div>
<p>データ宣言と型クラス宣言を並べてみました。この二つはよく似ています。</p>
<ul>
<li>データ宣言は、<code>*</code>という種の型になるような型コンストラクタ<code>SimpleData :: * -&gt; *</code>を作り、<code>SimpleData :: a -&gt; SimpleData a</code>という値コンストラクタを作ります。</li>
<li>型クラス宣言は、<code>Constraint</code>という種の型制約になるような<code>SimpleClass :: * -&gt; Constraint</code>を作り、<code>simpleMethod :: SimpleClass a =&gt; a -&gt; a</code>というような関数を作ります。</li>
</ul>
<p>作られるものがそれぞれ違いますが、両方型の世界に一つの型関数、値の世界に関数を作るわけです。型クラスの方をデータ宣言に合わせるとしたら、型クラスは型制約コンストラクタとメソッドを作るものと言えるかもしれません。型の世界だけでの話なら、データ宣言は型コンストラクタを、型クラスは型制約コンストラクタを単に作るだけの構文ということになります。ではここで、データ型と型制約の対比を表にしてみましょう。</p>
<table>
<thead>
<tr class="header">
<th>種</th>
<th>表現される型</th>
<th>定義方法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>*</code></td>
<td>データ型</td>
<td>データ宣言<span class="ascii">(</span><code>data C a = ...</code><span class="ascii">)</span></td>
</tr>
<tr class="even">
<td><code>Constraint</code></td>
<td>型制約</td>
<td>型クラス宣言<span class="ascii">(</span><code>class C a where ...</code><span class="ascii">)</span></td>
</tr>
</tbody>
</table>
<p>両者はそれぞれ特別な意味を与えられています。実際、データ型が値を持ち<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>、それによって型注釈が書けるように、型制約は<code>=&gt;</code>という特別に型制約を計算するような型上の構文を持っています。ですが、逆に言えば特別なのはそれだけで、それ以外に両者の違いはありません。例えば、<code>Proxy</code>型は種多相化されているので、型制約や型制約コンストラクタ<span class="ascii">(</span>型クラス<span class="ascii">)</span>を渡すこともできます<span class="ascii">:</span></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">import</span> <span class="dt">Data.Proxy</span></a>
<a class="sourceLine" id="cb11-2" title="2"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="dt">Proxy</span></a>
<a class="sourceLine" id="cb11-3" title="3"><span class="dt">Proxy</span><span class="ot"> ::</span> k <span class="ot">-&gt;</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb11-4" title="4"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span><span class="kw">type</span> <span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">Monoid</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb11-5" title="5"><span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">Monoid</span> <span class="dt">Bool</span>)<span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">Monoid</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb11-6" title="6"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span><span class="kw">type</span> <span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">Monoid</span></a>
<a class="sourceLine" id="cb11-7" title="7"><span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">Monoid</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">Monoid</span></a></code></pre></div>
<p><code>=&gt;</code>を使用していないので、型制約の計算は行われないことに注意してください！ また、<code>Proxy</code>型コンストラクタは、それぞれ以下のように特殊化されます<span class="ascii">:</span></p>
<ul>
<li><code>Proxy :: Proxy (Monoid Bool)</code>の場合は、<code>Proxy :: Constraint -&gt; *</code></li>
<li><code>Proxy :: Proxy Monoid</code>の場合は、<code>Proxy :: (* -&gt; Constraint) -&gt; *</code></li>
</ul>
<p>では、この<code>Proxy</code>で型制約を受け取り、型制約の計算だけを行うような関数を作って使って見ましょう。その関数は、以下のように作ることができます<span class="ascii">:</span></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XConstraintKinds</span></a>
<a class="sourceLine" id="cb12-2" title="2"><span class="op">&gt;&gt;&gt;</span> <span class="kw">import</span> <span class="dt">Data.Proxy</span></a>
<a class="sourceLine" id="cb12-3" title="3"><span class="op">&gt;&gt;&gt;</span> <span class="co">-- 型制約計算を行う関数を定義</span></a>
<a class="sourceLine" id="cb12-4" title="4"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>{</a>
<a class="sourceLine" id="cb12-5" title="5"><span class="ot">    evalConstraint ::</span> a <span class="ot">=&gt;</span> <span class="dt">Proxy</span> a <span class="ot">-&gt;</span> ()</a>
<a class="sourceLine" id="cb12-6" title="6">    evalConstraint _ <span class="ot">=</span> ()</a>
<a class="sourceLine" id="cb12-7" title="7">    <span class="op">:</span>}</a>
<a class="sourceLine" id="cb12-8" title="8"><span class="op">&gt;&gt;&gt;</span> <span class="co">-- この段階では、まだ型制約計算されない!</span></a>
<a class="sourceLine" id="cb12-9" title="9"><span class="op">&gt;&gt;&gt;</span> <span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">Monoid</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb12-10" title="10"><span class="dt">Proxy</span></a>
<a class="sourceLine" id="cb12-11" title="11"><span class="op">&gt;&gt;&gt;</span> <span class="co">-- 型制約計算をする関数に適用</span></a>
<a class="sourceLine" id="cb12-12" title="12"><span class="op">&gt;&gt;&gt;</span> evalConstraint (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">Monoid</span> <span class="dt">Bool</span>))</a>
<a class="sourceLine" id="cb12-13" title="13"></a>
<a class="sourceLine" id="cb12-14" title="14"><span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">12</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span></a>
<a class="sourceLine" id="cb12-15" title="15">    • <span class="dt">No</span> <span class="kw">instance</span> for (<span class="dt">Monoid</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb12-16" title="16">        arising from a use <span class="kw">of</span> ‘evalConstraint’</a>
<a class="sourceLine" id="cb12-17" title="17">    • <span class="dt">In</span> the expression<span class="op">:</span> evalConstraint (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">Monoid</span> <span class="dt">Bool</span>))</a>
<a class="sourceLine" id="cb12-18" title="18">      <span class="dt">In</span> an equation for ‘it’<span class="op">:</span></a>
<a class="sourceLine" id="cb12-19" title="19">          it <span class="ot">=</span> evalConstraint (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">Monoid</span> <span class="dt">Bool</span>))</a>
<a class="sourceLine" id="cb12-20" title="20"><span class="op">&gt;&gt;&gt;</span> evalConstraint (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">Monoid</span> <span class="dt">String</span>))</a>
<a class="sourceLine" id="cb12-21" title="21">()</a></code></pre></div>
<p>やっと、<code>ConstraintKinds</code>拡張の登場です。<code>ConstraintKinds</code>拡張は、型制約に関する<span class="ascii">Haskell</span>標準の制限を幾つか取り払う拡張です。どのようなことが可能になるかは後で紹介するとして、今は上の関数の使い方に注目しましょう。この例のように、型制約は<code>Proxy</code>型で持ち回し<code>=&gt;</code>で任意のタイミングで型制約計算を行うといったことも可能です。面白いですね。</p>
<p>上の<code>Proxy</code>を使った例から明らかですが、もちろんデータ宣言時に種注釈を使うことで型制約を受け取るようなデータ型を作ることもできるわけです。そして、型制約を受け取るような型クラスも作ることができます。次の例を見てください<span class="ascii">:</span></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XKindSignatures</span> <span class="op">-</span><span class="dt">XFlexibleInstances</span></a>
<a class="sourceLine" id="cb13-2" title="2"><span class="op">&gt;&gt;&gt;</span> <span class="kw">import</span> <span class="dt">GHC.Exts</span> (<span class="dt">Constraint</span>)</a>
<a class="sourceLine" id="cb13-3" title="3"><span class="op">&gt;&gt;&gt;</span> <span class="kw">class</span> <span class="dt">AConstraint</span> (<span class="ot">c ::</span> <span class="dt">Constraint</span>)</a>
<a class="sourceLine" id="cb13-4" title="4"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="dt">AConstraint</span></a>
<a class="sourceLine" id="cb13-5" title="5"><span class="dt">AConstraint</span><span class="ot"> ::</span> <span class="dt">Constraint</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span></a>
<a class="sourceLine" id="cb13-6" title="6"><span class="op">&gt;&gt;&gt;</span> <span class="kw">instance</span> <span class="dt">AConstraint</span> (<span class="dt">Monad</span> <span class="dt">Maybe</span>)</a></code></pre></div>
<p><code>FlexibleInstances</code>拡張は、<code>FlexibleContexts</code>拡張と同じような拡張で、<code>FlexibleContexts</code>は型制約の書き方の制限を、<code>FlexibleInstances</code>拡張はインスタンスの書き方の制限をそれぞれ取り払う拡張です。また、<code>Constraint</code>種は<code>GHC.Exts</code>モジュールに入っていて、使用する際はこのモジュールを<code>import</code>する必要があります。これらを使って、上のようにすれば、型制約の分類分けすらすることができるようになります。</p>
<p>他にも<code>Constraint</code>に関連する特殊な型上の演算子があります。普段気にも留めていなかったと思いますが、型制約のペアです。<span class="ascii">GHC</span>上では、以下のような型制約が書けます<span class="ascii">:</span></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="co">-- 常に型制約は満たされる</span></a>
<a class="sourceLine" id="cb14-2" title="2"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span><span class="kw">type</span><span class="ot"> undefined ::</span> () <span class="ot">=&gt;</span> a</a>
<a class="sourceLine" id="cb14-3" title="3"><span class="fu">undefined</span><span class="ot"> ::</span> () <span class="ot">=&gt; a ::</span> a</a>
<a class="sourceLine" id="cb14-4" title="4"><span class="op">&gt;&gt;&gt;</span> <span class="co">-- 二つの型制約が満たされる場合に、満たされる</span></a>
<a class="sourceLine" id="cb14-5" title="5"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span><span class="kw">type</span><span class="ot"> undefined ::</span> (<span class="dt">Monad</span> m, <span class="dt">Monoid</span> a) <span class="ot">=&gt;</span> m a</a>
<a class="sourceLine" id="cb14-6" title="6"><span class="fu">undefined</span><span class="ot"> ::</span> (<span class="dt">Monad</span> m, <span class="dt">Monoid</span> a) <span class="ot">=&gt;</span> m a</a>
<a class="sourceLine" id="cb14-7" title="7"><span class="ot">  ::</span> (<span class="dt">Monoid</span> a, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> m a</a>
<a class="sourceLine" id="cb14-8" title="8"><span class="op">&gt;&gt;&gt;</span> <span class="co">-- 以下の二つは同じ</span></a>
<a class="sourceLine" id="cb14-9" title="9"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XConstraintKinds</span></a>
<a class="sourceLine" id="cb14-10" title="10"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span><span class="kw">type</span><span class="ot"> undefined ::</span> (<span class="dt">Monad</span> m, <span class="dt">Monoid</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> m a</a>
<a class="sourceLine" id="cb14-11" title="11"><span class="fu">undefined</span><span class="ot"> ::</span> (<span class="dt">Monad</span> m, <span class="dt">Monoid</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> m a</a>
<a class="sourceLine" id="cb14-12" title="12"><span class="ot">  ::</span> (<span class="dt">Show</span> a, <span class="dt">Monoid</span> a, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> m a</a>
<a class="sourceLine" id="cb14-13" title="13"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span><span class="kw">type</span><span class="ot"> undefined ::</span> ((<span class="dt">Monad</span> m, <span class="dt">Monoid</span> a), <span class="dt">Show</span> a) <span class="ot">=&gt;</span> m a</a>
<a class="sourceLine" id="cb14-14" title="14"><span class="fu">undefined</span><span class="ot"> ::</span> ((<span class="dt">Monad</span> m, <span class="dt">Monoid</span> a), <span class="dt">Show</span> a) <span class="ot">=&gt;</span> m a</a>
<a class="sourceLine" id="cb14-15" title="15"><span class="ot">  ::</span> (<span class="dt">Show</span> a, <span class="dt">Monoid</span> a, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> m a</a></code></pre></div>
<p>最後の例では<code>ConstraintKinds</code>拡張を使用していますが、これについては最後にどんな拡張なのか説明しましょう。今、注目してもらいたいのは、型制約のペアについてです。普段何気なく使っていると思いますが、これらも一種の型制約の演算子と見ることができるわけです。注意してもらいたいのが、この演算子はタプル型と同じ形式だということです。次を見てください<span class="ascii">:</span></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind ()</a>
<a class="sourceLine" id="cb15-2" title="2"><span class="ot">() ::</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb15-3" title="3"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind (<span class="dt">Bool</span>, <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb15-4" title="4">(<span class="dt">Bool</span>, <span class="dt">Int</span>)<span class="ot"> ::</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb15-5" title="5"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind (<span class="dt">Monad</span> <span class="dt">Maybe</span>, <span class="dt">Monoid</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb15-6" title="6">(<span class="dt">Monad</span> <span class="dt">Maybe</span>, <span class="dt">Monoid</span> <span class="dt">Bool</span>)<span class="ot"> ::</span> <span class="dt">Constraint</span></a>
<a class="sourceLine" id="cb15-7" title="7"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind (<span class="dt">Bool</span>, <span class="dt">Monad</span> <span class="dt">Maybe</span>)</a>
<a class="sourceLine" id="cb15-8" title="8"></a>
<a class="sourceLine" id="cb15-9" title="9"><span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">1</span><span class="op">:</span><span class="dv">8</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span></a>
<a class="sourceLine" id="cb15-10" title="10">    • <span class="dt">Expected</span> a <span class="kw">type</span>, but ‘<span class="dt">Monad</span> <span class="dt">Maybe</span>’ has kind ‘<span class="dt">Constraint</span>’</a>
<a class="sourceLine" id="cb15-11" title="11">    • <span class="dt">In</span> the <span class="kw">type</span> ‘(<span class="dt">Bool</span>, <span class="dt">Monad</span> <span class="dt">Maybe</span>)’</a>
<a class="sourceLine" id="cb15-12" title="12"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind (<span class="dt">Monad</span> <span class="dt">Maybe</span>, <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb15-13" title="13"></a>
<a class="sourceLine" id="cb15-14" title="14"><span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">1</span><span class="op">:</span><span class="dv">15</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span></a>
<a class="sourceLine" id="cb15-15" title="15">    • <span class="dt">Expected</span> a constraint, but ‘<span class="dt">Bool</span>’ has kind ‘<span class="op">*</span>’</a>
<a class="sourceLine" id="cb15-16" title="16">    • <span class="dt">In</span> the <span class="kw">type</span> ‘(<span class="dt">Monad</span> <span class="dt">Maybe</span>, <span class="dt">Bool</span>)’</a></code></pre></div>
<p><code>()</code>は、ユニット型の方が優先されています。<code>(,)</code>は、最初に書いた型の種によって、受け取る種が左右されていることが分かりますね。型制約のペアは、<code>(,) (Monad Maybe) (Monoid Bool)</code>というような表記は許容されていませんが、それ以外はあまりタプル型と変わりありません。異なるのは、タプル型が幾つかのデータ型を受け取って一つのデータ型となるのに対し、型制約のペアは型制約を幾つか受け取りそれを全て満たすような型制約になるということです。</p>
<p>最後に<code>ConstraintKinds</code>拡張をきちんと紹介しておきましょう。<code>ConstraintKinds</code>拡張は、次のようなことを可能にしてくれる拡張です。</p>
<ul>
<li>型エイリアスと同じ構文で、型制約コンストラクタのエイリアスを書くことができるようになる。</li>
</ul>
<p>つまり、次のようなことが可能になります<span class="ascii">:</span></p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="ot">{-# LANGUAGE ConstraintKinds #-}</span></a>
<a class="sourceLine" id="cb16-2" title="2"></a>
<a class="sourceLine" id="cb16-3" title="3"><span class="co">-- 型制約のエイリアス</span></a>
<a class="sourceLine" id="cb16-4" title="4"><span class="kw">type</span> <span class="dt">MonMonad</span> m a <span class="ot">=</span> (<span class="dt">Monoid</span> (m a), <span class="dt">Monad</span> m)</a>
<a class="sourceLine" id="cb16-5" title="5"></a>
<a class="sourceLine" id="cb16-6" title="6"><span class="co">-- 型制約コンストラクタのエイリアス</span></a>
<a class="sourceLine" id="cb16-7" title="7"><span class="kw">type</span> <span class="dt">Mappable</span> <span class="ot">=</span> <span class="dt">Functor</span></a></code></pre></div>
<ul>
<li>型制約種<code>Constraint</code>を持つ型を、型制約として使用できるようにする。</li>
</ul>
<p>こちらは、あまり実感が湧かないかもしれません。デフォルトで、<span class="ascii">GHC</span>では型クラスなどを型制約として扱う、つまり<code>=&gt;</code>に渡すことができます。ですが、<code>Constraint</code>の種を持つ型制約変数などを渡すことはできません<span class="ascii">:</span></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">import</span> <span class="dt">Data.Proxy</span></a>
<a class="sourceLine" id="cb17-2" title="2"><span class="op">&gt;&gt;&gt;</span> <span class="co">-- 型クラスを型制約として使っているため、問題ない</span></a>
<a class="sourceLine" id="cb17-3" title="3"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span><span class="kw">type</span><span class="ot"> undefined ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a</a>
<a class="sourceLine" id="cb17-4" title="4"><span class="fu">undefined</span><span class="ot"> ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m<span class="ot"> a ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a</a>
<a class="sourceLine" id="cb17-5" title="5"><span class="op">&gt;&gt;&gt;</span> <span class="co">-- 型制約変数は、型制約として扱えない</span></a>
<a class="sourceLine" id="cb17-6" title="6"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span><span class="kw">type</span><span class="ot"> undefined ::</span> a <span class="ot">=&gt;</span> <span class="dt">Proxy</span> a</a>
<a class="sourceLine" id="cb17-7" title="7"></a>
<a class="sourceLine" id="cb17-8" title="8"><span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">1</span><span class="op">:</span><span class="dv">14</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span></a>
<a class="sourceLine" id="cb17-9" title="9">    • <span class="dt">Illegal</span> constraint<span class="op">:</span> a (<span class="dt">Use</span> <span class="dt">ConstraintKinds</span> to permit this)</a>
<a class="sourceLine" id="cb17-10" title="10">    • <span class="dt">In</span> an expression <span class="kw">type</span> signature<span class="op">:</span> a <span class="ot">=&gt;</span> <span class="dt">Proxy</span> a</a>
<a class="sourceLine" id="cb17-11" title="11">      <span class="dt">In</span> the expression<span class="op">:</span><span class="ot"> undefined ::</span> a <span class="ot">=&gt;</span> <span class="dt">Proxy</span> a</a>
<a class="sourceLine" id="cb17-12" title="12"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XConstraintKinds</span></a>
<a class="sourceLine" id="cb17-13" title="13"><span class="op">&gt;&gt;&gt;</span> <span class="co">-- 型制約種を持つものなら、型制約として扱えるようになる</span></a>
<a class="sourceLine" id="cb17-14" title="14"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span><span class="kw">type</span><span class="ot"> undefined ::</span> a <span class="ot">=&gt;</span> <span class="dt">Proxy</span> a</a>
<a class="sourceLine" id="cb17-15" title="15"><span class="fu">undefined</span><span class="ot"> ::</span> a <span class="ot">=&gt;</span> <span class="dt">Proxy</span><span class="ot"> a ::</span> a <span class="ot">=&gt;</span> <span class="dt">Proxy</span> a</a></code></pre></div>
<p><code>((Monad m, Monoid a), Show a)</code>などが標準で扱えないのも、<code>(Monad m, Monoid a)</code>という形式のものは型制約種を持ってはいますが、標準で許容されている形式ではないからです。このような場合に、より柔軟に扱えるようにしてくれる拡張が、<code>ConstraintKinds</code>拡張です。</p>
<p>型制約種<code>Constraint</code>について、馴染んでもらえたでしょうか？普段、この種や<code>ConstraintKinds</code>を明示的に使うような場面は少ないかもしれませんね。もし、型制約種について興味を持ったなら、<a href="http://hackage.haskell.org/package/constraints"><span class="ascii">constraints</span></a>というパッケージを見てみるのが良いでしょう。このパッケージは、型制約プログラミングに関する幾つかの有用な<span class="ascii">API</span>を提供しています。</p>
<h3 id="データ型の昇格"><span class="link-to-here-outer"><a href="#データ型の昇格" title="データ型の昇格"><span class="link-to-here">Link to<br />
here</span></a></span>データ型の昇格</h3>
<p>今までは、<code>*</code>や<code>Constraint</code>、<code>k1 -&gt; k2</code>といった、予め用意された特別な種を紹介してきました。<span class="ascii">GHC</span>上で、私たちが種を定義するような方法も、実は用意されています。それが、<code>DataKinds</code>という拡張です。<code>DataKinds</code>は基本的には簡単な拡張です。</p>
<p>私たちは、以下のようなデータ宣言を使ってデータ型を定義することができました<span class="ascii">:</span></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">data</span> <span class="dt">SimpleData</span> a <span class="ot">=</span> <span class="dt">SimpleData</span> a</a></code></pre></div>
<p>このデータ宣言は、</p>
<ul>
<li><code>SimpleData :: * -&gt; *</code>な、<code>SimpleData a</code>という<strong>データ型</strong>を作るような型コンストラクタ</li>
<li><code>SimpleData :: a -&gt; SimpleData a</code>な、<code>SimpleData a</code>という<strong>データ型の値</strong>を作る値コンストラクタ</li>
</ul>
<p>をそれぞれ作るのでした。<code>DataKinds</code>は、このそれぞれのコンストラクタを、一つ上の層に昇格させることができるようになる拡張です。どういうことかは、見てみた方が早いと思うので、<span class="ascii">GHCi</span>上でいくつか試してみます<span class="ascii">:</span></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="co">-- 単純なデータ型を作成</span></a>
<a class="sourceLine" id="cb19-2" title="2"><span class="op">&gt;&gt;&gt;</span> <span class="kw">data</span> <span class="dt">SimpleData</span> a <span class="ot">=</span> <span class="dt">SimpleData</span> a</a>
<a class="sourceLine" id="cb19-3" title="3"><span class="op">&gt;&gt;&gt;</span> <span class="co">-- DataKinds拡張有効化</span></a>
<a class="sourceLine" id="cb19-4" title="4"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XDataKinds</span></a>
<a class="sourceLine" id="cb19-5" title="5"><span class="op">&gt;&gt;&gt;</span> <span class="co">-- 通常のコンストラクタ</span></a>
<a class="sourceLine" id="cb19-6" title="6"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="dt">SimpleData</span></a>
<a class="sourceLine" id="cb19-7" title="7"><span class="dt">SimpleData</span><span class="ot"> ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb19-8" title="8"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span><span class="kw">type</span> <span class="dt">SimpleData</span></a>
<a class="sourceLine" id="cb19-9" title="9"><span class="dt">SimpleData</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">SimpleData</span> a</a>
<a class="sourceLine" id="cb19-10" title="10"><span class="op">&gt;&gt;&gt;</span> <span class="co">-- DataKindsによって、一つ上の層に昇格させたコンストラクタ</span></a>
<a class="sourceLine" id="cb19-11" title="11"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="dt">'SimpleData</span></a>
<a class="sourceLine" id="cb19-12" title="12"><span class="dt">'SimpleData</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">SimpleData</span> a</a></code></pre></div>
<p>最後の実行例に注目してください。ここで書かれている<code>SimpleData</code>は値コンストラクタのものです。先頭に<code>'</code><span class="ascii">(</span>シングルクォーテーション<span class="ascii">)</span>がついていますが、何より注目すべきなのは、種の表示にもやはり<code>SimpleData</code>というものが現れていることです。これが一つ上の層に昇格させるということになります。<code>DataKinds</code>拡張は、以下のようなものを提供する拡張になります<span class="ascii">:</span></p>
<ul>
<li>データ型の型コンストラクタを、種上で書けるようにする<span class="ascii">(</span><strong>種への昇格</strong><span class="ascii">)</span></li>
<li>データ型の値コンストラクタを、先頭に<code>'</code>を付けることにより型上で書けるようにする<span class="ascii">(</span><strong>型への昇格</strong><span class="ascii">)</span></li>
</ul>
<p>上の実行例では、<code>'SimpleData :: a -&gt; SimpleData a</code>の、</p>
<ul>
<li>種の表記に現れているものが、<strong>型コンストラクタ</strong><code>SimpleData :: * -&gt; *</code>を昇格したもの</li>
<li><code>'SimpleData</code>が、<strong>値コンストラクタ</strong><code>SimpleData :: a -&gt; SimpleData a</code>を昇格したもの</li>
</ul>
<p>になります。値コンストラクタ<code>SimpleData</code>は型多相化されたコンストラクタなので、それを昇格させた<code>'SimpleData</code>は種多相化された型コンストラクタになります。上の実行例の、</p>
<ul>
<li>最初の<code>SimpleData :: a -&gt; SimpleData</code>という表示での<code>a</code>は、任意の<span class="ascii">(</span><code>*</code>という種を持つような<span class="ascii">)</span><strong>型</strong>を、</li>
<li>二つ目の<code>'SimpleData :: a -&gt; SimpleData a</code>の<code>a</code>は、任意の<strong>種</strong>を、</li>
</ul>
<p>それぞれ表すということに注意してください。では、種多相化されていることを確認してみましょう。以下を見てください<span class="ascii">:</span></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="dt">'SimpleData</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb20-2" title="2"><span class="dt">'SimpleData</span> <span class="dt">Bool</span><span class="ot"> ::</span> <span class="dt">SimpleData</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb20-3" title="3"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="dt">'SimpleData</span> <span class="dt">Maybe</span></a>
<a class="sourceLine" id="cb20-4" title="4"><span class="dt">'SimpleData</span> <span class="dt">Maybe</span><span class="ot"> ::</span> <span class="dt">SimpleData</span> (<span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>)</a>
<a class="sourceLine" id="cb20-5" title="5"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="dt">'SimpleData</span> <span class="dt">Monad</span></a>
<a class="sourceLine" id="cb20-6" title="6"><span class="dt">'SimpleData</span> <span class="dt">Monoid</span><span class="ot"> ::</span> <span class="dt">SimpleData</span> (<span class="op">*</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span>)</a></code></pre></div>
<p><code>Proxy</code>型のように、どんな値でもとれるようになっていることが分かると思います。注意して欲しいのは、値コンストラクタ、型コンストラクタがそれぞれ一つ上に昇格されたので、<code>'SimpleData Monoid</code>という型を持つような値は存在しないということです。値を作るコンストラクタは昇格して型コンストラクタになってしまいましたからね！ 値を持つ型は全て、<code>*</code>という種を持つのでしたね。<code>SimpleData a</code>という種は<code>*</code>と一致しないため、値を持たないということもできます。値が存在しないならば、一体どういう場面で役に立つのでしょうか？ 一つの活用例としては、データ型のタグに利用ができます。以下を見てください<span class="ascii">:</span></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" title="1"><span class="ot">{-# LANGUAGE KindSignatures #-}</span></a>
<a class="sourceLine" id="cb21-2" title="2"></a>
<a class="sourceLine" id="cb21-3" title="3"><span class="kw">data</span> <span class="dt">GET</span></a>
<a class="sourceLine" id="cb21-4" title="4"><span class="kw">data</span> <span class="dt">POST</span></a>
<a class="sourceLine" id="cb21-5" title="5"><span class="kw">data</span> <span class="dt">PUT</span></a>
<a class="sourceLine" id="cb21-6" title="6"><span class="kw">data</span> <span class="dt">DELETE</span></a>
<a class="sourceLine" id="cb21-7" title="7"></a>
<a class="sourceLine" id="cb21-8" title="8"><span class="kw">data</span> <span class="dt">Request</span> (<span class="ot">a ::</span> <span class="op">*</span>) <span class="ot">=</span> <span class="dt">Request</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb21-9" title="9"></a>
<a class="sourceLine" id="cb21-10" title="10"><span class="ot">forGetMethod ::</span> <span class="dt">Request</span> <span class="dt">GET</span> <span class="ot">-&gt;</span> <span class="op">...</span></a></code></pre></div>
<p>この例は、<span class="ascii">HTTP</span>のリクエストが、どんなメソッドでのリクエストかを、タグ情報で持つような例です。このタグ情報によって、処理を型安全に分けることができます。しかしながら、以下の問題点があります。</p>
<ul>
<li>各メソッドのタグが別々のデータとして宣言されていて、集約されていません。</li>
<li><code>Request</code>型も、メソッド用のタグの他にも<code>*</code>という種を持っているならどんな型でも、例えば<code>Request Bool</code>といった型を作ることもできるようになってしまいます。</li>
</ul>
<p><code>DataKinds</code>を使うことで、もう少しタグ情報を明確に書くことができます。それは、以下のような修正をくわえることで、実現できます<span class="ascii">:</span></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" title="1"><span class="ot">{-# LANGUAGE DataKinds, KindSignatures #-}</span></a>
<a class="sourceLine" id="cb22-2" title="2"></a>
<a class="sourceLine" id="cb22-3" title="3"><span class="kw">data</span> <span class="dt">HttpMethod</span></a>
<a class="sourceLine" id="cb22-4" title="4">  <span class="ot">=</span> <span class="dt">GET</span></a>
<a class="sourceLine" id="cb22-5" title="5">  <span class="op">|</span> <span class="dt">POST</span></a>
<a class="sourceLine" id="cb22-6" title="6">  <span class="op">|</span> <span class="dt">PUT</span></a>
<a class="sourceLine" id="cb22-7" title="7">  <span class="op">|</span> <span class="dt">DELETE</span></a>
<a class="sourceLine" id="cb22-8" title="8"></a>
<a class="sourceLine" id="cb22-9" title="9"><span class="kw">data</span> <span class="dt">Request</span> (<span class="ot">a ::</span> <span class="dt">HttpMethod</span>) <span class="ot">=</span> <span class="dt">Request</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb22-10" title="10"></a>
<a class="sourceLine" id="cb22-11" title="11"><span class="ot">forGetMethod ::</span> <span class="dt">Request</span> <span class="dt">'GET</span> <span class="ot">-&gt;</span> <span class="op">...</span></a></code></pre></div>
<p>この例では、<code>DataKinds</code>拡張を使うことで、前の例での欠点を修正しています。メソッド情報は<code>HttpMethod</code>というデータ型の宣言に集約していますし、種に昇格させたデータ型で種注釈を行うことで、<code>Request</code>は<code>HttpMethod</code>以外の型がとれないようになっています。このように、<code>DataKinds</code>は値を持ちませんが、タグを表す型としてとても便利です。</p>
<p>その他にも、<code>DataKinds</code>拡張は、シングルトンというものを定義することによって、より有用になる場合があります。ただし、これらの話は種の話題というよりは型レベルプログラミングの話題になるので、この記事では紹介しません。興味がある方は、<a href="http://hackage.haskell.org/package/singletons"><span class="ascii">singletons</span></a>という有用なパッケージがあるので、見てみると良いでしょう。</p>
<p>ところで、<code>DataKinds</code>は、リスト型<code>[a]</code>、タプル型<code>(a, b)</code>などにも適用できます。まずリスト型の昇格から見ていきましょう。以下を見てください<span class="ascii">:</span></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XDataKinds</span> <span class="op">-</span><span class="dt">XTypeOperators</span></a>
<a class="sourceLine" id="cb23-2" title="2"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind '[]</a>
<a class="sourceLine" id="cb23-3" title="3">'[]<span class="ot"> ::</span> [k]</a>
<a class="sourceLine" id="cb23-4" title="4"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind '(<span class="op">:</span>)</a>
<a class="sourceLine" id="cb23-5" title="5">'<span class="ot">(:) ::</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb23-6" title="6"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="dt">Functor</span> '<span class="op">:</span> <span class="dt">Applicative</span> '<span class="op">:</span> <span class="dt">Monad</span> '<span class="op">:</span> '[]</a>
<a class="sourceLine" id="cb23-7" title="7"><span class="dt">Functor</span> '<span class="op">:</span> <span class="dt">Applicative</span> '<span class="op">:</span> <span class="dt">Monad</span> '<span class="op">:</span> '[]<span class="ot"> ::</span> [(<span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>) <span class="ot">-&gt;</span> <span class="dt">Constraint</span>]</a>
<a class="sourceLine" id="cb23-8" title="8"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind '[<span class="dt">Functor</span>, <span class="dt">Applicative</span>, <span class="dt">Monad</span>]</a>
<a class="sourceLine" id="cb23-9" title="9">'[<span class="dt">Functor</span>, <span class="dt">Applicative</span>, <span class="dt">Monad</span>]<span class="ot"> ::</span> [(<span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>) <span class="ot">-&gt;</span> <span class="dt">Constraint</span>]</a></code></pre></div>
<p>リストの値コンストラクタは二つ、<code>[] :: [a]</code>、<code>(:) :: a -&gt; [a] -&gt; [a]</code>でした。また、リストは特別な構文として、<code>[True, False] == True : False : [] :: [Bool]</code>といったようなものが書けるのでした。これらをそれぞれ昇格させたものが上のものになります。タプル型の方は、以下のようになります<span class="ascii">:</span></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind '()</a>
<a class="sourceLine" id="cb24-2" title="2">'<span class="ot">() ::</span> ()</a>
<a class="sourceLine" id="cb24-3" title="3"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind '(,)</a>
<a class="sourceLine" id="cb24-4" title="4">'(,)<span class="ot"> ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> (a, b)</a>
<a class="sourceLine" id="cb24-5" title="5"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind '(<span class="dt">Bool</span>, <span class="dt">Monad</span> <span class="dt">Maybe</span>)</a>
<a class="sourceLine" id="cb24-6" title="6">'(<span class="dt">Bool</span>, <span class="dt">Monad</span> <span class="dt">Maybe</span>)<span class="ot"> ::</span> (<span class="op">*</span>, <span class="dt">Constraint</span>)</a>
<a class="sourceLine" id="cb24-7" title="7"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind '(,,,)</a>
<a class="sourceLine" id="cb24-8" title="8">'(,,,)<span class="ot"> ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> (a, b, c, d)</a></code></pre></div>
<p>タプル型もリスト型と大体同じような感じですね。</p>
<p>さてここからは、<code>DataKinds</code>のもう少し詳細な見方を紹介しておきましょう。<code>DataKinds</code>は型コンストラクタを種上に昇格、値コンストラクタを型上に昇格させることをできるようにするような拡張でした。実は、<code>Constraint</code>や<code>k1 -&gt; k2</code>という種も昇格された種とみなすことができます。</p>
<p><code>Costraint</code>の方は単純で、以下のようになっています<span class="ascii">:</span></p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">import</span> <span class="dt">GHC.Exts</span> (<span class="dt">Constraint</span>)</a>
<a class="sourceLine" id="cb25-2" title="2"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>info <span class="dt">Constraint</span></a>
<a class="sourceLine" id="cb25-3" title="3"><span class="kw">data</span> <span class="dt">Constraint</span>         <span class="co">-- Defined in ‘GHC.Types’</span></a></code></pre></div>
<p>見ての通り、<code>GHC.Types</code>というモジュールで定義された、値コンストラクタを持たないデータ型です。この型が<code>DataKinds</code>と違うところは、</p>
<ul>
<li>デフォルトで、型コンストラクタ<code>Constraint :: *</code>が、種に昇格可能なこと</li>
<li>型制約は、<code>Constraint</code>型が昇格された種に結び付けられること</li>
</ul>
<p>だけで、他は<code>DataKinds</code>と同じです。なので、昇格前は単純に値も型引数も持たないデータ型です。見てみましょう<span class="ascii">:</span></p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">import</span> <span class="dt">GHC.Exts</span> (<span class="dt">Constraint</span>)</a>
<a class="sourceLine" id="cb26-2" title="2"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="dt">Constraint</span></a>
<a class="sourceLine" id="cb26-3" title="3"><span class="dt">Constraint</span><span class="ot"> ::</span> <span class="op">*</span></a></code></pre></div>
<p>確かに<code>Constraint</code>が、<code>*</code>を種に持つ型であることが分かりますね。</p>
<p><code>k1 -&gt; k2</code>の方はちょっと特殊で、関数型コンストラクタ<code>(-&gt;)</code>が昇格したものになっています。関数型は関数に結びついているデータ型でした。<code>Constraint</code>の時と同じように定義を見てみると、以下のようになっています<span class="ascii">:</span></p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>info (<span class="ot">-&gt;</span>)</a>
<a class="sourceLine" id="cb27-2" title="2"><span class="kw">data</span> (<span class="ot">-&gt;</span>) t1 t2         <span class="co">-- Defined in ‘GHC.Prim’</span></a>
<a class="sourceLine" id="cb27-3" title="3"><span class="kw">infixr</span> <span class="dv">0</span> <span class="ot">`(-&gt;)`</span></a>
<a class="sourceLine" id="cb27-4" title="4"><span class="op">...</span></a></code></pre></div>
<p>関数型もやはり値コンストラクタを持ちません。ですが、<code>Constraint</code>と違い、関数型は関数という値を持ちます。<span class="ascii">Haskell</span>上では、<code>a -&gt; b</code>という型を持つ値は、<code>a</code>型の値を受け取り<code>b</code>型の値を返すような関数になるのでしたね。これらの関数を作る操作、例えばラムダ記法や関数宣言などが、関数型の値コンストラクタと言えるでしょう。これらがそれぞれ昇格すると、<code>a -&gt; b</code>という種は、<code>a</code>の種を持つ型を受け取り、<code>b</code>の種を持つ型を返すような、型上の関数を表します。つまり、</p>
<ul>
<li><code>a -&gt; b</code>という関数型を、種<code>a -&gt; b</code>に昇格</li>
<li><code>a -&gt; b</code>という型の関数を、<code>a -&gt; b</code>という種の型関数に昇格</li>
</ul>
<p>という感じの対応をすることになります。こう見ると、少々特殊ではありますが、<code>DataKinds</code>での昇格したデータ型と同じような扱いと思うことができます。</p>
<p>このように、<code>Constraint</code>や<code>k1 -&gt; k2</code>でさえ、<code>DataKinds</code>の昇格と同じように見ることができます。<code>*</code>はどうでしょうか？実は、<code>*</code>だけは少し特別です。見てみましょう<span class="ascii">:</span></p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">import</span> <span class="dt">GHC.Types</span></a>
<a class="sourceLine" id="cb28-2" title="2"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="op">*</span></a>
<a class="sourceLine" id="cb28-3" title="3"><span class="op">*</span><span class="ot"> ::</span> <span class="op">*</span></a></code></pre></div>
<p>さて、<code>GHC.Types</code>モジュールには、データ型<code>*</code>が定義されています。このデータ型は自身を、つまり<code>*</code>の昇格された種を持っていると見ることができます。つまり、次のような型表記も可能です<span class="ascii">:</span></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">import</span> <span class="dt">GHC.Types</span></a>
<a class="sourceLine" id="cb29-2" title="2"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb29-3" title="3"><span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span><span class="ot"> ::</span> <span class="op">*</span></a></code></pre></div>
<p>種においての<code>* -&gt; *</code>とは、上の型が種に昇格されたものとなるわけです。もちろん、次のような型表記もできます<span class="ascii">:</span></p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XDataKinds</span></a>
<a class="sourceLine" id="cb30-2" title="2"><span class="op">&gt;&gt;&gt;</span> <span class="kw">import</span> <span class="dt">GHC.Types</span></a>
<a class="sourceLine" id="cb30-3" title="3"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="op">*</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span></a>
<a class="sourceLine" id="cb30-4" title="4"><span class="op">*</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span><span class="ot"> ::</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb30-5" title="5"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="dt">'Just</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb30-6" title="6"><span class="dt">'Just</span> <span class="dt">Int</span><span class="ot"> ::</span> <span class="dt">Maybe</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb30-7" title="7"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="dt">Maybe</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb30-8" title="8"><span class="dt">Maybe</span> <span class="op">*</span><span class="ot"> ::</span> <span class="op">*</span></a></code></pre></div>
<p>これらをもっと視覚的にまとめてみましょう。型が結びついている種は、どのような型が昇格したものかをまとめてみると、以下のようなグラフの形になるわけです<span class="ascii">:</span></p>
<figure>
<img src="../../img/2017/13-01-kind-graph.png" alt="kind graph" /><figcaption><span class="ascii">kind graph</span></figcaption>
</figure>
<p><code>'Nothing :: Maybe a</code>であることに注意してください。<code>'Nothing</code>は種多相化されているので、<code>'Nothing :: Maybe *</code>とすることも、<code>'Nothing :: Maybe Bool</code>とすることも可能です<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>。</p>
<p>このように見てみると、私たちが種と呼んでいたものは、単にある型に付属する単なる型情報だと思えてきます。種注釈とは、単にその型がどういう型に付属しているかの情報に過ぎないのです。そして、値にもやはり型情報が付属しています。値と<code>DataKinds</code>によって型に昇格したものを同一視してみると、値と型の間には差異はないということになりますね。このアイデアを元に、<span class="ascii">GHC</span>では <code>TypeInType</code> という拡張が提供されています。この拡張は後ほど紹介しましょう。</p>
<p>最後に名前空間の話をしておきましょう。全ての種は、ある型が昇格したものである、という話をしました。<span class="ascii">GHC</span>では、そういう背景があり、種の名前空間は型の名前空間と完全に一致します。ただし、値の名前空間と型の名前空間を完全に一致させることはできません。それは<span class="ascii">Haskell</span>が多用している、型コンストラクタと値コンストラクタの名前を同じにするという文化があるからです。以下の例を見てください<span class="ascii">:</span></p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XDataKinds</span></a>
<a class="sourceLine" id="cb31-2" title="2"><span class="op">&gt;&gt;&gt;</span> <span class="kw">data</span> <span class="dt">A</span> a <span class="ot">=</span> <span class="dt">A</span> a <span class="op">|</span> <span class="dt">B</span> a</a>
<a class="sourceLine" id="cb31-3" title="3"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="dt">A</span></a>
<a class="sourceLine" id="cb31-4" title="4"><span class="dt">A</span><span class="ot"> ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb31-5" title="5"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="dt">'A</span></a>
<a class="sourceLine" id="cb31-6" title="6"><span class="dt">'A</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">A</span> a</a>
<a class="sourceLine" id="cb31-7" title="7"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="dt">B</span></a>
<a class="sourceLine" id="cb31-8" title="8"><span class="dt">B</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">A</span> a</a></code></pre></div>
<p><code>B</code>の例は、<code>'</code>を書いていないのに型に昇格できていますね。<code>DataKinds</code>は値と型の名前で被るものが無いようなものは<code>'</code>を書かなくていいようになっています。これは型から種へ昇格できる時は自然な動作でしたが、値から型の場合、今回でいう<code>A</code>のように型コンストラクタと値コンストラクタの名前が被ってしまうケースが出てきます。もちろん、データ型<code>B</code>が新しく宣言されてしまうような場合もあるでしょう。このように、型から種へは名前空間が一致しますが、値から型へは名前が被るのを避けるために<code>'</code>を付けるようにしているのです。なので、本質的には値から型へも、<code>'</code>を付けないで昇格させることが理想です。それを覚えておきながら、<code>DataKinds</code>拡張使用の際は、<code>'</code>を適切に付けていくのが良いでしょう。</p>
<h3 id="型の分類"><span class="link-to-here-outer"><a href="#型の分類" title="型の分類"><span class="link-to-here">Link to<br />
here</span></a></span>型の分類</h3>
<p>最後に、少し変わった型と、それにまつわる種の分類分けについてお話ししましょう。この見方は、より<span class="ascii">GHC</span>のプリミティブな部分に携わる時に、役にたつはずです。<span class="ascii">Haskell</span>標準では、種は<code>*</code>と<code>k1 -&gt; k2</code>しかありませんでした。<span class="ascii">GHC</span>では、それに型制約種<code>Constraint</code>が追加されてるのでしたね。そして、<code>DataKinds</code>拡張を使えば、データ型を種に昇格することもできました。しかし、結局値を持つ型は<code>*</code>という種を持つのでしたね。ですが、この制約には一部例外があります。それは、<span class="ascii">GHC</span>のプリミティブな値についてです。</p>
<p>私たちは普段何気なく<code>Int</code>型や<code>Double</code>型を使用しています。しかしながら、これらは実際に実行するとき、メモリ上でどのような構造で保持されているのか考えたことはないでしょうか？ ここでは詳細な話はしませんが、幾つか基本的な<span class="ascii">GHC</span>での内部表現についてお話ししましょう。<span class="ascii">GHCi</span>で、この二つの型の情報を表示してみましょう。</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">import</span> <span class="dt">Prelude</span> (<span class="dt">Int</span>, <span class="dt">Double</span>)</a>
<a class="sourceLine" id="cb32-2" title="2"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>info <span class="dt">Int</span></a>
<a class="sourceLine" id="cb32-3" title="3"><span class="kw">data</span> <span class="dt">Int</span> <span class="ot">=</span> <span class="dt">GHC.Types.I</span><span class="op">#</span> <span class="dt">GHC.Prim.Int</span><span class="op">#</span>   <span class="co">-- Defined in ‘GHC.Types’</span></a>
<a class="sourceLine" id="cb32-4" title="4"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>info <span class="dt">Double</span></a>
<a class="sourceLine" id="cb32-5" title="5"><span class="kw">data</span> <span class="dt">Double</span> <span class="ot">=</span> <span class="dt">GHC.Types.D</span><span class="op">#</span> <span class="dt">GHC.Prim.Double</span><span class="op">#</span></a>
<a class="sourceLine" id="cb32-6" title="6">        <span class="co">-- Defined in ‘GHC.Types’</span></a></code></pre></div>
<p>どうやらこの二つの型は、不思議な値コンストラクタを持っているようですね。</p>
<ul>
<li><code>Int</code>データ型は、一つの値コンストラクタ<code>I# :: Int# -&gt; Int</code>を持ちます。</li>
<li><code>Double</code>データ型は、一つの値コンストラクタ<code>D# :: Double# -&gt; Double</code>を持ちます。</li>
</ul>
<p><code>Int#</code>や<code>Double#</code>といった見慣れないデータ型が出てきましたね。これらが今回紹介する<span class="ascii">GHC</span>の用意しているプリミティブなデータ型です。せっかくですから、上の値コンストラクタを使って、それぞれのデータ型の値を作ってみましょう。それには<code>MagicHash</code>拡張が必要です。通常、<code>#</code>のついた値や型は、私たちは扱うことができません。それを可能にするのが<code>MagicHash</code>拡張です。また、<code>Int</code>や<code>Double</code>の値は、<code>1</code>といった数値リテラルで作れるのでした。同じように、<code>Int#</code>や<code>Double#</code>といった不思議なデータ型にも、それぞれのリテラルが用意されています。使ってみましょう<span class="ascii">:</span></p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XMagicHash</span></a>
<a class="sourceLine" id="cb33-2" title="2"><span class="op">&gt;&gt;&gt;</span> <span class="kw">import</span> <span class="dt">GHC.Types</span> (<span class="dt">Int</span>(..), <span class="dt">Double</span>(..))</a>
<a class="sourceLine" id="cb33-3" title="3"><span class="op">&gt;&gt;&gt;</span> <span class="co">-- I#を使って、Int型を作る</span></a>
<a class="sourceLine" id="cb33-4" title="4"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span><span class="kw">type</span> <span class="dv">1</span><span class="op">#</span></a>
<a class="sourceLine" id="cb33-5" title="5"><span class="dv">1</span><span class="op">#</span><span class="ot"> ::</span> <span class="dt">GHC.Prim.Int</span><span class="op">#</span></a>
<a class="sourceLine" id="cb33-6" title="6"><span class="op">&gt;&gt;&gt;</span> <span class="dt">I</span><span class="op">#</span> <span class="dv">1</span><span class="op">#</span></a>
<a class="sourceLine" id="cb33-7" title="7"><span class="dv">1</span></a>
<a class="sourceLine" id="cb33-8" title="8"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span><span class="kw">type</span> <span class="dt">I</span><span class="op">#</span> <span class="dv">1</span><span class="op">#</span></a>
<a class="sourceLine" id="cb33-9" title="9"><span class="dt">I</span><span class="op">#</span> <span class="dv">1</span><span class="op">#</span><span class="ot"> ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb33-10" title="10"><span class="op">&gt;&gt;&gt;</span> <span class="co">-- D#を使って、Double型を作る</span></a>
<a class="sourceLine" id="cb33-11" title="11"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span><span class="kw">type</span> <span class="fl">1.0</span><span class="op">##</span></a>
<a class="sourceLine" id="cb33-12" title="12"><span class="fl">1.0</span><span class="op">##</span><span class="ot"> ::</span> <span class="dt">GHC.Prim.Double</span><span class="op">#</span></a>
<a class="sourceLine" id="cb33-13" title="13"><span class="op">&gt;&gt;&gt;</span> <span class="dt">D</span><span class="op">#</span> <span class="fl">1.0</span><span class="op">##</span></a>
<a class="sourceLine" id="cb33-14" title="14"><span class="fl">1.0</span></a>
<a class="sourceLine" id="cb33-15" title="15"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span><span class="kw">type</span> <span class="dt">D</span><span class="op">#</span> <span class="fl">1.0</span><span class="op">##</span></a>
<a class="sourceLine" id="cb33-16" title="16"><span class="dt">D</span><span class="op">#</span> <span class="fl">1.0</span><span class="op">##</span><span class="ot"> ::</span> <span class="dt">Double</span></a></code></pre></div>
<p>各リテラル表記は、次のようになっています<span class="ascii">:</span></p>
<ul>
<li><code>Int#</code>のリテラルは、整数と<code>#</code>で作ることができます。</li>
<li><code>Double#</code>のリテラルは、実数と<code>##</code>で作ることができます。</li>
</ul>
<p>他にも幾つか<code>#</code>の付くデータ型があるのですが、まずはこのデータ型がどのようなものなのかについて、紹介しましょう。これらのデータ型は、 <strong>プリミティブ型<span class="ascii">(primitive types)</span></strong> と呼ばれます。そして、その多くが <strong>非ボックス型<span class="ascii">(unboxed types)</span></strong> と呼ばれています。</p>
<p><span class="ascii">GHC</span>では、多くのデータ型はボックス化、つまりヒープ上に参照データとして格納されています。データ型の値自体はポインタで、本体はヒープ上にあるというわけです。これは、データ型が、値コンストラクタを複数持つ場合もありますし、複数の様々なデータ型を取るパラメータを持つこともあり、サイズが多岐に渡るからです。しかし、ヒープに格納するには、格納する場所を計算して領域を確保し、必要なくなったら領域を解放しなければならないという、大きなコストがかかります。これは、サイズが大きなデータ型については、いちいち領域をコピーし実データのまま扱うよりも、低コストになる場合が多いですが、サイズが固定されていて尚且つ小さなデータの場合、大きな足かせになります。このため、<span class="ascii">GHC</span>は幾つかの特別なデータ型を用意し、そのデータ型はヒープ上に格納せず直接実データとして扱うようにしています。それが、非ボックス型です。</p>
<p>また、<span class="ascii">GHC</span>は非ボックス型の他にも幾つか特別なデータ型を用意しています。<code>Array#</code>や<code>MutableArray#</code>、<code>MVar#</code>などのデータ型です。これらは、実データとしてではなくヒープ上に格納され、ポインタをデータとするようなものです。つまり、ボックス化されているわけです。しかしながら、通常のデータ型と異なり、ヒープ上のデータは特殊な構造をしています。このように、<span class="ascii">GHC</span>が用意している、<span class="ascii">Haskell</span>上では定義できない特殊な構造を持つデータ型をボックス化されている<span class="ascii">/</span>されていないに関わらず、プリミティブ型と言います。少し、まとめておきましょう<span class="ascii">:</span></p>
<ul>
<li>プリミティブ型とは、<span class="ascii">GHC</span>が事前に用意している、<span class="ascii">Haskell</span>の構文では定義できない、値が特殊な構造を持つようなデータ型のこと。</li>
<li>非ボックス型とは、ボックス化されていない型、つまりポインタとして表現されるのではなく実データとして表現されるような値を持つ型のこと。</li>
</ul>
<p>さて、この記事は種についての記事なので、種の話もしましょう。プリミティブ型は、<span class="ascii">GHC</span>では<code>*</code>ではなくそれぞれが特別な種を割り当てられています。見てみましょう<span class="ascii">:</span></p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XMagicHash</span></a>
<a class="sourceLine" id="cb34-2" title="2"><span class="op">&gt;&gt;&gt;</span> <span class="kw">import</span> <span class="dt">GHC.Prim</span> (<span class="dt">Int</span>#, <span class="dt">Double</span>#)</a>
<a class="sourceLine" id="cb34-3" title="3"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="dt">Int</span><span class="op">#</span></a>
<a class="sourceLine" id="cb34-4" title="4"><span class="dt">Int</span><span class="op">#</span><span class="ot"> ::</span> <span class="dt">TYPE</span> <span class="dt">'GHC.Types.IntRep</span></a>
<a class="sourceLine" id="cb34-5" title="5"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="dt">Double</span><span class="op">#</span></a>
<a class="sourceLine" id="cb34-6" title="6"><span class="dt">Double</span><span class="op">#</span><span class="ot"> ::</span> <span class="dt">TYPE</span> <span class="dt">'GHC.Types.DoubleRep</span></a></code></pre></div>
<p>なにやら、不思議な種が登場しました。一体これらの種は、どのようなものなのでしょうか？ <code>info</code>コマンドで見てみましょう<span class="ascii">:</span></p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">import</span> <span class="dt">GHC.Types</span></a>
<a class="sourceLine" id="cb35-2" title="2"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>info <span class="dt">TYPE</span></a>
<a class="sourceLine" id="cb35-3" title="3"><span class="kw">data</span> <span class="dt">TYPE</span> (<span class="ot">a ::</span> <span class="dt">RuntimeRep</span>)</a>
<a class="sourceLine" id="cb35-4" title="4">        <span class="co">-- Defined in ‘GHC.Prim’</span></a>
<a class="sourceLine" id="cb35-5" title="5"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>info <span class="dt">RuntimeRep</span></a>
<a class="sourceLine" id="cb35-6" title="6"><span class="kw">data</span> <span class="dt">RuntimeRep</span></a>
<a class="sourceLine" id="cb35-7" title="7">  <span class="ot">=</span> <span class="dt">VecRep</span> <span class="dt">VecCount</span> <span class="dt">VecElem</span></a>
<a class="sourceLine" id="cb35-8" title="8">  <span class="op">|</span> <span class="dt">TupleRep</span> [<span class="dt">RuntimeRep</span>]</a>
<a class="sourceLine" id="cb35-9" title="9">  <span class="op">|</span> <span class="dt">SumRep</span> [<span class="dt">RuntimeRep</span>]</a>
<a class="sourceLine" id="cb35-10" title="10">  <span class="op">|</span> <span class="dt">LiftedRep</span></a>
<a class="sourceLine" id="cb35-11" title="11">  <span class="op">|</span> <span class="dt">UnliftedRep</span></a>
<a class="sourceLine" id="cb35-12" title="12">  <span class="op">|</span> <span class="dt">IntRep</span></a>
<a class="sourceLine" id="cb35-13" title="13">  <span class="op">|</span> <span class="dt">WordRep</span></a>
<a class="sourceLine" id="cb35-14" title="14">  <span class="op">|</span> <span class="dt">Int64Rep</span></a>
<a class="sourceLine" id="cb35-15" title="15">  <span class="op">|</span> <span class="dt">Word64Rep</span></a>
<a class="sourceLine" id="cb35-16" title="16">  <span class="op">|</span> <span class="dt">AddrRep</span></a>
<a class="sourceLine" id="cb35-17" title="17">  <span class="op">|</span> <span class="dt">FloatRep</span></a>
<a class="sourceLine" id="cb35-18" title="18">  <span class="op">|</span> <span class="dt">DoubleRep</span></a>
<a class="sourceLine" id="cb35-19" title="19">        <span class="co">-- Defined in ‘GHC.Types’</span></a></code></pre></div>
<p><strong>注記</strong><span class="ascii">:</span> この実行例は<span class="ascii">GHC 8.2.1</span>のものですが、これらのデータ型は現在かなりアグレッシブな変更が加えられており、表現方法がバージョンによってかなり異なります。ただし、データ型の意味は特に変わらないはずなので、手元の環境の実行例に差異があっても、特に気にしないでください！</p>
<p><code>TYPE :: RuntimeRep -&gt; *</code>、<code>RuntimeRep :: *</code>、共に特に難しい定義ではありませんね。<code>RuntimeRep</code>は“<span class="ascii">runtime representation</span>”<span class="ascii">(</span>実行環境での表現<span class="ascii">)</span>という意味を表した名前になっています。前の章でのデータ型の昇格の話を思い出してください。<code>TYPE 'IntRep</code>という種は、<code>TYPE 'IntRep</code>という型が昇格したものになります。<code>'IntRep</code>は、<code>RuntimeRep</code>データ型の値コンストラクタ<code>IntRep</code>が、型に昇格したものということを思い出してください。つまり、値<code>IntRep</code>を型に昇格した<code>'IntRep</code>が、さらに種に昇格しているということになります。ちゃんと型が合ってるかは、昇格される前の型で調べれば良いのですね。いちよ<span class="ascii">GHCi</span>で確認してみましょう<span class="ascii">:</span></p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">import</span> <span class="dt">GHC.Types</span></a>
<a class="sourceLine" id="cb36-2" title="2"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="dt">TYPE</span></a>
<a class="sourceLine" id="cb36-3" title="3"><span class="dt">TYPE</span><span class="ot"> ::</span> <span class="dt">RuntimeRep</span> <span class="ot">-&gt;</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb36-4" title="4"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="dt">'IntRep</span></a>
<a class="sourceLine" id="cb36-5" title="5"><span class="dt">'IntRep</span><span class="ot"> ::</span> <span class="dt">RuntimeRep</span></a>
<a class="sourceLine" id="cb36-6" title="6"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="dt">TYPE</span> <span class="dt">'IntRep</span></a>
<a class="sourceLine" id="cb36-7" title="7"><span class="dt">TYPE</span> <span class="dt">'IntRep</span><span class="ot"> ::</span> <span class="op">*</span></a></code></pre></div>
<p>ちゃんと種が符合していることが分かりますね。<code>RuntimeRep</code>や<code>TYPE</code>は、<code>*</code>や<code>Constraint</code>、<code>a -&gt; b</code>などと同じく、<code>DataKinds</code>無しで特別に種に昇格することが許可されています。この特別なデータ型によって、プリミティブ型は表現されています。幾つかのプリミティブ型に対する対応を、表にしてみました<span class="ascii">:</span></p>
<table>
<thead>
<tr class="header">
<th>プリミティブ型</th>
<th>非ボックス型か？</th>
<th>紐づいている種</th>
<th>リテラル</th>
<th><span class="ascii">C</span>言語での型表現</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Char#</code></td>
<td><span class="ascii">o</span></td>
<td><code>TYPE 'WordRep</code></td>
<td>文字と<code>#</code><span class="ascii">(</span><code>'x'#</code><span class="ascii">)</span></td>
<td><code>int32_t</code></td>
</tr>
<tr class="even">
<td><code>Int#</code></td>
<td><span class="ascii">o</span></td>
<td><code>TYPE 'IntRep</code></td>
<td>整数と<code>#</code><span class="ascii">(</span><code>3#</code><span class="ascii">)</span></td>
<td><code>int</code></td>
</tr>
<tr class="odd">
<td><code>Word#</code></td>
<td><span class="ascii">o</span></td>
<td><code>TYPE 'WordRep</code></td>
<td>整数と<code>##</code><span class="ascii">(</span><code>3##</code><span class="ascii">)</span></td>
<td><code>unsigned int</code></td>
</tr>
<tr class="even">
<td><code>Float#</code></td>
<td><span class="ascii">o</span></td>
<td><code>TYPE 'FloatRep</code></td>
<td>実数と<code>#</code><span class="ascii">(</span><code>3.2#</code><span class="ascii">)</span></td>
<td><code>float</code></td>
</tr>
<tr class="odd">
<td><code>Double#</code></td>
<td><span class="ascii">o</span></td>
<td><code>TYPE 'DoubleRep</code></td>
<td>実数と<code>##</code><span class="ascii">(</span><code>3.2##</code><span class="ascii">)</span></td>
<td><code>double</code></td>
</tr>
<tr class="even">
<td><code>Addr#</code></td>
<td><span class="ascii">o</span></td>
<td><code>TYPE 'AddrRep</code></td>
<td>文字列と<code>#</code><span class="ascii">(</span><code>"foo"#</code><span class="ascii">)</span></td>
<td><code>void *</code></td>
</tr>
<tr class="odd">
<td><code>Array# a</code></td>
<td><span class="ascii">x</span></td>
<td><code>TYPE 'UnliftedRep</code></td>
<td><span class="ascii">-</span></td>
<td><span class="ascii">-</span></td>
</tr>
<tr class="even">
<td><code>MutableArray# s a</code></td>
<td><span class="ascii">x</span></td>
<td><code>TYPE 'UnliftedRep</code></td>
<td><span class="ascii">-</span></td>
<td><span class="ascii">-</span></td>
</tr>
<tr class="odd">
<td><code>MVar# s a</code></td>
<td><span class="ascii">x</span></td>
<td><code>TYPE 'UnliftedRep</code></td>
<td><span class="ascii">-</span></td>
<td><span class="ascii">-</span></td>
</tr>
</tbody>
</table>
<p>この他にも<span class="ascii">GHC</span>はプリミティブ型を用意しています。プリミティブ型は、<a href="https://www.stackage.org/package/ghc-prim"><code>ghc-prim</code>パッケージ</a>の<a href="https://www.stackage.org/haddock/lts-9.4/ghc-prim-0.5.0.0/GHC-Prim.html"><code>GHC.Prim</code>モジュール</a>にて公開されています。興味があれば、種を確認しながら見てみると面白いでしょう<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>。また、<code>TupleRep</code>や<code>SumRep</code>を持つ型は、それぞれ<code>UnboxedTuples</code>拡張、<code>UnboxedSums</code>拡張を使用する必要があります。こちらについても、気になる方は調べてみてください。</p>
<p>さて、プリミティブ型は、その表現方法によって種が用意されていることは分かったと思います。最後に、この<code>RuntimeRep</code>の中で二つの特殊な要素<code>LiftedRep</code>と<code>UnliftedRep</code>について話しておきましょう。データ型を表す種として、<code>*</code>を紹介しました。実はこの種は、次のようなエイリアスになっています<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a><span class="ascii">:</span></p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" title="1"><span class="kw">type</span> <span class="op">*</span> <span class="ot">=</span> <span class="dt">TYPE</span> <span class="dt">'LiftedRep</span></a></code></pre></div>
<p>つまり、今まで見てきたデータ型は、実行時に<strong><span class="ascii">lifted</span></strong>という枠組みで表現されるようなものというわけです。では、この<strong><span class="ascii">lifted</span></strong>と<strong><span class="ascii">unlifted</span></strong>の違いはなんなのでしょうか？ それの説明に入る前に、<span class="ascii">GHC</span>においての評価戦略とデータの内部表現についての話をしておきましょう。ときに、<span class="ascii">Haskell</span>は遅延評価デフォルトの言語です。例えば、以下の式の評価は例外になりません<span class="ascii">:</span></p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" title="1"><span class="op">&gt;&gt;&gt;</span><span class="ot"> f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>; f _ <span class="ot">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb38-2" title="2"><span class="op">&gt;&gt;&gt;</span> f (<span class="fu">error</span> <span class="st">&quot;raise an exception&quot;</span>)</a>
<a class="sourceLine" id="cb38-3" title="3"><span class="dv">0</span></a></code></pre></div>
<p><span class="ascii">GHC</span>では、このような<code>error "raise an exception"</code>という式は評価されるまでは実際の値でなく、サンクという計算式を表現したデータとして保持されます。サンクは一度評価されると破棄され、実際の値にすげ変わります。上の関数<code>f</code>が受け取るのは、このサンクまたはすげ変わった実際の値を指し示すようなポインタです。今回の場合、<code>error "raise an exception"</code>という、まだ評価されていない式のサンクを指し示すポインタというわけです。上の例では、関数<code>f</code>に渡されたサンクを示すポインタは、特に評価されないまま捨てられ、定数値が返ってきます。では、サンクを評価するような関数を作って、動かしてみましょう<span class="ascii">:</span></p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" title="1"><span class="op">&gt;&gt;&gt;</span><span class="ot"> f ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>; f b <span class="ot">=</span> <span class="kw">if</span> b <span class="kw">then</span> <span class="dv">0</span> <span class="kw">else</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb39-2" title="2"><span class="op">&gt;&gt;&gt;</span> f (<span class="fu">error</span> <span class="st">&quot;raise an exception&quot;</span>)</a>
<a class="sourceLine" id="cb39-3" title="3"><span class="op">***</span> <span class="dt">Exception</span><span class="op">:</span> raise an exception</a>
<a class="sourceLine" id="cb39-4" title="4"><span class="dt">CallStack</span> (from <span class="dt">HasCallStack</span>)<span class="op">:</span></a>
<a class="sourceLine" id="cb39-5" title="5">  <span class="fu">error</span>, called at <span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">2</span><span class="op">:</span><span class="dv">4</span> <span class="kw">in</span> interactive<span class="op">:</span><span class="dt">Ghci2</span></a></code></pre></div>
<p>この例では先ほどと違い、受け取ったサンクを関数<code>f</code>の中の<span class="ascii">if</span>文で評価しています。そのため、例外が発生しているわけです。サンクは<span class="ascii">GHC</span>が遅延評価を実装するための仕組みであり、<span class="ascii">lifted</span>型の値は指し示す先がサンクになり得るようなポインタで表現されます。<span class="ascii">lifted</span>型とは、その値としてボトムと称される値になるようなものも持てるような型のことです。ボトムと呼ばれる値には、主に以下のようなものがあります<span class="ascii">:</span></p>
<ul>
<li>評価すると例外が出されるような値</li>
<li>無限ループになっていて永遠に評価が終わらないような値</li>
</ul>
<p><span class="ascii">Haskell</span>の通常の型は、上のような式を表すサンクをも値として持ちますから、無限ループになったり例外が出されたりするような値、つまりボトムをも表現できます。それに対して、<span class="ascii">GHC</span>ではボトムを表現できない型も存在します。その典型が非ボックス型です。非ボックス型はポインタではなく、実データとして表されているんでしたよね。実データは、サンクとすげ替えるということができないですよね。では、非ボックス型を処理するような関数に、<code>undefined</code>を渡すとどうなるか、見てみましょう<span class="ascii">:</span></p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XMagicHash</span></a>
<a class="sourceLine" id="cb40-2" title="2"><span class="op">&gt;&gt;&gt;</span> <span class="kw">import</span> <span class="dt">GHC.Exts</span></a>
<a class="sourceLine" id="cb40-3" title="3"><span class="op">&gt;&gt;&gt;</span><span class="ot"> f ::</span> <span class="dt">Int</span><span class="op">#</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>; f _ <span class="ot">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb40-4" title="4"><span class="op">&gt;&gt;&gt;</span> f (<span class="fu">error</span> <span class="st">&quot;raise an exception&quot;</span>)</a>
<a class="sourceLine" id="cb40-5" title="5"><span class="op">***</span> <span class="dt">Exception</span><span class="op">:</span> raise an exception</a>
<a class="sourceLine" id="cb40-6" title="6"><span class="dt">CallStack</span> (from <span class="dt">HasCallStack</span>)<span class="op">:</span></a>
<a class="sourceLine" id="cb40-7" title="7">  <span class="fu">error</span>, called at <span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">7</span><span class="op">:</span><span class="dv">4</span> <span class="kw">in</span> interactive<span class="op">:</span><span class="dt">Ghci4</span></a></code></pre></div>
<p>先ほどの<span class="ascii">lifted</span>の例<span class="ascii">(</span><code>Int</code>の例<span class="ascii">)</span>と、何が違うか分かりますか？ 今回、関数<code>f</code>はやはり受け取った値を無視して定数を返します。どこにも受け取った引数を評価する箇所はありません。</p>
<ul>
<li><span class="ascii">lifted</span>の例<span class="ascii">(</span><code>Int</code>の例<span class="ascii">)</span>では、<code>undefined</code>を評価せず、つまり例外が一切出ずに定数が返ってきました。</li>
<li>今回の非ボックス型の例<span class="ascii">(</span><code>Int#</code>の例<span class="ascii">)</span>では、例外が発生しています。</li>
</ul>
<p>なぜでしょうか？ 実は、非ボックス型は遅延評価ではなく正格評価が行われます。その理由はお分かりですね？ なぜなら遅延評価のためにサンクを用意しようにも、非ボックス型はサンクを表現できないからです！ 非ボックス型として値を格納するならば、サンクではなく評価した後の実データでないといけません。そのため、ボックス型の引数を受け取る関数の場合は、一旦引数に渡される式を評価して実データにした上で、関数に渡すということを行います。実は、これは非ボックス型だけに止まりません。<span class="ascii">GHC</span>では、ボックス型の中にも正格評価になるような、つまりサンクを値として持たないような型があります。それが、<code>TYPE 'UnliftedRep</code>を種に持つデータ型です。見てみましょう<span class="ascii">:</span></p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XMagicHash</span></a>
<a class="sourceLine" id="cb41-2" title="2"><span class="op">&gt;&gt;&gt;</span> <span class="kw">import</span> <span class="dt">GHC.Exts</span></a>
<a class="sourceLine" id="cb41-3" title="3"><span class="op">&gt;&gt;&gt;</span><span class="ot"> f ::</span> <span class="dt">Array</span><span class="op">#</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span>; f _ <span class="ot">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb41-4" title="4"><span class="op">&gt;&gt;&gt;</span> f (<span class="fu">error</span> <span class="st">&quot;raise an exception&quot;</span>)</a>
<a class="sourceLine" id="cb41-5" title="5"><span class="op">***</span> <span class="dt">Exception</span><span class="op">:</span> raise an exception</a>
<a class="sourceLine" id="cb41-6" title="6"><span class="dt">CallStack</span> (from <span class="dt">HasCallStack</span>)<span class="op">:</span></a>
<a class="sourceLine" id="cb41-7" title="7">  <span class="fu">error</span>, called at <span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">8</span><span class="op">:</span><span class="dv">4</span> <span class="kw">in</span> interactive<span class="op">:</span><span class="dt">Ghci2</span></a></code></pre></div>
<p><code>Array# a</code>はヒープ上に本体があり、それを指し示すポインタで表現されます。ただしこのポインタは、サンクを指し示すことはありません。つまりかならず実データを指し示すことになり、ボトムを値に持つことはないのです。</p>
<p>ところで、今までは引数が<span class="ascii">unlifted</span>な型である場合の話をしてきましたが、返り値が<span class="ascii">unlifted</span>な型になっている場合はどう見ることができるのでしょう？例えば、次のような関数を考えてみてください<span class="ascii">:</span></p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" title="1"><span class="ot">{-# LANGUAGE MagicHash #-}</span></a>
<a class="sourceLine" id="cb42-2" title="2"></a>
<a class="sourceLine" id="cb42-3" title="3"><span class="kw">import</span> <span class="dt">GHC.Exts</span></a>
<a class="sourceLine" id="cb42-4" title="4"></a>
<a class="sourceLine" id="cb42-5" title="5"><span class="ot">infLoop ::</span> <span class="dt">Int</span><span class="op">#</span> <span class="ot">-&gt;</span> <span class="dt">Int</span><span class="op">#</span></a>
<a class="sourceLine" id="cb42-6" title="6">infLoop i <span class="ot">=</span> infLoop (i <span class="op">+#</span> <span class="dv">1</span><span class="op">#</span>)</a></code></pre></div>
<p><code>(+#) :: Int# -&gt; Int# -&gt; Int#</code>は、<span class="ascii">GHC</span>で用意されている<code>Int#</code>専用の加算演算子です。この関数は問題なく定義することができますが、実行すると無限ループを起こします。つまり<code>infLoop 1# :: Int#</code>というような式はボトムを表しているように見えます。<span class="ascii">unlifted</span>な型は、ボトムを持たないはずでは無かったのでしょうか？ 注意して欲しいのは、<code>infLoop 1#</code>という式は、それ単体では<span class="ascii">Haskell</span>では単なる表記に過ぎないということです。この式は、なんらかのトップレベル関数や定数の一部になっているはずです。関数は<span class="ascii">lifted</span>な型の値です<span class="ascii">(</span>関数型は、<code>a -&gt; b :: *</code>であることを思い出してください！<span class="ascii">)</span>。関数はコンパイルされ、ランタイムによって実行されます。つまり、最終的に実行時に意味を持つのは、トップレベルの関数であり、それは<span class="ascii">lifted</span>な型で表現されるということです。また、<span class="ascii">Haskell</span>では<span class="ascii">unlifted</span>型のトップレベル定数の宣言は許されていません。以下のコードはコンパイルエラーになります<span class="ascii">:</span></p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" title="1"><span class="ot">{-# LANGUAGE MagicHash #-}</span></a>
<a class="sourceLine" id="cb43-2" title="2"></a>
<a class="sourceLine" id="cb43-3" title="3"><span class="kw">import</span> <span class="dt">GHC.Exts</span></a>
<a class="sourceLine" id="cb43-4" title="4"></a>
<a class="sourceLine" id="cb43-5" title="5"><span class="co">-- 許可されていない</span></a>
<a class="sourceLine" id="cb43-6" title="6"><span class="ot">unliftedConstant ::</span> <span class="dt">Int</span><span class="op">#</span></a>
<a class="sourceLine" id="cb43-7" title="7">unliftedConstant <span class="ot">=</span> <span class="dv">1</span><span class="op">#</span></a></code></pre></div>
<p>これにより、トップレベルの関数や定数は、全て<span class="ascii">lifted</span>な型を持つことになります。もし、内部で<span class="ascii">unlifted</span>な式が無限ループや例外を吐くなら、それはその式を含んだトップレベルの<span class="ascii">lifted</span>な関数や定数が、ボトムを表すサンクを持つことになるということです。これは、<span class="ascii">unlifted</span>の考え方を逸脱しません。</p>
<ul>
<li>トップレベルの関数や定数はサンクを持つ<span class="ascii">lifted</span>な値に翻訳され、</li>
<li><span class="ascii">unlifted</span>な型を持つ引数は、受け取る前に正格に評価され、サンクを持たない値となった後関数に渡されます。</li>
</ul>
<p>このような解釈によって、<span class="ascii">Haskell</span>での<span class="ascii">lifted/unlifted</span>の枠組みは保たれます。</p>
<p>ボトムについての形式的な議論は、領域理論という分野でされています。もし、<strong><span class="ascii">lifted/unlifted</span></strong>についての理論的な背景が知りたいなら、領域理論や表示的意味論について学習してみると良いでしょう<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a>。</p>
<p>ここまでのことを大雑把にまとめておきました。<span class="ascii">GHC</span>では型について幾つかの大別をしています<span class="ascii">:</span></p>
<ul>
<li>プリミティブ型<span class="ascii">/</span>非プリミティブ型<span class="ascii">: GHC</span>が自前で用意している特殊な型か、<span class="ascii">Haskell</span>で定義可能な型か</li>
<li>ボックス型<span class="ascii">/</span>非ボックス型<span class="ascii">:</span> ポインタで表され本体はヒープにあるような参照型か、実データで表される型か</li>
<li><span class="ascii">lifted</span>型<span class="ascii">/unlifted</span>型<span class="ascii">:</span> サンクを持ちボトムを値として含むような型か、サンクを持たない型か</li>
</ul>
<p>なお、非ボックス型は<span class="ascii">unlifted</span>であり、<span class="ascii">lifted</span>な型はボックス型になります<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a>。では、幾つかの型の種別を見て、今回は終わりにしましょう<span class="ascii">(</span><code>type * = TYPE 'LiftedRep</code>であることに注意してください！<span class="ascii">):</span></p>
<table>
<thead>
<tr class="header">
<th>型名</th>
<th>種</th>
<th>プリミティブ型か</th>
<th>ボックス型か</th>
<th><span class="ascii">lifted</span>か</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Bool</code></td>
<td><code>TYPE 'LiftedRep</code></td>
<td><span class="ascii">x</span></td>
<td><span class="ascii">o</span></td>
<td><span class="ascii">o</span></td>
</tr>
<tr class="even">
<td><code>Int#</code></td>
<td><code>TYPE 'IntRep</code></td>
<td><span class="ascii">o</span></td>
<td><span class="ascii">x</span></td>
<td><span class="ascii">x</span></td>
</tr>
<tr class="odd">
<td><code>Array# a</code></td>
<td><code>TYPE 'UnliftedRep</code></td>
<td><span class="ascii">o</span></td>
<td><span class="ascii">o</span></td>
<td><span class="ascii">x</span></td>
</tr>
</tbody>
</table>
<h3 id="この章のまとめ"><span class="link-to-here-outer"><a href="#この章のまとめ" title="この章のまとめ"><span class="link-to-here">Link to<br />
here</span></a></span>この章のまとめ</h3>
<p>この章では、型制約を表す種<code>Constraint</code>の紹介、型を種に、値を型に昇格する<code>DataKinds</code>拡張の紹介、そしてプリミティブ型の種と<span class="ascii">GHC</span>の型の大別について、お話ししました。</p>
<p>型制約には型制約種<code>Constraint</code>という種がつくのでした。データ宣言が型コンストラクタと値コンストラクタを作るように、型クラスは型制約コンストラクタと型制約下でのメソッド群を作るものとみることができました。また、型制約は、<code>=&gt;</code>によって制約が満たされるか検査されるのでしたね。ただ、<span class="ascii">Haskell</span>標準では型制約は決まった形状でしか書けませんでした。そのため、<code>ConstraintKinds</code>拡張が用意されており、この拡張によって型制約種を持つものならば変数であろうと型制約のペアであろうと、型制約として扱えるようになるのでした。また、この拡張によって、型制約のエイリアスも書けるようになりました。</p>
<p><code>DataKinds</code>はデータ型の型コンストラクタを種において使えるように、値コンストラクタを型において使えるようにするものでした。値コンストラクタは、昇格の際先頭に<code>'</code>をつけるのでした。また、<span class="ascii">Haskell</span>の種全般が、何かしらの型が昇格したものとみなせるという話もしましたね。<code>*</code>ですら、一つのデータ型でした。</p>
<p>最後に、<span class="ascii">GHC</span>のプリミティブ型、ボックス型、<span class="ascii">lifted</span>型という大別を紹介しました。</p>
<ul>
<li>プリミティブ型は、<span class="ascii">Haskell</span>では定義できない<span class="ascii">GHC</span>が事前に用意してくれている型でした。例えば<code>Int#</code>、<code>Array#</code>などがそうです。</li>
<li>ボックス型の値は、ポインタで表現されヒープ上に本体を持ちました。非ボックス型の値は、実データとして表現されます。</li>
<li><span class="ascii">lifted</span>型の値は、評価されるまではサンクを指すポインタとなっており、<code>undefined</code>などの評価すると例外になるようなものや無限ループでさえ値として持ち得るのでした。<span class="ascii">unlifted</span>型の値は、サンクを持たず、正格に評価されるのでした。</li>
</ul>
<p>以降では、少し高度な種に関する話題を紹介していきます。あまり知られてない機能や最近入った機能、まだ入ってない提案中のものなども紹介していきます。これらの話題は、最初に掲げた想定読者層から外れているのであまり詳しくは紹介しません。こんな話もあるんだぐらいに留めておいてもらえれば、良いでしょう。</p>
<h2 id="advanced-topics"><span class="link-to-here-outer"><a href="#advanced-topics" title="advanced-topics"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Advanced Topics</span></h2>
<h3 id="もう一つの型の分類"><span class="link-to-here-outer"><a href="#もう一つの型の分類" title="もう一つの型の分類"><span class="link-to-here">Link to<br />
here</span></a></span>もう一つの型の分類</h3>
<p>今までは、種に関する基本的な話題を紹介しました。ここでは、種とは別の、もう一つの型に付属する種別情報を紹介しましょう。それは、<span class="ascii">type role</span>と呼ばれるものです。<span class="ascii">type role</span>は、<code>GeneralizedNewtypeDeriving</code>という拡張と、密接な関係があります。</p>
<p>ここでは詳しく解説しませんが、<code>GeneralizedNewtypeDeriving</code>という拡張は、<code>newtype</code>で作った型のクラスインスタンス導出を簡略化するための拡張で、そのインスタンスを元の型のものを持ってきて実装します。この拡張は利便性を向上させますが、その導出が壊れるケースが出てきます。例えば次のケースです<span class="ascii">:</span></p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" title="1"><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving, StandaloneDeriving, TypeFamilies #-}</span></a>
<a class="sourceLine" id="cb44-2" title="2"></a>
<a class="sourceLine" id="cb44-3" title="3"><span class="kw">newtype</span> <span class="dt">Age</span> <span class="ot">=</span> <span class="dt">MkAge</span> {<span class="ot"> unAge ::</span> <span class="dt">Int</span> }</a>
<a class="sourceLine" id="cb44-4" title="4"></a>
<a class="sourceLine" id="cb44-5" title="5"><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Inspect</span> x</a>
<a class="sourceLine" id="cb44-6" title="6"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Inspect</span> <span class="dt">Age</span> <span class="ot">=</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb44-7" title="7"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Inspect</span> <span class="dt">Int</span> <span class="ot">=</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb44-8" title="8"></a>
<a class="sourceLine" id="cb44-9" title="9"><span class="kw">class</span> <span class="dt">BadIdea</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb44-10" title="10"><span class="ot">  bad ::</span> a <span class="ot">-&gt;</span> <span class="dt">Inspect</span> a</a>
<a class="sourceLine" id="cb44-11" title="11"></a>
<a class="sourceLine" id="cb44-12" title="12"><span class="kw">instance</span> <span class="dt">BadIdea</span> <span class="dt">Int</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb44-13" title="13">  bad <span class="ot">=</span> (<span class="op">&gt;</span> <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb44-14" title="14"></a>
<a class="sourceLine" id="cb44-15" title="15"><span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">BadIdea</span> <span class="dt">Age</span> <span class="co">-- 壊れた導出になる</span></a>
<a class="sourceLine" id="cb44-16" title="16"><span class="co">{- | 上のものは、以下のものと同じ</span></a>
<a class="sourceLine" id="cb44-17" title="17"><span class="co">instance BadIdea Age where</span></a>
<a class="sourceLine" id="cb44-18" title="18"><span class="co">  bad = coerce (bad :: Int -&gt; Inspect Int)</span></a>
<a class="sourceLine" id="cb44-19" title="19"><span class="co">-}</span></a></code></pre></div>
<p><code>Age -&gt; Inspect Age</code>は<code>Age -&gt; Int</code>と同じ、<code>Int -&gt; Inspect Int</code>は<code>Int -&gt; Bool</code>と同じであるということに注意してください。この場合、<code>Age</code>と<code>Int</code>は同じ実行時表現を持ちますが、<code>Int</code>と<code>Bool</code>は同じ表現を持たないわけですから、直感的には<code>Int -&gt; Inspect Int</code>を<code>Age -&gt; Inspect Age</code>にキャストすることは型の健全性を壊します。</p>
<p><span class="ascii">type role</span>は、二つの型が同じ表現を持つ型かどうかを判断するために、組み込まれた機能です。つまり、キャストが型安全にできるかを判断するためのものなのです。データ型や型クラス、型族などの型変数は、<span class="ascii">type role</span>を持ちます。<span class="ascii">type role</span>の概念は、<code>a</code>と<code>b</code>という型が同じ表現を持つときに<span class="ascii">(</span>例えば、<code>Int</code>と<code>Age</code>は同じ表現を持ちます<span class="ascii">)</span>、型コンストラクタや型族<code>T</code>に対して<code>T a</code>と<code>T b</code>が同じ表現を持つかを判断するための機構で、<code>T</code>のどのパラメータが判断するときに関与するか、という情報を持ちます。<span class="ascii">type role</span>は以下の三種類があります<span class="ascii">:</span></p>
<ul>
<li><p><span class="ascii">nominal:</span> 受け取ったパラメータの型が例え同じ表現であっても、全体として同じ表現になるとは限らないことを示します<span class="ascii">:</span></p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" title="1"><span class="kw">type</span> <span class="kw">family</span> <span class="dt">F</span> a <span class="co">-- a has nominal type role</span></a>
<a class="sourceLine" id="cb45-2" title="2"></a>
<a class="sourceLine" id="cb45-3" title="3"><span class="kw">data</span> <span class="dt">D</span> a <span class="ot">=</span> <span class="dt">D</span> (<span class="dt">F</span> a) <span class="co">-- a has nominal type role</span></a></code></pre></div></li>
<li><p><span class="ascii">representational:</span> 受け取ったパラメータの型が同じ表現であるならば、全体としても同じ表現になることを示します。一般的にはこの<span class="ascii">type role</span>を持ちます<span class="ascii">:</span></p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" title="1"><span class="kw">data</span> <span class="dt">Simple</span> a <span class="ot">=</span> <span class="dt">Simple</span> a <span class="co">-- a has representational type role</span></a></code></pre></div></li>
<li><p><span class="ascii">phantom:</span> 受け取ったパラメータが、表現に全く関与しないことを示します<span class="ascii">:</span></p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb47-1" title="1"><span class="kw">data</span> <span class="dt">Tag</span> a <span class="ot">=</span> <span class="dt">Tag</span> <span class="co">-- a has phantom type role</span></a></code></pre></div></li>
</ul>
<p>これらの<span class="ascii">type role</span>は推論によって決定するようになっているため、私たちは普段特に意識する必要はありません。ただし、推論結果が意図しないものである場合もあります。その際は、<code>RoleAnnotations</code>拡張を使って、以下のようにすることで、<span class="ascii">type role</span>を明示的に書くこともできます<span class="ascii">:</span></p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb48-1" title="1"><span class="kw">type</span> role <span class="dt">T</span> nominal _ phantom</a>
<a class="sourceLine" id="cb48-2" title="2"><span class="kw">data</span> <span class="dt">T</span> a b c <span class="ot">=</span> <span class="dt">T</span> <span class="dt">Int</span> b</a></code></pre></div>
<p><code>_</code>は推論に任せることを意味します。</p>
<p><span class="ascii">type role</span>に興味があるならば、<a href="https://downloads.haskell.org/~ghc/8.2.1/docs/html/users_guide/glasgow_exts.html#roles"><span class="ascii">GHC User</span>’<span class="ascii">s Guide - 9.36 Roles</span></a>を読んでみると良いでしょう。また、歴史的経緯については、<a href="https://typesandkinds.wordpress.com/2013/08/15/roles-a-new-feature-of-ghc/"><span class="ascii">Roles: a new feature of GHC</span></a>に簡潔にまとまっています。</p>
<h3 id="軽率多相"><span class="link-to-here-outer"><a href="#軽率多相" title="軽率多相"><span class="link-to-here">Link to<br />
here</span></a></span>軽率多相</h3>
<p>前の章では、プリミティブ型の種を紹介しました。この種は<code>TYPE :: RuntimeRep -&gt; *</code>という型コンストラクタを昇格したものによって、作られているのでした。そして、<code>*</code>でさえ<code>TYPE 'LiftedRep</code>のエイリアスでしか無かったのでしたね。このような種の表現になったのは、実は最近のことです。昔はそれぞれの種は実行時の表現ごとに切り離されていました。<code>TYPE</code>を使って共通化されたのには、幾つかの歴史的経緯があり、 <strong>軽率多相<span class="ascii">(levity polymorphism)</span></strong> という話題と密接な関係があります。軽率多相は、種多相を少し制限したものです。種多相は任意の種を扱えるような種変数を許容しますが、軽率多相は実行時表現に関係するような範囲での種の多相を提供します。</p>
<p>関数型コンストラクタ<code>(-&gt;)</code>の種は、<code>(-&gt;) :: * -&gt; * -&gt; *</code>であると話してきました。実際には、<code>(-&gt;) :: TYPE q -&gt; TYPE r -&gt; *</code>というような種を持っています。<code>TYPE</code>の引数の部分は、任意の<code>RuntimeRep</code>をとれるようになっています。確認してみましょう<span class="ascii">:</span></p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb49-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XTypeInType</span> <span class="op">-</span><span class="dt">XKindSignatures</span></a>
<a class="sourceLine" id="cb49-2" title="2"><span class="op">&gt;&gt;&gt;</span> <span class="kw">import</span> <span class="dt">GHC.Exts</span></a>
<a class="sourceLine" id="cb49-3" title="3"><span class="op">&gt;&gt;&gt;</span> <span class="kw">type</span> <span class="dt">CheckFuncType</span> (<span class="ot">q ::</span> <span class="dt">RuntimeRep</span>) (<span class="ot">r ::</span> <span class="dt">RuntimeRep</span>) (<span class="ot">a ::</span> <span class="dt">TYPE</span> q) (<span class="ot">b ::</span> <span class="dt">TYPE</span> r) <span class="ot">=</span> a <span class="ot">-&gt;</span> b <span class="co">-- no error</span></a></code></pre></div>
<p><code>TypeInType</code>拡張については、後ほど解説しますので、今はおまじないとしておきましょう。上の例では、任意の<code>RuntimeRep</code>に対して、確かに関数型コンストラクタが有効であることが確認できます。このように関数型コンストラタは軽率多相化されています。なので、私たちは<code>Int# -&gt; Int#</code>といったような関数を、通常の関数型の表記で書けるようになっていたのです。</p>
<p>関数型が軽率多相化されているということは、軽率多相化された関数が書けるということでもあります。実際、幾つかの関数は軽率多相化された形で提供されています。例えば<code>($)</code>や<code>error</code>などがそうです。ただし、軽率多相は全てに気軽に適用できるというわけではありません。以下の例を考えて見ましょう<span class="ascii">:</span></p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb50-1" title="1"><span class="ot">{-# LANGUAGE TypeInType, KindSignatures, ExplicitForAll #-}</span></a>
<a class="sourceLine" id="cb50-2" title="2"></a>
<a class="sourceLine" id="cb50-3" title="3"><span class="kw">import</span> <span class="dt">GHC.Exts</span> (<span class="dt">RuntimeRep</span>, <span class="dt">TYPE</span>)</a>
<a class="sourceLine" id="cb50-4" title="4"></a>
<a class="sourceLine" id="cb50-5" title="5"><span class="ot">bad ::</span> <span class="kw">forall</span> (<span class="ot">r1 ::</span> <span class="dt">RuntimeRep</span>) (<span class="ot">r2 ::</span> <span class="dt">RuntimeRep</span>)</a>
<a class="sourceLine" id="cb50-6" title="6">              (<span class="ot">a ::</span> <span class="dt">TYPE</span> r1) (<span class="ot">b ::</span> <span class="dt">TYPE</span> r2)<span class="op">.</span></a>
<a class="sourceLine" id="cb50-7" title="7">       (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb50-8" title="8">bad f x <span class="ot">=</span> f x</a></code></pre></div>
<p>この例は、<code>($)</code>を軽率多相化した例になります。しかし、この実装には幾つかの問題があります。<code>bad</code>をコンパイルすることを考えてみてください。<code>bad</code>の引数<code>f</code>はただの関数なので問題ありませんが、引数<code>x</code>は軽率多相化されています。<code>x</code>は果たして実データかポインタかどちらでしょうか？ また、サンクを持っているのでしょうか？ <code>x</code>のビット幅は？ <code>x</code>はどのレジスタに格納すべきでしょうか？ 私たちはコンパイル時に、この質問に答えることはできません。なぜなら実データである場合もありポインタである場合もありますし、サンクを持っているかもしれません。浮動小数点数である場合も整数である場合もあり、ビット幅も一定ではないからです！ つまり私たちは、<code>bad</code>の引数<code>x</code>をどのように扱えばいいのか、コンパイル時に決めることができないのです。これは、引数が軽率多相化された関数全てに対して当てはまることです。このため、<span class="ascii">GHC</span>では軽率多相化したような変数を使った関数宣言は許可されていません。ですが、注意して欲しいのは、次のような関数は作ることができるということです<span class="ascii">:</span></p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb51-1" title="1"><span class="ot">{-# LANGUAGE TypeInType, KindSignatures, ExplicitForAll #-}</span></a>
<a class="sourceLine" id="cb51-2" title="2"></a>
<a class="sourceLine" id="cb51-3" title="3"><span class="kw">import</span> <span class="dt">GHC.Exts</span> (<span class="dt">RuntimeRep</span>, <span class="dt">TYPE</span>)</a>
<a class="sourceLine" id="cb51-4" title="4"></a>
<a class="sourceLine" id="cb51-5" title="5"><span class="ot">good ::</span> <span class="kw">forall</span> (<span class="ot">r1 ::</span> <span class="dt">RuntimeRep</span>) (<span class="ot">r2 ::</span> <span class="dt">RuntimeRep</span>)</a>
<a class="sourceLine" id="cb51-6" title="6">              (<span class="ot">a ::</span> <span class="dt">TYPE</span> r1) (<span class="ot">b ::</span> <span class="dt">TYPE</span> r2)<span class="op">.</span></a>
<a class="sourceLine" id="cb51-7" title="7">       (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb51-8" title="8">good f <span class="ot">=</span> f</a></code></pre></div>
<p>この場合、軽率多相化された変数はどこにも出てきていません。</p>
<p>ところで、軽率多相の焦点は、実行時表現の中でも<span class="ascii">lifted/unlifted</span>の枠組みについてです。<span class="ascii">lifted</span>な型の値はサンクを持ち遅延評価を主とし、<span class="ascii">unlifted</span>な型の値はサンクを持たないので正格評価になるのでしたね。このサンクを持つ持たないに関わらず関数を多相化して書けるようにするのが、軽率多相の主な目的です。ですが、<span class="ascii">GHC</span>ではもう一つ重要な<span class="ascii">boxed/unboxed</span>という枠組みもあるのでしたね。この二つの枠組みを分けて多相化できるように、現在次のような変更も提案されています<span class="ascii">:</span></p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb52-1" title="1"><span class="kw">data</span> <span class="dt">Boxity</span> <span class="ot">=</span> <span class="dt">Boxed</span> <span class="op">|</span> <span class="dt">Unboxed</span></a>
<a class="sourceLine" id="cb52-2" title="2"><span class="kw">data</span> <span class="dt">Levity</span> <span class="ot">=</span> <span class="dt">Lifted</span> <span class="op">|</span> <span class="dt">Unlifted</span></a>
<a class="sourceLine" id="cb52-3" title="3"><span class="kw">data</span> <span class="dt">TYPE</span> (<span class="ot">b ::</span> <span class="dt">Boxity</span>) (<span class="ot">l ::</span> <span class="dt">Levity</span>)</a>
<a class="sourceLine" id="cb52-4" title="4"></a>
<a class="sourceLine" id="cb52-5" title="5"><span class="kw">type</span> <span class="op">*</span> <span class="ot">=</span> <span class="dt">TYPE</span> <span class="dt">'Boxed</span> <span class="dt">'Lifted</span></a></code></pre></div>
<p>もし、軽率多相に興味があるならば、原論文<a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/levity-1.pdf"><span class="ascii">Levity Polymorphism (extended version)</span></a>を読んでみるのがいいでしょう。この論文では、軽率多相に至るまでの<span class="ascii">GHC</span>での経緯と問題点、軽率多相の動機などが丁寧に解説されています。また、論文より説明が若干劣りますが<a href="https://downloads.haskell.org/~ghc/8.2.1/docs/html/users_guide/glasgow_exts.html#levity-polymorphism"><span class="ascii">GHC User</span>’<span class="ascii">s Guide - 9.12 Levity polymorphism</span></a>にも、<span class="ascii">GHC</span>での軽率多相についての仕組みが書かれています。</p>
<h3 id="トップレベル種注釈"><span class="link-to-here-outer"><a href="#トップレベル種注釈" title="トップレベル種注釈"><span class="link-to-here">Link to<br />
here</span></a></span>トップレベル種注釈</h3>
<p><code>KindSignatures</code>拡張は、種の注釈を書けるようにするようなものでした。<code>KindSignatures</code>は型パラメータの種を明示的に書くことができるようにする拡張でしたね。種が明示されないパラメータは、種推論によってその種が定まります。ですが、種推論は幾つか制約があり、その一つに再帰的データ型に対しては、単相的な再帰の種推論しか行えないというものがあります。以下のケースを見てください<span class="ascii">:</span></p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb53-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XPolyKinds</span></a>
<a class="sourceLine" id="cb53-2" title="2"><span class="op">&gt;&gt;&gt;</span> <span class="kw">data</span> <span class="dt">T</span> m a <span class="ot">=</span> <span class="dt">Nil</span> <span class="op">|</span> <span class="dt">MkT</span> (m a) (<span class="dt">T</span> <span class="dt">Maybe</span> (m a))</a>
<a class="sourceLine" id="cb53-3" title="3"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="dt">T</span></a>
<a class="sourceLine" id="cb53-4" title="4"><span class="dt">T</span><span class="ot"> ::</span> (<span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>) <span class="ot">-&gt;</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span></a></code></pre></div>
<p>このデータ型<code>T</code>の種は<code>(k -&gt; *) -&gt; k -&gt; *</code>というような多相化された種でも問題ないはずですが、実際には<code>PolyKinds</code>をつけているにも関わらず<code>*</code>で単相化されて推論されます。単相制約によって、例えば次のように、一部種注釈を書いてもうまく推論できません<span class="ascii">:</span></p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb54-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">data</span> <span class="dt">T</span> (<span class="ot">m ::</span> k <span class="ot">-&gt;</span> <span class="op">*</span>) a <span class="ot">=</span> <span class="dt">Nil</span> <span class="op">|</span> <span class="dt">MkT</span> (m a) (<span class="dt">T</span> <span class="dt">Maybe</span> (m a))</a>
<a class="sourceLine" id="cb54-2" title="2"></a>
<a class="sourceLine" id="cb54-3" title="3"><span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">49</span><span class="op">:</span><span class="dv">45</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span></a>
<a class="sourceLine" id="cb54-4" title="4">    • <span class="dt">Expected</span> kind ‘k <span class="ot">-&gt;</span> <span class="op">*</span>’, but ‘<span class="dt">Maybe</span>’ has kind ‘<span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>’</a>
<a class="sourceLine" id="cb54-5" title="5">    • <span class="dt">In</span> the first argument <span class="kw">of</span> ‘<span class="dt">T</span>’, namely ‘<span class="dt">Maybe</span>’</a>
<a class="sourceLine" id="cb54-6" title="6">      <span class="dt">In</span> the <span class="kw">type</span> ‘<span class="dt">T</span> <span class="dt">Maybe</span> (m a)’</a>
<a class="sourceLine" id="cb54-7" title="7">      <span class="dt">In</span> the definition <span class="kw">of</span> <span class="kw">data</span> constructor ‘<span class="dt">MkT</span>’</a>
<a class="sourceLine" id="cb54-8" title="8"><span class="op">&gt;&gt;&gt;</span> <span class="kw">data</span> <span class="dt">T</span> m (<span class="ot">a ::</span> k) <span class="ot">=</span> <span class="dt">Nil</span> <span class="op">|</span> <span class="dt">MkT</span> (m a) (<span class="dt">T</span> <span class="dt">Maybe</span> (m a))</a>
<a class="sourceLine" id="cb54-9" title="9"></a>
<a class="sourceLine" id="cb54-10" title="10"><span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">50</span><span class="op">:</span><span class="dv">40</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span></a>
<a class="sourceLine" id="cb54-11" title="11">    • <span class="dt">Expected</span> kind ‘k <span class="ot">-&gt;</span> <span class="op">*</span>’, but ‘<span class="dt">Maybe</span>’ has kind ‘<span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>’</a>
<a class="sourceLine" id="cb54-12" title="12">    • <span class="dt">In</span> the first argument <span class="kw">of</span> ‘<span class="dt">T</span>’, namely ‘<span class="dt">Maybe</span>’</a>
<a class="sourceLine" id="cb54-13" title="13">      <span class="dt">In</span> the <span class="kw">type</span> ‘<span class="dt">T</span> <span class="dt">Maybe</span> (m a)’</a>
<a class="sourceLine" id="cb54-14" title="14">      <span class="dt">In</span> the definition <span class="kw">of</span> <span class="kw">data</span> constructor ‘<span class="dt">MkT</span>’</a></code></pre></div>
<p>ですが、私たちは完全に種推論に頼らないような種注釈を提供することで、<code>T :: (k -&gt; *) -&gt; k -&gt; *</code>というような種多相化された型コンストラクタを作ることができます<span class="ascii">:</span></p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb55-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">data</span> <span class="dt">T</span> (<span class="ot">m ::</span> k <span class="ot">-&gt;</span> <span class="op">*</span>) (<span class="ot">a ::</span> k) <span class="ot">=</span> <span class="dt">Nil</span> <span class="op">|</span> <span class="dt">MkT</span> (m a) (<span class="dt">T</span> <span class="dt">Maybe</span> (m a))</a>
<a class="sourceLine" id="cb55-2" title="2"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="dt">T</span></a>
<a class="sourceLine" id="cb55-3" title="3"><span class="dt">T</span><span class="ot"> ::</span> (k <span class="ot">-&gt;</span> <span class="op">*</span>) <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="op">*</span></a></code></pre></div>
<p>このような完全に種が提供されているような種注釈の形式を、<span class="ascii">GHC</span>では <strong><span class="ascii">CUSKs(Complete User-Supplied Kind signatures)</span></strong> と呼んでいます。<span class="ascii">CUSK</span>は、種多相な再帰的データ型を提供する場合必須のものになってきますが、上の例からも分かる通り非常に見にくいのが難点です。また構文を解析して<span class="ascii">CUSK</span>か判断するのにも、手間がかかります。そのため、現在<span class="ascii">CUSK</span>に代わるものとして、 <strong>トップレベル種注釈<span class="ascii">(top-level kind signatures)</span></strong> という機能が提案されています。この提案は、上の例の<span class="ascii">CUSK</span>と同等の注釈を、次のように書けるようにするものです<span class="ascii">:</span></p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb56-1" title="1"><span class="kw">type</span> <span class="dt">T</span><span class="ot"> ::</span> (k <span class="ot">-&gt;</span> <span class="op">*</span>) <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb56-2" title="2"><span class="kw">data</span> <span class="dt">T</span> m a <span class="ot">=</span> <span class="dt">Nil</span> <span class="op">|</span> <span class="dt">MkT</span> (m a) (<span class="dt">T</span> <span class="dt">Maybe</span> (m a))</a></code></pre></div>
<p>関数の型注釈などと同じスタイルで、非常に見やすいですね。</p>
<p>トップレベル種注釈は、現在、<a href="https://github.com/ghc-proposals/ghc-proposals/pull/54"><span class="ascii">GHC Proposals - Pull Request #54</span></a>で提案されています。興味がある方は、<a href="https://downloads.haskell.org/~ghc/8.2.1/docs/html/users_guide/glasgow_exts.html#complete-user-supplied-kind-signatures-and-polymorphic-recursion"><span class="ascii">GHC User</span>’<span class="ascii">s Guide - 9.11.5 Complete user-supplied kind signatures and polymorphic recursion</span></a>と合わせて提案内容を見てみると良いでしょう。</p>
<h3 id="unliftedデータ型"><span class="link-to-here-outer"><a href="#unliftedデータ型" title="unliftedデータ型"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Unlifted</span>データ型</h3>
<p><span class="ascii">Haskell</span>のデータ型は、<span class="ascii">lifted</span>という枠組みの型でした。<span class="ascii">lifted</span>な型は、評価されるまではサンクになっているのでした。<span class="ascii">unlifted</span>な型は、<span class="ascii">GHC</span>で幾つかプリミティブ型として提供されているのでした。現在、<strong><span class="ascii">unlifted</span>データ型</strong>という拡張が提案されています。この拡張は、ユーザー定義の<span class="ascii">unlifted</span>な型を定義できるようにする拡張です。</p>
<p>この拡張は、次のような新たなデータ宣言をできるようにするものです<span class="ascii">:</span></p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb57-1" title="1"><span class="kw">data</span> unlifted <span class="dt">UBool</span> <span class="ot">=</span> <span class="dt">UTrue</span> <span class="op">|</span> <span class="dt">UFalse</span></a></code></pre></div>
<p>ここで、<code>UBool</code>型の値は、<span class="ascii">unlifted</span>な型でありボックス型であるようなデータ型になります。つまり、<code>Array# a</code>と同じようなデータ型で、サンクを持たずポインタでヒープ上の本体を指し示すような表現がされます。そして、その種は<code>TYPE 'UnliftedRep</code>になります。また、この拡張下では、<span class="ascii">unlifted</span>型の<code>newtype</code>が行えるようにするという提案もされています。</p>
<p>ただこの拡張は新たなシンタックスを導入することになるため、<code>GADTSyntax</code>と<code>KindSignatures</code>を使って以下のようなことをできるようにすることが、代わりに提案されています<span class="ascii">:</span></p>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb58-1" title="1"><span class="ot">{-# LANGUAGE GADTSyntax, KindSignatures #-}</span></a>
<a class="sourceLine" id="cb58-2" title="2"></a>
<a class="sourceLine" id="cb58-3" title="3"><span class="kw">data</span> <span class="dt">UBool</span><span class="ot"> ::</span> <span class="dt">TYPE</span> <span class="dt">'UnliftedRep</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb58-4" title="4">    <span class="dt">UTrue</span><span class="ot">  ::</span> <span class="dt">UBool</span></a>
<a class="sourceLine" id="cb58-5" title="5">    <span class="dt">UFalse</span><span class="ot"> ::</span> <span class="dt">UBool</span></a></code></pre></div>
<p>これにより、新たな構文を導入しなくても、<span class="ascii">unlifted</span>なデータ型を定義できるようになります。</p>
<p><span class="ascii">unlifted</span>データ型について興味があるならば、<a href="https://ghc.haskell.org/trac/ghc/wiki/UnliftedDataTypes"><span class="ascii">GHC Wiki - UnliftedDataTypes</span></a>のページを見てみると良いでしょう。このページに、主な提案内容が書かれています。</p>
<h3 id="type-in-type"><span class="link-to-here-outer"><a href="#type-in-type" title="type-in-type"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Type in Type</span></h3>
<p><code>TypeInType</code>拡張は、<code>DataKinds</code>拡張と<code>PolyKinds</code>拡張をより強力にした拡張です。例えば、以下のようなことができるようになります<span class="ascii">:</span></p>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb59-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XTypeInType</span> <span class="op">-</span>fprint<span class="op">-</span>explicit<span class="op">-</span>foralls</a>
<a class="sourceLine" id="cb59-2" title="2"><span class="op">&gt;&gt;&gt;</span> <span class="co">-- 型エイリアスを種として使えるようになる</span></a>
<a class="sourceLine" id="cb59-3" title="3"><span class="op">&gt;&gt;&gt;</span> <span class="kw">type</span> <span class="dt">B</span> <span class="ot">=</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb59-4" title="4"><span class="op">&gt;&gt;&gt;</span> <span class="kw">data</span> <span class="dt">D</span> (<span class="ot">a ::</span> <span class="dt">B</span>)</a>
<a class="sourceLine" id="cb59-5" title="5"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="dt">D</span></a>
<a class="sourceLine" id="cb59-6" title="6"><span class="dt">D</span><span class="ot"> ::</span> <span class="dt">B</span> <span class="ot">-&gt;</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb59-7" title="7"><span class="op">&gt;&gt;&gt;</span> <span class="co">-- より広い範囲の多相を書けるようになる</span></a>
<a class="sourceLine" id="cb59-8" title="8"><span class="op">&gt;&gt;&gt;</span> <span class="kw">data</span> <span class="dt">A</span> (<span class="ot">d ::</span> <span class="dt">D</span> a)</a>
<a class="sourceLine" id="cb59-9" title="9"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="dt">A</span></a>
<a class="sourceLine" id="cb59-10" title="10"><span class="dt">A</span><span class="ot"> ::</span> <span class="kw">forall</span> (<span class="ot">a ::</span> <span class="dt">B</span>)<span class="op">.</span> <span class="dt">D</span> a <span class="ot">-&gt;</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb59-11" title="11"><span class="op">&gt;&gt;&gt;</span> <span class="co">-- RankN多相な種を書けるようになる</span></a>
<a class="sourceLine" id="cb59-12" title="12"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XRankNTypes</span></a>
<a class="sourceLine" id="cb59-13" title="13"><span class="op">&gt;&gt;&gt;</span> <span class="kw">data</span> <span class="dt">AN</span> (<span class="ot">d ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">D</span> a)</a>
<a class="sourceLine" id="cb59-14" title="14"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>kind <span class="dt">AN</span></a>
<a class="sourceLine" id="cb59-15" title="15"><span class="dt">AN</span><span class="ot"> ::</span> (<span class="kw">forall</span> (<span class="ot">a ::</span> <span class="dt">B</span>)<span class="op">.</span> <span class="dt">D</span> a) <span class="ot">-&gt;</span> <span class="op">*</span></a></code></pre></div>
<p>このように、型注釈でできたことが、種注釈でできるようになるわけです。</p>
<p>ただし、この拡張は現状とても不安定であり、使用が推奨されているわけではありません。この拡張を使用する場合は、コンパイル時、内部でこの拡張の挙動をチェックするように<code>-dcore-lint</code>というフラグを使用することが推奨されています。将来的には、この拡張の範囲を型と種の範囲から、型と値の範囲、ひいては種と型と値の違いを取り払い、依存型というシステムに徐々に近づけていくことも視野に入れているようです。ただし、まずは種と型の範囲で安定的な機能を提供するのが、目的ということでしょう。</p>
<p><code>TypeInType</code>拡張については、主に<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#overview-of-type-in-type"><span class="ascii">GHC User</span>’<span class="ascii">s Guide - 9.11.3 Overview of Type-in-Type</span></a>に、その概要が書かれています。</p>
<h3 id="この章のまとめ-1"><span class="link-to-here-outer"><a href="#この章のまとめ-1" title="この章のまとめ-1"><span class="link-to-here">Link to<br />
here</span></a></span>この章のまとめ</h3>
<p>この章では、幾つかの種に関する話題をかいつまんで紹介しました。</p>
<p><span class="ascii">type role</span>は、二つの型が同じ内部表現を持つ型かを判定するための、型変数が持つ種とは異なる情報でした。<span class="ascii">nominal/representational/phantom</span>の三種があり、データ宣言でどの<span class="ascii">type role</span>を割り当てるかが推論されるのでした。また、<code>RoleAnnotations</code>拡張によって明示的に指定することも可能なのでした。</p>
<p>軽率多相<span class="ascii">(levity polymorphism)</span>は<span class="ascii">lifted/unlifted</span>の違いを吸収する多相でした。これによって、<span class="ascii">lifted/unlifted</span>の違いを問わない多相化された関数を書けるようになるのでした。ただし、全ての関数を制限なく軽率多相化することはできず、関数の引数が軽率多相化されているようなものは、機械語にうまく翻訳できないため書けないのでした。</p>
<p>トップレベル種注釈は、既存の<span class="ascii">CUSK</span>という種注釈の方法に変わり、種注釈を分かりやすく書くための提案でした。再帰的データ型に対して種推論がうまく働かないという制約から、多相的な種を使用する場合、種推論に頼らず完全な種の情報を提供する必要があり、完全に情報が提供されるような種の注釈を<span class="ascii">GHC</span>では<span class="ascii">CUSK</span>と読んでいるのでした。しかし、<span class="ascii">CUSK</span>は一般的に見づらいため、それを解決するための提案でしたね。この提案されている構文は、関数の型注釈と同じスタイルで非常に分かりやすいですね。</p>
<p><span class="ascii">unlifted</span>データ型は、<span class="ascii">unlifted</span>な型を定義できるようにするような拡張として提案されているものでした。この拡張により、ボックス型でかつ<span class="ascii">unlifted</span>なもの、つまりサンクを持たないボックス型を定義できるようになるのでした。現状、幾つか議論されるべき課題が残っていますが、近い将来導入されるかもしれません。</p>
<p><code>TypeInType</code>は型と種の違いを取り払うような拡張でした。これにより、型エイリアスを種に昇格したり、<span class="ascii">RankN</span>の種注釈を書けるようになるのでした。ただし、現状は非常に不安定であり、使用には注意が必要です。</p>
<h2 id="まとめ"><span class="link-to-here-outer"><a href="#まとめ" title="まとめ"><span class="link-to-here">Link to<br />
here</span></a></span>まとめ</h2>
<p>さて、<span class="ascii">Part 1</span>と合わせて、一通りの種に関する話題を紹介してきました。種の仕組みの紹介と<span class="ascii">5</span>つの大きな話題を取り扱ってきました。また、少し高度な話題を幾つか、駆け足で紹介しました。この二つの記事が、何かの役に立てば幸いです。</p>
<p>もし、<span class="ascii">Advanced Topics</span>の内容について、詳細が知りたいという声が多ければ、<span class="ascii">Part 3</span>を書くかもしれませんが、ひとまずはこれで。では、良い<span class="ascii">Haskell</span>ライフをノシ</p>
<h2 id="参考文献"><span class="link-to-here-outer"><a href="#参考文献" title="参考文献"><span class="link-to-here">Link to<br />
here</span></a></span>参考文献</h2>
<ul>
<li><a href="https://www.haskell.org/onlinereport/haskell2010/haskell.html"><span class="ascii">Haskell 2010 Language Report</span></a><span class="ascii">: Haskell2010</span>の仕様書です。主に標準の仕組みを紹介する際に参照しました。
<ul>
<li><a href="https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-630004.1"><span class="ascii">4.1 Overview of Types and Classes</span></a><span class="ascii">:</span> 標準の型システムや型制約について、書かれています。</li>
</ul></li>
<li><a href="https://downloads.haskell.org/~ghc/8.2.1/docs/html/users_guide/"><span class="ascii">GHC 8.2.1 Users Guide</span></a><span class="ascii">:</span> 主な種に関する参考資料としてと<span class="ascii">GHC</span>拡張についての資料として参考にしました。
<ul>
<li><a href="https://downloads.haskell.org/~ghc/8.2.1/docs/html/users_guide/glasgow_exts.html#unboxed-types-and-primitive-operations"><span class="ascii">9.2 Unboxed types and primitive operations</span></a><span class="ascii">:</span> 非ボックス型を主とするプリミティブ型と、その演算のために用意されている関数についての解説が書かれています。</li>
<li><a href="https://downloads.haskell.org/~ghc/8.2.1/docs/html/users_guide/glasgow_exts.html#datatype-promotion"><span class="ascii">9.10 Datatype promotion</span></a><span class="ascii">:</span> <code>DataKinds</code>拡張の動機と解説が書かれています。</li>
<li><a href="https://downloads.haskell.org/~ghc/8.2.1/docs/html/users_guide/glasgow_exts.html#kind-polymorphism-and-type-in-type"><span class="ascii">9.11 Kind polymorphism and Type-in-Type</span></a><span class="ascii">: GHC</span>においての種推論などの、種に関することが総括してあります。</li>
<li><a href="https://downloads.haskell.org/~ghc/8.2.1/docs/html/users_guide/glasgow_exts.html#levity-polymorphism"><span class="ascii">9.12 Levity polymorphism</span></a><span class="ascii">:</span> 軽率多相に関する<span class="ascii">GHC</span>での主な仕組みや制約について解説されています。</li>
<li><a href="https://downloads.haskell.org/~ghc/8.2.1/docs/html/users_guide/glasgow_exts.html#constraints-in-types"><span class="ascii">9.14 Constraints in types</span></a><span class="ascii">:</span> 型制約に関する、<span class="ascii">GHC</span>上のいくつかの話題が書かれています。</li>
<li><a href="https://downloads.haskell.org/~ghc/8.2.1/docs/html/users_guide/glasgow_exts.html#roles"><span class="ascii">9.36 Roles</span></a><span class="ascii">: type role</span>についての、動機と解説が書かれています。</li>
</ul></li>
<li><a href="https://github.com/ghc-proposals/ghc-proposals"><span class="ascii">GHC Proposals</span></a><span class="ascii">: GHC</span>での実装面、言語面での提案を管理するリポジトリです。
<ul>
<li><a href="https://github.com/ghc-proposals/ghc-proposals/blob/c8931ec32464040334ee6a0ad8299309d0424ee8/proposals/0003-levity-polymorphism.rst"><span class="ascii">Revise Levity Polymorphism</span></a><span class="ascii">: GHC 8.2.1</span>での軽率多相に関する変更が書かれています。</li>
<li><a href="https://github.com/ghc-proposals/ghc-proposals/pull/54"><span class="ascii">Top-level kind signatures (instead of CUSKs)</span></a><span class="ascii">:</span> トップレベル型注釈に関しての提案です。</li>
</ul></li>
<li><a href="https://ghc.haskell.org/trac/ghc/"><span class="ascii">GHC Developer Wiki</span></a><span class="ascii">: GHC</span>の実装に関する事や、その元となるアイデアについてまとめられている<span class="ascii">Wiki</span>です。
<ul>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/Kinds"><span class="ascii">Commentary/Compiler/Kinds</span></a><span class="ascii">:</span> この記事のストーリーを決める際に参照しました。</li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/TypeType"><span class="ascii">Commentary/Compiler/TypeType</span></a><span class="ascii">: GHC</span>の型にまつわる内部表現や分類法などについて書かれています。</li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects"><span class="ascii">Commentary/Rts/Storage/HeapObjects</span></a><span class="ascii">: GHC</span>オブジェクトの内部表現について書かれています。<span class="ascii">lifted/unlifted</span>、<span class="ascii">boxed/unboxed</span>の違いについて、参考にしました。</li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/GhcKinds"><span class="ascii">GhcKinds</span></a><span class="ascii">:</span> <code>PolyKinds</code>拡張に関する話題がまとまっているページです。</li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/UnliftedDataTypes"><span class="ascii">UnliftedDataTypes</span></a><span class="ascii">: unlifted</span>データ型を定義できるようにするための拡張の提案が、まとめられているページです。</li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/NoSubKinds"><span class="ascii">NoSubKinds</span></a><span class="ascii">:</span> 軽率多相以前の<span class="ascii">GHC</span>の仕組みとして、<code>OpenKind</code>というものがありました。しかしながら、この仕組みは幾つか問題が知られており、現在は軽率多相によって置き換えられています。ここでは、<code>OpenKind</code>の仕組みと問題点、その解決法が書いてあります。</li>
</ul></li>
<li>その他の参考文献<span class="ascii">:</span>
<ul>
<li><a href="http://dreixel.net/research/pdf/ghp.pdf"><span class="ascii">Giving Haskell a Promotion</span></a><span class="ascii">:</span> <code>DataKinds</code>拡張の提唱論文です。<code>DataKinds</code>について紹介する時、参考にしました。</li>
<li><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/levity-1.pdf"><span class="ascii">Levity Polymorphism (extended version)</span></a><span class="ascii">:</span> 軽率多相の提唱論文です。軽率多相について紹介する時、参考にしました。</li>
<li><a href="https://link.springer.com/content/pdf/10.1007%2F3540543961_30.pdf"><span class="ascii">Unboxed values a non-strict as first class citizens in functional language</span></a><span class="ascii">:</span> 非ボックス型の提唱論文です。<span class="ascii">unlifted</span>な型の意味を紹介する場合に、参考にしました。</li>
</ul></li>
</ul>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>型コンストラクタは値を持てないことに注意してください！ 何らかの値を持つ型は全て<code>*</code>という種を持つものになっており、例えば<code>Maybe :: * -&gt; *</code>という型コンストラクタはそれだけでは値を持たず、<code>Maybe Int</code>など型を一つ渡して初めて値を持つような型になるのでした。<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>ここでの<code>Bool</code>は、<code>Bool</code>型が種に昇格したものという点にも注意してくださいね！<code>DataKinds</code>拡張によって、データ型は種に昇格できるのでした。<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p><code>VecRep</code>を持つプリミティブ型は紹介しませんでしたが、この型は<span class="ascii">SIMD</span>ベクトル演算を利用するために用意されています。<code>VecCount</code>はレーン数、<code>VecElem</code>は<span class="ascii">SIMD API</span>のどのデータ型を使用するかを表します。これらのプリミティブ型は<a href="https://hackage.haskell.org/package/ghc-prim-0.5.1.0/docs/GHC-Prim.html#g:29"><span class="ascii">SIMD Vectors</span></a>の章にまとまっているので、興味があれば見てみると良いでしょう。<a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p>この種の定義は、<a href="https://hackage.haskell.org/package/ghc-prim-0.5.1.0/docs/GHC-Types.html#t:-42-"><span class="ascii">GHC.Types</span>モジュール</a>で確認することができます。他にも、エイリアスとして<a href="https://hackage.haskell.org/package/ghc-prim-0.5.1.0/docs/GHC-Types.html#t:Type"><code>Type</code></a>や<span class="ascii">Unicode</span>版の<a href="https://hackage.haskell.org/package/ghc-prim-0.5.1.0/docs/GHC-Types.html#t:-9733-"><code>★</code></a>が用意されています。<a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p>あなたがもし領域理論について興味があるならば、<a href="http://www.cs.bham.ac.uk/~axj/pub/papers/handy1.pdf"><span class="ascii">Domain Theory</span></a>を読んでみるのがよいでしょう。この文献は、領域理論に必要な順序理論の知識から、領域理論の基本的な概念を解説してくれている文献です。もし、理論自体に興味がなく、この理論がどのような問題解決を目指しているかだけを知りたいなら、<span class="ascii">Origins</span>だけでも読むと良いでしょう。<a href="#fnref5" class="footnote-back">↩</a></p></li>
<li id="fn6"><p>非ボックス型は実データなので、サンクはどうやったって持てないんでしたね！ 逆に<span class="ascii">lifted</span>ならば必ずポインタで表されているはずなので、ボックス型になります。ただし、<span class="ascii">unlifted</span>だからといって非ボックス型とは限りません<span class="ascii">(</span>例<span class="ascii">:</span> <code>Array# a</code><span class="ascii">)</span>。また、ボックス型だからといって<span class="ascii">lifted</span>であるとは限りません。<a href="#fnref6" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="../../posts/2017/no-stack-build.html" lang="ja">Haskell-jp Blogへの投稿が簡単になりました！</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="../../" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="../../posts/2017/12-ghc-show-info.html" style="margin-left: auto;" lang="ja">GHCにおける多彩な情報の出力方法</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>



    <hr>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <ul class="list-inline text-center">
                        <li>
                            <a href="https://github.com/haskell-jp/blog">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    </ul>
                    <div class="text-muted notice text-center"> <br /><span class="author">&copy; mizunashi-mana 2017</span> <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.ja"><img alt="クリエイティブ・コモンズ・ライセンス" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a></div>
                    <div class="text-muted notice text-center">この作品は<a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.ja">クリエイティブ・コモンズ 表示 4.0 国際 ライセンス</a>の下に提供されています。</div>
                    <p class="text-muted notice">
                      当ウェブサイトでは<a href="https://support.google.com/analytics/answer/6004245?hl=ja">Google Analytics</a>でアクセス情報を収集しています。集めた情報は統計的に処理した上で、当ウェブサイトの改善のための参考情報としてのみ使用します。
                    </p>
                </div>
            </div>
        </div>
    </footer>

    <!-- jQuery -->
    <script src="../../js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../../js/bootstrap.min.js"></script>

    <!-- Custom Theme JavaScript -->
    <script src="../../js/clean-blog.js"></script>

    <!-- Google Analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-94110610-1', 'auto');
      ga('send', 'pageview');
    </script>
</body>

</html>
