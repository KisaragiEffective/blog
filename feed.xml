<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Haskell-jp Blog</title>
    <link href="https://haskell.jp/blog/feed.xml" rel="self" />
    <link href="https://haskell.jp/blog" />
    <id>https://haskell.jp/blog/feed.xml</id>
    <author>
        <name>Haskell-jp</name>
        <email></email>
    </author>
    <updated>2018-05-25T00:00:00Z</updated>
    <entry>
    <title>Errors and the workarounds frequently encountered when dealing with Haskell on Windows</title>
    <link href="https://haskell.jp/blog/posts/2018/windows-gotchas-en.html" />
    <id>https://haskell.jp/blog/posts/2018/windows-gotchas-en.html</id>
    <published>2018-05-25T00:00:00Z</published>
    <updated>2018-05-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="en">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>This is the English version of <a href="https://haskell.jp/blog/posts/2017/windows-gotchas.html">WindowsでHaskellを扱う時によく遭遇するエラーと対処法</a>.<br />
The original article is the 4th article of <a href="https://qiita.com/advent-calendar/2017/haskell4">Haskell (その4) Advent Calendar 2017 (Japanese)</a>.</p>
<p>What I’m going to tell is summarized as <a href="https://twitter.com/igrep/status/938056578934042626">just one tweet (originally in Japanese)</a>:</p>
<blockquote>
<p>What I’ve learned:</p>
<ul>
<li>chcp65001 if ‘Invalid character’</li>
<li>rebuild if ‘Permission Denied’</li>
<li>Don’t mix Japanese characters in file paths.</li>
<li>Some libraries in C are available, and others are not.</li>
</ul>
<p>Perhaps they’re helpful in other languages.</p>
</blockquote>
<p>Let me add more details.</p>
<h1 id="chcp-65001-if-invalid-character">chcp 65001 if “Invalid character”</h1>
<p>You would have encountered this frequently, especially if you don’t know how to avoid/fix this.<br />
Oh, it’s caused again by building with hakyll!</p>
<pre><code>&gt; stack exec -- site rebuild
...
  [ERROR] preprocessed-site\posts/2017/01-first.md: hGetContents: invalid argument (invalid byte sequence)</code></pre>
<p>The object called <a href="https://www.stackage.org/haddock/lts-10.0/base-4.10.1.0/System-IO.html#t:Handle"><code>Handle</code></a>, used by GHC to read and write a file, knows its character encoding.</p>
<p>This resembles Ruby’s <a href="https://ruby-doc.org/core-2.5.0/IO.html"><code>IO</code></a> and Perl’s file handler.<br />
Both of them represent the “gateway” of data, and assigning character encoding to them enables us to handle the only, consistently encoded strings by converting the incoming data.<br />
In Haskell’s type <code>Char</code>, the only default encoding is UTF-32 (is this the right name in this case?).</p>
<p>The character encoding assigned to a <code>Handle</code> by default depends on the locale settings of the OS: in Japanese Windows, Windows-31J (a.k.a CP932).<br />
But it’s now soon becoming 2018 (when writing the original article). Most files you create should be in UTF-8 unless you write programs in notepad.exe<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.<br />
It doesn’t work to read a UTF-8 file as a Windows-31J file because they’re very different encoding system.<br />
The <code>invalid byte sequence</code> error, shown at the head of this section, is caused by that inconsistency.<br />
Remember this kind of errors are often caused when reading or writing stdout/stdin, as well as plain files.</p>
<h2 id="workaround">Workaround</h2>
<h3 id="if-you-encounter-as-a-user">If you encounter as a user</h3>
<p>In many cases you can avoid these kind of errors by running the below command in advance.</p>
<pre><code>&gt; chcp 65001
&gt; stack exec -- site rebuild
... Should work!</code></pre>
<p>This command temporarily changes the character encoding in the current Command Prompt session.<br />
The number <code>65001</code> seems to stand for UTF-8.<br />
To roll it back, run <code>chcp 932</code>.</p>
<pre><code>&gt; chcp 932</code></pre>
<p>It seems that the “932” of “CP932” is the same “932” entered here!</p>
<p>The <code>chcp</code> command is available in MSYS2’s bash (Surprises me a little. Wondering how it works…😕).<br />
But you should know that <code>chcp</code> exists at <code>C:\Windows\System32\</code>, which MSYS2 users usually don’t want to include in the <code>PATH</code>.<br />
The directory contains many incompatible commands whose names conflict with the tools loved by Unix people (e.g. <code>find.exe</code>)!</p>
<p>So I’ve dropped <code>C:\Windows\System32\</code> from <code>PATH</code> when using MSYS2.<br />
If you’ve done like me, run by full path:</p>
<pre><code>/c/Windows/System32/chcp.com 932</code></pre>
<h3 id="if-it-still-doesnt-work-or-youre-the-developer-of-the-libraries-etc.">If it still doesn’t work, or you’re the developer of the libraries etc.</h3>
<p>Unfortunately, the error can often persist even after running <code>chcp 65001</code><a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>.<br />
According to my guess, the <code>chcp 65001</code> command doesn’t affect the grandchild processes of the Command Prompt (or bash etc.) on which the <code>chcp</code> is run (i.e. the child processes of the command you enter).</p>
<p>If the error still happens you can either report to the developer, or fix it yourself!<br />
When reporting; asking the developer to run after doing <code>chcp 932</code> could help him/her reproduce the bug (Sorry, I’ve never tried it).<br />
When fixing by yourself, perhaps the best and most certain way would be to switch the character encoding of the <code>Handle</code> object.</p>
<p>This problem is caused by the inconsistency between the <code>Handle</code>'s character encoding and the encoding of the bytes that are actually transferred. So switching into the proper encoding should fix it.<br />
If the error happens when reading/writing a common UTF-8 file via the <code>Handle</code>, writing like below can avoid it:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">import</span> <span class="dt">System.IO</span> (hSetEncoding)</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="kw">import</span> <span class="dt">GHC.IO.Encoding</span> (utf8)</a>
<a class="sourceLine" id="cb5-3" data-line-number="3"></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">hSetEncoding handle utf8</a></code></pre></div>
<p>As a bonus, I’ll show you an example of how <a href="https://github.com/haskell/haddock/pull/566">I myself addressed a problem caused by the standard output (or standard error output), and fixed a bug in haddock</a>. In short, it can at least suppress the error to paste the code below before your program uses the <code>Handle</code> (Copied from <a href="https://github.com/haskell/haddock/pull/566/commits/855118ee45e323fd9b2ee32103c7ba3eb1fbe4f2">this commit</a>).</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">{-# LANGUAGE CPP #-}</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">import</span> <span class="dt">System.IO</span> (hSetEncoding, stdout)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="ot">#if defined(mingw32_HOST_OS)</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="kw">import</span> <span class="dt">GHC.IO.Encoding.CodePage</span> (mkLocaleEncoding)</a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="kw">import</span> <span class="dt">GHC.IO.Encoding.Failure</span> (<span class="dt">CodingFailureMode</span>(<span class="dt">TransliterateCodingFailure</span>))</a>
<a class="sourceLine" id="cb6-8" data-line-number="8"><span class="ot">#endif</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9"></a>
<a class="sourceLine" id="cb6-10" data-line-number="10"><span class="fu">...</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11"></a>
<a class="sourceLine" id="cb6-12" data-line-number="12"><span class="ot">#if defined(mingw32_HOST_OS)</span></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">  liftIO <span class="fu">$</span> hSetEncoding stdout <span class="fu">$</span> mkLocaleEncoding <span class="dt">TransliterateCodingFailure</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14"><span class="ot">#endif</span></a></code></pre></div>
<p>CPP macros to <code>import</code> modules only available on Windows makes this code hard to read, so let’s cut out the verbose part:</p>
<pre><code>hSetEncoding stdout $ mkLocaleEncoding TransliterateCodingFailure</code></pre>
<p>Here’re the details:<br />
First of all, <code>hSetEncoding</code> is the function to change the <code>Handle</code>‘s character encoding, as I referred before.<br />
Then <code>stdout</code> is the <code>Handle</code> for the standard output as its name.<br />
The last function call <code>mkLocaleEncoding TransliterateCodingFailure</code> returns a character encoding object for the current Windows’ character encoding (i.e. <code>chcp</code>ed character encoding), configured as “Even if the <code>Handle</code> detects any characters which can’t be converted into/from a Unicode character, don’t raise an error, convert it into some likable character instead.”.</p>
<p>As the result of the <code>hSetEncoding</code> above, and the current character encoding is Windows-31J, the character used in the compilation error of GHC:</p>
<pre><code>↓This character
• No instance for (Transformation Nagisa CardCommune_Mepple)
↑</code></pre>
<p>is converted into</p>
<pre><code>? No instance for (Transformation Nagisa CardCommune_Mepple)</code></pre>
<p>the question mark. Yeah, this is the “?” I bet most users of GHC on Japanese Windows have seen at least once 😅<br />
This makes me guess GHC executes <code>hSetEncoding stderr $ mkLocaleEncoding TransliterateCodingFailure</code> by default before printing out the compilation error.<br />
Anyway, it’s good that the program doesn’t abort due to the error!</p>
<p>As the last note of this section: Read <a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/GHC-IO-Encoding.html">the document of GHC.IO.Encoding</a> for the details of how GHC handles various character encodings.</p>
<h1 id="rebuild-if-permission-denied">Rebuild if “Permission Denied”</h1>
<p>I’ve made the first section too long for “Quick-and-dirty checklist”, but I’ll tell you in short from this section.<br />
We often encounter some errors like “Permission Denied”, “Directory not empty” and similar ones when running <code>stack build</code>, <code>ghc</code>, <code>elm-make</code>, and any other commands written in Haskell.<br />
To tell the truth, I’m completely not sure of the cause, but those errors disappear by running the same command several times.<br />
The key is to repeat many times. Never give up only by once or twice 😅<br />
Turning off your antivirus software’s scanning of the problematic directory, Dropbox’s synchronisation, etc. might also fix such errors.</p>
<h1 id="try-hard-to-build-libraries-in-c">Try hard to build libraries in C…</h1>
<p>On Windows, it frequently troubles us to install libraries which depend on libraries written in C (registered as <code>lib***</code> in your OS’s package manager).<br />
But this is not the case only for Haskell.</p>
<p>The way to fix depends on the case, so let me give you some examples as external links (Sorry, all pages are written in Japanese!).</p>
<ul>
<li>HDBC-sqlite3:
<ul>
<li><a href="https://qiita.com/igrep/items/d947ab871eb5b20b57e4">Windows版stackでもHDBC-sqlite3をビルドする - Qiita</a></li>
<li><a href="http://hiratara.hatenadiary.jp/entry/2017/01/29/110100">MSYS2でHDBC-sqlite3をコンパイル - 北海道苫小牧市出身の初老PGが書くブログ</a></li>
</ul></li>
<li><a href="https://teratail.com/questions/102462">Haskell - Haskellにてstackでiconvパッケージを利用する方法【Windows環境】(102462)｜teratail</a></li>
</ul>
<p>That’s all!<br />
Then, Happy Hacking in Haskell on Windows 10!! I don’t know WSL!🏁🏁🏁</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Translator’s note: In Japanese locale, notepad.exe saves the file in Windows-31J. This will be changed (into UTF-8) in the future release of Windows 10.<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>By the way, when I once tried to build the compiler of <a href="http://eta-lang.org/">Eta</a>, (as far as I remember) <code>chcp 65001</code> didn’t fix the problem, but <code>chcp 20127</code> did.<br />
As <code>chcp 20127</code> switches into US-ASCII, I suspect the local environment of the developer of Eta is US-ASCII…<a href="#fnref2" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2018/about-ghc-exts-1.html" style="margin-left: auto;" lang="ja">GHC拡張ノック(Part 1)</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>GHC拡張ノック(Part 1)</title>
    <link href="https://haskell.jp/blog/posts/2018/about-ghc-exts-1.html" />
    <id>https://haskell.jp/blog/posts/2018/about-ghc-exts-1.html</id>
    <published>2018-05-15T00:00:00Z</published>
    <updated>2018-05-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p><span class="ascii">Haskell</span><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>では各処理系で言語拡張を提供し，<code>LANGUAGE</code>プラグマというものを利用することで，言語拡張を利用することが許容されています．<span class="ascii">Haskell</span>のデファクト標準的な処理系<span class="ascii">GHC</span>も多くの言語拡張を提供しており，その拡張は<strong><span class="ascii">GHC</span>拡張</strong>と呼ばれています．</p>
<p>今回は，この<span class="ascii">GHC</span>拡張の簡単な紹介と，個人的に良く使う拡張についての簡単な紹介を，全<span class="ascii">3</span>回に分けて行いたいと思います．対象としては，<span class="ascii">GHC</span>で<span class="ascii">Haskell</span>プログラミングをしたことがあり，通常の<span class="ascii">Haskell</span>の構文や動作方法が分かっている人を考えています．また，この記事はあくまで簡単な紹介に留めるもので，付随する留意点や詳細な機能説明は，大事な箇所は漏らさないよう注意するつもりですが，全てを網羅するつもりはありませんのでその点は注意してください．もし，実際に<span class="ascii">GHC</span>拡張を使用する際は，<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/"><span class="ascii">GHC</span>のユーザーガイド</a>をよく読んでから使用するのが良いでしょう．</p>
<h1 id="ghc拡張について"><span class="ascii">GHC</span>拡張について</h1>
<h2 id="haskellの言語拡張"><span class="ascii">Haskell</span>の言語拡張</h2>
<p><span class="ascii">Haskell</span>には，言語拡張を取り込む方法が標準で提供されています．<span class="ascii">Haskell</span>標準では，コンパイラプラグマというものが策定されており，これを通してコンパイラに追加情報を提供することができます．コンパイラプラグマは<code>{-#</code>と<code>#-}</code>で囲まれ，字句的にはコメントとして扱われます．標準では，インラインプラグマや特殊化プラグマの他に，<code>LANGUAGE</code>プラグマというものが策定されており，このプラグマを通して言語拡張を指定することができます．</p>
<p>例えば，実装によって<code>CPP</code>と<code>ScopedTypeVariables</code>という名前の言語拡張が提供されており，それを使いたい場合，次のような文をモジュールの開始前に指定することで，言語拡張が有効になります．</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE CPP, ScopedTypeVariables #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">module</span> <span class="dt">A</span> <span class="kw">where</span></a></code></pre></div>
<p>また，<code>LANGUAGE</code>プラグマを複数指定することもできます．</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">{-# LANGUAGE CPP                 #-}</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">module</span> <span class="dt">A</span> <span class="kw">where</span></a></code></pre></div>
<p>この機能を通して，多くの<span class="ascii">Haskell</span>処理系では言語拡張を提供しています．</p>
<h2 id="ghc拡張"><span class="ascii">GHC</span>拡張</h2>
<p><span class="ascii">Haskell</span>のデファクト標準な処理系<span class="ascii">GHC</span>も，多数の拡張を提供しており，この拡張が<span class="ascii">GHC</span>拡張と呼ばれるものです．<span class="ascii">GHC</span>拡張は，バージョン<span class="ascii">8.4.2</span>現在，以下の数が提供されています<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>．</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" data-line-number="1">$ <span class="ex">ghc</span> --supported-extensions <span class="kw">|</span> <span class="fu">wc</span> -l</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="ex">235</span></a></code></pre></div>
<p><code>--supported-extensions</code>オプションは，現在の<span class="ascii">GHC</span>で使用できる<span class="ascii">GHC</span>拡張を表示してくれるオプションです．ただ，<span class="ascii">GHC</span>拡張は全てが独立した拡張ではなく，互いに依存しあった拡張が多く存在します．また，先頭に<code>No</code>がついている拡張は，その<span class="ascii">GHC</span>拡張を無効にするような拡張になっています <a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a> <a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>（例えば，<code>NoImplicitPrelude</code>拡張は<code>ImplicitPrelude</code>拡張を無効にする拡張です<span class="ascii">)</span>．</p>
<p>また，デフォルトで有効になっている拡張などもあります．例えば，<code>ImplicitPrelude</code>という拡張はデフォルトで有効になります．現在デフォルトの<span class="ascii">Haskell 2010</span>をベースにしたモードで<span class="ascii">GHC 8.4.2</span>を使用する場合，以下の拡張が<a href="https://github.com/ghc/ghc/blob/ghc-8.4.2-release/compiler/main/DynFlags.hs#L2022">デフォルトで有効になります</a> <a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a> <a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a> <a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a>．</p>
<ul>
<li><a href="https://prime.haskell.org/wiki/NondecreasingIndentation"><code>NondecreasingIndentation</code></a><span class="ascii">: Haskell</span>のレイアウトルールを変更する拡張です．この拡張を有効にすると，ネストされた<code>do</code>式の場合，インデントをしなくていいようになります．</li>
<li><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#rebindable-syntax-and-the-implicit-prelude-import"><code>ImplicitPrelude</code></a><span class="ascii">:</span> 暗黙的に<code>Prelude</code>モジュールがインポートされるようになる拡張です．</li>
<li><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#switching-off-the-dreaded-monomorphism-restriction"><code>MonomorphismRestriction</code></a><span class="ascii">:</span> <a href="https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-930004.5.5">単相性制限</a>を課すようにする拡張です．この制限により，関数束縛でなく型注釈もない束縛変数の型は，デフォルティングルールによって単相化されます．</li>
<li><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#traditional-record-syntax"><code>TraditionalRecordSyntax</code></a><span class="ascii">:</span> レコード構文を有効にする拡張です．この拡張では，名前付きのフィールドを持つデータ型を定義し，それを使用することが可能になります．</li>
<li><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-EmptyDataDecls"><code>EmptyDataDecls</code></a><span class="ascii">:</span> コンストラクタを持たないデータ型の定義を許容する拡張です．</li>
<li><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi-chap.html#extension-ForeignFunctionInterface"><code>ForeignFunctionInterface</code></a><span class="ascii">: FFI</span>が使えるようになる拡張です．この拡張により，<code>foreign import</code>構文を使用することで，<span class="ascii">Haskell</span>から<span class="ascii">C</span>の関数を読み込むことができるようになります．</li>
<li><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pattern-guards"><code>PatternGuards</code></a><span class="ascii">:</span> <code>case</code>式において，通常のパターンに加えて，<code>&lt;-</code>を使用してガードの中でさらにマッチした条件下でパターンマッチができるようになる拡張です．例えば，<code>case (x, y) of { (True, y) | False &lt;- y -&gt; True; _ -&gt; False }</code>というような式が書けるようになります．</li>
<li><a href="https://prime.haskell.org/wiki/DoAndIfThenElse"><code>DoAndIfThenElse</code></a><span class="ascii">:</span> <code>if</code>式の構文を，<code>then</code>と<code>else</code>の前に<code>;</code>を許容するよう変更する拡張です．これにより，<code>do</code>式において<code>then</code>や<code>else</code>をインデントする必要がなくなります．</li>
</ul>
<p>歴史的経緯で生まれ，互換性のために残されているものの，現状使用が推奨されていない拡張もあります．他に実験的な拡張やかなり大胆な拡張も存在するため，<span class="ascii">GHC</span>拡張を使用する際は<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/"><span class="ascii">GHC</span>のユーザーガイド</a>をよく読んでから使用するのが良いでしょう．</p>
<h2 id="ghc拡張の使い方"><span class="ascii">GHC</span>拡張の使い方</h2>
<p><span class="ascii">GHC</span>で<span class="ascii">GHC</span>拡張を使用する方法は，<span class="ascii">Haskell</span>標準の<code>LANGUAGE</code>プラグマを使用する他に，幾つかあります．まず，<span class="ascii">GHC</span>にオプションを渡して有効にする方法です．例えば，<code>NoImplicitPrelude</code>拡張と<code>Strict</code>拡張を有効にした状態で<code>Main.hs</code>をコンパイルしたい場合，次のように書けます．</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ex">ghc</span> -XNoImplicitPrelude -XStrict --make Main.hs</a></code></pre></div>
<p><span class="ascii">GHC</span>では<code>-X</code>の後に拡張名を続けることで，言語拡張を有効にしてコンパイルすることができます．通常は，<code>LANGUAGE</code>プラグマを使用するのが良いですが，何らかの事情で<code>LANGUAGE</code>プラグマを使用できない場合や，デフォルトで有効にしたい言語拡張がある場合などに便利でしょう．特に<span class="ascii">GHCi</span>で言語拡張を有効にしたくなった場合，このオプションを<code>set</code>コマンドで指定すると良いでしょう．</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span>set <span class="fu">-</span><span class="dt">XNoImplicitPrelude</span> <span class="fu">-</span><span class="dt">XStrict</span></a></code></pre></div>
<p>他に<span class="ascii">GHC</span>拡張を有効にする方法として，<code>Cabal</code>の機能を活用する方法があります．<code>cabal</code>ファイルのビルド情報欄には，<a href="https://www.haskell.org/cabal/users-guide/developing-packages.html#pkg-field-default-extensions"><code>default-extensions</code>というフィールド</a>を指定することができ，そこにデフォルトで有効にしたい言語拡張のリストを書くことで，その拡張を有効にした状態で<code>Cabal</code>がビルドを行ってくれます．例えば，<code>NoImplicitPrelude</code>拡張と<code>Strict</code>拡張をデフォルトで有効にしてビルドしたい場合，次のように書きます．</p>
<pre class="cabal"><code>name:           TestPackage
version:        0.0
synopsis:       Small package with a program
author:         Angela Author
license:        BSD3
build-type:     Simple
cabal-version:  &gt;= 1.2

executable program1
  build-depends:      base
  main-is:            Main.hs
  default-extensions: NoImplicitPrelude, Strict</code></pre>
<h1 id="主要なghc拡張">主要な<span class="ascii">GHC</span>拡張</h1>
<p>以下では，個人的にデフォルトで有効化して使っている拡張を幾つか紹介します．なお，<span class="ascii">GHC</span>のバージョンは<span class="ascii">8.4.2</span>で<span class="ascii">Haskell2010</span>モードで使用することを前提にしています．</p>
<h2 id="preludeの暗黙的な使用を抑制する"><span class="ascii">Prelude</span>の暗黙的な使用を抑制する</h2>
<p>この節では，以下の拡張を紹介します．</p>
<ul>
<li><code>NoImplicitPrelude</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-NoImplicitPrelude">ユーザーガイド <span class="ascii">- NoImplicitPrelude</span>拡張</a></li>
</ul>
<p><span class="ascii">Haskell</span>では，<a href="https://www.stackage.org/haddock/lts-10.8/base-4.10.1.0/Prelude.html"><span class="ascii">Prelude</span>モジュール</a>が暗黙的に<span class="ascii">import</span>されます．つまり，<span class="ascii">Haskell</span>プログラムは暗黙に</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Prelude</span></a></code></pre></div>
<p>と書いてあると，解釈されるということです．<a href="https://www.stackage.org/haddock/lts-10.8/base-4.10.1.0/Prelude.html"><span class="ascii">Prelude</span>モジュール</a>には，<code>Int</code><span class="ascii">/</span><code>IO</code>といった基本的なデータ型や，<code>Eq</code><span class="ascii">/</span><code>Functor</code>といった基本的な型クラス，<code>zip</code><span class="ascii">/</span><code>putStrLn</code>といった基本的な関数が含まれています．</p>
<p><a href="https://www.stackage.org/haddock/lts-10.8/base-4.10.1.0/Prelude.html"><span class="ascii">Prelude</span>モジュール</a>の暗黙的な<span class="ascii">import</span>は，<span class="ascii">Haskell</span>プログラムを簡潔に書く上では便利ですが，これを無効にしたい場合もあります．</p>
<ol type="1">
<li><a href="https://www.stackage.org/haddock/lts-10.8/base-4.10.1.0/Prelude.html"><span class="ascii">Prelude</span>モジュール</a>にあるデータ型や関数と同じ名前の，別モジュールの関数を使いたい時</li>
<li>別の代替となる<span class="ascii">prelude</span>パッケージを使う時</li>
</ol>
<p>といった場合です．<code>NoImplicitPrelude</code>拡張はまさしくこのような場合に，<a href="https://www.stackage.org/haddock/lts-10.8/base-4.10.1.0/Prelude.html"><span class="ascii">Prelude</span>モジュール</a>を暗黙的に<span class="ascii">import</span>しないようにする<span class="ascii">GHC</span>拡張です．<span class="ascii">1</span>番目の理由の場合，この拡張をデフォルトで入れずモジュール度に指定すればいいと思いますが，私的には<span class="ascii">2</span>番目の理由でこの拡張を使うためデフォルトで有効にしています．代替となる<span class="ascii">prelude</span>パッケージは幾つか存在しますが，主に</p>
<ul>
<li><span class="ascii">classy-prelude:</span> <a href="https://hackage.haskell.org/package/classy-prelude"><span class="ascii">Hackage</span>リンク</a></li>
<li><span class="ascii">protolude:</span> <a href="https://hackage.haskell.org/package/protolude"><span class="ascii">Hackage</span>リンク</a></li>
<li><span class="ascii">universum:</span> <a href="https://hackage.haskell.org/package/universum"><span class="ascii">Hackage</span>リンク</a></li>
<li><span class="ascii">basic-prelude:</span> <a href="https://hackage.haskell.org/package/basic-prelude"><span class="ascii">Hackage</span>リンク</a></li>
</ul>
<p>などがあります<a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a>．これらのパッケージを探すには<a href="https://hackage.haskell.org/packages/#cat:Prelude"><span class="ascii">Hackage</span>の<span class="ascii">Prelude</span>カテゴリ</a>を参照するといいでしょう．</p>
<p>私の場合，<span class="ascii">classy-prelude</span>を使っていますが，それも生で使用しているわけではなく，パッケージごとに<span class="ascii">prelude</span>モジュールを作って使用しています．<span class="ascii">Prelude</span>は，最もよく使うものが提供されているモジュールですから，<span class="ascii">API</span>の変更の影響を最も強く受けます．それを外部パッケージに依存させると，パッケージ保守が結構大変です．もし，パッケージごとに<span class="ascii">prelude</span>モジュールを作っておけば，パッケージ側や<span class="ascii">GHC</span>のバージョン変更の影響などで<span class="ascii">API</span>が変更されても，そのモジュール内でフォールバックを設定することで他のモジュールに変更を持ち越す必要がなくなります．これを<code>NoImplicitPrelude</code>拡張と組み合わせ，</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="kw">module</span> <span class="dt">A</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="kw">import</span> <span class="dt">MyPrelude</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6"></a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="fu">...</span></a></code></pre></div>
<p>と書くことで，保守がかなりしやすくなります．</p>
<h2 id="便利な構文の導入">便利な構文の導入</h2>
<h3 id="新たなリテラル表記を可能にする">新たなリテラル表記を可能にする</h3>
<p>この節では，以下の<span class="ascii">3</span>つの拡張を紹介します．</p>
<ul>
<li><code>BinaryLiterals</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-BinaryLiterals">ユーザーガイド <span class="ascii">- BinaryLiterals</span>拡張</a></li>
<li><code>NagativeLiterals</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-NegativeLiterals">ユーザーガイド <span class="ascii">- NagativeLiterals</span>拡張</a></li>
<li><code>HexFloatLiterals</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#ghc-flag--XHexFloatLiterals">ユーザーガイド <span class="ascii">- HexFloatLiterals</span>拡張</a></li>
</ul>
<p><span class="ascii">Haskell</span>には幾つかのリテラルが存在します．例えば，<code>'c'</code>は文字<span class="ascii">c</span>を表す<span class="ascii">Char</span>型のリテラルです．<code>100</code>は整数<span class="ascii">100</span>を表す<code>Num a =&gt; a</code>型のリテラルで，<code>100.1</code>は浮動小数点数<span class="ascii">100.1</span>を表す<code>Fractional a =&gt; a</code>型のリテラルになります．<span class="ascii">Haskell</span>標準には他にも幾つかリテラルが存在しますが，特に数値は非常に多様な使われ方がなされるため，他の多くの言語はより強力なリテラル表現を持つことがあります．<span class="ascii">GHC</span>拡張ではこの背景を元に，リテラルに対する幾つかの拡張を提供しています．<code>BinaryLiterals</code>は<code>Num a =&gt; a</code>型のリテラルに対して，<code>HexFloatLiterals</code>は<code>Fractional a =&gt; a</code>型のリテラルに対して，<code>NegativeLiterals</code>はどちらに対してもの拡張を，それぞれ提供します．</p>
<p>数値型に対するリテラルは，既存のものでも数種類存在します．通常の数値表現<code>20</code>，オクテット<span class="ascii">(8</span>進数<span class="ascii">)</span>表現<code>0o24</code>，ヘックス<span class="ascii">(16</span>進数<span class="ascii">)</span>表現<code>0x14</code>の<span class="ascii">3</span>つです．<code>BinaryLiterals</code>拡張は，これに加え<code>0b</code>を接頭辞に付けることでバイナリ<span class="ascii">(2</span>進数<span class="ascii">)</span>表現<code>0b10100</code>を可能にする拡張です．</p>
<p>これらのオクテット表現やヘックス，バイナリ表現は浮動小数点数の表現はできません．しかし，浮動小数点数は実際には<span class="ascii">IEEE</span>の規格に則ったデータ表現になりますから，<span class="ascii">10</span>進数表現よりも<span class="ascii">16</span>進数表現の方が実態として分かりやすい場合があります．このため<code>HexFloatLiterals</code>拡張では，接頭に<code>0x</code>の付くヘックス表現でも浮動小数点数のリテラルを記述できるようにしています．この拡張によって，<code>0.25</code>は<code>0x0.4</code>と表記できるようになります．また，指数表記も<span class="ascii">10</span>進方式のものではなく，ビット方式のものになります．指数表記には<code>e</code>ではなく<code>p</code>を使い，何ビット移動させるか<span class="ascii">(</span>つまり，<span class="ascii">2</span>の何乗を掛けるか<span class="ascii">)</span>を書くようにします．例えば，<code>1.0</code>は<code>0x0.4p2</code>と表記できます．また，<code>0.125</code>は<code>0x0.4p-1</code>と表記できます．</p>
<p>さて，<span class="ascii">Haskell</span>には唯一の単項演算子<code>-</code>があります．この演算子を使用することで<code>negate 1</code>の代わりに<code>-1</code>という表記が可能になります．しかし，この演算子の結合度は非常に弱く，また二項演算子の<code>-</code>も存在することから<code>f -1</code>という表記は<code>(f) - (1)</code>というように解釈されてしまうなどの問題があり，非常に使い勝手が悪い演算子となっていました．また，<span class="ascii">Haskell</span>の仕様上，<code>-128</code>という表現は最終的に<code>negate (fromInteger 128)</code>という式に<a href="https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-280003.4">脱糖されます</a>が，例えば<code>Int8</code>などの，負数は<code>-128</code>まで扱えるが正数は<code>+127</code>までしか扱えないといったデータ型の場合に，この式は<code>fromInteger</code>で一度<code>+128</code>の値になってしまいオーバーフローを起こしてしまうという問題がありました．これを解決するため導入されたのが<code>NagativeLiterals</code>拡張です．この拡張を導入することで空白を挟まない<code>-1.0</code>などは<span class="ascii">1</span>つのリテラルと解釈されるようになります．この拡張を導入後は，次のようになります．</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> max <span class="fu">-</span><span class="dv">1</span> <span class="dv">2</span> <span class="fu">==</span> max (<span class="fu">-</span><span class="dv">1</span>) <span class="dv">2</span> <span class="co">-- before: max -1 2 == max - (1 2)</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="dt">True</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="fu">&gt;&gt;&gt;</span> <span class="kw">data</span> <span class="dt">SamplePZ</span> <span class="fu">=</span> <span class="dt">SamplePZ</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="fu">&gt;&gt;&gt;</span> <span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">SamplePZ</span> <span class="kw">where</span> { fromInteger i <span class="fu">|</span> i <span class="fu">&lt;=</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dt">SamplePZ</span> }</a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="fu">&gt;&gt;&gt;</span> <span class="fu">-</span><span class="dv">100</span><span class="ot"> ::</span> <span class="dt">SamplePZ</span> <span class="co">-- before: raise error</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6"><span class="dt">SamplePZ</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7"><span class="fu">&gt;&gt;&gt;</span> <span class="fu">-</span> <span class="dv">100</span><span class="ot"> ::</span> <span class="dt">SamplePZ</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8"><span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9"><span class="fu">&gt;&gt;&gt;</span> <span class="kw">instance</span> <span class="dt">Fractional</span> <span class="dt">SamplePZ</span> <span class="kw">where</span> { fromRational r <span class="fu">|</span> r <span class="fu">&lt;=</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dt">SamplePZ</span> }</a>
<a class="sourceLine" id="cb9-10" data-line-number="10"><span class="fu">&gt;&gt;&gt;</span> <span class="fu">-</span><span class="fl">100.10</span><span class="ot"> ::</span> <span class="dt">SamplePZ</span> <span class="co">-- before: raise error</span></a>
<a class="sourceLine" id="cb9-11" data-line-number="11"><span class="dt">SamplePZ</span></a>
<a class="sourceLine" id="cb9-12" data-line-number="12"><span class="fu">&gt;&gt;&gt;</span> <span class="fu">-</span> <span class="fl">100.10</span><span class="ot"> ::</span> <span class="dt">SamplePZ</span></a>
<a class="sourceLine" id="cb9-13" data-line-number="13"><span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> <span class="fu">...</span></a></code></pre></div>
<h3 id="空のデータ型に対するより強力なサポートを導入する">空のデータ型に対するより強力なサポートを導入する</h3>
<p>この節では，以下の<span class="ascii">2</span>つの拡張を紹介します．</p>
<ul>
<li><code>EmptyCase</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-EmptyCase">ユーザーガイド <span class="ascii">- EmptyCase</span>拡張</a></li>
<li><code>EmptyDataDeriving</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#ghc-flag--XEmptyDataDeriving">ユーザーガイド <span class="ascii">- EmptyDataDeriving</span>拡張</a></li>
</ul>
<p><span class="ascii">Haskell</span>では，コンストラクタを一切持たない型を定義できます．これは空のデータ型と呼ばれ，次のように書けます．</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Empty</span></a></code></pre></div>
<p>このような型は<code>base</code>パッケージの<code>Data.Void</code>モジュールでも提供されており，有用な場合があります．しかし，<span class="ascii">Haskell</span>標準ではこのようなデータ型に対するサポートが薄く，使用する上で不便な場面があります．このサポートを強化する拡張が，<code>EmptyCase</code>拡張と<code>EmptyDataDeriving</code>拡張です．</p>
<p><code>EmptyCase</code>拡張は，空のパターンマッチを書けるようにする拡張です．<span class="ascii">Haskell</span>標準では，空のパターンマッチは書けません．つまり，<code>case x of {}</code>というような式が書けないということです．通常はデータ型は何らかのコンストラクタを持っていますから，このようなパターンマッチを書きたいと思う場面はないでしょう．しかし，空のデータ型においてこのようなパターンマッチを書きたいと思うことがあります．</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">f ::</span> <span class="dt">Empty</span> <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">f x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span> {}</a></code></pre></div>
<p>このような表記を可能にするのが<code>EmptyCase</code>拡張です．なお，このケース式は次のように書くのと同値になります．</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">f ::</span> <span class="dt">Empty</span> <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">f x <span class="fu">=</span> x <span class="ot">`seq`</span> error <span class="st">&quot;Non-exhaustive patterns in case&quot;</span></a></code></pre></div>
<p>もう<span class="ascii">1</span>つの<code>EmptyDataDeriving</code>拡張は，空のデータ型に対して<code>deriving</code>構文を使用できるようにする拡張です．空のデータ型は，通常のデータ型と違い<code>Eq</code>や<code>Show</code>などの型クラスインスタンスを<a href="https://www.haskell.org/onlinereport/haskell2010/haskellch11.html#x18-182014x6"><code>deriving</code>することができません</a>．つまり以下のようなことができません．</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Empty</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>しかし，これでは不便な場合があります．それを可能にするのが<code>EmptyDataDeriving</code>拡張です．この拡張では，<code>Eq</code><span class="ascii">/</span><code>Ord</code><span class="ascii">/</span><code>Show</code><span class="ascii">/</span><code>Read</code>の<span class="ascii">4</span>つが<code>deriving</code>可能になり，それぞれは次のようなインスタンスを生成します．</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Empty</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  _ <span class="fu">==</span> _ <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3"></a>
<a class="sourceLine" id="cb14-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Ord</span> <span class="dt">Empty</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">  compare _ _ <span class="fu">=</span> <span class="dt">EQ</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6"></a>
<a class="sourceLine" id="cb14-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">Read</span> <span class="dt">Empty</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-8" data-line-number="8">  readPrec <span class="fu">=</span> pfail</a>
<a class="sourceLine" id="cb14-9" data-line-number="9"></a>
<a class="sourceLine" id="cb14-10" data-line-number="10"><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Empty</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-11" data-line-number="11">  showsPrec _ x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span> {}</a></code></pre></div>
<h3 id="新たな基本構文を導入する">新たな基本構文を導入する</h3>
<p>この節では，以下の<span class="ascii">3</span>つの拡張を紹介します．</p>
<ul>
<li><code>TupleSections</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-TupleSections">ユーザーガイド <span class="ascii">- TupleSections</span>拡張</a></li>
<li><code>MultiWayIf</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-MultiWayIf">ユーザーガイド <span class="ascii">- MultiWayIf</span>拡張</a></li>
<li><code>LambdaCase</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-LambdaCase">ユーザーガイド <span class="ascii">- LambdaCase</span>拡張</a></li>
</ul>
<p><span class="ascii">Haskell</span>では，タプルやラムダ抽象，セクション，<code>if</code>式や<code>case</code>式といった構文が導入されていますが，これらを組み合わせて多用する場合，幾つか冗長な表現が生まれる場合があります．その中でも頻出する表現に対して，新たな構文を提供する<span class="ascii">GHC</span>拡張があります．それが，<code>TupleSections</code>，<code>MultiWayIf</code>，<code>LambdaCase</code>の<span class="ascii">3</span>つの拡張です．</p>
<p><span class="ascii">Haskell</span>には，セクションと呼ばれる二項演算子の部分適用を表す構文があります．また，<span class="ascii">Haskell</span>ではタプルにも独自の構文が充てがわれています．このタプルを使用する際，セクションのように部分適用を簡潔に書きたい場合があります．例えば，<code>\x -&gt; (1, x)</code>という表現をもっと簡潔に書きたい場合があります．この場合は<code>(,) 1</code>というな表記が可能ですが，<span class="ascii">2</span>番目に部分適用したい場合や，<span class="ascii">3</span>つ組のタプルに部分適用したい場合などは非常に面倒です．このため，<code>TupleSections</code>拡張は<code>(1, )</code>という表記でタプルの部分適用を書ける構文を提供します．<span class="ascii">2</span>つ以上空きがある場合は，左から引数を受け取っていくようになります．例えば，<code>(True, , &quot;str&quot;, )</code>は<code>\x y -&gt; (True, x, &quot;str&quot;, y)</code>と同等です．</p>
<p><code>MultiWayIf</code>は名前の通り複数の条件をガード構文のように指定できる<code>if</code>式を提供する拡張です．つまり，以下のようなことがかけます．</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">f ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">f xs <span class="fu">=</span> sequence_ <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  x <span class="ot">&lt;-</span> xs</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">  pure <span class="fu">$</span> <span class="kw">if</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    <span class="fu">|</span> x <span class="fu">&lt;=</span> <span class="dv">0</span>          <span class="ot">-&gt;</span> fail <span class="st">&quot;non-positive number&quot;</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6">    <span class="fu">|</span> x <span class="ot">`mod`</span> <span class="dv">15</span> <span class="fu">==</span> <span class="dv">0</span> <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;FizzBuzz&quot;</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7">    <span class="fu">|</span> x <span class="ot">`mod`</span> <span class="dv">3</span>  <span class="fu">==</span> <span class="dv">0</span> <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;Fizz&quot;</span></a>
<a class="sourceLine" id="cb15-8" data-line-number="8">    <span class="fu">|</span> x <span class="ot">`mod`</span> <span class="dv">5</span>  <span class="fu">==</span> <span class="dv">0</span> <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;Buzz&quot;</span></a>
<a class="sourceLine" id="cb15-9" data-line-number="9">    <span class="fu">|</span> otherwise       <span class="ot">-&gt;</span> print x</a></code></pre></div>
<p>この<code>MultiWayIf</code>は次のように<code>case</code>式で書き換えることが可能です．</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">f ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">f xs <span class="fu">=</span> sequence_ <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  x <span class="ot">&lt;-</span> xs</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">  pure <span class="fu">$</span> <span class="kw">case</span> () <span class="kw">of</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5">    _ <span class="fu">|</span> x <span class="fu">&lt;=</span> <span class="dv">0</span>          <span class="ot">-&gt;</span> fail <span class="st">&quot;non-positive number&quot;</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">    _ <span class="fu">|</span> x <span class="ot">`mod`</span> <span class="dv">15</span> <span class="fu">==</span> <span class="dv">0</span> <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;FizzBuzz&quot;</span></a>
<a class="sourceLine" id="cb16-7" data-line-number="7">    _ <span class="fu">|</span> x <span class="ot">`mod`</span> <span class="dv">3</span>  <span class="fu">==</span> <span class="dv">0</span> <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;Fizz&quot;</span></a>
<a class="sourceLine" id="cb16-8" data-line-number="8">    _ <span class="fu">|</span> x <span class="ot">`mod`</span> <span class="dv">5</span>  <span class="fu">==</span> <span class="dv">0</span> <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;Buzz&quot;</span></a>
<a class="sourceLine" id="cb16-9" data-line-number="9">    _ <span class="fu">|</span> otherwise       <span class="ot">-&gt;</span> print x</a></code></pre></div>
<p><span class="ascii">3</span>つ目の<code>LambdaCase</code>拡張は，ラムダ抽象と<code>case</code>式を組み合わせた際に良く使う表現をより簡潔に書けるようにする拡張です．この拡張を使うと，<code>\x -&gt; case x of (a, b) -&gt; a + b</code>というようなラムダ抽象を，<code>\case (a, b) -&gt; a + b</code>と書けるようになります．もちろんレイアウトルールも<code>case-of</code>式と同じように作用するため，改行を含んだ式も書けます．</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="ot">f ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">f <span class="fu">=</span> negate <span class="fu">.</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3">  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  <span class="dt">Just</span> x  <span class="ot">-&gt;</span> x</a></code></pre></div>
<h3 id="正格化に対するサポートを導入する">正格化に対するサポートを導入する</h3>
<p>この節では，以下の<span class="ascii">3</span>つの拡張を紹介します．</p>
<ul>
<li><code>BangPatterns</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-BangPatterns">ユーザーガイド <span class="ascii">- BangPatterns</span>拡張</a></li>
<li><code>StrictData</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-StrictData">ユーザーガイド <span class="ascii">- StrictData</span>拡張</a></li>
<li><code>Strict</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-Strict">ユーザーガイド <span class="ascii">- Strict</span>拡張</a></li>
</ul>
<p><span class="ascii">Haskell</span>はデフォルトの評価戦略として，グラフ簡約の遅延評価を採用しています．これはリストや再帰に関する表現を非常に豊かにする反面，パフォーマンスを悪化させたりデバッグを困難にさせる場面が多いなどの負の面もあります．このため<span class="ascii">Haskell</span>標準では，<code>seq</code>関数や正格フラグといった正格評価へのサポートも提供しています．しかし，このサポートは表現が冗長な場合が多く，使い勝手が悪い側面があります．この面を解決するための拡張が，<code>BangPatterns</code>，<code>StrictData</code>，<code>Strict</code>の<span class="ascii">3</span>つの拡張です．</p>
<p>再帰関数において，累積引数は多くの場合正格に計算した方が効率が良いですが，<span class="ascii">Haskell</span>標準では以下のように書く必要がありました．</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1">sum<span class="ot"> ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">sum xs y <span class="fu">=</span> y <span class="ot">`seq`</span> <span class="kw">case</span> xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  x<span class="fu">:</span>xs&#39; <span class="ot">-&gt;</span> sum xs&#39; (x <span class="fu">+</span> y)</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">  []    <span class="ot">-&gt;</span> y</a></code></pre></div>
<p>このような<code>seq</code>による評価をより簡潔に書けるよう，<code>BangPatterns</code>拡張というものが提供されています．これはパターンを拡張し，バンパターンというものを導入します．このバンパターンは，通常のパターンに<code>!</code>を付けることで書けます．例えば，上の例はバンパターンを使うと以下のように書けます．</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">sum<span class="ot"> ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2">sum xs <span class="fu">!</span>y <span class="fu">=</span> <span class="kw">case</span> xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  x<span class="fu">:</span>xs&#39; <span class="ot">-&gt;</span> sum xs&#39; (x <span class="fu">+</span> y)</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">  []    <span class="ot">-&gt;</span> y</a></code></pre></div>
<p>バンパターンはパターンの<span class="ascii">1</span>つですから，もちろん<code>let</code>式や<code>case</code>式でも<code>let !y = f x in y</code>や<code>case f x of !y -&gt; y</code>というように使えます．また，<code>case x of (!y, z) -&gt; y + z</code>というように部分パターンとしても有効です．バンパターンは<a href="https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-610003.17.3"><span class="ascii">Haskell</span>の<code>case</code>式の翻訳ルール</a>に次の規則を加えることで実現されます．</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">case</span> v <span class="kw">of</span> { <span class="fu">!</span>pat <span class="ot">-&gt;</span> e; _ <span class="ot">-&gt;</span> e&#39; }</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">≡ v <span class="ot">`seq`</span> <span class="kw">case</span> v <span class="kw">of</span> { pat <span class="ot">-&gt;</span> e; _ <span class="ot">-&gt;</span> e&#39; }</a></code></pre></div>
<p><span class="ascii">Haskell</span>標準では，データ型の宣言において，コンストラクタの引数に正格フラグというものを付けることが許容されています．このフラグをつけた引数は，正格に評価された後コンストラクタに渡されます．ただ，一般にデータ型の引数は正格な方が効率が良いため，データ型宣言時に正格フラグを付けるという慣習がありました．この慣習を打破するために導入されたのが，<code>StrictData</code>拡張です．<code>StrictData</code>拡張下のモジュールでは，データ型宣言時，コンストラクタの引数は全て正格フラグをつけているものとして扱われます．また，<code>~</code>というフラグが新たに導入され，このフラグをつけた引数の場合は<span class="ascii">Haskell</span>標準化のデフォルトの動作，つまり引数は正格に評価されず遅延されるようになります．<code>StrictData</code>下で宣言された</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">data</span> <span class="dt">T</span> <span class="fu">=</span> <span class="dt">Normal</span> <span class="dt">Int</span> <span class="fu">|</span> <span class="dt">Strict</span> <span class="fu">!</span><span class="dt">Int</span> <span class="fu">|</span> <span class="dt">Lazy</span> <span class="fu">~</span><span class="dt">Int</span></a></code></pre></div>
<p>というデータ型は，通常の<span class="ascii">Haskell</span>の以下のデータ型と同等になります．</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">data</span> <span class="dt">T</span> <span class="fu">=</span> <span class="dt">Normal</span> <span class="fu">!</span><span class="dt">Int</span> <span class="fu">|</span> <span class="dt">Strict</span> <span class="fu">!</span><span class="dt">Int</span> <span class="fu">|</span> <span class="dt">Lazy</span> <span class="dt">Int</span></a></code></pre></div>
<p><code>Strict</code>拡張は，<code>StrictData</code>拡張に加え，ほとんどのパターンを暗黙的にバンパターンにする拡張です．つまり，殆どの評価を正格にする拡張です．バンパターンに変わる箇所は，関数の引数，<code>let</code><span class="ascii">/</span><code>where</code>句の束縛変数，<code>case</code>式のパターンマッチなどです．これらのパターンには，最外の場所に<code>!</code>が暗黙的に付与されます．例えば，<code>Strict</code>拡張下で定義された</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="ot">f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">f x (z, y) <span class="fu">=</span> <span class="kw">let</span> zy <span class="fu">=</span> z <span class="fu">*</span> y <span class="kw">in</span> <span class="kw">case</span> x <span class="fu">-</span> z <span class="kw">of</span> z&#39; <span class="ot">-&gt;</span> z&#39; <span class="fu">^</span> z</a></code></pre></div>
<p>という関数は，<code>BangPatterns</code>拡張下の<span class="ascii">Haskell</span>の以下の関数と同等になります．</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="ot">f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2">f <span class="fu">!</span>x <span class="fu">!</span>(z, y) <span class="fu">=</span> <span class="kw">let</span> <span class="fu">!</span>zy <span class="fu">=</span> z <span class="fu">*</span> y <span class="kw">in</span> <span class="kw">case</span> x <span class="fu">-</span> z <span class="kw">of</span> <span class="fu">!</span>z&#39; <span class="ot">-&gt;</span> z&#39; <span class="fu">^</span> z</a></code></pre></div>
<p>注意して欲しいのは，このバンパターンは<code>seq</code>に置き換わるため，<span class="ascii">WHNF</span>までしか評価されないということです．つまり，<code>!(z, y)</code>というパターンは単なる<code>(z, y)</code>と完全に同じです．またトップレベルの束縛にバンパターンを付与することは許されておらず，遅延されるということにも注意が必要です．</p>
<h3 id="パターンマッチをより柔軟に扱えるようにする">パターンマッチをより柔軟に扱えるようにする</h3>
<p>この節では，以下の<span class="ascii">2</span>つの拡張を紹介します．</p>
<ul>
<li><code>ViewPatterns</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-ViewPatterns">ユーザーガイド <span class="ascii">- ViewPatterns</span>拡張</a></li>
<li><code>PatternSynonyms</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-PatternSynonyms">ユーザーガイド <span class="ascii">- PatternSynonyms</span>拡張</a></li>
</ul>
<p><span class="ascii">GHC</span>拡張では，<span class="ascii">Haskell</span>標準のパターンをさらに強力なものにする拡張があります．<code>ViewPatterns</code>はビューパターンという新たなパターンを導入します．また，<code>PatternSynonyms</code>はパターンの別名を付けることができるようにする拡張です．</p>
<p><span class="ascii">Haskell</span>標準にあるパターンガードは，非常に強力ですが，表現が非常に冗長になる場合があります．これを短縮して書けるように，<code>ViewPatterns</code>拡張はビューパターンというものを導入します．ビューパターンは，<code>-&gt;</code>の左側に式を，右側にパターンを書くことで，左の式に対象を適用して結果が右側のパターンにマッチした時，マッチするようなパターンです．例えば，</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1">f ((<span class="ot">`mod`</span> <span class="dv">2</span>) <span class="ot">-&gt;</span> <span class="dv">0</span>) <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2">f x                <span class="fu">=</span> <span class="dt">Just</span> x</a></code></pre></div>
<p>というように使用でき，<code>f 0</code>は<code>Nothing</code>を，<code>f 3</code>は<code>Just 3</code>をそれぞれ返すようになります．この関数宣言は，以下のパターンガードを用いて書いた関数と一致します．</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1">f x <span class="fu">|</span> <span class="dv">0</span> <span class="ot">&lt;-</span> x <span class="ot">`mod`</span> <span class="dv">2</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb26-2" data-line-number="2">f x                  <span class="fu">=</span> <span class="dt">Just</span> x</a></code></pre></div>
<p>ビューパターンは<a href="https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-610003.17.3"><span class="ascii">Haskell</span>の<code>case</code>式の翻訳ルール</a>に次の規則を加えることで実現されます．</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">case</span> v <span class="kw">of</span> { (e <span class="ot">-&gt;</span> p) <span class="ot">-&gt;</span> e1; _ <span class="ot">-&gt;</span> e2 }</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">≡ <span class="kw">case</span> (e v) <span class="kw">of</span> { p <span class="ot">-&gt;</span> e1; _ <span class="ot">-&gt;</span> e2 }</a></code></pre></div>
<p><code>PatternSynonyms</code>拡張は，非常に強力で大きな拡張です<a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a>．<code>PatternSynonyms</code>拡張は名前の通り，パターンに別名を与えるパターンシノニム機能を提供します．パターンシノニムは通常の関数と同じように，次のように定義できます．</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1">pattern <span class="dt">Nil</span><span class="ot"> ::</span> [a]</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">pattern <span class="dt">Nil</span> <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb28-3" data-line-number="3"></a>
<a class="sourceLine" id="cb28-4" data-line-number="4">pattern <span class="dt">Cons</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb28-5" data-line-number="5">pattern <span class="dt">Cons</span> x xs <span class="fu">=</span> x <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb28-6" data-line-number="6"></a>
<a class="sourceLine" id="cb28-7" data-line-number="7"><span class="ot">{-# COMPLETE Nil, Cons #-}</span></a></code></pre></div>
<p>このように定義したパターンは，以下のように使用できます．</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="ot">len ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb29-2" data-line-number="2">len (<span class="dt">Cons</span> _ xs) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> len xs</a>
<a class="sourceLine" id="cb29-3" data-line-number="3">len <span class="dt">Nil</span>         <span class="fu">=</span> <span class="dv">0</span></a></code></pre></div>
<p>パターンシノニムは非常に便利な機能ですが，一方で注意する事項も幾つかあります．</p>
<p>まず，パターンシノニムの定義は関数定義と非常に似ていますが，パターンの別名であることに注意してください．パターンシノニムの定義において変数が出現する場合，関数の引数のように錯覚してしまいがちですが，この変数にはパターンにマッチした時そのマッチした部分が当てがわれます．つまり，右の式でマッチしたものが左の変数に束縛されるため，左の変数に束縛された後右の式を実行する関数と，流れが逆になるということです．このため，パターンシノニムの引数の変数は必ず右に出現する必要があります．また，パターンシノニムの右側には変数を含むパターンしかかけません．そのため，式を書きたい場合，<code>ViewPatterns</code>拡張などを用いなければなりません．さらにパターンシノニムは，デフォルトではパターンの網羅性検査が非常に難しいため，網羅性検査を行わないようになっています．ただし，<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#complete-pragma"><code>COMPLETE</code>プラグマ</a>を用いてパターンシノニムの網羅条件を与えることで，その範囲で網羅性検査を行うようになります．</p>
<p>パターンシノニムはパターンの種類に応じて<span class="ascii">3</span>種類の書き方が存在します．上の単純なパターンシノニムは，双方向<span class="ascii">(bidirectional)</span>パターンシノニムと呼ばれ，暗黙的にパターンの名前と等しい関数が作られます．この関数を用いることで，<code>[0, 1, 2]</code>の代わりに<code>Cons 0 (Cons 1 (Cons 2 Nil))</code>といった式も書くことができるようになります．ただし，このような関数が単純には作れないパターンも存在します．例えば，<code>(x, _)</code>というパターンに，<code>First x</code>というパターンシノニムを与えたい場合，この<code>First</code>に対する関数は<code>_</code>の部分に入れるべき値が分からないため，作りようがありません．このような関数が単純に作れないパターンシノニムは単方向<span class="ascii">(unidirectional)</span>パターンシノニムと呼ばれ，双方向パターンシノニムが<code>=</code>を使って定義されるのに対し，次のように<code>&lt;-</code>を使って書きます．</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1">pattern <span class="dt">First</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">pattern <span class="dt">First</span> x <span class="ot">&lt;-</span> (x, _)</a></code></pre></div>
<p>このパターンシノニムは<code>First</code>という関数は作らず，単純にパターンの別名だけを提供します．ただし，<code>First</code>関数の定義を次のように与えることが可能になっています．</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1">pattern <span class="dt">First</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb31-2" data-line-number="2">pattern <span class="dt">First</span> x <span class="ot">&lt;-</span> (x, _)</a>
<a class="sourceLine" id="cb31-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb31-4" data-line-number="4">    <span class="dt">First</span> x <span class="fu">|</span> x <span class="fu">&lt;</span> <span class="dv">0</span> <span class="fu">=</span> (x, <span class="dt">False</span>)</a>
<a class="sourceLine" id="cb31-5" data-line-number="5">    <span class="dt">First</span> x         <span class="fu">=</span> (x, <span class="dt">True</span>)</a></code></pre></div>
<p>また，パターンシノニムはパターンの評価順序にも注意する必要があります．例えば，次の例をみてください．</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Pair</span> a b <span class="fu">=</span> <span class="dt">Pair</span> a b</a>
<a class="sourceLine" id="cb32-2" data-line-number="2"></a>
<a class="sourceLine" id="cb32-3" data-line-number="3"><span class="kw">type</span> <span class="dt">Pair3</span> a b c <span class="fu">=</span> <span class="dt">Pair</span> a (<span class="dt">Pair</span> b c)</a>
<a class="sourceLine" id="cb32-4" data-line-number="4"></a>
<a class="sourceLine" id="cb32-5" data-line-number="5">pattern <span class="dt">Pair3</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> <span class="dt">Pair3</span> a b c</a>
<a class="sourceLine" id="cb32-6" data-line-number="6">pattern <span class="dt">Pair3</span> x y z <span class="fu">=</span> <span class="dt">Pair</span> x (<span class="dt">Pair</span> y z)</a>
<a class="sourceLine" id="cb32-7" data-line-number="7"></a>
<a class="sourceLine" id="cb32-8" data-line-number="8"><span class="ot">f ::</span> <span class="dt">Pair3</span> <span class="dt">Bool</span> <span class="dt">Bool</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb32-9" data-line-number="9">f (<span class="dt">Pair3</span> <span class="dt">True</span> <span class="dt">True</span> <span class="dt">True</span>) <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb32-10" data-line-number="10">f _                      <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb32-11" data-line-number="11"></a>
<a class="sourceLine" id="cb32-12" data-line-number="12"><span class="ot">f&#39; ::</span> <span class="dt">Pair3</span> <span class="dt">Bool</span> <span class="dt">Bool</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb32-13" data-line-number="13">f&#39; (<span class="dt">Pair</span> <span class="dt">True</span> (<span class="dt">Pair</span> <span class="dt">True</span> <span class="dt">True</span>)) <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb32-14" data-line-number="14">f&#39; _                            <span class="fu">=</span> <span class="dt">False</span></a></code></pre></div>
<p>この<code>f</code>と<code>f'</code>は評価順が異なり，<code>f (Pair False undefined)</code>が例外を投げるのに対し，<code>f' (Pair False undefined)</code>は<code>False</code>を返します．これは，パターンシノニムを使ったパターンマッチでは，自身のパターンを先に調べ，次に引数のパターンマッチを行うからです．つまり，<code>f</code>は以下と同等になります．</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="ot">f ::</span> <span class="dt">Pair3</span> <span class="dt">Bool</span> <span class="dt">Bool</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb33-2" data-line-number="2">f (<span class="dt">Pair</span> x (<span class="dt">Pair</span> y z)) <span class="fu">|</span> <span class="dt">True</span> <span class="ot">&lt;-</span> x, <span class="dt">True</span> <span class="ot">&lt;-</span> y, <span class="dt">True</span> <span class="ot">&lt;-</span> z <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb33-3" data-line-number="3">f _                                                     <span class="fu">=</span> <span class="dt">False</span></a></code></pre></div>
<p>パターンシノニムは，モジュールエクスポートを書く際にも注意が必要で，<code>module A (pattern Cons, pattern Nil) where ...</code>というように接頭に<code>pattern</code>をつける必要があります．</p>
<h3 id="レコードに対するサポートを強化する">レコードに対するサポートを強化する</h3>
<p>この節では，以下の<span class="ascii">4</span>つの拡張を紹介します．</p>
<ul>
<li><code>DuplicateRecordFields</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-DuplicateRecordFields">ユーザーガイド <span class="ascii">- DuplicateRecordFields</span>拡張</a></li>
<li><code>OverloadedLabels</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-OverloadedLabels">ユーザーガイド <span class="ascii">- OverloadedLabels</span>拡張</a></li>
<li><code>NamedFieldPuns</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-NamedFieldPuns">ユーザーガイド <span class="ascii">- NamedFieldPuns</span>拡張</a></li>
<li><code>RecordWildCards</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-RecordWildCards">ユーザーガイド <span class="ascii">- RecordWildCards</span>拡張</a></li>
</ul>
<p><span class="ascii">Haskell</span>のレコード構文は，便利な反面幾つか機能が劣る場面もあります．このため，<span class="ascii">GHC</span>では，レコードをより扱いやすくするための拡張を幾つか提供しています．それが，<code>DuplicateRecordFields</code>，<code>OverloadedLabels</code>，<code>NamedFieldPuns</code>，<code>RecordWildCards</code>の<span class="ascii">4</span>つの拡張です<a href="#fn10" class="footnote-ref" id="fnref10"><sup>10</sup></a>．</p>
<p><span class="ascii">Haskell</span>標準では，同じモジュール内で同じフィールド名を持つ複数のレコード構文を使用したデータ型の定義を行うことができません．これはどのデータ型のフィールドかが曖昧であるようなプログラムを書けてしまうからですが，そういう状況に遭遇するとこの制約は非常に不便です．これを解決するのが，<code>DuplicateRecordFields</code>拡張です．<code>DuplicateRecordFields</code>拡張は，曖昧になるような式を書けなくする代わりに，同一モジュールの複数のデータ型が同じフィールド名を持つことを許容する拡張です．つまり，以下のようなことが可能になります．</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="kw">data</span> <span class="dt">A</span> <span class="fu">=</span> <span class="dt">A</span> {<span class="ot"> d ::</span> <span class="dt">Int</span> }</a>
<a class="sourceLine" id="cb34-2" data-line-number="2"><span class="kw">data</span> <span class="dt">B</span> <span class="fu">=</span> <span class="dt">B</span> {<span class="ot"> d ::</span> <span class="dt">Bool</span> }</a></code></pre></div>
<p>ただし，この拡張下では，曖昧なフィールドを用いたレコードのアップデート構文やフィールドの選択関数の使用の際は型を明記する必要があったり，モジュールのエクスポートリストで選択関数をエクスポートすることが出来なくなったりします．</p>
<p><code>OverloadedLabels</code>拡張は，<code>#foo</code>というような<code>#</code>から始まる新たな構文を導入します．<code>#foo</code>は<code>GHC.OverloadedLabels</code>モジュールの<code>fromLabel</code>メソッドにおいて<code>IsLabel &quot;foo&quot; a =&gt; a</code>というような型を持つ場合と同等になります．これを用いることで，同じフィールドを持つデータ型に対する選択関数を次のように書けます<a href="#fn11" class="footnote-ref" id="fnref11"><sup>11</sup></a>．</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="ot">{-# LANGUAGE OverloadedLabels       #-}</span> <span class="co">-- the main extension</span></a>
<a class="sourceLine" id="cb35-2" data-line-number="2"><span class="ot">{-# LANGUAGE DataKinds              #-}</span> <span class="co">-- for Symbol kind</span></a>
<a class="sourceLine" id="cb35-3" data-line-number="3"><span class="ot">{-# LANGUAGE KindSignatures         #-}</span> <span class="co">-- for HasField&#39;s `l` parameter</span></a>
<a class="sourceLine" id="cb35-4" data-line-number="4"><span class="ot">{-# LANGUAGE MultiParamTypeClasses  #-}</span> <span class="co">-- for HasField and IsLabel classes</span></a>
<a class="sourceLine" id="cb35-5" data-line-number="5"><span class="ot">{-# LANGUAGE FunctionalDependencies #-}</span> <span class="co">-- for HasField class</span></a>
<a class="sourceLine" id="cb35-6" data-line-number="6"><span class="ot">{-# LANGUAGE FlexibleInstances      #-}</span> <span class="co">-- for HasField instances</span></a>
<a class="sourceLine" id="cb35-7" data-line-number="7"><span class="ot">{-# LANGUAGE ScopedTypeVariables    #-}</span> <span class="co">-- for the IsLabel instance</span></a>
<a class="sourceLine" id="cb35-8" data-line-number="8"><span class="ot">{-# LANGUAGE DuplicateRecordFields  #-}</span> <span class="co">-- for A and B data types</span></a>
<a class="sourceLine" id="cb35-9" data-line-number="9"></a>
<a class="sourceLine" id="cb35-10" data-line-number="10"><span class="kw">import</span> <span class="dt">GHC.OverloadedLabels</span> (<span class="dt">IsLabel</span>(..))</a>
<a class="sourceLine" id="cb35-11" data-line-number="11"><span class="kw">import</span> <span class="dt">GHC.TypeLits</span> (<span class="dt">Symbol</span>)</a>
<a class="sourceLine" id="cb35-12" data-line-number="12"><span class="kw">import</span> <span class="dt">Data.Proxy</span> (<span class="dt">Proxy</span>(..))</a>
<a class="sourceLine" id="cb35-13" data-line-number="13"></a>
<a class="sourceLine" id="cb35-14" data-line-number="14"><span class="kw">data</span> <span class="dt">A</span> <span class="fu">=</span> <span class="dt">A</span> {<span class="ot"> d ::</span> <span class="dt">Int</span> }</a>
<a class="sourceLine" id="cb35-15" data-line-number="15"><span class="kw">data</span> <span class="dt">B</span> <span class="fu">=</span> <span class="dt">B</span> {<span class="ot"> d ::</span> <span class="dt">Bool</span> }</a>
<a class="sourceLine" id="cb35-16" data-line-number="16"></a>
<a class="sourceLine" id="cb35-17" data-line-number="17"><span class="kw">class</span> <span class="dt">HasField</span> a (<span class="ot">l ::</span> <span class="dt">Symbol</span>) b <span class="fu">|</span> a l <span class="ot">-&gt;</span> b <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-18" data-line-number="18"><span class="ot">  selectField ::</span> <span class="dt">Proxy</span> l <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb35-19" data-line-number="19"></a>
<a class="sourceLine" id="cb35-20" data-line-number="20"><span class="kw">instance</span> <span class="dt">HasField</span> <span class="dt">A</span> <span class="st">&quot;d&quot;</span> <span class="dt">Int</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-21" data-line-number="21">  selectField _ (<span class="dt">A</span> x) <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb35-22" data-line-number="22"></a>
<a class="sourceLine" id="cb35-23" data-line-number="23"><span class="kw">instance</span> <span class="dt">HasField</span> <span class="dt">B</span> <span class="st">&quot;d&quot;</span> <span class="dt">Bool</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-24" data-line-number="24">  selectField _ (<span class="dt">B</span> x) <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb35-25" data-line-number="25"></a>
<a class="sourceLine" id="cb35-26" data-line-number="26"><span class="kw">instance</span> <span class="dt">HasField</span> a l b <span class="ot">=&gt;</span> <span class="dt">IsLabel</span> l (a <span class="ot">-&gt;</span> b) <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-27" data-line-number="27">  fromLabel <span class="fu">=</span> selectField (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> l)</a></code></pre></div>
<p>これを使うことで，<code>#d A { d = 0 }</code>は<code>0</code>を，<code>#d B { d = True }</code>は<code>True</code>を返してくるようになります．また，<code>#d</code>には型を明記しなくても型推論が働くようになります．</p>
<p>さて他にレコードのパターンマッチやコンストラクトを非常に便利にしてくれる拡張として，<code>NamedFieldPuns</code>拡張と<code>RecordWildCards</code>拡張があります．レコードのパターンマッチは多くの場合冗長になりがちで，次のようなボイラープレートを書きがちです．</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="kw">data</span> <span class="dt">A</span> <span class="fu">=</span> <span class="dt">A</span> {<span class="ot"> x ::</span> <span class="dt">Int</span>,<span class="ot"> y ::</span> <span class="dt">Bool</span> }</a>
<a class="sourceLine" id="cb36-2" data-line-number="2"></a>
<a class="sourceLine" id="cb36-3" data-line-number="3"><span class="ot">f ::</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb36-4" data-line-number="4">f <span class="dt">A</span>{ x <span class="fu">=</span> x } <span class="fu">=</span> x <span class="fu">+</span> <span class="dv">1</span></a></code></pre></div>
<p><code>NamedFieldPuns</code>拡張は，同等のことを次のように書けるようにする拡張です．</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="ot">f ::</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb37-2" data-line-number="2">f <span class="dt">A</span>{ x } <span class="fu">=</span> x <span class="fu">+</span> <span class="dv">1</span></a></code></pre></div>
<p>また，このパターンは旧来の書き方と合わせて書くこともできます．</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="ot">g ::</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb38-2" data-line-number="2">g <span class="dt">A</span>{ x, y <span class="fu">=</span> <span class="dt">False</span> } <span class="fu">=</span> <span class="fu">-</span> x</a>
<a class="sourceLine" id="cb38-3" data-line-number="3">g <span class="dt">A</span>{ x }            <span class="fu">=</span> x</a></code></pre></div>
<p>さらにこの拡張は，コンストラクトの際も役に立ちます．<code>let x = 1 in A { x, y = True }</code>と書くとこの式は，<code>A { x = 1, y = True }</code>と書くのと同等になります．</p>
<p><code>NamedFieldPuns</code>拡張ではフィールド名を明記する必要がありましたが，<code>RecordWildCards</code>拡張はさらにフィールド名を明記する必要がなくなります．以下のように<code>{..}</code>と書くことで，全てのフィールドを展開してくれるようになります．</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="ot">f ::</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb39-2" data-line-number="2">f <span class="dt">A</span>{<span class="fu">..</span>} <span class="fu">=</span> x <span class="fu">+</span> <span class="dv">1</span></a></code></pre></div>
<p>また，部分的に明記することも可能で，その場合以下のように書きます．</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" data-line-number="1"><span class="ot">g ::</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb40-2" data-line-number="2">g <span class="dt">A</span>{ y <span class="fu">=</span> <span class="dt">False</span>, <span class="fu">..</span>} <span class="fu">=</span> <span class="fu">-</span>x</a>
<a class="sourceLine" id="cb40-3" data-line-number="3">g <span class="dt">A</span>{<span class="fu">..</span>}             <span class="fu">=</span> x</a></code></pre></div>
<p>コンストラクトの際も，この拡張は有効です．<code>let x = 1 in A { y = True, ..}</code>と書いた場合，<code>A { x = 1, y = True }</code>と書くのと同等になります．</p>
<h3 id="型演算子を導入する">型演算子を導入する</h3>
<p>この節では，以下の拡張を紹介します．</p>
<ul>
<li><code>TypeOperators</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-TypeOperators">ユーザーガイド <span class="ascii">- TypeOperators</span>拡張</a></li>
</ul>
<p><span class="ascii">Haskell</span>ではユーザー定義の関数やデータ型のコンストラクタにおいて，演算子表記のものも定義できるようになっています．例えば，以下のようにです．</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Pair</span> a b <span class="fu">=</span> a <span class="fu">:*:</span> b</a>
<a class="sourceLine" id="cb41-2" data-line-number="2"><span class="kw">infixl</span> <span class="dv">7</span> <span class="fu">:*:</span></a>
<a class="sourceLine" id="cb41-3" data-line-number="3"></a>
<a class="sourceLine" id="cb41-4" data-line-number="4"><span class="ot">(&amp;) ::</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb41-5" data-line-number="5">x <span class="fu">&amp;</span> f <span class="fu">=</span> f x</a>
<a class="sourceLine" id="cb41-6" data-line-number="6"><span class="kw">infixl</span> <span class="dv">1</span> <span class="fu">&amp;</span></a></code></pre></div>
<p>しかし<span class="ascii">Haskell</span>標準では，型を定義する場合そのようなことはできません．これを可能にするのが，<code>TypeOperators</code>拡張です．この拡張の有効下では，</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="kw">type</span> a <span class="fu">+</span> b <span class="fu">=</span> <span class="dt">Either</span> a b</a>
<a class="sourceLine" id="cb42-2" data-line-number="2"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">+</span></a></code></pre></div>
<p>ということが可能になります．ただし，このように定義した型演算子は，同じ名前の値としての演算子があった場合区別ができません．このため，モジュールのエクスポートリストを書く際，型演算子か値レベルの演算子かの区別が付かなくなった場合，値レベルの方が優先されます．この時，型演算子を明示したい場合，<code>type</code>を付けます<a href="#fn12" class="footnote-ref" id="fnref12"><sup>12</sup></a>．</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" data-line-number="1"><span class="ot">{-# LANGUAGE TypeOperators #-}</span></a>
<a class="sourceLine" id="cb43-2" data-line-number="2"></a>
<a class="sourceLine" id="cb43-3" data-line-number="3"><span class="kw">module</span> <span class="dt">A</span></a>
<a class="sourceLine" id="cb43-4" data-line-number="4">  ( <span class="kw">type</span> (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb43-5" data-line-number="5">  ) <span class="kw">where</span></a>
<a class="sourceLine" id="cb43-6" data-line-number="6"></a>
<a class="sourceLine" id="cb43-7" data-line-number="7"><span class="kw">type</span> a <span class="fu">+</span> b <span class="fu">=</span> <span class="dt">Either</span> a b</a></code></pre></div>
<h3 id="型クラスを拡張する">型クラスを拡張する</h3>
<p>この節では，以下の<span class="ascii">4</span>つの拡張を紹介します．</p>
<ul>
<li><code>MultiParamTypeClasses</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-MultiParamTypeClasses">ユーザーガイド <span class="ascii">- MultiParamTypeClasses</span>拡張</a></li>
<li><code>FlexibleContexts</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-FlexibleContexts">ユーザーガイド <span class="ascii">- FlexibleContexts</span>拡張</a></li>
<li><code>FlexibleInstances</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-FlexibleInstances">ユーザーガイド <span class="ascii">- FlexibleInstances</span>拡張</a></li>
<li><code>InstanceSigs</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-InstanceSigs">ユーザーガイド <span class="ascii">- InstanceSigs</span>拡張</a></li>
</ul>
<p><span class="ascii">Haskell</span>の型クラスは非常に強力な機構です．しかしながら，<span class="ascii">Haskell</span>標準の型クラスの構文は非常に制約がきつく，これらを緩和したいと思うことがよくあります．このため，<span class="ascii">GHC</span>では制約を緩和する拡張をいくつか提供しています．それが，<code>MultiParamTypeClasses</code>，<code>FlexibleContexts</code>，<code>FlexibleInstances</code>，<code>InstanceSigs</code>の<span class="ascii">4</span>つの拡張です．</p>
<p><span class="ascii">Haskell</span>標準では，クラスは<span class="ascii">1</span>つの変数しか持てません．なので，次のような型クラスは作れません．</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" data-line-number="1"><span class="kw">class</span> <span class="dt">C</span> a b</a></code></pre></div>
<p>これは非常に不便な制約なため，複数のパラメータを使うような型クラスを許容する拡張が<code>MultiParamTypeClasses</code>拡張です．この拡張により，上のコードが許容されるようになる他，以下のように変数が全くない型クラスも宣言することができるようになります．</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Nullary</span></a></code></pre></div>
<p>また，<span class="ascii">Haskell</span>標準では，メソッドにおいてクラスの型変数に型制約をかけるということも許容されていませんが，<code>MultiParamTypeClasses</code>拡張ではこれも可能にします<a href="#fn13" class="footnote-ref" id="fnref13"><sup>13</sup></a>．これによって以下のようなクラス定義も書けるようになります．</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Setable</span> s a <span class="kw">where</span></a>
<a class="sourceLine" id="cb46-2" data-line-number="2"><span class="ot">  elem ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> s a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a></code></pre></div>
<p><span class="ascii">Haskell</span>標準では，型制約の解決を安全に，しかも単純にするために，<a href="https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-660004.1.3">型注釈における制約の書き方</a>や<a href="https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-760004.3.1">クラス定義，インスタンス定義の際の制約の書き方</a>を大きく制限しています．しかし，より複雑な型制約を書きたい時が往々にしてあります．そこで，この制限を緩め，クラス階層が非循環である場合には許容するようにする拡張が，<code>FlexibleContexts</code>拡張です．この拡張下では，</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb47-1" data-line-number="1"><span class="co">-- valid</span></a>
<a class="sourceLine" id="cb47-2" data-line-number="2"><span class="kw">class</span> (<span class="dt">Monad</span> m, <span class="dt">Monad</span> (t m)) <span class="ot">=&gt;</span> <span class="dt">Transform</span> t m <span class="kw">where</span></a>
<a class="sourceLine" id="cb47-3" data-line-number="3"><span class="ot">  lift ::</span> m a <span class="ot">-&gt;</span> (t m) a</a>
<a class="sourceLine" id="cb47-4" data-line-number="4"></a>
<a class="sourceLine" id="cb47-5" data-line-number="5"><span class="co">-- valid</span></a>
<a class="sourceLine" id="cb47-6" data-line-number="6"><span class="ot">f ::</span> <span class="dt">Functor</span> <span class="dt">Maybe</span> <span class="ot">=&gt;</span> ()</a>
<a class="sourceLine" id="cb47-7" data-line-number="7">f <span class="fu">=</span> ()</a>
<a class="sourceLine" id="cb47-8" data-line-number="8"></a>
<a class="sourceLine" id="cb47-9" data-line-number="9"><span class="co">-- invalid</span></a>
<a class="sourceLine" id="cb47-10" data-line-number="10"><span class="kw">class</span> <span class="dt">A</span> a <span class="ot">=&gt;</span> <span class="dt">B</span> a</a>
<a class="sourceLine" id="cb47-11" data-line-number="11"><span class="kw">class</span> <span class="dt">B</span> a <span class="ot">=&gt;</span> <span class="dt">A</span> a</a></code></pre></div>
<p>となります．</p>
<p><code>FlexibleInstances</code>拡張も<code>FlexibleContexts</code>拡張と同じく，<span class="ascii">Haskell</span>標準での<a href="https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-770004.3.2">型クラスインスタンスの書き方</a>の制限を，<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#instance-termination">停止制限</a>を守る場合に許容するというように緩和する拡張です．停止制限は簡単に言ってしまえば，インスタンス宣言において，型制約がインスタンスより小さく<a href="#fn14" class="footnote-ref" id="fnref14"><sup>14</sup></a>，型関数を使っていないというものです<a href="#fn15" class="footnote-ref" id="fnref15"><sup>15</sup></a>．この拡張下では，</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb48-1" data-line-number="1"><span class="co">-- valid</span></a>
<a class="sourceLine" id="cb48-2" data-line-number="2"><span class="kw">instance</span> <span class="dt">C1</span> (<span class="dt">Maybe</span> [a])</a>
<a class="sourceLine" id="cb48-3" data-line-number="3"></a>
<a class="sourceLine" id="cb48-4" data-line-number="4"><span class="co">-- valid</span></a>
<a class="sourceLine" id="cb48-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">C2</span> a a <span class="ot">=&gt;</span> <span class="dt">C2</span> [a] [a]</a>
<a class="sourceLine" id="cb48-6" data-line-number="6"></a>
<a class="sourceLine" id="cb48-7" data-line-number="7"><span class="co">-- valid</span></a>
<a class="sourceLine" id="cb48-8" data-line-number="8"><span class="kw">instance</span> (<span class="dt">Eq</span> a, <span class="dt">Show</span> b) <span class="ot">=&gt;</span> <span class="dt">C3</span> a b</a>
<a class="sourceLine" id="cb48-9" data-line-number="9"></a>
<a class="sourceLine" id="cb48-10" data-line-number="10"><span class="co">-- valid</span></a>
<a class="sourceLine" id="cb48-11" data-line-number="11"><span class="kw">instance</span> (<span class="dt">Show</span> a, <span class="dt">Show</span> (s a)) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">S</span> s a)</a>
<a class="sourceLine" id="cb48-12" data-line-number="12"></a>
<a class="sourceLine" id="cb48-13" data-line-number="13"><span class="co">-- invalid</span></a>
<a class="sourceLine" id="cb48-14" data-line-number="14"><span class="kw">instance</span> <span class="dt">C4</span> a <span class="ot">=&gt;</span> <span class="dt">C4</span> a</a>
<a class="sourceLine" id="cb48-15" data-line-number="15"></a>
<a class="sourceLine" id="cb48-16" data-line-number="16"><span class="co">-- invalid</span></a>
<a class="sourceLine" id="cb48-17" data-line-number="17"><span class="kw">instance</span> <span class="dt">C2</span> a a <span class="ot">=&gt;</span> <span class="dt">C1</span> [a]</a>
<a class="sourceLine" id="cb48-18" data-line-number="18"></a>
<a class="sourceLine" id="cb48-19" data-line-number="19"><span class="co">-- invalid</span></a>
<a class="sourceLine" id="cb48-20" data-line-number="20"><span class="kw">instance</span> <span class="dt">Functor</span> [] <span class="ot">=&gt;</span> <span class="dt">C1</span> a</a></code></pre></div>
<p>となります．また，この拡張下では，型シノニムをインスタンスにすることもできます<a href="#fn16" class="footnote-ref" id="fnref16"><sup>16</sup></a>．</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb49-1" data-line-number="1"><span class="kw">type</span> <span class="dt">List</span> a <span class="fu">=</span> [a]</a>
<a class="sourceLine" id="cb49-2" data-line-number="2"></a>
<a class="sourceLine" id="cb49-3" data-line-number="3"><span class="co">-- Instead of `instance C [a]`</span></a>
<a class="sourceLine" id="cb49-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">C</span> (<span class="dt">List</span> a)</a></code></pre></div>
<p>ただし，型シノニムを使う場合そのシノニムの引数は全て適用しなければならないことに注意が必要です．</p>
<p><span class="ascii">Haskell</span>標準では，型クラスインスタンスの定義時，そのメソッドの型注釈は書けないようになっています．しかし，複雑な型クラスインスタンスを書く際，メソッドの型注釈を書きたい場合があります<a href="#fn17" class="footnote-ref" id="fnref17"><sup>17</sup></a>．これを可能にするのが<code>InstanceSigs</code>拡張です．<code>InstanceSigs</code>拡張の元では，以下のようなインスタンス宣言が書けます．</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb50-1" data-line-number="1"><span class="kw">data</span> <span class="dt">A</span> <span class="fu">=</span> <span class="dt">A</span></a>
<a class="sourceLine" id="cb50-2" data-line-number="2"></a>
<a class="sourceLine" id="cb50-3" data-line-number="3"><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">A</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb50-4" data-line-number="4"><span class="ot">  (==) ::</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb50-5" data-line-number="5">  <span class="dt">A</span> <span class="fu">==</span> <span class="dt">A</span> <span class="fu">=</span> <span class="dt">True</span></a></code></pre></div>
<h3 id="型ワイルドカードをより柔軟に扱う">型ワイルドカードをより柔軟に扱う</h3>
<p>この節では，以下の拡張を紹介します．</p>
<ul>
<li><code>NamedWildCards</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-NamedWildCards">ユーザーガイド <span class="ascii">- NamedWildCards</span>拡張</a></li>
</ul>
<p><span class="ascii">GHC</span>には型ワイルドカードという機能があります．この機能は，<code>_</code>と型シグネチャ上で書いておくと，そこの部分の型を推論してエラーメッセージとして表示してくれる機能です．この機能は，以下のように部分的に記述したり複数指定したりすることも可能です．</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb51-1" data-line-number="1"><span class="co">-- Inferred type: (a, b) -&gt; (a, Maybe a1)</span></a>
<a class="sourceLine" id="cb51-2" data-line-number="2"><span class="ot">ignoreSecond ::</span> _ <span class="ot">-&gt;</span> _</a>
<a class="sourceLine" id="cb51-3" data-line-number="3">ignoreSecond (x, _) <span class="fu">=</span> (x, <span class="dt">Nothing</span>)</a></code></pre></div>
<p>これを活用すれば，複雑な型をある程度ヒントを与えた状態で推論してもらい，型を追記するプログラミングスタイルや，<span class="ascii">GHC</span>が実際に型をどう推論するかを見るための補助に応用できます．しかし，例えば<code>ignoreSecond</code>が引数と返り値で型が同じであるという情報が分かっていた場合に，これをヒントとして伝えたい場合がありますが，型ワイルドカードでそれを伝える方法はありません．これを解決するのが<code>NamedWildCards</code>拡張です．この拡張を使うと，以下のようなプログラムに対しても，接頭に<code>_</code>が付いている型をワイルドカードとみなして，エラーメッセージで型の推論結果を表示してくれるようになります．</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb52-1" data-line-number="1"><span class="co">-- Inferred type: (a, Maybe a1) -&gt; (a, Maybe a1)</span></a>
<a class="sourceLine" id="cb52-2" data-line-number="2"><span class="ot">ignoreSecond ::</span> _a <span class="ot">-&gt;</span> _a</a>
<a class="sourceLine" id="cb52-3" data-line-number="3">ignoreSecond (x, _) <span class="fu">=</span> (x, <span class="dt">Nothing</span>)</a></code></pre></div>
<h3 id="新たな表記法の導入">新たな表記法の導入</h3>
<p>この節では，以下の<span class="ascii">2</span>つの拡張を紹介します．</p>
<ul>
<li><code>Arrows</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-Arrows">ユーザーガイド <span class="ascii">- Arrows</span>拡張</a></li>
<li><code>RecursiveDo</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-RecursiveDo">ユーザーガイド <span class="ascii">- RecursiveDo</span>拡張</a></li>
</ul>
<p><span class="ascii">Haskell</span>では，モナドを扱いやすくするための，<span class="ascii">do</span>構文という専用の構文が用意されています．この構文は<span class="ascii">Haskell</span>プログラミングにおいて広く利用されています．<span class="ascii">GHC</span>では，これに加え<code>Arrow</code>と<code>MonadFix</code>というクラスに対しての専用の構文も提供しています．これは<span class="ascii">GHC</span>拡張で実装されており，それぞれ<code>Arrows</code>拡張，<code>RecursiveDo</code>拡張を有効にすることで使用可能です．</p>
<p><code>Arrow</code>クラスは，モナドの一般化として導入されました<a href="#fn18" class="footnote-ref" id="fnref18"><sup>18</sup></a>．このクラスには，モナドの<code>do</code>構文と同様に，クラスメソッドだけの式に脱糖できる構文が考案され，<span class="ascii">GHC</span>拡張として実装されています．それが<code>Arrows</code>拡張で利用できる<code>proc</code>構文です．</p>
<p>例えば，<code>Arrow</code>クラスのメソッドを使った次のような関数は，</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb53-1" data-line-number="1"><span class="ot">doSomething ::</span> <span class="dt">Arrow</span> a <span class="ot">=&gt;</span> a <span class="dt">Int</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="dt">Int</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="dt">Int</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="dt">Int</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb53-2" data-line-number="2">doSomething f g h</a>
<a class="sourceLine" id="cb53-3" data-line-number="3">  <span class="fu">=</span>   arr (\x <span class="ot">-&gt;</span> (x <span class="fu">+</span> <span class="dv">1</span>, x))</a>
<a class="sourceLine" id="cb53-4" data-line-number="4">  <span class="fu">&gt;&gt;&gt;</span> first (f <span class="fu">&gt;&gt;&gt;</span> (arr (\y <span class="ot">-&gt;</span> <span class="dv">2</span> <span class="fu">*</span> y) <span class="fu">&gt;&gt;&gt;</span> g) <span class="fu">&amp;&amp;&amp;</span> returnA <span class="fu">&gt;&gt;&gt;</span> arr snd)</a>
<a class="sourceLine" id="cb53-5" data-line-number="5">  <span class="fu">&gt;&gt;&gt;</span> arr (\(y, x) <span class="ot">-&gt;</span> (x, x <span class="fu">+</span> y))</a>
<a class="sourceLine" id="cb53-6" data-line-number="6">  <span class="fu">&gt;&gt;&gt;</span> arr (\(x, z) <span class="ot">-&gt;</span> (z, x <span class="fu">*</span> z))</a>
<a class="sourceLine" id="cb53-7" data-line-number="7">  <span class="fu">&gt;&gt;&gt;</span> second h</a>
<a class="sourceLine" id="cb53-8" data-line-number="8">  <span class="fu">&gt;&gt;&gt;</span> arr (\(z, t) <span class="ot">-&gt;</span> t <span class="fu">+</span> z)</a></code></pre></div>
<p><code>proc</code>構文を使うと，</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb54-1" data-line-number="1"><span class="ot">doSomething ::</span> <span class="dt">Arrow</span> a <span class="ot">=&gt;</span> a <span class="dt">Int</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="dt">Int</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="dt">Int</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="dt">Int</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb54-2" data-line-number="2">doSomething f g h <span class="fu">=</span> proc x <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb54-3" data-line-number="3">  y <span class="ot">&lt;-</span> f <span class="fu">-&lt;</span> x <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb54-4" data-line-number="4">  g <span class="fu">-&lt;</span> <span class="dv">2</span> <span class="fu">*</span> y</a>
<a class="sourceLine" id="cb54-5" data-line-number="5">  <span class="kw">let</span> z <span class="fu">=</span> x <span class="fu">+</span> y</a>
<a class="sourceLine" id="cb54-6" data-line-number="6">  t <span class="ot">&lt;-</span> h <span class="fu">-&lt;</span> x <span class="fu">*</span> z</a>
<a class="sourceLine" id="cb54-7" data-line-number="7">  returnA <span class="fu">-&lt;</span> t <span class="fu">+</span> z</a></code></pre></div>
<p>というように書けます<a href="#fn19" class="footnote-ref" id="fnref19"><sup>19</sup></a>．また，<code>ArrowLoop</code>クラスの<code>loop</code>メソッドに変換される，<code>rec</code>構文も搭載されており次のようなフィードバック制御を相互再帰で行うプログラムを書くことができます．</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb55-1" data-line-number="1"><span class="ot">counter ::</span> <span class="dt">ArrowLoop</span> a <span class="ot">=&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="dt">Int</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> a <span class="dt">Bool</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb55-2" data-line-number="2">counter delay <span class="fu">=</span> proc reset <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb55-3" data-line-number="3">  rec output <span class="ot">&lt;-</span> returnA <span class="fu">-&lt;</span> <span class="kw">if</span> reset <span class="kw">then</span> <span class="dv">0</span> <span class="kw">else</span> next</a>
<a class="sourceLine" id="cb55-4" data-line-number="4">      next <span class="ot">&lt;-</span> delay <span class="dv">0</span> <span class="fu">-&lt;</span> output <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb55-5" data-line-number="5">  returnA <span class="fu">-&lt;</span> output</a></code></pre></div>
<p><code>proc</code>構文については<a href="https://www.haskell.org/arrows/syntax.html"><span class="ascii">Arrow syntax</span></a>のページにまとめられている他，<a href="http://www.staff.city.ac.uk/~ross/papers/notation.html">提案論文</a>にて変換規則を確認することが可能です．</p>
<p>さて，もう<span class="ascii">1</span>つの<code>MonadFix</code>クラスは，モナドを拡張し，再帰的なバインディングを許すようなものです．このクラスを元に，<code>RecursiveDo</code>拡張は<span class="ascii">do</span>構文をさらに拡張します．具体的には，次のように使用できる<code>rec</code>という構文を新たに導入します．</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb56-1" data-line-number="1"><span class="ot">doSomething ::</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb56-2" data-line-number="2">doSomething <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb56-3" data-line-number="3">  rec x <span class="ot">&lt;-</span> [y, y <span class="fu">*</span> <span class="dv">10</span>]</a>
<a class="sourceLine" id="cb56-4" data-line-number="4">      y <span class="ot">&lt;-</span> [<span class="dv">1</span>, <span class="dv">2</span>]</a>
<a class="sourceLine" id="cb56-5" data-line-number="5">  pure <span class="fu">$</span> x <span class="fu">+</span> y</a></code></pre></div>
<p>この関数は，次のように<code>MonadFix</code>クラスのメソッド<code>mfix</code>を使った関数と同等です．</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb57-1" data-line-number="1"><span class="ot">doSomething ::</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb57-2" data-line-number="2">doSomething <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb57-3" data-line-number="3">  (x, y) <span class="ot">&lt;-</span> mfix <span class="fu">$</span> \<span class="fu">~</span>(x, y) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb57-4" data-line-number="4">    x <span class="ot">&lt;-</span> [y, y <span class="fu">*</span> <span class="dv">10</span>]</a>
<a class="sourceLine" id="cb57-5" data-line-number="5">    y <span class="ot">&lt;-</span> [<span class="dv">1</span>, <span class="dv">2</span>]</a>
<a class="sourceLine" id="cb57-6" data-line-number="6">    pure (x, y)</a>
<a class="sourceLine" id="cb57-7" data-line-number="7">  pure <span class="fu">$</span> x <span class="fu">+</span> y</a></code></pre></div>
<p>また，<code>rec</code>を省略して書ける<code>mdo</code>という構文も提供されます．</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb58-1" data-line-number="1"><span class="ot">doSomething ::</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb58-2" data-line-number="2">doSomething <span class="fu">=</span> mdo</a>
<a class="sourceLine" id="cb58-3" data-line-number="3">  x <span class="ot">&lt;-</span> [y, y <span class="fu">*</span> <span class="dv">10</span>]</a>
<a class="sourceLine" id="cb58-4" data-line-number="4">  y <span class="ot">&lt;-</span> [<span class="dv">1</span>, <span class="dv">2</span>]</a>
<a class="sourceLine" id="cb58-5" data-line-number="5">  pure <span class="fu">$</span> x <span class="fu">+</span> y</a></code></pre></div>
<p><code>mdo</code>構文は，それぞれの文と変数の依存関係を解析し，自動的に<code>rec</code>ブロックに分けてくれます．後は，その分けられた<code>rec</code>文を<code>mfix</code>に翻訳することで，通常の<code>do</code>構文に翻訳することができます．例えば，</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb59-1" data-line-number="1">mdo</a>
<a class="sourceLine" id="cb59-2" data-line-number="2">  a <span class="ot">&lt;-</span> m</a>
<a class="sourceLine" id="cb59-3" data-line-number="3">  b <span class="ot">&lt;-</span> f a c</a>
<a class="sourceLine" id="cb59-4" data-line-number="4">  c <span class="ot">&lt;-</span> f b a</a>
<a class="sourceLine" id="cb59-5" data-line-number="5">  z <span class="ot">&lt;-</span> h a b</a>
<a class="sourceLine" id="cb59-6" data-line-number="6">  d <span class="ot">&lt;-</span> g d e</a>
<a class="sourceLine" id="cb59-7" data-line-number="7">  e <span class="ot">&lt;-</span> g a z</a>
<a class="sourceLine" id="cb59-8" data-line-number="8">  pure c</a></code></pre></div>
<p>という式は，</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb60-1" data-line-number="1"><span class="kw">do</span></a>
<a class="sourceLine" id="cb60-2" data-line-number="2">  a <span class="ot">&lt;-</span> m</a>
<a class="sourceLine" id="cb60-3" data-line-number="3">  (b, c) <span class="ot">&lt;-</span> mfix <span class="fu">$</span> \<span class="fu">~</span>(b, c) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb60-4" data-line-number="4">    b <span class="ot">&lt;-</span> f a c</a>
<a class="sourceLine" id="cb60-5" data-line-number="5">    c <span class="ot">&lt;-</span> f b a</a>
<a class="sourceLine" id="cb60-6" data-line-number="6">    pure (b, c)</a>
<a class="sourceLine" id="cb60-7" data-line-number="7">  z <span class="ot">&lt;-</span> h a b</a>
<a class="sourceLine" id="cb60-8" data-line-number="8">  (d, e) <span class="ot">&lt;-</span> mfix <span class="fu">$</span> \<span class="fu">~</span>(d, e) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb60-9" data-line-number="9">    d <span class="ot">&lt;-</span> g d e</a>
<a class="sourceLine" id="cb60-10" data-line-number="10">    e <span class="ot">&lt;-</span> g a z</a>
<a class="sourceLine" id="cb60-11" data-line-number="11">    pure (d, e)</a>
<a class="sourceLine" id="cb60-12" data-line-number="12">  pure c</a></code></pre></div>
<p>という式に翻訳されます．<code>mdo</code>と<code>rec</code>の変換規則は，<a href="https://dl.acm.org/citation.cfm?doid=581690.581693">提案論文</a>にて確認が可能です．</p>
<h1 id="次回予告">次回予告</h1>
<p>今回は，<span class="ascii">GHC</span>拡張の簡単な紹介と使い方について，それから個人的にデフォルトで有効化している，<span class="ascii">Prelude</span>の暗黙的なインポートを抑制する拡張，新たな構文を導入する拡張を紹介しました．</p>
<p>次回は，他のデフォルトで有効化している拡張について紹介したいと思います．</p>
<h1 id="参考文献">参考文献</h1>
<ul>
<li><a href="https://downloads.haskell.org/~ghc/8.4.2/docs/html/users_guide/"><span class="ascii">GHC 8.4.2 User</span>’<span class="ascii">s Guide</span></a>
<ul>
<li><a href="https://downloads.haskell.org/~ghc/8.4.2/docs/html/users_guide/glasgow_exts.html#options-language"><span class="ascii">GHC 8.4.2 User</span>’<span class="ascii">s Guide - 9. GHC Language Features</span></a></li>
<li><a href="https://downloads.haskell.org/~ghc/8.4.2/docs/html/users_guide/ffi-chap.html"><span class="ascii">GHC 8.4.2 User</span>’<span class="ascii">s Guide - 10. Foreign function interface (FFI)</span></a></li>
</ul></li>
<li><a href="http://dev.stephendiehl.com/hask/#language-extensions"><span class="ascii">What I Wish I Knew When Learning Haskell - Language Extensions</span></a></li>
<li><a href="https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/language-standards"><span class="ascii">Guide to GHC Extensions - Language Standards</span></a></li>
<li><a href="https://www.haskell.org/onlinereport/haskell2010/"><span class="ascii">Haskell 2010 Language Report</span></a></li>
<li><a href="https://www.haskell.org/cabal/users-guide/cabal-projectindex.html"><span class="ascii">Cabal reference</span></a></li>
</ul>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>この記事では特に断らない限り，<a href="https://www.haskell.org/onlinereport/haskell2010/"><span class="ascii">Haskell2010</span></a>を「<span class="ascii">Haskell</span>標準」または「<span class="ascii">Haskell</span>」と呼称します．<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>このオプションは，拡張を無効にする<span class="ascii">GHC</span>拡張<span class="ascii">(</span>例えば，<code>NoImplicitPrelude</code>拡張など<span class="ascii">)</span>も含めて表示します．実際には<code>No</code>が付いている拡張を抜くと，提供されている数は<span class="ascii">120</span>個になります．<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p><span class="ascii">Haskell</span>標準では，ある拡張を無効にするといった機能は提供されていません．このため，<span class="ascii">GHC</span>では無効にする機能を<span class="ascii">1</span>つの拡張として，<span class="ascii">Haskell</span>標準に則った形で提供しています．<a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p>有効にする拡張と無効にする拡張を両方指定した場合，<span class="ascii">GHC</span>は指定された順番に沿って最後に指定された方を拡張として採用します．<a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p><span class="ascii">Haskell2010</span>標準では，<code>Haskell2010</code>というプラグマをサポートすること，また<span class="ascii">Haskell98</span>から新たに<span class="ascii">Haskell2010</span>までに取り込まれた機能を切り離した<code>PatternGuards</code><span class="ascii">/</span><code>NoNPlusKPatterns</code><span class="ascii">/</span><code>RelaxedPolyRec</code><span class="ascii">/</span><code>EmptyDataDecls</code><span class="ascii">/</span><code>EmptyDataDecls</code>という拡張をそれぞれサポートすることが望ましいと規定されています．<span class="ascii">GHC</span>も<code>Haskell2010</code>という拡張を指定できるようになっており，ここにあるほとんどはこの拡張を有効にした場合にも有効になります．<a href="#fnref5" class="footnote-back">↩</a></p></li>
<li id="fn6"><p>デフォルトで有効になる拡張のほとんどは，<span class="ascii">Haskell 2010</span>を元にしたものです．ただし全てがそうというわけではありません．<code>NondecreasingIndentation</code>は<span class="ascii">Haskell</span>標準にはない機能です．また<span class="ascii">GHC</span>は<span class="ascii">Haskell 2010</span>で規定されている仕様を全てデフォルトで取り込んでいる訳でもありません．特に<span class="ascii">Haskell</span>標準ではデータ型の宣言に型制約を書くことができますが，<span class="ascii">GHC</span>ではデフォルトではできません．これを有効にする場合，<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-DatatypeContexts"><code>DatatypeContexts</code>拡張</a>を有効にする必要があります．<a href="#fnref6" class="footnote-back">↩</a></p></li>
<li id="fn7"><p><span class="ascii">GHC</span>の内部では<code>RelaxedPolyRec</code>という拡張も一緒に有効になります．しかし，現在この拡張は実装上の問題で<span class="ascii">GHC</span>上で無効にすることができないため，ドキュメント上からも削除されています．この記事でも<span class="ascii">GHC</span>の方針に従って，この拡張は特に扱いませんのでご留意ください．<a href="#fnref7" class="footnote-back">↩</a></p></li>
<li id="fn8"><p>現在，<span class="ascii">Prelude</span>の代替を目指す，<a href="https://hackage.haskell.org/package/rio"><span class="ascii">rio</span></a>というパッケージが作成されています．このパッケージは現在まだ<span class="ascii">prerelease</span>の段階で，<a href="https://github.com/commercialhaskell/stack"><span class="ascii">stack</span></a>において実験的に使用されています．様々な最新の<span class="ascii">Haskell</span>プログラミングの知見を取り入れており，標準の<span class="ascii">Prelude</span>に大きく拡張を施しているため，<span class="ascii">Haskell</span>で大規模な開発を行う場合注目する価値があるかもしれません．<a href="#fnref8" class="footnote-back">↩</a></p></li>
<li id="fn9"><p><span class="ascii">GHC 8.2.2</span>の段階では，パターンシノニムはコンパイラがクラッシュするなどの非常に多くのバグを抱えていました．私は<span class="ascii">8.4.2</span>をまだあまり試していませんが，パターンシノニムの仕様が非常に複雑なため，<span class="ascii">8.4.2</span>でもまだバグを多く抱えている可能性があります．パターンシノニムをプロダクトで多用する場合，その点に注意した方が良いでしょう．<a href="#fnref9" class="footnote-back">↩</a></p></li>
<li id="fn10"><p><span class="ascii">GHC</span>のレコードシステムの拡張は非常に強力ですが，その反面システムが非常に複雑になっています．このため，<span class="ascii">8.2.2</span>の段階でコンパイラがクラッシュするなど非常に多くのバグを抱えていました．レコードシステムの仕様の改良は現在も進んでいますが，<span class="ascii">8.4.2</span>でもまだバグを多く抱えている可能性があります．これらの拡張をプロダクトで多用する場合，その点に注意した方が良いでしょう．特に，<span class="ascii">GHC 8.0</span>以降に導入された拡張には注意が必要です．<a href="#fnref10" class="footnote-back">↩</a></p></li>
<li id="fn11"><p><code>OverloadedLabels</code>拡張はかなり最近入った拡張で，多数の<span class="ascii">GHC</span>拡張，特に強力な型システムを前提にして書かれています．このため，選択関数の実装にもかなり多くの<span class="ascii">GHC</span>拡張を使用しています．ここでは，特に解説しないのでそういうものだと思っておいてください．なお，このプログラムはプロダクションで使うことを前提にしていませんので，そこはご注意ください．<a href="#fnref11" class="footnote-back">↩</a></p></li>
<li id="fn12"><p>この機能は型演算子を定義しないで再エクスポートなどをする場合にも使用されるため，<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-ExplicitNamespaces"><code>ExplicitNamespaces</code>拡張</a>として切り離されています．<a href="#fnref12" class="footnote-back">↩</a></p></li>
<li id="fn13"><p>この機能は<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-ConstrainedClassMethods"><code>ConstrainedClassMethods</code>拡張</a>として切り離されており，<code>MultiParamTypeClasses</code>拡張を有効にすると一緒に有効になります．<a href="#fnref13" class="footnote-back">↩</a></p></li>
<li id="fn14"><p>型制約が小さいとは，型変数とコンストラクタと変数の組の出現が少ないということです．<a href="#fnref14" class="footnote-back">↩</a></p></li>
<li id="fn15"><p>より正確には，<code>FunctionalDependencies</code>に対する制限もありますが，ここでは割愛します．<a href="#fnref15" class="footnote-back">↩</a></p></li>
<li id="fn16"><p>この拡張は，<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-TypeSynonymInstances"><code>TypeSynonymInstances</code>拡張</a>として切り離されており，<code>FlexibleInstances</code>拡張を有効にすると一緒に有効になります．<a href="#fnref16" class="footnote-back">↩</a></p></li>
<li id="fn17"><p>特に<code>ScopedTypeVariables</code>拡張を指定する場合，型注釈は必要です．<a href="#fnref17" class="footnote-back">↩</a></p></li>
<li id="fn18"><p><a href="https://dl.acm.org/citation.cfm?id=347246">“<span class="ascii">Generalising Monads to Arrows</span>”</a><span class="ascii">, John Hughes, in Science of Computer Programming 37, pp. 67</span>–<span class="ascii">111, May 2000</span><a href="#fnref18" class="footnote-back">↩</a></p></li>
<li id="fn19"><p>一見，この構文は単純な脱糖を行うと脱糖後のプログラムが非常に冗長になるように思えます．しかし，<code>Arrow</code>クラスのメソッドに設けられている書き換え規則によって，最終的に妥当な大きさまで脱糖後のプログラムが小さくなってくれます．<a href="#fnref19" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2018/windows-gotchas-en.html" lang="en">Errors and the workarounds frequently encountered when dealing with Haskell on Windows</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2018/main-tester.html" style="margin-left: auto;" lang="ja">CLIアプリのE2Eテストを行うためのライブラリー main-testerをリリースしました</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>CLIアプリのE2Eテストを行うためのライブラリー main-testerをリリースしました</title>
    <link href="https://haskell.jp/blog/posts/2018/main-tester.html" />
    <id>https://haskell.jp/blog/posts/2018/main-tester.html</id>
    <published>2018-04-09T00:00:00Z</published>
    <updated>2018-04-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>こんにちは。みなさん、テストは書いてますか？<br />
「<a href="http://syocy.hatenablog.com/entry/haskell-library-2016#%E3%83%86%E3%82%B9%E3%83%88"><span class="ascii">Haskell</span>ライブラリ所感<span class="ascii">2016</span></a>」という記事でも紹介されているとおり、<span class="ascii">Haskell</span>にも様々なテスト用ライブラリーがあります。<br />
今回は、「<span class="ascii">Haskell</span>ライブラリ所感<span class="ascii">2016</span>」でも紹介されている<a href="https://hackage.haskell.org/package/silently"><span class="ascii">silently</span></a>というパッケージにインスパイアされた、新しいテスト用ライブラリーを作りました。<br />
タイトルにも書きましたが<a href="https://hackage.haskell.org/package/main-tester"><span class="ascii">main-tester</span></a>といいます。</p>
<h1 id="main-testerができること"><span class="ascii">main-tester</span>ができること</h1>
<p><span class="ascii">main-tester</span>は名前の通り、<code>main</code>関数のテストをサポートするライブラリーです。<br />
<span class="ascii">Haskell</span>製のプログラムを起動すると最初に実行される、あの<code>main</code>関数です。</p>
<p><code>main</code>関数は<code>IO ()</code>という型であるとおり、原則として必ず入出力を伴うので、自動テストがしにくい関数です。<br />
一般的なベストプラクティスとしては、できるだけ<code>IO</code>でない、純粋な関数を中心にテストを書いていくのが普通でしょう。<br />
それでも敢えて<code>main</code>関数の自動テストを書くのには、以下のメリットがあります。</p>
<ol type="1">
<li><code>main</code>関数をテストすると言うことは、作っているコマンドの、ユーザーの要求に最も近いレベルのテスト、<span class="ascii">E2E</span>テスト（<span class="ascii">end-to-end</span> テスト）をすることができる。</li>
<li><code>main</code>関数（や、その他の<code>IO</code>を伴う関数）に対するテストは、データベースやファイルシステムなど、外部のソフトウェアとの「組み合わせ」で起こるバグを検出できる。
<ul>
<li>経験上、特に単純なアプリケーションでは、そうした外部のソフトウェアに対する「誤解」が原因となったバグが比較的多いように感じています。</li>
</ul></li>
<li>私の個人的な都合ですが、趣味では小さなアプリケーションを書くことが多いので、そうした<span class="ascii">E2E</span>テストの方が効果的だったりする。</li>
</ol>
<p>このように、<code>main</code>関数をはじめとする、<code>IO</code>な関数に対して敢えて自動テストを書くことには、様々なメリットがあります。<br />
<code>main-tester</code>はそうした<code>IO</code>な関数をテストする際に伴う、<span class="ascii">2</span>つの問題を解決しました。</p>
<ol type="1">
<li>標準出力・標準エラー出力に出力した文字列がテストしにくい
<ul>
<li>➡️ <code>captureProcessResult</code>という関数で、標準出力・標準エラー出力に出力した文字列をそれぞれ<code>ByteString</code>として取得することができます。</li>
</ul></li>
<li>標準入力から文字列を読み出そうとすると、テストの実行が停止してしまう。
<ul>
<li>➡️ <code>withStdin</code>という関数で、標準入力に与えたい文字列を<code>ByteString</code>として与えることができます。</li>
</ul></li>
</ol>
<p>ここに書いたことは、ビルドした実行ファイルを子プロセスとして呼び出すことによってもできます。<br />
入出力の順番など、標準出力や標準エラー出力のより細かい挙動をテストするにはその方がいいでしょう<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>。<br />
しかし、テストのために<code>PATH</code>を分離させる必要があったり、そのために<a href="https://github.com/commercialhaskell/stack/issues/2885"><code>stack exec</code>を使ったらめっちゃ遅い</a>という問題があったり、そもそも子プロセス呼び出しはそれだけでオーバーヘッドがあったりと、様々な問題があります。<br />
物事をよりシンプルにするには、<code>main</code>関数を直接呼び出した方がよいでしょう。<br />
<span class="ascii">main-tester</span>は、<span class="ascii">CLI</span>アプリケーションの<span class="ascii">E2E</span>テストにおける、そうした子プロセスの呼び出しの問題と、より大きな関数をテストしたいというニーズに応えるためのライブラリーなのです。</p>
<h1 id="ほかのライブラリーとの違い">ほかのライブラリーとの違い</h1>
<p>「<span class="ascii">silently</span>というパッケージにインスパイアされた」と冒頭で申しましたとおり、前節で紹介した機能は、実はすでにほかのライブラリーに似たものがあります。<br />
<span class="ascii">silently</span>に加え、<a href="https://hackage.haskell.org/package/imperative-edsl-0.7.1/docs/System-IO-Fake.html"><span class="ascii">imperative-edsl</span>というパッケージに含まれる、<code>System.IO.Fake</code>というモジュール</a>です<small>（ほかにもあったらすみません！🙇🙇🙇）</small>。<br />
これらと<span class="ascii">main-tester</span>との違いは何でしょう？</p>
<p>第一に、先ほども触れましたが、<span class="ascii">main-tester</span>の<code>captureProcessResult</code>関数や<code>withStdin</code>関数は、標準出力・標準エラー出力・標準入力でやりとりする文字列を<span class="ascii">strict</span>な<code>ByteString</code>でやりとりします。<br />
<span class="ascii">silently</span>や<code>System.IO.Fake</code>は、<code>String</code>なのです。<br />
<code>ByteString</code>は文字通り任意のバイト列を扱うことができるので、「<span class="ascii">Unicode</span>の文字のリスト」である<code>String</code>よりも、多様なデータを扱うことができます。</p>
<p>これは、特に複数の種類の文字コードを扱うとき、非常に重要な機能となります。<br />
<a href="https://haskell.jp/blog/posts/2017/windows-gotchas.html">以前の記事で取り上げた、<code>Invalid character</code>というエラー</a>を再現させる場合も、ないと大変やりづらいでしょう。</p>
<p>第二に、<span class="ascii">main-tester</span>の<code>captureProcessResult</code>関数は、<code>main</code>関数の終了コードも<a href="https://hackage.haskell.org/package/base-4.11.0.0/docs/System-Exit.html#t:ExitCode"><code>ExitCode</code>型</a>の値として取得できます。<br />
<code>main</code>関数の中で<code>exitFailure</code>等の関数を呼び出すと、<code>ExitCode</code>が例外として投げられます。<br />
既存のライブラリーでこれを行うと、<code>ExitCode</code>が例外として処理されるため、テストしたい<code>main</code>関数の実行が終了してしまいます。<br />
結果、<code>main</code>関数が標準出力・標準エラー出力に書き込んだ文字列を取得することができないのです。<br />
「○○というエラーメッセージを出力して異常終了する」といったことをテストしたい場合、これでは使いづらいでしょう。<br />
<strong>「<code>main</code>関数の<span class="ascii">E2E</span>テストを行うためのライブラリーである」</strong>という観点から、必須の機能であると判断し、実装しました。 ちなみに、<code>ExitCode</code>以外の例外についてはそのまま投げられます。仕様を単純にするために、これはユーザーのテストコードの中で処理することとしています。</p>
<h1 id="使い方バグ報告">使い方・バグ報告</h1>
<p>機能は非常にシンプルなので、使い方については<a href="https://hackage.haskell.org/package/main-tester-0.1.0.0/docs/Test-Main.html">ドキュメント</a>のサンプルコードを読めば大体わかるかなぁと思いますが、簡単にサンプルを載せておきましょう。</p>
<p>例えばこんなソース👇のプログラムがあった場合、</p>
<p><span class="ascii">ExampleMain.hs:</span></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">module</span> <span class="dt">ExampleMain</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Data.List</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="kw">import</span> <span class="dt">System.Exit</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">  putStr <span class="st">&quot;What&#39;s your name?: &quot;</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">  name <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">  <span class="kw">if</span> <span class="st">&quot;Yuji&quot;</span> <span class="ot">`isInfixOf`</span> name</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">    <span class="kw">then</span> putStrLn <span class="st">&quot;Nice name!&quot;</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12">    <span class="kw">else</span> die <span class="fu">$</span> name <span class="fu">++</span> <span class="st">&quot;? Sorry I don&#39;t know such a guy!&quot;</span></a></code></pre></div>
<p><span class="ascii">main-tester</span>を使えば、次のように<span class="ascii">Hspec</span>でテストできます。</p>
<p><span class="ascii">ExampleSpec.hs:</span></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">import</span> <span class="dt">System.Exit</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Test.Main</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="kw">import</span> <span class="dt">Test.Hspec</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">ExampleMain</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString</span> <span class="kw">as</span> <span class="dt">B</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">main <span class="fu">=</span> hspec <span class="fu">$</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">  describe <span class="st">&quot;your-cool-command&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">    context <span class="st">&quot;Given &#39;Yuji&#39; to stdin&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12">      it <span class="st">&quot;prints a string including &#39;Nice name&#39; without an error&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-13" data-line-number="13">        result <span class="ot">&lt;-</span> withStdin <span class="st">&quot;Yuji&quot;</span><span class="fu">$</span> captureProcessResult ExampleMain.main</a>
<a class="sourceLine" id="cb2-14" data-line-number="14">        prExitCode result <span class="ot">`shouldBe`</span> <span class="dt">ExitSuccess</span></a>
<a class="sourceLine" id="cb2-15" data-line-number="15">        prStderr result <span class="ot">`shouldSatisfy`</span> B.null</a>
<a class="sourceLine" id="cb2-16" data-line-number="16">        prStdout result <span class="ot">`shouldSatisfy`</span> (<span class="st">&quot;Nice name&quot;</span> <span class="ot">`B.isInfixOf`</span>)</a>
<a class="sourceLine" id="cb2-17" data-line-number="17"></a>
<a class="sourceLine" id="cb2-18" data-line-number="18">    context <span class="st">&quot;Given other name to stdin&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb2-19" data-line-number="19">      it <span class="st">&quot;prints an error message&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-20" data-line-number="20">        result <span class="ot">&lt;-</span> withStdin <span class="st">&quot;other name&quot;</span> <span class="fu">$</span> captureProcessResult ExampleMain.main</a>
<a class="sourceLine" id="cb2-21" data-line-number="21">        prExitCode result <span class="ot">`shouldBe`</span> <span class="dt">ExitFailure</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-22" data-line-number="22">        prStderr result <span class="ot">`shouldSatisfy`</span> (not <span class="fu">.</span> B.null)</a></code></pre></div>
<p>それぞれのファイルを同じディレクトリーに置いた上で、次のように実行すれば試せるはずです <small>（<span class="ascii">cabal</span>ユーザーの皆さんは適当に読み替えてください…）</small>。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="op">&gt;</span> <span class="ex">stack</span> build hspec main-tester</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="op">&gt;</span> <span class="ex">stack</span> exec runghc -- --ghc-arg=-i. ExampleSpec.hs</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="ex">your-cool-command</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">  <span class="ex">Given</span> <span class="st">&#39;Yuji&#39;</span> to stdin</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    <span class="ex">prints</span> a string including <span class="st">&#39;Nice name&#39;</span> without an error</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">  <span class="ex">Given</span> other name to stdin</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">    <span class="ex">prints</span> an error message</a>
<a class="sourceLine" id="cb3-9" data-line-number="9"></a>
<a class="sourceLine" id="cb3-10" data-line-number="10"><span class="ex">Finished</span> in 0.0130 seconds</a>
<a class="sourceLine" id="cb3-11" data-line-number="11"><span class="ex">2</span> examples, 0 failures</a></code></pre></div>
<p>バグを見つけたら<a href="https://gitlab.com/igrep/main-tester/issues">こちらの<span class="ascii">GitLab</span>の<span class="ascii">Issue</span></a>に報告してください<small>（最近の個人的な判官贔屓により、敢えて<span class="ascii">GitLab</span>にしております 😏）</small>。<br />
それではこの春は<span class="ascii">main-tester</span>で<span class="ascii">Happy Haskell Testing!!</span> 💚💚💚</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p><code>main</code>関数を子スレッドとして<code>forkIO</code>することで同じことが恐らくできますが、テスト結果の報告に使うべき、標準出力・標準エラー出力を食い合うことになってしまうので、非常にやりづらいと思います。<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2018/about-ghc-exts-1.html" lang="ja">GHC拡張ノック(Part 1)</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2018/renew-haskell-antenna.html" style="margin-left: auto;" lang="ja">Haskell Antenna をリニューアルしました</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>Haskell Antenna をリニューアルしました</title>
    <link href="https://haskell.jp/blog/posts/2018/renew-haskell-antenna.html" />
    <id>https://haskell.jp/blog/posts/2018/renew-haskell-antenna.html</id>
    <published>2018-03-21T00:00:00Z</published>
    <updated>2018-03-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <p><a href="https://haskell.jp/antenna/"><span class="ascii">Haskell Antenna</span></a>は<a href="https://github.com/lotz84"><span class="ascii">lotz84</span></a>氏が作った<span class="ascii">Haskell</span>の日本語情報を収集するウェブサイトです。 下記の記事を読むと、動機付けなどが分かると思います。</p>
<ul>
<li><a href="https://haskell.jp/blog/posts/2017/03-haskell-antenna.html"><span class="ascii">Haskell Antenna</span> を公開しました <span class="ascii">- Haskell-jp</span></a></li>
</ul>
<p>残念なことに<span class="ascii">Haskell Antenna</span>は動作が重く、なかなか満足に閲覧することが出来ませんでした。 そこで、<span class="ascii">Haskell Antenna</span>をリニューアルしました！</p>
<p>正確には、<a href="https://planet.haskell.org/"><span class="ascii">Planet Haskell</span></a>の日本語版として作成した<a href="https://github.com/matsubara0507/planet-haskell-jp-demo">もの</a>を、新しい<span class="ascii">Haskell Antenna</span>として置き換えました。 新<span class="ascii">Antenna</span>は旧<span class="ascii">Antenna</span>と比べると見た目も機能も更新頻度も残念なことになってしまいましたが、各サイトのフィードから記事の一覧を取得し静的サイトとして生成しているだけなので動作は軽快です。</p>
<p>旧<span class="ascii">Antenna</span>同様に新<span class="ascii">Antenna</span>でも配信する情報源<span class="ascii">(</span>今のところ<span class="ascii">Atom</span>か<span class="ascii">RSS2.0</span>形式のフィード<span class="ascii">)</span>をいつでも募集しています。 もし追加すべき情報源にアイデアがあれば<a href="https://github.com/haskell-jp/antenna#サイトの追加方法"><span class="ascii">GitHub</span>レポジトリの<span class="ascii">README</span></a>にかかれている方法を参考に<span class="ascii">Pull Request</span>を送っていただくことが可能です。 また、<span class="ascii">PR</span>を送るのは面倒だという方は<span class="ascii">Haskell-jp</span>の<span class="ascii">Slack</span>の<span class="ascii">#antenna</span>チャンネルを通じて提案を行ってもらうことも大歓迎です。 <span class="ascii">(Planet Haskell</span>がそうであるように<span class="ascii">)Haskell</span>中心でなくても良いので、<span class="ascii">Haskell</span>の情報を発信しているブログを持っている方は是非、追加提案をしていただけると助かります。</p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2018/main-tester.html" lang="ja">CLIアプリのE2Eテストを行うためのライブラリー main-testerをリリースしました</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2018/windows-long-path.html" style="margin-left: auto;" lang="ja">WindowsでHaskellを扱う時によく遭遇するNo such file or directoryについて</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>WindowsでHaskellを扱う時によく遭遇するNo such file or directoryについて</title>
    <link href="https://haskell.jp/blog/posts/2018/windows-long-path.html" />
    <id>https://haskell.jp/blog/posts/2018/windows-long-path.html</id>
    <published>2018-03-13T00:00:00Z</published>
    <updated>2018-03-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>去年、<a href="/posts/2017/windows-gotchas.html"><span class="ascii">Windows</span>で<span class="ascii">Haskell</span>を扱う時によく遭遇するエラーと対処法</a>という記事で、<span class="ascii">Windows</span>ユーザーが<span class="ascii">Haskell</span>で開発したとき、あるいは<span class="ascii">Haskell</span>製のプログラムを使用した際によく遭遇するエラーやその回避方法を紹介しました。<br />
今回は、そこに追記したい内容として、最近私がよく出遭うようになったエラーを紹介します。</p>
<h1 id="openfile-does-not-exist-no-such-file-or-directoryといわれたら短いパスに移そう"><code>openFile: does not exist (No such file or directory)</code>といわれたら短いパスに移そう</h1>
<p><code>does not exist (No such file or directory)</code>というエラーは、本当に読んで字のごとく、開こうとしたファイルが存在しないためのエラーであることとがもちろん多いのですが、エラーメッセージに反して違う原因である場合もあります。</p>
<p>例えば、最近私はとあるプロジェクトを数文字長い名前にリネームしたのですが、たったそれだけで、<code>stack test</code>した際必ず問題のエラーが発生するようになってしまいました。</p>
<pre><code>$ stack test
a-little-longer-name-project-0.1.0.0: build (lib + exe + test)
Preprocessing library for a-little-longer-name-project-0.1.0.0..
Building library for a-little-longer-name-project-0.1.0.0..
Preprocessing executable &#39;mmlh&#39; for a-little-longer-name-project-0.1.0.0..
Building executable &#39;mmlh&#39; for a-little-longer-name-project-0.1.0.0..
Preprocessing test suite &#39;a-little-longer-name-project-test&#39; for a-little-longer-name-project-0.1.0.0..
Building test suite &#39;a-little-longer-name-project-test&#39; for a-little-longer-name-project-0.1.0.0..
[1 of 5] Compiling Paths_aLittleLongerNameProject ( .stack-work\dist\5c8418a7\build\a-little-longer-name-project-test\autogen\Paths_aLittleLongerNameProject.hs, .stack-work\dist\5c8418a7\build\a-little-longer-name-project-test\a-little-longer-name-project-test-tmp\Paths_aLittleLongerNameProject.o )
.stack-work\dist\5c8418a7\build\a-little-longer-name-project-test\a-little-longer-name-project-test-tmp\.stack-work\dist\5c8418a7\build\a-little-longer-name-project-test\autogen\Paths_aLittleLongerNameProject.dump-hi: openFile: does not exist (No such file or directory)</code></pre>
<p>どういうことかと悩んでいたところ、<a href="https://github.com/commercialhaskell/stack/issues/3649">こんな<span class="ascii">Issue</span></a>を見つけました。<br />
<a href="https://github.com/commercialhaskell/stack/issues/3649#issuecomment-351612621"><span class="ascii">Snoyman</span>の指摘</a>のとおり、こちらの問題は<span class="ascii">Windows</span>で使えるパスの長さが原因のエラーのようです。<br />
どういうことかというと、<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247%20(v=vs.85)#maxpath"><span class="ascii">MSDN</span>のこちらのページ</a>でも触れているとおり、<span class="ascii">Windows</span>の（<span class="ascii">C</span>言語レベルでの）各種ファイル操作用<span class="ascii">API</span>では、一度に扱えるパスの長さが<span class="ascii">260</span>文字までと決められていて、その制限にかかったためのエラーだというのです！<br />
<code>does not exist (No such file or directory)</code>なんてエラーメッセージで表されるのでわかりづらい！<small>（おそらく<span class="ascii">Windows</span>のエラーコードの出し方に問題があるんじゃないかと思います）</small></p>
<p><span class="ascii">DOS</span>時代から残るこの制限、完全に時代錯誤なものでしかないのですが、<span class="ascii">Windows</span>でパッケージマネージャーなどが自動的に作ったパスを扱っていると、しばしば出くわすことがあります。<br />
<span class="ascii">stack</span>においても、<a href="https://github.com/commercialhaskell/stack/issues/3285">こちらの<span class="ascii">Issue</span></a>で同じ問題が議論されていたり、<a href="https://github.com/commercialhaskell/stack/releases/tag/v1.6.5"><span class="ascii">ver. 1.6.5</span>の<span class="ascii">ChangeLog</span></a>でも言及されていたりと、至る所で格闘している跡があります。</p>
<h2 id="回避方法">回避方法</h2>
<p>そんな<code>does not exist (No such file or directory)</code>ですが、残念ながら私が知る限り、プロジェクトなどのパスを（<code>C:\</code>などのよりルートに近い場所に置いて）より短くする以外の回避方法はありません。<br />
<a href="https://github.com/haskell/haskell-ide-engine#installation-on-windows"><span class="ascii">haskell-ide-engine</span>のインストール方法のページ</a>曰く、（新しめの）<span class="ascii">Windows 10</span>であれば、グループポリシーを編集して、「<span class="ascii">Win32</span>の長いパスを有効にする」を「有効」にすれば回避できるとのことですが、残念ながら手元で試した限りうまくいきませんでした。何かやり方がまずかったのかもしれませんが。<br />
いずれにしても、<code>stack build</code>コマンドなどを実行したときに問題のエラーに遭遇した場合、ビルドしたいもののパスをなんとかして短くする以上の方法はありません。<br />
<code>C:\</code>直下をホームディレクトリのように使う人が今でもたくさんいるわけです。</p>
<p>一方、あなたが問題のエラーが発生するプログラムを<strong>修正する</strong>ことができる立場にある場合、次の方法で回避できるかもしれません。</p>
<h3 id="長いパスをより短くするためにカレントディレクトリーを変更して相対パスを短くする">長いパスをより短くするために、カレントディレクトリーを変更して、相対パスを短くする。</h3>
<p>本件はあくまでも、<span class="ascii">Windows</span>の各種ファイル操作用<span class="ascii">API</span>の<span class="ascii">1</span>回の呼び出しで渡せる長さの制限ですので、制限を超えてしまうような場合はパスを分割すればよいのです。<br />
<a href="https://hackage.haskell.org/package/filepath-1.4.2/docs/System-FilePath-Posix.html#v:splitFileName"><span class="ascii">filepath</span>パッケージの<code>splitFileName</code>関数</a>や<a href="https://hackage.haskell.org/package/filepath-1.4.2/docs/System-FilePath-Posix.html#v:splitPath"><code>splitPath</code>関数</a>を駆使してパスを分割した上で、対象のファイルの親ディレクトリーまで<a href="https://hackage.haskell.org/package/directory-1.3.2.1/docs/System-Directory.html#v:setCurrentDirectory"><span class="ascii">directory</span>パッケージの<code>setCurrentDirectory</code>関数</a>で移動すれば、制限に引っかからないはずです<small>（時間の都合でこちらについては試すコードを用意しておりません。あしからず）</small>。</p>
<p>残念ながらカレントディレクトリーはプロセス全体で共有される情報ですので、マルチスレッドなプログラムでは頭の痛い問題が出てきてしまいますが、一番確実に回避できる方法のはずです。<br />
マルチスレッドである場合を考慮したくない場合は、次に紹介する方法を検討するとよいでしょう。</p>
<h3 id="win32-apiのユニコード版の関数にというプレフィックスを着けた絶対パスを渡す"><span class="ascii">Win32 API</span>のユニコード版の関数に、<code>\\?\</code>というプレフィックスを着けた絶対パスを渡す。</h3>
<p>ここまでに出てきた、「<span class="ascii">Windows</span>の各種ファイル操作用<span class="ascii">API</span>」は、すべて「<span class="ascii">Win32 API</span>」と呼ばれる<span class="ascii">Windows</span>固有の<span class="ascii">API</span>群の一部です。<br />
この「<span class="ascii">Win32 API</span>」に含まれる関数の多くは、「ユニコード版」とそうでないものに分かれます<small>（詳細は<a href="https://msdn.microsoft.com/ja-jp/library/windows/desktop/dd317766(v=vs.85).aspx"><span class="ascii">Conventions for Function Prototypes (Windows)</span></a>をご覧ください）</small>。</p>
<p>このうち、「ユニコード版」の<span class="ascii">API</span>には、この制限を緩和する専用の機能が含まれています。<br />
先ほども触れた<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247%20(v=vs.85)#maxpath"><span class="ascii">MSDN</span>のページ</a>曰く、なんと<code>\\?\</code>という変な文字列を絶対パスの頭に着けると、最大約<span class="ascii">32,767</span>文字のパスまで受け付けるようになるというのです！<br />
なんともアドホックな感じのする解決方法ですが、<span class="ascii">Microsoft</span>が言うんだから間違いありません。<br />
いずれにしても<span class="ascii">32,767</span>文字という微妙な最大文字数ができてしまいますが、<span class="ascii">UTF-16</span>での<span class="ascii">32,767</span>文字なので、そう簡単に超えることはないでしょう。<br />
いちいち絶対パスに変えて変なプレフィックスを加えないといけないという面倒くささはありますが、いちいち分割して相対パスに変換するよりは簡単なはずですので、検討する価値があります。</p>
<p>この、<code>\\?\</code>機能を試す場合、下記のコードを適当なファイルに貼り付けて保存し、<code>stack runghc file.hs</code>などと実行してみてください <span class="ascii">(Thanks,</span> <span class="citation" data-cites="matsubara0507"><span class="ascii">@matsubara0507</span></span><span class="ascii">!)</span>。<br />
<code>catch</code>関数を使って例外を捕捉している箇所では、実際にパスが長すぎるためにエラーが発生し、<code>catch</code>されているはずです。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">import</span>           <span class="dt">Control.Exception</span> (catch, <span class="dt">IOException</span>)</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="kw">import</span>           <span class="dt">Data.List</span>        (replicate)</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">import</span>           <span class="dt">System.Directory</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  crDir <span class="ot">&lt;-</span> getCurrentDirectory</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">    path1 <span class="fu">=</span> mconcat <span class="fu">$</span> replicate <span class="dv">20</span> <span class="st">&quot;abcdefgh/&quot;</span> <span class="co">-- ok</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">    path2 <span class="fu">=</span> mconcat <span class="fu">$</span> replicate <span class="dv">30</span> <span class="st">&quot;abcdefgh/&quot;</span> <span class="co">-- error</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">    path3 <span class="fu">=</span> crDir <span class="fu">++</span> <span class="st">&quot;/&quot;</span> <span class="fu">++</span> path2 <span class="co">-- error</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12">    path4 <span class="fu">=</span> <span class="st">&quot;\\\\?\\&quot;</span> <span class="fu">++</span> path3 <span class="co">-- ok</span></a>
<a class="sourceLine" id="cb2-13" data-line-number="13"></a>
<a class="sourceLine" id="cb2-14" data-line-number="14">  putStrLn <span class="fu">$</span> <span class="st">&quot;path1: &quot;</span> <span class="fu">++</span> show path1</a>
<a class="sourceLine" id="cb2-15" data-line-number="15">  createDirectoryIfMissing <span class="dt">True</span> path1</a>
<a class="sourceLine" id="cb2-16" data-line-number="16"></a>
<a class="sourceLine" id="cb2-17" data-line-number="17">  putStrLn <span class="fu">$</span> <span class="st">&quot;path2: &quot;</span> <span class="fu">++</span> show path2</a>
<a class="sourceLine" id="cb2-18" data-line-number="18">  createDirectoryIfMissing <span class="dt">True</span> path2 <span class="ot">`catch`</span> (\e <span class="ot">-&gt;</span> putStrLn <span class="fu">$</span> <span class="st">&quot;  &quot;</span> <span class="fu">++</span> show (<span class="ot">e ::</span> <span class="dt">IOException</span>))</a>
<a class="sourceLine" id="cb2-19" data-line-number="19"></a>
<a class="sourceLine" id="cb2-20" data-line-number="20">  putStrLn <span class="fu">$</span> <span class="st">&quot;path3: &quot;</span> <span class="fu">++</span> show path3</a>
<a class="sourceLine" id="cb2-21" data-line-number="21">  createDirectoryIfMissing <span class="dt">True</span> path3 <span class="ot">`catch`</span> (\e <span class="ot">-&gt;</span> putStrLn <span class="fu">$</span> <span class="st">&quot;  &quot;</span> <span class="fu">++</span> show (<span class="ot">e ::</span> <span class="dt">IOException</span>))</a>
<a class="sourceLine" id="cb2-22" data-line-number="22"></a>
<a class="sourceLine" id="cb2-23" data-line-number="23">  putStrLn <span class="fu">$</span> <span class="st">&quot;path4: &quot;</span> <span class="fu">++</span> show path4</a>
<a class="sourceLine" id="cb2-24" data-line-number="24">  createDirectoryIfMissing <span class="dt">True</span> path4</a></code></pre></div>
<h1 id="おわりに">おわりに</h1>
<p>さて、またしても<span class="ascii">Windows</span>固有の面倒な問題を紹介することとなってしまいましたが、俗世の喜び（主にゲーム）と簡単にインストールできる<span class="ascii">GUI</span>に慣らされてしまった私は、今後も<span class="ascii">Windows</span>を使い続けるつもりです。<br />
いろいろ困難は尽きませんがこれからも<span class="ascii">Windows</span>で<span class="ascii">Happy Haskell Life</span>を！🏁🏁🏁</p>
<h1 id="参考url">参考<span class="ascii">URL</span></h1>
<p>※本文中で言及していないもののみ</p>
<ul>
<li><a href="http://kkamegawa.hatenablog.jp/entry/2016/07/27/220014">プログラマ的に<span class="ascii">Windows 10 Anniversary Update</span>のうれしいところ <span class="ascii">- kkamegawa</span>’<span class="ascii">s weblog</span></a></li>
<li><a href="https://superuser.com/questions/1119883/windows-10-enable-ntfs-long-paths-policy-option-missing"><span class="ascii">Windows 10</span> “<span class="ascii">Enable NTFS long paths policy</span>” <span class="ascii">option missing - Super User</span></a></li>
</ul>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2018/renew-haskell-antenna.html" lang="ja">Haskell Antenna をリニューアルしました</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2018/topic-request.html" style="margin-left: auto;" lang="ja">Haskell-jp Blogで書いてほしいネタを募集します！</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>Haskell-jp Blogで書いてほしいネタを募集します！</title>
    <link href="https://haskell.jp/blog/posts/2018/topic-request.html" />
    <id>https://haskell.jp/blog/posts/2018/topic-request.html</id>
    <published>2018-02-18T00:00:00Z</published>
    <updated>2018-02-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p><span class="ascii">Haskell-jp Blog</span>では、設立当初より<span class="ascii">Haskell</span>に関する記事を幅広く募集してきました。<br />
このたびはそれに加え、この<span class="ascii">Haskell-jp Blog</span>で「書いて欲しい！」「読んでみたい！」<span class="ascii">Haskell</span>に関する話題も募集することにしました！ 例えば、下記のような話題が考えられるでしょう。</p>
<ul>
<li>○○パッケージの解説記事が欲しい</li>
<li>数学用語と<span class="ascii">Haskell</span>用語の対応関係が知りたい</li>
<li><span class="ascii">Real World Haskell</span>を今読むならの注意点</li>
<li>そのほか、<span class="ascii">Haskell</span>に関する話題であれば何でも！</li>
</ul>
<p><strong>ただし、提案していただいたネタに関する知見の持ち主が居ないかもしれませんし、誰かの負担になるものなので必ず記事になるとは限りません。</strong> また、場合によっては既に記事があるため、既存の記事を薦められるかもしれません。</p>
<h2 id="ネタを提案してくれる場合">ネタを提案してくれる場合</h2>
<p><a href="https://github.com/haskell-jp/blog/issues/new?template=topic-request.md&amp;labels=Topic+Request">この<span class="ascii">Blog</span>のリポジトリの<span class="ascii">Issue</span></a>からお願いします。 既に提案されていたら、その<span class="ascii">Issue</span>に対して 👍 するといいと思います。</p>
<h2 id="書いてもいいよって場合">書いてもいいよって場合</h2>
<p><code>TopicRequest</code> というラベルを作ったので、<a href="https://github.com/haskell-jp/blog/issues?q=is:issue+is:Aopen+label:%22Topic+Request%22"><span class="ascii">Issue</span>をそのラベルで検索</a>してください。 書いてもいいという提案があった場合は、<span class="ascii">Issue</span>に「書いてもいいよ」という旨をコメントしていただけるとバッティングが無くて助かります。</p>
<p>それでは、今後は<span class="ascii">Haskell</span>に関するあなたの記事だけでなく、あなたが<span class="ascii">Haskell</span>について読みたい記事も募集していきますので、どしどし応募してください！ 🙏</p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2018/windows-long-path.html" lang="ja">WindowsでHaskellを扱う時によく遭遇するNo such file or directoryについて</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2018/ghc-proposal-and-patch.html" style="margin-left: auto;" lang="ja">GHCへの変更提案とパッチ送付の手順例</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>GHCへの変更提案とパッチ送付の手順例</title>
    <link href="https://haskell.jp/blog/posts/2018/ghc-proposal-and-patch.html" />
    <id>https://haskell.jp/blog/posts/2018/ghc-proposal-and-patch.html</id>
    <published>2018-02-11T00:00:00Z</published>
    <updated>2018-02-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<h2 id="はじめに">はじめに</h2>
<p><span class="ascii">Haskell</span>のコンパイラの１つである<span class="ascii">GHC</span>は、オープンソースソフトウェア<span class="ascii">(OSS)</span>のプロジェクトとして今も活発に開発が進められています。 個人の経験や経歴や肩書きや権限などに関わらず、誰でも<span class="ascii">GHC</span>の開発にすぐに参加することができます。</p>
<p>ここでは、<span class="ascii">GHC</span>に新しい変更を提案し実装するための、以下の手順例を紹介します。</p>
<ol type="1">
<li><a href="#ch1">変更提案</a> <span class="ascii">(GitHub</span>の<span class="ascii">ghc-proposals</span> リポジトリ上にて実施<span class="ascii">)</span></li>
<li><a href="#ch2">パッチ送付</a> <span class="ascii">(Phabricator</span>の<span class="ascii">Haskell.org</span> インスタンス上にて実施<span class="ascii">)</span></li>
</ol>
<p><span class="ascii">GHC</span>に改善したい点があれば、誰でも変更提案が可能です。 提案のハードルは案外高いものではありません。<span class="ascii">GHC</span>開発では、新たな<span class="ascii">contribution</span>が歓迎されています。<br />
仮に提案やパッチが<span class="ascii">reject</span>判断されるとしても、<span class="ascii">GHC</span>の開発者と直接やり取りする良い機会が得られます。</p>
<p>以下では、数値リテラルの構文を変更する単純な例をもとに、変更提案やパッチ送付の手順例を紹介します。<span class="ascii">(</span>文章だらけになってしまいましたがご容赦を 😊 <span class="ascii">)</span></p>
<hr />
<h2 id="ch1"><span class="ascii">1.</span> 変更提案<span class="ascii">(proposal)</span></h2>
<h3 id="概要">概要</h3>
<p><span class="ascii">GHC</span>は、コンパイラ本体やライブラリやツールチェーンなど多くの要素で構成されていますが、ここではコンパイラ本体への変更提案の手順について紹介します。</p>
<p><span class="ascii">GHC</span>のコンパイラ本体の開発では、<a href="https://github.com/ghc-proposals/ghc-proposals#what-is-a-proposal">ユーザーに見える<span class="ascii">(user-visible)</span>振る舞い</a>等を変更<span class="ascii">(</span>追加・修正・削除など<span class="ascii">)</span>するための提案<span class="ascii">(proposal)</span>手順が定められています。 事前の調整や権限などを必要とせず、<span class="ascii">GitHub</span>への<span class="ascii">pull request</span>を通じて誰もが提案できます。</p>
<p>なお、変更提案<span class="ascii">(</span>仕様<span class="ascii">)</span>のプロセスと、修正パッチ送付<span class="ascii">(</span>実装<span class="ascii">)</span>のプロセスは、分離されています。必ずしも、変更提案者が実装まで行う必要はありません。</p>
<h3 id="変更提案の正確な手続き">変更提案の正確な手続き</h3>
<p>提案の具体的な手続きについては、以下に記載されています。よく読んでおきましょう。</p>
<ul>
<li><a href="https://github.com/ghc-proposals/ghc-proposals#ghc-proposals"><span class="ascii">https://github.com/ghc-proposals/ghc-proposals#ghc-proposals</span></a></li>
</ul>
<p>変更提案は、提案書を書いて以下の場所<span class="ascii">(</span>リポジトリ<span class="ascii">)</span>に、<span class="ascii">pull request</span>を送ることで行えます。</p>
<ul>
<li><a href="https://github.com/ghc-proposals/ghc-proposals/pulls"><span class="ascii">https://github.com/ghc-proposals/ghc-proposals/pulls</span></a></li>
</ul>
<h3 id="変更提案のおおまかな流れ">変更提案のおおまかな流れ</h3>
<p><a href="https://github.com/ghc-proposals/ghc-proposals#what-is-the-timeline-of-a-proposal">提案の流れ</a>は、ざくっと以下の通りです。</p>
<ul>
<li>提案の作成
<ul>
<li><span class="ascii">GitHub</span>上で、<a href="https://github.com/ghc-proposals/ghc-proposals"><span class="ascii">ghc-proposals</span></a>のリポジトリを<span class="ascii">fork</span>する <a href="https://github.com/takenobu-hs/ghc-proposals"><span class="ascii">(</span>例<span class="ascii">)</span></a></li>
<li><span class="ascii">fork</span>してきた自分のリポジトリで作業用のブランチを作る <a href="https://github.com/takenobu-hs/ghc-proposals/tree/numeric-underscores"><span class="ascii">(</span>例<span class="ascii">)</span></a></li>
<li><span class="ascii">proposals</span>ディレクトリの下に、“<span class="ascii">0000-</span>プロポーザル名<span class="ascii">.rst</span>”のファイル名で<a href="https://github.com/ghc-proposals/ghc-proposals#how-to-start-a-new-proposal">提案用のファイルを作る</a> <a href="https://github.com/takenobu-hs/ghc-proposals/blob/numeric-underscores/proposals/0000-numeric-underscores.rst"><span class="ascii">(</span>例<span class="ascii">)</span></a></li>
<li>“<span class="ascii">Motivation</span>”などの<a href="https://github.com/ghc-proposals/ghc-proposals#what-should-a-proposal-look-like">必要な項目</a>を、<a href="http://docs.sphinx-users.jp/rest.html"><span class="ascii">reStructuredText</span></a>の書式に従い記述する <a href="https://github.com/takenobu-hs/ghc-proposals/blob/numeric-underscores/proposals/0000-numeric-underscores.rst"><span class="ascii">(</span>例<span class="ascii">)</span></a></li>
</ul></li>
<li>提案の送付
<ul>
<li><span class="ascii">GitHub</span>上で、<span class="ascii">ghc-proposals</span>のリポジトリに、<span class="ascii">pull request</span>を送る <a href="https://github.com/ghc-proposals/ghc-proposals/pull/76"><span class="ascii">(</span>例<span class="ascii">)</span></a></li>
<li>確定した<span class="ascii">pull request</span>の<span class="ascii">URL</span>を、提案用のファイルの“<span class="ascii">This proposal is discussed at this pull request.</span>”の箇所に記載してから、再度<span class="ascii">commit</span>し直す <a href="https://github.com/takenobu-hs/ghc-proposals/commit/61149ee277aadc6bd46e0ad35aeb529f02da1182#diff-1128b179eb6630a402469b59a8a7dce6"><span class="ascii">(</span>例<span class="ascii">)</span></a></li>
<li><span class="ascii">pull request</span>の <span class="ascii">Conversation</span>のところに、“<span class="ascii">Rendered</span>”という文字で提案ファイルへのリンクを貼っておく <a href="https://github.com/ghc-proposals/ghc-proposals/pull/76#issue-261822915"><span class="ascii">(</span>例<span class="ascii">)</span></a></li>
</ul></li>
<li>提案についての議論
<ul>
<li><span class="ascii">pull request</span>上で、<a href="https://github.com/ghc-proposals/ghc-proposals#discussion-goals">議論する</a> <a href="https://github.com/ghc-proposals/ghc-proposals/pull/76"><span class="ascii">(</span>例<span class="ascii">)</span></a></li>
<li>フィードバックがあれば、提案ファイルを修正する</li>
<li>議論期間を充分に<span class="ascii">(</span>一ヶ月くらいは<span class="ascii">)</span>設ける</li>
</ul></li>
<li>提案の判断
<ul>
<li>議論が収束したら、<a href="https://github.com/ghc-proposals/ghc-proposals#who-is-the-committee"><span class="ascii">GHC Steering Committee</span></a> へ、<a href="https://github.com/ghc-proposals/ghc-proposals#how-to-bring-a-proposal-before-the-committee">判断依頼</a>をかける <a href="https://github.com/ghc-proposals/ghc-proposals/pull/76#issuecomment-339952996"><span class="ascii">(</span>例<span class="ascii">)</span></a></li>
<li><span class="ascii">GHC Steering Committee</span>が<span class="ascii">Accepted/Rejected</span>を判断する <a href="https://github.com/ghc-proposals/ghc-proposals/pull/76#event-1341434473"><span class="ascii">(</span>例<span class="ascii">)</span></a></li>
<li><span class="ascii">Accepted</span>なら、<span class="ascii">Trac</span>で<a href="https://ghc.haskell.org/trac/ghc/newticket?type=task"><span class="ascii">ticket</span>を登録</a>する <a href="https://ghc.haskell.org/trac/ghc/ticket/14473"><span class="ascii">(</span>例<span class="ascii">)</span></a></li>
<li>次は、コード修正パッチの作成・送付フェーズへ</li>
</ul></li>
</ul>
<h3 id="変更提案の例">変更提案の例</h3>
<p>数値リテラルの構文を変更する場合の、具体的な変更提案の例を紹介します。</p>
<ul>
<li><a href="https://github.com/takenobu-hs/ghc-proposals/blob/0a694636560ca37d9b76e56bddc43c6bf1c9348a/proposals/0000-numeric-underscores.rst">変更提案の初版</a> <span class="ascii">|</span> <a href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0009-numeric-underscores.rst">最終的な変更提案</a></li>
<li><a href="https://github.com/ghc-proposals/ghc-proposals/pull/76">議論フェーズの例</a></li>
</ul>
<p>その他の提案の例は以下にたくさんあります。</p>
<ul>
<li><a href="https://github.com/ghc-proposals/ghc-proposals/pulls?q=is%3Aopen+is%3Apr"><span class="ascii">Open</span>中の提案</a></li>
<li><a href="https://github.com/ghc-proposals/ghc-proposals/pulls?q=is%3Apr+is%3Aclosed"><span class="ascii">Close</span>済みの提案</a></li>
</ul>
<h3 id="いくつかのポイントなど">いくつかのポイントなど</h3>
<ul>
<li>他の良い提案が参考になります <span class="ascii">(</span>同じ種類の提案や議論がうまく進んでいる提案などから、色々な観点を学べます。<span class="ascii">)</span></li>
<li>数カ月単位で気長に根気よくやる<span class="ascii">(</span>開発者は全員がボランティアで忙しい。<span class="ascii">)</span></li>
<li>提案してよいか迷う場合は、事前に<a href="https://mail.haskell.org/cgi-bin/mailman/listinfo/ghc-devs"><span class="ascii">ghc-devs</span>の<span class="ascii">ML(</span>メーリングリスト<span class="ascii">)</span></a>などで相談してもよい</li>
<li>英語の精度を必要以上に気にする必要はない。日本語でしっかり考える。あとは短い文に区切って、<span class="ascii">Google</span>翻訳にでも。</li>
</ul>
<p>提案プロセスは<span class="ascii">GitHub</span>上で行うものです。操作ミスがあったところでやり直しは何度でも行えます。失敗やミスを不必要に怖れる必要はありません。<br />
また、多くの提案は<span class="ascii">Accepted</span>に至らないこともあるので、結果を恥ずかしがる必要もありません。提案の結果に関わらず、提案とその議論自体が、他の開発者に新たな観点や気づき・刺激を提供できます。</p>
<p>それでは、提案プロセスをお楽しみ！</p>
<hr />
<h2 id="ch2"><span class="ascii">2.</span> パッチ送付<span class="ascii">(patch)</span></h2>
<h3 id="概要-1">概要</h3>
<p><span class="ascii">GHC</span>への変更提案に対するコード修正は、パッチを作成して送付することにより行われます。 ここでは、コード開発ツールである<span class="ascii">Phabricator</span>の<span class="ascii">differential</span>機能を用いる、標準的なパッチ送付の手順について紹介します。</p>
<p>なお、修正パッチは<span class="ascii">GitHub</span>の<span class="ascii">pull request</span>を通じても送付できますが、後のコードレビューのフェーズを考慮すると、<span class="ascii">Phabricator</span>を用いるこの手順が効率的です。</p>
<h3 id="パッチ送付の正確な手続き">パッチ送付の正確な手続き</h3>
<p>パッチ作成から送付についての具体的な手続きについては以下に記載されています。</p>
<ul>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/WorkingConventions/FixingBugs"><span class="ascii">How to contribute a patch to GHC</span></a></li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Phabricator"><span class="ascii">Using Phabricator for GHC development</span></a></li>
</ul>
<p>また、<span class="ascii">Phabricator</span>の詳細な操作手順については、以下に解説記事があります。</p>
<ul>
<li><a href="https://medium.com/@zw3rk/contributing-to-ghc-290653b63147"><span class="ascii">Contributing to GHC via Phabricator</span></a></li>
</ul>
<h3 id="パッチ送付のおおまかな流れ">パッチ送付のおおまかな流れ</h3>
<p>パッチ送付の流れは、ざくっと以下の通りです。</p>
<ul>
<li>パッチの作成
<ul>
<li><span class="ascii">GHC</span>の<span class="ascii">build/validate</span>用環境を<a href="https://ghc.haskell.org/trac/ghc/wiki/Building/Preparation">整えておく</a></li>
<li><span class="ascii">GHC</span>のリポジトリを<a href="https://ghc.haskell.org/trac/ghc/wiki/Building/GettingTheSources#CloningHEAD"><span class="ascii">clone</span>する</a></li>
<li>事前に<span class="ascii">master</span>ブランチ上で、<a href="https://ghc.haskell.org/trac/ghc/wiki/Building/QuickStart"><span class="ascii">build</span>できることを確認しておく</a> <span class="ascii">(master</span>自体が<span class="ascii">fail</span>していることがあるため。<span class="ascii">)</span></li>
<li>事前に<span class="ascii">master</span>ブランチ上で、<a href="https://ghc.haskell.org/trac/ghc/wiki/TestingPatches#Locally"><span class="ascii">validate</span>が正常終了することを確認しておく</a> <span class="ascii">(master</span>自体が<span class="ascii">fail</span>していることがあるため。<span class="ascii">)</span></li>
<li>作業用のブランチを作り、コードを修正する
<ul>
<li>修正が１つの<span class="ascii">commit</span>にまとまっていると、後の<span class="ascii">arc</span>コマンドでのパッチ送付がラクです。“<span class="ascii">git merge</span> –<span class="ascii">squash</span>”でまとめられます。</li>
</ul></li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Building/RunningTests/Adding">テストケースを追加する</a> <a href="https://phabricator.haskell.org/D4235#change-AHneoV84zpis"><span class="ascii">(</span>例<span class="ascii">)</span></a></li>
<li>必要に応じて<a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/UserManual">ユーザーガイド</a>に変更機能についての説明を追加する <a href="https://phabricator.haskell.org/D4235#change-0p_6dVtsoCP3"><span class="ascii">(</span>例<span class="ascii">)</span></a></li>
<li>修正コードにて<span class="ascii">build</span>できることを確認しておく<span class="ascii">(</span>必ず行う<span class="ascii">)</span></li>
<li>修正コードにて<span class="ascii">validate</span>が正常終了することを確認しておく<span class="ascii">(</span>必ず行う<span class="ascii">)</span></li>
</ul></li>
<li>パッチの送付
<ul>
<li><span class="ascii">Phabricator</span>用のコマンドラインツール<a href="https://ghc.haskell.org/trac/ghc/wiki/Phabricator#TheCLI:Arcanist"><span class="ascii">Arcanist</span>をインストールする</a> <span class="ascii">(</span><a href="https://secure.phabricator.com/book/phabricator/article/arcanist/"><span class="ascii">arcanist</span>ツールの説明</a><span class="ascii">)</span></li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Phabricator#Startingoff:Fixingabugsubmittingareview"><span class="ascii">Phabricator</span>にパッチを送付する</a> <a href="https://phabricator.haskell.org/D4235"><span class="ascii">(</span>例<span class="ascii">)</span></a>
<ul>
<li>具体的なコマンドは“<span class="ascii">arc diff HEAD~</span>”。 最後の<span class="ascii">commit</span>が送信される。</li>
</ul></li>
<li><span class="ascii">Trac</span>の<span class="ascii">ticket</span>の、“<span class="ascii">Differential Rev</span>”の箇所に<span class="ascii">Phab</span>の管理番号を書いておく <a href="https://ghc.haskell.org/trac/ghc/ticket/14473"><span class="ascii">(</span>例<span class="ascii">)</span></a></li>
<li><span class="ascii">Phabricator</span>上で、コードレビューしてもらう（待つ、議論する）</li>
<li>必要に応じてコードを修正する
<ul>
<li>コード修正後に、修正パッチを送り直すコマンドは“<span class="ascii">arc diff</span>”。</li>
<li>レビュー待ちの間に、<span class="ascii">master</span>と<span class="ascii">conflict</span>を起こした場合は、パッチを送り直すと親切。</li>
<li>レビュー待ちの間に、<span class="ascii">master</span>との差分が大きくなった場合は、“<span class="ascii">git rebase</span>”してから送り直すのも親切。<span class="ascii">rebase</span>については<a href="https://ghc.haskell.org/trac/ghc/wiki/Phabricator#Workingwithmultipledependentdiffs">ここを参照</a></li>
</ul></li>
<li>レビューが完了して<span class="ascii">master</span>ブランチに取り込まれたら、<span class="ascii">proposals</span>の“<span class="ascii">implemented</span>”のフィールドに、実装済みの<span class="ascii">GHC</span>のバージョン番号を記載しておく <a href="https://github.com/ghc-proposals/ghc-proposals/commit/1974c2a45a782461084ea596ec839638d4ff0743#diff-ffb9f607b8f1e69494a276ae9afa8268"><span class="ascii">(</span>例<span class="ascii">)</span></a></li>
</ul></li>
</ul>
<h3 id="パッチ送付の例">パッチ送付の例</h3>
<p>数値リテラルの構文を変更する場合の、具体的なパッチ送付の例を紹介します。</p>
<ul>
<li><a href="https://phabricator.haskell.org/D4235"><span class="ascii">https://phabricator.haskell.org/D4235</span></a></li>
</ul>
<p>その他のレビュー中パッチの例は以下にたくさんあります。</p>
<ul>
<li><a href="https://phabricator.haskell.org/differential/"><span class="ascii">https://phabricator.haskell.org/differential/</span></a></li>
</ul>
<h3 id="いくつかのポイントなど-1">いくつかのポイントなど</h3>
<ul>
<li>他の良いパッチが参考になります<span class="ascii">(</span>同じ種類の修正を探すと、修正方法や慣習や修正漏れなどを確認できます。<span class="ascii">)</span></li>
<li><span class="ascii">build</span>確認と<span class="ascii">validation</span>確認は絶対に行う<span class="ascii">(</span>つたないコードは問題視されませんが、本来行うべき手順を行わないことは、開発全体にダメージを与えるとともに、個人の信用度に影響します。<span class="ascii">)</span></li>
<li>数カ月単位で気長に根気よくやる<span class="ascii">(</span>パッチ作業は多数並走しており、<span class="ascii">GHC</span>のリリース時期は特に多忙です。全員がボランティアで行っている自発的な活動ですので、忘れられている状況への<span class="ascii">ping</span>は構いませんが、強い催促は控えるのが賢明です。<span class="ascii">)</span></li>
<li>わからない点は、<span class="ascii">ghc-devs ML</span>や<span class="ascii">Phabricator</span>上で相談するとよいでしょう。</li>
<li><span class="ascii">Phabricator(arc</span>コマンド<span class="ascii">)</span>には慣れが必要かと思います。最初は影響範囲の少ない、ドキュメント修正などで<span class="ascii">Phabricator</span>の作業手順に慣れていくのも良いです。</li>
</ul>
<p>パッチ送付は、<span class="ascii">Phabricator</span>や<span class="ascii">git</span>の機能を用いて行うものです。操作ミスがあったところで、<span class="ascii">GHC</span>のリポジトリ本体に直ちに反映されるわけではありません。やり直しは何度でも行えます。失敗やミスを不必要に怖れる必要はありません。<span class="ascii">community</span>のためになる<span class="ascii">contribution</span>は常に歓迎されています。</p>
<p>それでは、パッチ送付プロセスをお楽しみ！</p>
<hr />
<h2 id="補足">補足</h2>
<p>わからないことがあれば、<a href="https://mail.haskell.org/cgi-bin/mailman/listinfo/ghc-devs"><span class="ascii">ghc-devs</span>の<span class="ascii">ML</span></a>に問い合わせると親切に教えてもらえます。 もちろん、<a href="https://join-haskell-jp-slack.herokuapp.com/"><span class="ascii">Haskell-jp</span>の<span class="ascii">slack</span></a>の<span class="ascii">#questions</span>チャネルなどで尋ねるのも良いでしょう。</p>
<p>なお、<span class="ascii">GHC</span>での開発作業については、<a href="https://ghc.haskell.org/trac/ghc/wiki/WorkingConventions"><span class="ascii">Working on GHC</span></a>も参考にどうぞ。<br />
また、<span class="ascii">GHC</span>の開発フロー全体については、<a href="https://takenobu-hs.github.io/downloads/ghc_development_flow.pdf">こちら</a>も参考にどうぞ。<span class="ascii">GHC</span>関連のサイトの情報を力づくで検索するには、<a href="https://takenobu-hs.github.io/haskell-wiki-search/">こちら</a>もどうぞ。</p>
<p><span class="ascii">Happy Hacking!</span></p>
<p>以上です。</p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2018/topic-request.html" lang="ja">Haskell-jp Blogで書いてほしいネタを募集します！</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2018/unordered-containers-hash-dos.html" style="margin-left: auto;" lang="ja">hashdos脆弱性とunordered-containers</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>hashdos脆弱性とunordered-containers</title>
    <link href="https://haskell.jp/blog/posts/2018/unordered-containers-hash-dos.html" />
    <id>https://haskell.jp/blog/posts/2018/unordered-containers-hash-dos.html</id>
    <published>2018-01-21T00:00:00Z</published>
    <updated>2018-01-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>あらゆるソフトウェアに脆弱性は存在し得ます。<br />
<span class="ascii">Haskell</span>は高度な型システムを駆使することで、脆弱性を根本的に回避したプログラムを作ることを可能にします<small>（脆弱性を防ぐためだけのものではないですが、興味のある人は<a href="http://www.kotha.net/ghcguide_ja/7.6.2/safe-haskell.html"><span class="ascii">Safe Haskell</span></a>についても調べてみるといいでしょう）</small>。<br />
しかし、だからといって、型を設計する段階で脆弱性を回避できるよう気をつけなければいけないことには変わりませんし、<span class="ascii">GHC</span>が生成した実行ファイル、使用するライブラリーに絶対に脆弱性がないとは言えません。<br />
現状、<span class="ascii">Haskell</span>はほかの著名なプログラミング言語ほど使用されていないためか、あまり脆弱性が報告されることはありません<small>（<span class="ascii">libc</span>など、ほかの言語の処理系も依存しているようなライブラリーの脆弱性は別として）</small>。<br />
今回は、そんな中でも<a href="https://hackage.haskell.org/package/unordered-containers"><span class="ascii">unordered-containers</span>というパッケージ</a>について、<a href="https://github.com/tibbe/unordered-containers/blob/60ced060304840ed0bf368249ed6eb4e43d4cefc/docs/developer-guide.md#security">ドキュメントにも書かれている</a>ため<strong>おそらく直ることがないであろう脆弱性</strong>と、その回避方法について紹介します。<br />
<span class="ascii">hashdos</span>脆弱性自体は結構有名ですし、ドキュメントに書いてあることなので、ご存知の方には何を今更感があるかと思いますが、検索した限りこの問題について日本語で説明した記事は見当たらなかったので、ここで紹介します。</p>
<h1 id="そもそもunordered-containersって">そもそも<span class="ascii">unordered-containers</span>って？</h1>
<p>脆弱性の前に<span class="ascii">unordered-containers</span>パッケージについて簡単に紹介しましょう。<br />
<a href="https://hackage.haskell.org/package/unordered-containers"><span class="ascii">unordered-containers</span>パッケージ</a>は、<span class="ascii">GHC</span>に標準で付いている<a href="https://hackage.haskell.org/package/containers"><span class="ascii">containers</span>パッケージ</a>よりも高速な連想配列（<a href="https://hackage.haskell.org/package/unordered-containers-0.2.8.0/docs/Data-HashMap-Lazy.html"><code>HashMap</code>型</a>）や集合（<a href="https://hackage.haskell.org/package/unordered-containers-0.2.8.0/docs/Data-HashSet.html"><code>HashSet</code>型</a>）を提供してくれます。<br />
<a href="https://www.stackage.org/lts-10.3/package/unordered-containers-0.2.8.0"><span class="ascii">Stackage</span>の<span class="ascii">LTS Haskell 10.3</span>ではなんと<span class="ascii">970</span>ものパッケージに依存されている</a>、超大人気汎用パッケージです。</p>
<h2 id="どうやって高速化しているの">どうやって高速化しているの？</h2>
<p><code>HashMap</code>という名前が示しているとおり、キーとなる値のハッシュ値を計算・利用することで高速化しています。<br />
しかし、<span class="ascii">Java</span>言語などほかの言語によくある<code>HashMap</code>とは大きく異なり、内部ではハッシュテーブルを使用していません。<br />
<a href="http://itpro.nikkeibp.co.jp/article/COLUMN/20091104/340002/?rt=nocnt">本物のプログラマは<span class="ascii">Haskell</span>を使う <span class="ascii">-</span> 第<span class="ascii">35</span>回　キーを使って値を参照する<span class="ascii">Map</span>型：<span class="ascii">ITpro</span></a>でも説明しているとおり、ハッシュテーブルはミュータブルな配列を内部で使用していることから、イミュータブルなデータ構造を使用して行う関数型プログラミングとは、相性が悪いのです<small>（<code>ST</code>モナドや<code>IO</code>モナドを利用した<a href="https://hackage.haskell.org/package/hashtables"><span class="ascii">hashtables</span>パッケージ</a>などを使えば、限られた範囲内でハッシュテーブルを使うこともできます）</small>。</p>
<p>ハッシュテーブルを使用しない代わりに、<span class="ascii">unordered-containers</span>では内部で<a href="https://en.wikipedia.org/wiki/Hash_array_mapped_trie"><span class="ascii">Hash array mapped trie</span></a>という特殊な木を使っています。<br />
どのような構造かは、<a href="http://keens.github.io/slide/HAMT/"><span class="ascii">HAMT ~</span> イミュータブルで高速なハッシュマップ <span class="ascii">~ |</span> κ<span class="ascii">een</span>の<span class="ascii">Happy Hac</span>κ<span class="ascii">ing Blog</span></a>に詳しく書かれています。<br />
こちらのスライドは<span class="ascii">Scala</span>での実装の話ですが、基本的には<span class="ascii">unordered-containers</span>パッケージの<code>HashMap</code>も同じはずです。</p>
<p>大雑把に言うと、<span class="ascii">Hash array mapped trie</span>を使った<code>HashMap</code>では、ハッシュテーブルと同様に、キーとなる値を<strong>ハッシュ関数で一旦固定長の整数に変換する</strong>ことで、キーが存在しているかどうかの確認を高速化しています。そのため、<span class="ascii">containers</span>パッケージよりも高速な処理ができるのです。<br />
<span class="ascii">containers</span>パッケージの<code>Map</code>ではキーの存在を確認する際、キー全体を既存のキーと比較する必要があるため、特に長い文字列をキーとする場合は、処理が遅くなりがちだったのです。</p>
<h1 id="hashdos脆弱性とは"><span class="ascii">hashdos</span>脆弱性とは？</h1>
<p><span class="ascii">hashdos</span>脆弱性は<a href="https://blog.tokumaru.org/2011/12/webdoshashdos.html"><span class="ascii">2011</span>年頃<span class="ascii">Ruby</span>や<span class="ascii">PHP</span>、<span class="ascii">Perl</span>など多くのプログラミング言語が影響を受けるとされた</a>、著名な脆弱性です。<br />
ここでも簡単に仕組みを説明しましょう。</p>
<p>前節で説明したとおり、<span class="ascii">Hash array mapped trie</span>もハッシュテーブルも、必ずキーを一旦固定長の整数に変換します。<br />
文字列など、ハッシュ関数を適用されるキーとなる値は、当然固定長の整数よりも幅広い値を取り得るので、違う文字列同士でも、同じハッシュ値をとることがあります。<br />
この、違う値であるはずのキーが同じハッシュ値をとってしまった状態を「ハッシュ値の衝突」と呼びます。<br />
ハッシュ値の衝突が発生した場合、ハッシュテーブルや<span class="ascii">Hash array mapped trie</span>といったハッシュ値を利用した連想配列は、（単純な）配列やリストなど、やむを得ず逐次探索が必要なデータ構造を内部で使用しなければならなくなります。</p>
<p><span class="ascii">hashdos</span>脆弱性はこの性質を利用した<span class="ascii">DoS</span>攻撃です。<br />
攻撃者は、あらかじめ対象のプログラムで使っているハッシュ関数が、「必ず同じハッシュ値」を返すキー<span class="ascii">(</span>大抵文字列でしょう）を大量に用意して、それを対象のプログラムに入力として与えることで、簡単に<span class="ascii">DoS</span>攻撃を仕掛けることができるのです。<br />
<a href="https://blog.tokumaru.org/2011/12/webdoshashdos.html">先ほど触れた徳丸先生の記事</a>では、<span class="ascii">PHP</span>のアプリケーションに対してわずか<span class="ascii">500KB</span>の<span class="ascii">form-data</span>を送るだけで<span class="ascii">CPU</span>時間を<span class="ascii">1</span>分も消費させることができたそうですから、その威力はすさまじいものと言えるでしょう。</p>
<h1 id="なぜ直さないのか">なぜ直さないのか？</h1>
<p><a href="https://github.com/tibbe/unordered-containers/blob/60ced060304840ed0bf368249ed6eb4e43d4cefc/docs/developer-guide.md#security"><span class="ascii">unordered-containers</span>の<span class="ascii">Developer Guide</span></a>には、次のように書かれています。</p>
<blockquote>
<p><span class="ascii">There</span>’<span class="ascii">s an uncomfortable trade-off with regards to security threats posed by e.g. denial of service attacks. Always using more secure hash function, like SipHash, would provide security by default. However, those functions would make the performance of the data structures no better than that of ordered containers, which defeats the purpose of this package.</span></p>
</blockquote>
<p>要するに、「セキュリティー上問題はあるけど、<span class="ascii">SipHash</span>のような安全なハッシュ関数を使ったら<span class="ascii">containers</span>パッケージよりも速度が出なかった。それではこのパッケージの意味がない」ということです。<br />
<span class="ascii">containers</span>パッケージよりも高速な連想配列を作るために<span class="ascii">unordered-containers</span>パッケージを作ったのだから、それより遅くなっては存在価値がなくなってしまうのです。<br />
従って、ユーザーが任意にキーを入力できるようなプログラムでは、<span class="ascii">unordered-containers</span>ではなく、<span class="ascii">containers</span>を使え、ということです。<br />
このことは<span class="ascii">unordered-containers</span>が使用している<a href="https://hackage.haskell.org/package/hashable-1.2.6.1/docs/Data-Hashable.html#g:1"><span class="ascii">hashable</span>のドキュメント</a>にも書かれています。ある意味ノーガード戦法ですね。</p>
<h1 id="回避方法">回避方法</h1>
<p>前節で触れたとおりですが、<strong>ユーザーが任意にキーを入力できるようなプログラム</strong>では、<span class="ascii">unordered-containers</span>パッケージの<code>HashMap</code>や<code>HashSet</code>ではなく、<span class="ascii">containers</span>パッケージの<code>Map</code>や<code>Set</code>を使いましょう。<br />
<span class="ascii">containers</span>パッケージにある<code>Map</code>や<code>Set</code>はハッシュ関数を一切使っていないので、ハッシュ値の衝突も起こらず、内部で逐次探索が必要なデータ構造を使ってもいません。<br />
なので<span class="ascii">hashdos</span>攻撃に遭うことはないのです。</p>
<p>ただし、実際のところ、<a href="https://www.stackage.org/lts-10.3/package/unordered-containers-0.2.8.0"><span class="ascii">Stackage</span>の<span class="ascii">LTS Haskell 10.3</span>で<span class="ascii">970</span>ものパッケージに依存されている</a><span class="ascii">unordered-containers</span>です。<br />
その中には<span class="ascii">JSON</span>のパーサーである<span class="ascii">aeson</span>も含まれているので、もしかしたら現状回避するのは非常に困難なのかもしれません。😱<br />
次回は、この問題について試しに攻撃用のコードを書いて速度の低下をチェックして報告する話を書くかもしれません…。😰</p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2018/ghc-proposal-and-patch.html" lang="ja">GHCへの変更提案とパッチ送付の手順例</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2017/advent-calendar-2017.html" style="margin-left: auto;" lang="ja">Haskell Advent Calendar 2017 まとめ</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>Haskell Advent Calendar 2017 まとめ</title>
    <link href="https://haskell.jp/blog/posts/2017/advent-calendar-2017.html" />
    <id>https://haskell.jp/blog/posts/2017/advent-calendar-2017.html</id>
    <published>2017-12-31T00:00:00Z</published>
    <updated>2017-12-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>これは <a href="https://qiita.com/advent-calendar/2017/haskell4"><span class="ascii">Haskell Advent Calendar</span> その<span class="ascii">4</span></a> の<span class="ascii">12</span>日目の記事です。</p>
<p>なんで<span class="ascii">12</span>日目の記事で「まとめ」をやっているのかって？ <span class="ascii">25</span>日を過ぎてから余ってた日付に登録しただけですよ。</p>
<p><a href="https://qiita.com/advent-calendar/2017/calendars"><span class="ascii">Qiita</span></a>と<a href="https://adventar.org/calendars?year=2017"><span class="ascii">ADVENTAR</span></a>のアドベントカレンダーで投稿された、<span class="ascii">Haskell</span>に関する記事を集めてみました。 いちおう機械的に集めたので、それなりに拾えてると思いますが、もし「この記事が無いよ」とか、逆に「<span class="ascii">Haskell</span>ちゃうやんこの記事」ってのがあったら、<a href="https://github.com/haskell-jp/blog/edit/master/preprocessed-site/posts/2017/advent-calendar-2017.md">ここから編集して</a><span class="ascii">PR</span>でも送ってください。</p>
<p>ちなみに「<a href="https://scrapbox.io/miyamoen/Elm_Advent_Calendar_2017_%E3%81%BE%E3%81%A8%E3%82%81"><span class="ascii">Elm Advent Calendar 2017</span> まとめ</a>」という記事が面白かったので、その<span class="ascii">Haskell</span>版オマージュ<span class="ascii">(</span>パクリ<span class="ascii">)</span>です。</p>
<h2 id="haskell-advent-calendar"><span class="ascii">Haskell Advent Calendar</span></h2>
<p><span class="ascii">Qiita</span>の方では<span class="ascii">4</span>つもできましたね。</p>
<ul>
<li><a href="https://qiita.com/advent-calendar/2017/haskell"><span class="ascii">Haskell Advent Calendar 2017 - Qiita</span></a></li>
<li><a href="https://qiita.com/advent-calendar/2017/haskell2"><span class="ascii">Haskell (</span>その<span class="ascii">2) Advent Calendar 2017 - Qiita</span></a></li>
<li><a href="https://qiita.com/advent-calendar/2017/haskell3"><span class="ascii">Haskell (</span>その<span class="ascii">3) Advent Calendar 2017 - Qiita</span></a></li>
<li><a href="https://qiita.com/advent-calendar/2017/haskell4"><span class="ascii">Haskell (</span>その<span class="ascii">4) Advent Calendar 2017 - Qiita</span></a></li>
</ul>
<p>まぁしかし、残念ながらどのカレンダーも埋まってないため<a href="https://qiita.com/advent-calendar/2017/ranking/subscriptions">ランキング</a>圏外となってしまいましたが<span class="ascii">(</span>笑<span class="ascii">)</span></p>
<p>加えて何故か、<span class="ascii">25</span>日が過ぎてからその<span class="ascii">5</span>のカレンダーができるという、なかなか面白い事案が発生しました。</p>
<ul>
<li><a href="https://qiita.com/advent-calendar/2017/haskell5"><span class="ascii">Haskell (</span>その<span class="ascii">5) Advent Calendar 2017 - Qiita</span></a></li>
</ul>
<p>上記のカレンダーの記事以外も含めて、全部で<span class="ascii">104</span>記事もありました。 みんなすごいですね。</p>
<h2 id="記事を集めた">記事を集めた</h2>
<p>超雑にスクレイパーを書いて<span class="ascii">Qiita</span>と<span class="ascii">ADVENTAR</span>のカレンダーをスクレイピングしてきました。 プログラムは以下のリポジトリにあります<span class="ascii">(</span>もちろん<span class="ascii">Haskell</span>で作ったよ<span class="ascii">)</span>。</p>
<ul>
<li><a href="https://github.com/matsubara0507/haskell-advent-calendar"><span class="ascii">matsubara0507/advent-calendar - GitHub</span></a></li>
</ul>
<p>カレンダーのタイトルか、記事のタイトルに「<span class="ascii">Haskell</span>」って単語が入っているやつだけ集めてます。 このプログラムの解説っぽい記事はそのうち自分のとこの記事として挙げる気がする<span class="ascii">(</span>たぶん<span class="ascii">)</span>。</p>
<h2 id="記事たち">記事たち</h2>
<p>分類は温もりのある手作業でやってます。 自然言語処理系が出来れば機械的に分類できたかもしれませんが…</p>
<p>分類違くね？というモノがあれば、<a href="https://github.com/haskell-jp/blog/edit/master/preprocessed-site/posts/2017/advent-calendar-2017.md">ここから編集して</a><span class="ascii">PR</span>でも送ってください。</p>
<p>それでは良いお年を。</p>
<h3 id="ポエム">ポエム</h3>
<p><strong><a href="http://kakkun61.hatenablog.com/entry/2017/12/25/%E3%81%AA%E3%81%9C_Haskell_%E3%81%8C%E5%A5%BD%E3%81%8D%E3%81%AA%E3%81%AE%E3%81%8B">なぜ <span class="ascii">Haskell</span> が好きなのか <span class="ascii">-</span> 趣味はデバッグ……</a></strong><br />
<span class="ascii">by kakkun61 on</span> <a href="http://qiita.com/advent-calendar/2017/haskell3"><span class="ascii">Haskell (</span>その<span class="ascii">3) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/06</span></p>
<p><strong><a href="https://qiita.com/Mizunashi_Mana/items/e82214dfae2765c6839a"><span class="ascii">Haskell</span>副作用ポエム <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by Mizunashi_Mana on</span> <a href="http://qiita.com/advent-calendar/2017/haskell4"><span class="ascii">Haskell (</span>その<span class="ascii">4) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/21</span></p>
<p><strong><a href="https://qiita.com/ababup1192/items/b15cdace30b7fef3338c"><span class="ascii">Haskell</span>を勉強して感動したこと・難しいと思ってること <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by ababup1192 on</span> <a href="http://qiita.com/advent-calendar/2017/haskell"><span class="ascii">Haskell Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/04</span></p>
<h3 id="入門してみた">入門してみた</h3>
<p><strong><a href="https://gist.github.com/sys9kdr/2484ed09f5cb7ea86beae8f5222d9a3c"><span class="ascii">Haskell</span>入門しようとして環境構築で失敗。 <span class="ascii">· GitHub</span></a></strong><br />
<span class="ascii">by sys9kdr on</span> <a href="http://qiita.com/advent-calendar/2017/haskell3"><span class="ascii">Haskell (</span>その<span class="ascii">3) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/05</span></p>
<p><strong><a href="https://qiita.com/lagenorhynque/items/f8b14ff70a26cfd27976"><span class="ascii">Clojurian</span>が<span class="ascii">Haskell</span>で<span class="ascii">Web API</span>開発に入門してみた <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by lagenorhynque on</span> <a href="http://qiita.com/advent-calendar/2017/haskell3"><span class="ascii">Haskell (</span>その<span class="ascii">3) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/19</span></p>
<p><strong><a href="https://qiita.com/hitsujisanmeme/items/e14972cfd349c1149d58">美術の人が考える <span class="ascii">Haskell - Qiita</span></a></strong><br />
<span class="ascii">by hitsujisanmeme on</span> <a href="http://qiita.com/advent-calendar/2017/haskell2"><span class="ascii">Haskell (</span>その<span class="ascii">2) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/14</span></p>
<p><strong><a href="https://qiita.com/brackss1/items/9f9466f160391dc53bba"><span class="ascii">Haskell</span>入門者がライブラリを触っちゃう<span class="ascii">!? - Qiita</span></a></strong><br />
<span class="ascii">by brackss1 on</span> <a href="http://qiita.com/advent-calendar/2017/haskell"><span class="ascii">Haskell Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/22</span></p>
<p><strong><a href="https://qiita.com/ryosukue/items/cf14d817a7067dfd2094"><span class="ascii">Ubuntu</span>、<span class="ascii">Haskell</span>で<span class="ascii">web</span>アプリ手始め <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by ryosukue on</span> <a href="http://qiita.com/advent-calendar/2017/nuco"><span class="ascii">Nuco Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/23</span></p>
<p><strong><a href="https://qiita.com/3nan/items/b89b7383ddb2bac5dda1"><span class="ascii">Haskell</span>をちょこっと紹介（フィボナッチ数列を書いてみる） <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by 3nan on</span> <a href="http://qiita.com/advent-calendar/2017/tecotec"><span class="ascii">TECOTEC Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/23</span></p>
<h3 id="ノウハウ">ノウハウ</h3>
<p><strong><a href="https://www.ncaq.net/2017/12/02/00/00/00/">私の<span class="ascii">Haskell</span>コーディングスタイルガイド<span class="ascii">,</span>改行出来るポイントを紹介 <span class="ascii">- ncaq</span></a></strong><br />
<span class="ascii">by ncaq on</span> <a href="http://qiita.com/advent-calendar/2017/haskell3"><span class="ascii">Haskell (</span>その<span class="ascii">3) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/02</span></p>
<p><strong><a href="https://www.ncaq.net/2017/12/03/00/00/00/">ゲーム販売<span class="ascii">web</span>アプリケーション<span class="ascii">SYAKERAKE</span>を支える技術<span class="ascii">,Haskell</span>と<span class="ascii">Yesod</span>で作られています <span class="ascii">- ncaq</span></a></strong><br />
<span class="ascii">by ncaq on</span> <a href="http://qiita.com/advent-calendar/2017/haskell3"><span class="ascii">Haskell (</span>その<span class="ascii">3) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/03</span></p>
<p><strong><a href="https://www.ncaq.net/2017/12/04/00/00/00/"><span class="ascii">Stackage Server</span>のちょっとした便利な使い方<span class="ascii">,Hoogle</span>をブラウザのカスタム検索エンジンに追加しましょう<span class="ascii">,</span>よく使うパッケージをブックマークする時は<span class="ascii">PackageR</span>の<span class="ascii">URL</span>にしましょう <span class="ascii">- ncaq</span></a></strong><br />
<span class="ascii">by ncaq on</span> <a href="http://qiita.com/advent-calendar/2017/haskell3"><span class="ascii">Haskell (</span>その<span class="ascii">3) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/04</span></p>
<p><strong><a href="http://d.hatena.ne.jp/kazu-yamamoto/20171212/1513050147"><span class="ascii">go</span>な関数</a></strong><br />
<span class="ascii">by kazu_yamamoto on</span> <a href="http://qiita.com/advent-calendar/2017/haskell2"><span class="ascii">Haskell (</span>その<span class="ascii">2) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/01</span></p>
<p><strong><a href="http://fumieval.hatenablog.com/entry/2017/12/19/203500"><span class="ascii">Haskell</span>の<span class="ascii">ABC(Haskell Advent Calendar 6th) -</span> モナドとわたしとコモナド</a></strong><br />
<span class="ascii">by fumieval on</span> <a href="http://qiita.com/advent-calendar/2017/haskell2"><span class="ascii">Haskell (</span>その<span class="ascii">2) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/06</span></p>
<p><strong><a href="https://haskell.jp/blog/posts/2017/windows-gotchas.html"><span class="ascii">Windows</span>で<span class="ascii">Haskell</span>を扱う時によく遭遇するエラーと対処法 <span class="ascii">- Haskell-jp</span></a></strong><br />
<span class="ascii">by igrep on</span> <a href="http://qiita.com/advent-calendar/2017/haskell4"><span class="ascii">Haskell (</span>その<span class="ascii">4) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/14</span></p>
<h3 id="解説">解説</h3>
<p><strong><a href="http://syocy.hatenablog.com/entry/a-tour-of-go-in-haskell"><span class="ascii">A Tour of Go in Haskell</span>を作ったのと、<span class="ascii">Go</span>と<span class="ascii">Haskell</span>の比較 <span class="ascii">- syocy</span>’<span class="ascii">s diary</span></a></strong><br />
<span class="ascii">by syocy on</span> <a href="http://qiita.com/advent-calendar/2017/haskell2"><span class="ascii">Haskell (</span>その<span class="ascii">2) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/03</span></p>
<p><strong><a href="https://qiita.com/cyclone_t/items/8443ed5d4a77f87b1f1b"><span class="ascii">Servant</span>のハンドラに<span class="ascii">ReaderT</span>を適用する <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by cyclone_t on</span> <a href="http://qiita.com/advent-calendar/2017/haskell2"><span class="ascii">Haskell (</span>その<span class="ascii">2) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/15</span></p>
<p><strong><a href="https://qiita.com/wgag/items/11a6e667011d530832e8">スーパーモナドについて <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by wgag on</span> <a href="http://qiita.com/advent-calendar/2017/haskell"><span class="ascii">Haskell Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/10</span></p>
<p><strong><a href="https://tech.recruit-mp.co.jp/dev-tools/post-13981/"><span class="ascii">CircleCI2.0</span>で<span class="ascii">Haskell</span>のテストを実行する – <span class="ascii">PSYENCE:MEDIA</span></a></strong><br />
<span class="ascii">by yukiasai on</span> <a href="http://adventar.org/calendars/2360"><span class="ascii">RECRUIT MARKETING PARTNERS Advent Calendar 2017 - Adventar</span></a> <span class="ascii">12/13</span></p>
<p><strong><a href="https://qiita.com/yukiasai/items/248294a871d40c0dcef6"><span class="ascii">Dokku</span>環境を構築して<span class="ascii">Haskell</span>のアプリケーションをデプロイする <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by yukiasai on</span> <a href="http://adventar.org/calendars/2324"><span class="ascii">Recruit Engineers Advent Calendar 2017 - Adventar</span></a> <span class="ascii">12/07</span></p>
<h3 id="周辺ツールについて">周辺ツールについて</h3>
<p><strong><a href="https://qiita.com/usamik26/items/672ed3c4451402bfc275"><span class="ascii">Haskell Stack</span> とは何をするツールなのか <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by usamik26 on</span> <a href="http://qiita.com/advent-calendar/2017/haskell2"><span class="ascii">Haskell (</span>その<span class="ascii">2) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/12</span></p>
<p><strong><a href="https://haskell.e-bigmoon.com/posts/2017-12-20-stack-ls-command.html"><span class="ascii">stack ls</span> コマンドが追加されます</a></strong><br />
<span class="ascii">by waddlaw on</span> <a href="http://qiita.com/advent-calendar/2017/haskell4"><span class="ascii">Haskell (</span>その<span class="ascii">4) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/08</span></p>
<p><strong><a href="https://haskell.e-bigmoon.com/posts/2017-12-24-stack163.html"><span class="ascii">stack v1.6.3</span> がリリースされました。</a></strong><br />
<span class="ascii">by waddlaw on</span> <a href="http://qiita.com/advent-calendar/2017/haskell4"><span class="ascii">Haskell (</span>その<span class="ascii">4) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/09</span></p>
<p><strong><a href="https://qiita.com/ogata-k/items/23d70250ec42359b6bb5"><span class="ascii">Haskell</span>や周辺ツールについてのリンク集 <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by ogata-k on</span> <a href="http://qiita.com/advent-calendar/2017/haskell4"><span class="ascii">Haskell (</span>その<span class="ascii">4) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/15</span></p>
<p><strong><a href="https://qiita.com/ogata-k/items/2b21326b2b7351bfc28c"><span class="ascii">Haskell</span>の<span class="ascii">stack</span>によるプロジェクトについて <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by ogata-k on</span> <a href="http://qiita.com/advent-calendar/2017/haskell4"><span class="ascii">Haskell (</span>その<span class="ascii">4) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/16</span></p>
<p><strong><a href="https://haskell.e-bigmoon.com/posts/2017-12-27-haddock-grid-table.html"><span class="ascii">haddock</span> に <span class="ascii">Grid Table</span> 記法が追加されました</a></strong><br />
<span class="ascii">by waddlaw on</span> <a href="http://qiita.com/advent-calendar/2017/haskell5"><span class="ascii">Haskell (</span>その<span class="ascii">5) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/02</span></p>
<p><strong><a href="https://haskell.e-bigmoon.com/posts/2017-12-23-stack161.html">カスタムスナップショットの紹介</a></strong><br />
<span class="ascii">by waddlaw on</span> <a href="http://qiita.com/advent-calendar/2017/haskell"><span class="ascii">Haskell Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/14</span></p>
<p><strong><a href="https://myuon.github.io/posts/haskell-project-setup/"><span class="ascii">Haskell</span>プロジェクトを始めるにあたって <span class="ascii">- The curse of</span> λ</a></strong><br />
<span class="ascii">by myuon_myon on</span> <a href="http://qiita.com/advent-calendar/2017/myuon_myon_cs">一人<span class="ascii">Computer Science Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/15</span></p>
<h3 id="ライブラリ紹介">ライブラリ紹介</h3>
<p><strong><a href="https://qiita.com/jabaraster/items/e8ebbe6d25b535947aba"><span class="ascii">servant+persistent</span>を利用する <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by jabaraster on</span> <a href="http://qiita.com/advent-calendar/2017/haskell3"><span class="ascii">Haskell (</span>その<span class="ascii">3) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/07</span></p>
<p><strong><a href="https://qiita.com/makoraru/items/596729de09d6aeb81e5a"><span class="ascii">Yampa</span>で<span class="ascii">Functional Reactive</span>な認知行動療法ボット <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by makoraru on</span> <a href="http://qiita.com/advent-calendar/2017/haskell3"><span class="ascii">Haskell (</span>その<span class="ascii">3) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/13</span></p>
<p><strong><a href="https://nnwww.github.io/blog/post/haskell_ml/"><span class="ascii">Haskell</span>で機械学習を実装しようと思った過去の自分へ</a></strong><br />
<span class="ascii">by _Nnwww on</span> <a href="http://qiita.com/advent-calendar/2017/haskell2"><span class="ascii">Haskell (</span>その<span class="ascii">2) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/23</span></p>
<p><strong><a href="https://qiita.com/cyclone_t/items/52ad44cfbb4603e123f3"><span class="ascii">Haskell</span>・<span class="ascii">Servant+Persistent/Esqueleto</span>で作る実用<span class="ascii">WebAPI (1) Servant</span>の基本 <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by cyclone_t on</span> <a href="http://qiita.com/advent-calendar/2017/haskell4"><span class="ascii">Haskell (</span>その<span class="ascii">4) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/11</span></p>
<p><strong><a href="https://matsubara0507.github.io/posts/2017-12-09-extensible-effects-step-by-step.html"><span class="ascii">Extensible Effects</span> ステップ・バイ・ステップ</a></strong><br />
<span class="ascii">by matsubara0507 on</span> <a href="http://qiita.com/advent-calendar/2017/haskell"><span class="ascii">Haskell Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/09</span></p>
<p><strong><a href="https://qiita.com/Mizunashi_Mana/items/115855bf2af9b9970198"><span class="ascii">Haskell</span>のパーサライブラリまとめ <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by Mizunashi_Mana on</span> <a href="http://qiita.com/advent-calendar/2017/haskell"><span class="ascii">Haskell Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/11</span></p>
<p><strong><a href="https://www.zaneli.com/blog/20171213"><span class="ascii">Haskell</span>入門者<span class="ascii">LT</span>会で自作ライブラリ<span class="ascii">network-voicetext</span>の話をしてきた <span class="ascii">|</span> ザネリは列車を見送った</a></strong><br />
<span class="ascii">by zaneli@github on</span> <a href="http://qiita.com/advent-calendar/2017/haskell"><span class="ascii">Haskell Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/13</span></p>
<p><strong><a href="https://qiita.com/satosystems/items/32bf104a041c8cc13809"><span class="ascii">Haskell</span> と <span class="ascii">SQLite - Qiita</span></a></strong><br />
<span class="ascii">by satosystems on</span> <a href="http://qiita.com/advent-calendar/2017/haskell"><span class="ascii">Haskell Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/16</span></p>
<p><strong><a href="https://qiita.com/masahiro_sakai/items/6a989d5b898a08f17821">部分構造の共有を観測する<span class="ascii">data-reify - Qiita</span></a></strong><br />
<span class="ascii">by masahiro_sakai on</span> <a href="http://qiita.com/advent-calendar/2017/haskell"><span class="ascii">Haskell Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/21</span></p>
<h3 id="作ってみた">作ってみた</h3>
<p><strong><a href="https://matsubara0507.github.io/posts/2017-12-13-elm-and-haskell-for-elmer.html"><span class="ascii">Elm</span> と <span class="ascii">Haskell</span> で作る <span class="ascii">ToDo</span> アプリ</a></strong><br />
<span class="ascii">by matsubara0507 on</span> <a href="http://qiita.com/advent-calendar/2017/elm"><span class="ascii">Elm Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/13</span></p>
<p><strong><a href="http://abc10946.hatenablog.com/entry/2017/12/18/014203"><span class="ascii">Haskell</span>に入門して<span class="ascii">1</span>年位経ったのでライフゲームを作ってみた話 <span class="ascii">- abc10946</span>の日記</a></strong><br />
<span class="ascii">by ABC10946 on</span> <a href="http://qiita.com/advent-calendar/2017/haskell3"><span class="ascii">Haskell (</span>その<span class="ascii">3) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/18</span></p>
<p><strong><a href="http://d.hatena.ne.jp/wvogel00/20171222/1513924995">仕事で<span class="ascii">Haskell</span>を使いたいなら外堀から</a></strong><br />
<span class="ascii">by hxf_vogel on</span> <a href="http://qiita.com/advent-calendar/2017/haskell3"><span class="ascii">Haskell (</span>その<span class="ascii">3) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/22</span></p>
<p><strong><a href="http://blog.nakaji.me/slack-api-bloodhound-servant/"><span class="ascii">slack-api + bloodhound + servant</span> で<span class="ascii">bot+</span>αを作る</a></strong><br />
<span class="ascii">by nakaji-dayo on</span> <a href="http://qiita.com/advent-calendar/2017/haskell2"><span class="ascii">Haskell (</span>その<span class="ascii">2) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/07</span></p>
<p><strong><a href="http://secret-garden.hatenablog.com/entry/2017/12/16/000000">【<span class="ascii">Haskell (</span>その<span class="ascii">2) Advent Calendar 2017</span>】<span class="ascii">Vim</span> から <span class="ascii">Hoogle</span> の検索が出来るプラグインをつくった【<span class="ascii">16</span>日目】 <span class="ascii">- Secret Garden(Instrumental)</span></a></strong><br />
<span class="ascii">by pink_bangbi on</span> <a href="http://qiita.com/advent-calendar/2017/haskell2"><span class="ascii">Haskell (</span>その<span class="ascii">2) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/16</span></p>
<p><strong><a href="https://qiita.com/rounddelta/items/807866bdaa81c3057ac0">お天気<span class="ascii">Bot</span> で理解する <span class="ascii">Haskell</span> の便利パッケージ <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by rounddelta on</span> <a href="http://qiita.com/advent-calendar/2017/haskell2"><span class="ascii">Haskell (</span>その<span class="ascii">2) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/25</span></p>
<p><strong><a href="https://qiita.com/arowM/items/e59442120ad3c1071c57"><span class="ascii">Haskell ochintin-daicho</span> で年末調整プログラミング <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by arowM on</span> <a href="http://qiita.com/advent-calendar/2017/haskell"><span class="ascii">Haskell Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/12</span></p>
<p><strong><a href="https://qiita.com/lotz/items/1aa6cf18aa193f40c647">作って学ぶ<span class="ascii">Bitcoin</span>！ゼロから作る<span class="ascii">SPV</span>ウォレット <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by lotz on</span> <a href="http://qiita.com/advent-calendar/2017/haskell"><span class="ascii">Haskell Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/18</span></p>
<p><strong><a href="http://tune.hateblo.jp/entry/2017/12/27/031803">優秀な秘書を雇いました<span class="ascii">!!! - Creatable a =&gt; a -&gt; IO b</span></a></strong><br />
<span class="ascii">by tokiwoousaka@github on</span> <a href="http://qiita.com/advent-calendar/2017/haskell"><span class="ascii">Haskell Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/20</span></p>
<p><strong><a href="https://qiita.com/satosystems/items/c1c0feef87345a9df69d"><span class="ascii">Haskell</span> における遅延ファイル読み込みとリソースリーク <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by satosystems on</span> <a href="http://qiita.com/advent-calendar/2017/haskell"><span class="ascii">Haskell Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/23</span></p>
<p><strong><a href="https://haskell.jp/blog/posts/2017/typesafe-precure2.html">タイプセーフプリキュア！を支える技術 その<span class="ascii">2 - Haskell-jp</span></a></strong><br />
<span class="ascii">by igrep on</span> <a href="http://qiita.com/advent-calendar/2017/haskell"><span class="ascii">Haskell Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/24</span></p>
<p><strong><a href="https://www.ncaq.net/2017/12/19/00/00/00/"><span class="ascii">Haskell</span>による<span class="ascii">web</span>スクレイピングの方法を<span class="ascii">dic-nico-intersection-pixiv</span>を例に書く <span class="ascii">- ncaq</span></a></strong><br />
<span class="ascii">by</span> エヌユル <span class="ascii">on</span> <a href="http://adventar.org/calendars/2105"><span class="ascii">Web</span>スクレイピング <span class="ascii">Advent Calendar 2017 - Adventar</span></a> <span class="ascii">12/19</span></p>
<p><strong><a href="https://matsubara0507.github.io/posts/2017-12-02-re-adventar-slack-bot-part1.html"><span class="ascii">Re:</span> ゼロから作る <span class="ascii">ADVENTAR</span> の <span class="ascii">Slack Bot (Haskell</span> 編<span class="ascii">)</span></a></strong><br />
<span class="ascii">by</span> ひげ <span class="ascii">on</span> <a href="http://adventar.org/calendars/2300">群馬大学電子計算機研究会 <span class="ascii">IGGG Advent Calendar 2017 - Adventar</span></a> <span class="ascii">12/02</span></p>
<h3 id="処理系">処理系</h3>
<p><strong><a href="http://ilyaletre.hatenablog.com/entry/2017/12/10/195016"><span class="ascii">GHC</span>の中間言語<span class="ascii">Core</span>への脱糖を覗き見る <span class="ascii">- Hash</span> λ <span class="ascii">Bye</span></a></strong><br />
<span class="ascii">by ilyaletre on</span> <a href="http://qiita.com/advent-calendar/2017/haskell3"><span class="ascii">Haskell (</span>その<span class="ascii">3) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/11</span></p>
<p><strong><a href="http://fujiy.hatenablog.com/entry/type-inference-1"><span class="ascii">Haskell</span>の型システムを書く<span class="ascii">(1) -</span> 純粋技術メモ</a></strong><br />
<span class="ascii">by fujiy on</span> <a href="http://qiita.com/advent-calendar/2017/haskell"><span class="ascii">Haskell Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/03</span></p>
<p><strong><a href="https://qiita.com/takoeight0821/items/9a1c3eb5b0f292026596"><span class="ascii">GHC</span>での中置演算子のパース <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by takoeight0821 on</span> <a href="http://qiita.com/advent-calendar/2017/haskell"><span class="ascii">Haskell Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/06</span></p>
<p><strong><a href="https://uhideyuki.sakura.ne.jp/studs/index.cgi/ja/HindleyMilnerInHaskell">型システムを学ぼう！</a></strong><br />
<span class="ascii">by unnohideyuki on</span> <a href="http://qiita.com/advent-calendar/2017/haskell"><span class="ascii">Haskell Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/15</span></p>
<h3 id="言語機能">言語機能</h3>
<p><strong><a href="https://matsubara0507.github.io/posts/2017-12-12-backpack-memo.html"><span class="ascii">Haskell Backpack</span> 覚え書き</a></strong><br />
<span class="ascii">by matsubara0507 on</span> <a href="http://qiita.com/advent-calendar/2017/haskell3"><span class="ascii">Haskell (</span>その<span class="ascii">3) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/12</span></p>
<p><strong><a href="https://qiita.com/aiya000/items/b802531c58c161cd245f">にこ、希と一緒に学ぶ<span class="ascii">Haskell</span>（番外）「あまり知られていない<span class="ascii">GHC</span>拡張の紹介」 <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by aiya000 on</span> <a href="http://qiita.com/advent-calendar/2017/haskell3"><span class="ascii">Haskell (</span>その<span class="ascii">3) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/21</span></p>
<p><strong><a href="https://qiita.com/ruicc/items/e2879c44eba77b1e7170"><span class="ascii">Levity polymorphism</span>について軽く <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by ruicc on</span> <a href="http://qiita.com/advent-calendar/2017/haskell2"><span class="ascii">Haskell (</span>その<span class="ascii">2) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/02</span></p>
<p><strong><a href="https://qiita.com/ryoppy/items/7156d587da2e6ae7e605"><span class="ascii">Kind</span>について <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by ryoppy on</span> <a href="http://qiita.com/advent-calendar/2017/haskell2"><span class="ascii">Haskell (</span>その<span class="ascii">2) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/11</span></p>
<p><strong><a href="http://khibino.hatenadiary.jp/entry/2017/12/18/081814"><span class="ascii">OverloadedLabels</span> と <span class="ascii">Haskell Relational Record - khibino blog</span></a></strong><br />
<span class="ascii">by khibino on</span> <a href="http://qiita.com/advent-calendar/2017/haskell2"><span class="ascii">Haskell (</span>その<span class="ascii">2) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/18</span></p>
<p><strong><a href="https://qiita.com/thimura/items/0d289c231f9aceac61dc"><span class="ascii">GHC 8.2</span> 以前で <span class="ascii">FFI</span> を使う際に注意すること <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by thimura on</span> <a href="http://qiita.com/advent-calendar/2017/haskell"><span class="ascii">Haskell Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/19</span></p>
<h3 id="型">型</h3>
<p><strong><a href="https://qiita.com/junjihashimoto@github/items/31f245f5e0138e5fac7e">依存型の紹介と応用としての<span class="ascii">Clash</span>の紹介 <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by junjihashimoto@github on</span> <a href="http://qiita.com/advent-calendar/2017/haskell2"><span class="ascii">Haskell (</span>その<span class="ascii">2) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/19</span></p>
<p><strong><a href="https://qiita.com/aiya000/items/81e8424c8a3ee23586a6">ことり、穂乃果と一緒に学ぶ<span class="ascii">Haskell</span>（入門）その<span class="ascii">6</span>「高階データ型」 <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by aiya000 on</span> <a href="http://qiita.com/advent-calendar/2017/haskell2"><span class="ascii">Haskell (</span>その<span class="ascii">2) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/24</span></p>
<p><strong><a href="https://qiita.com/mod_poppo/items/50ad2c0ee66171cc1ee9">型を実行時に作る：怖くないリフレクション <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by mod_poppo on</span> <a href="http://qiita.com/advent-calendar/2017/haskell4"><span class="ascii">Haskell (</span>その<span class="ascii">4) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/19</span></p>
<p><strong><a href="https://qiita.com/HirotoShioi/items/5474119ba3682448c109"><span class="ascii">Haskell</span>における型クラス制約の役割 <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by HirotoShioi on</span> <a href="http://qiita.com/advent-calendar/2017/haskell5"><span class="ascii">Haskell (</span>その<span class="ascii">5) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/04</span></p>
<h3 id="base"><span class="ascii">Base</span></h3>
<p><strong><a href="https://www.ncaq.net/2017/12/01/00/00/01/"><span class="ascii">Haskell</span>の<span class="ascii">State</span>の必要性が<span class="ascii">,</span>プログラミング言語の処理系を書いた時にわかったので<span class="ascii">,State</span>の良さを語ります <span class="ascii">- ncaq</span></a></strong><br />
<span class="ascii">by ncaq on</span> <a href="http://qiita.com/advent-calendar/2017/haskell3"><span class="ascii">Haskell (</span>その<span class="ascii">3) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/01</span></p>
<p><strong><a href="https://qiita.com/grainrigi/items/f45b586b4013ffc3814e"><span class="ascii">Haskell - $</span>の仕組みを覗いてみよう <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by grainrigi on</span> <a href="http://qiita.com/advent-calendar/2017/haskell3"><span class="ascii">Haskell (</span>その<span class="ascii">3) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/08</span></p>
<p><strong><a href="https://blog.b123400.net/functor/"><span class="ascii">Mapping things</span></a></strong><br />
<span class="ascii">by b123400 on</span> <a href="http://qiita.com/advent-calendar/2017/haskell3"><span class="ascii">Haskell (</span>その<span class="ascii">3) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/10</span></p>
<p><strong><a href="https://qiita.com/elipmoc101/items/4590210c9946ee2fd4c5"><span class="ascii">Maybe</span>自作から学ぶ<span class="ascii">Haskell</span>！ <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by elipmoc101 on</span> <a href="http://qiita.com/advent-calendar/2017/haskell3"><span class="ascii">Haskell (</span>その<span class="ascii">3) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/16</span></p>
<p><strong><a href="https://keiorogiken.wordpress.com/2017/12/24/list%E3%81%A7%E9%81%8A%E3%81%B6/"><span class="ascii">List</span>で遊ぶ <span class="ascii">|</span> 慶應義塾大学ロボット技術研究会</a></strong><br />
<span class="ascii">by mt_caret on</span> <a href="http://qiita.com/advent-calendar/2017/haskell4"><span class="ascii">Haskell (</span>その<span class="ascii">4) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/20</span></p>
<p><strong><a href="https://qiita.com/Lugendre/items/6b4a8c8a9c85fcdcb292"><span class="ascii">Arrow</span>を理解する <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by Lugendre on</span> <a href="http://qiita.com/advent-calendar/2017/haskell"><span class="ascii">Haskell Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/08</span></p>
<h3 id="アルゴリズムとデータ構造">アルゴリズムとデータ構造</h3>
<p><strong><a href="https://qiita.com/ryohji/items/d8bdba1648978c308cdd">探索問題を <span class="ascii">Haskell</span> で解く <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by ryohji on</span> <a href="http://qiita.com/advent-calendar/2017/haskell3"><span class="ascii">Haskell (</span>その<span class="ascii">3) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/09</span></p>
<p><strong><a href="https://qiita.com/v97ug/items/d6dd50a2b6b84a9e4d41">巡回セールスマン問題を遺伝的アルゴリズムとデータ構造を使って<span class="ascii">Haskell</span>で解く！ <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by v97ug on</span> <a href="http://qiita.com/advent-calendar/2017/haskell3"><span class="ascii">Haskell (</span>その<span class="ascii">3) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/15</span></p>
<p><strong><a href="https://qiita.com/as_capabl/items/39e55e7a035dea4dc93a">いつから<span class="ascii">Haskell</span>の<span class="ascii">5</span>行クイックソートが遅いと錯覚していた？ <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by as_capabl on</span> <a href="http://qiita.com/advent-calendar/2017/haskell3"><span class="ascii">Haskell (</span>その<span class="ascii">3) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/20</span></p>
<p><strong><a href="https://qiita.com/rst76/items/a7dd81b522a09d1b9986">キューの効率的な実装 または私は如何にして<span class="ascii">Haskell</span>を止めて<span class="ascii">F#</span>を愛するようになったか <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by rst76 on</span> <a href="http://qiita.com/advent-calendar/2017/haskell2"><span class="ascii">Haskell (</span>その<span class="ascii">2) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/21</span></p>
<p><strong><a href="http://autotaker.hatenablog.com/entry/2017/12/21/125153">永続リアルタイムキューの<span class="ascii">Haskell</span>実装と計算量解析 <span class="ascii">- autotaker</span>’<span class="ascii">s blog</span></a></strong><br />
<span class="ascii">by autotaker1984 on</span> <a href="http://qiita.com/advent-calendar/2017/haskell2"><span class="ascii">Haskell (</span>その<span class="ascii">2) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/22</span></p>
<p><strong><a href="https://qiita.com/Aruneko/items/dee20161358e7c39e27a"><span class="ascii">Zipper</span>に挑む <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by Aruneko on</span> <a href="http://qiita.com/advent-calendar/2017/haskell"><span class="ascii">Haskell Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/02</span></p>
<p><strong><a href="https://qiita.com/nobsun/items/27fe53516cbb90ba02e2"><span class="ascii">Tree:</span> 親子関係の付け替え <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by nobsun on</span> <a href="http://qiita.com/advent-calendar/2017/haskell"><span class="ascii">Haskell Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/07</span></p>
<p><strong><a href="http://zodi-g12.hatenablog.com/entry/2017/12/06/133951">コラッツの問題を<span class="ascii">Haskell</span>で書いてみた <span class="ascii">- Zodiac</span>の黙示録</a></strong><br />
<span class="ascii">by zodi_G12 on</span> <a href="http://adventar.org/calendars/2377"><span class="ascii">IQ</span>が<span class="ascii">1 Advent Calendar 2017 - Adventar</span></a> <span class="ascii">12/06</span></p>
<h3 id="数学科学">数学・科学</h3>
<p><strong><a href="https://qiita.com/tezca686/items/855236ccdda584ee8ebb"><span class="ascii">[Haskell]</span> とびだせ！<span class="ascii">Hask</span>圏 <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by tezca686 on</span> <a href="http://qiita.com/advent-calendar/2017/haskell3"><span class="ascii">Haskell (</span>その<span class="ascii">3) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/14</span></p>
<p><strong><a href="https://qiita.com/makoraru/items/768089b2aab1dde47593">区間代数と無限小と無限大 <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by makoraru on</span> <a href="http://qiita.com/advent-calendar/2017/haskell3"><span class="ascii">Haskell (</span>その<span class="ascii">3) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/17</span></p>
<p><strong><a href="https://qiita.com/as_capabl/items/2031fe28e577e77dc269">しりとりの圏の回答、または定理証明<span class="ascii">Haskell</span>を少しだけ <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by as_capabl on</span> <a href="http://qiita.com/advent-calendar/2017/haskell2"><span class="ascii">Haskell (</span>その<span class="ascii">2) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/04</span></p>
<p><strong><a href="https://qiita.com/hiratara/items/6265b5d4791144bee33b">しりとりの圏の実装<span class="ascii">(</span>未完<span class="ascii">) - Qiita</span></a></strong><br />
<span class="ascii">by hiratara on</span> <a href="http://qiita.com/advent-calendar/2017/haskell2"><span class="ascii">Haskell (</span>その<span class="ascii">2) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/05</span></p>
<p><strong><a href="https://qiita.com/kyamaz/items/67ec5c7d39e62c1de91d">量子コンピューターにはモナドがよく似合う <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by kyamaz on</span> <a href="http://qiita.com/advent-calendar/2017/haskell2"><span class="ascii">Haskell (</span>その<span class="ascii">2) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/17</span></p>
<p><strong><a href="https://qiita.com/makoraru/items/ab891a60d4dfe4bbf649"><span class="ascii">Haskell</span>と層 <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by makoraru on</span> <a href="http://qiita.com/advent-calendar/2017/haskell2"><span class="ascii">Haskell (</span>その<span class="ascii">2) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/20</span></p>
<p><strong><a href="https://qiita.com/NaOHaq/items/ba490cc1e1ab890cb399"><span class="ascii">Haskell</span>上で有限体を使って遊ぶ <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by NaOHaq on</span> <a href="http://qiita.com/advent-calendar/2017/haskell4"><span class="ascii">Haskell (</span>その<span class="ascii">4) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/22</span></p>
<p><strong><a href="https://qiita.com/cutsea110/items/69889a99d30b627bc04a"><span class="ascii">somehow-morphisms on fixed point written in Haskell - Qiita</span></a></strong><br />
<span class="ascii">by cutsea110 on</span> <a href="http://qiita.com/advent-calendar/2017/haskell"><span class="ascii">Haskell Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/01</span></p>
<p><strong><a href="https://qiita.com/kyamaz/items/e49b07e05e871a22246c">量子プログラミングは<span class="ascii">Haskell</span>で <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by kyamaz on</span> <a href="http://qiita.com/advent-calendar/2017/quantum">量子コンピュータ <span class="ascii">Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/17</span></p>
<h3 id="docker"><span class="ascii">Docker</span></h3>
<p><strong><a href="https://qiita.com/t10471/items/4afa598e1be5d6c7cc1f"><span class="ascii">Haskell</span>でも<span class="ascii">Go</span>みたいにシングルバイナリでアプリケーションをデプロイしたい <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by t10471 on</span> <a href="http://qiita.com/advent-calendar/2017/haskell2"><span class="ascii">Haskell (</span>その<span class="ascii">2) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/09</span></p>
<p><strong><a href="https://qiita.com/algas/items/fde155abbc9d8ae3f8c9"><span class="ascii">Haskell on Docker</span> で <span class="ascii">Portable CLI</span> を作ろう <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by algas on</span> <a href="http://qiita.com/advent-calendar/2017/haskell"><span class="ascii">Haskell Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/05</span></p>
<h3 id="eta"><span class="ascii">Eta</span></h3>
<p><strong><a href="https://qiita.com/aiya000/items/881d5f7e04b1178e7764"><span class="ascii">Eta</span>で表現されるデータ型としての<span class="ascii">Java</span>クラスとその継承関係 <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by aiya000 on</span> <a href="http://qiita.com/advent-calendar/2017/haskell"><span class="ascii">Haskell Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/25</span></p>
<p><strong><a href="https://qiita.com/aiya000/items/7dc0cb8694de0675088e"><span class="ascii">Haskell (Eta)</span> で<span class="ascii">JavaFX</span>の<span class="ascii">EDSL</span>を作る雰囲気を醸し出す <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by aiya000 on</span> <a href="http://adventar.org/calendars/2546">プロ生ちゃん <span class="ascii">Advent Calendar 2017 - Adventar</span></a> <span class="ascii">12/25</span></p>
<h3 id="書籍紹介">書籍紹介</h3>
<p><strong><a href="https://qiita.com/waddlaw/items/dd926462d398c4cbd019">これから <span class="ascii">Haskell</span> を学ぶ人のための書籍紹介 <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by waddlaw on</span> <a href="http://qiita.com/advent-calendar/2017/haskell4"><span class="ascii">Haskell (</span>その<span class="ascii">4) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/01</span></p>
<p><strong><a href="https://qiita.com/Aruneko/items/e72f7c6ee49159751cba"><span class="ascii">2017</span>年に「すごい<span class="ascii">Haskell</span>たのしく学ぼう」を読む <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by Aruneko on</span> <a href="http://qiita.com/advent-calendar/2017/haskell4"><span class="ascii">Haskell (</span>その<span class="ascii">4) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/13</span></p>
<p><strong><a href="https://qiita.com/YoshikuniJujo/items/0708f108bf53a216a61a">拙書「<span class="ascii">Haskell</span> 教養としての関数型プログラミング」の紹介 <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by YoshikuniJujo on</span> <a href="http://qiita.com/advent-calendar/2017/haskell4"><span class="ascii">Haskell (</span>その<span class="ascii">4) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/24</span></p>
<p><strong><a href="https://mt-caret.github.io/blog/posts/2017-12-01-book01.html"><span class="ascii">mt_caret.log -</span> 本<span class="ascii">1</span> “<span class="ascii">Haskell Programming from first principles</span>”</a></strong><br />
<span class="ascii">by mt_caret on</span> <a href="http://adventar.org/calendars/2433">本 <span class="ascii">Advent Calendar 2017 - Adventar</span></a> <span class="ascii">12/01</span></p>
<h3 id="翻訳記事">翻訳記事</h3>
<p><strong><a href="https://qiita.com/Pythonissam/items/ace180b1b78876f1c190"><span class="ascii">Haskell</span> で暗号学的ハッシュを扱う <span class="ascii">(</span>和訳<span class="ascii">) - Qiita</span></a></strong><br />
<span class="ascii">by rounddelta on</span> <a href="http://qiita.com/advent-calendar/2017/haskell4"><span class="ascii">Haskell (</span>その<span class="ascii">4) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/02</span></p>
<p><strong><a href="https://qiita.com/rounddelta/items/d767f36d544427a9c60d"><span class="ascii">Haskell</span> のアプリケーション向けに軽量の <span class="ascii">Docker</span>イメージ を作る <span class="ascii">(</span>和訳<span class="ascii">) - Qiita</span></a></strong><br />
<span class="ascii">by rounddelta on</span> <a href="http://qiita.com/advent-calendar/2017/haskell4"><span class="ascii">Haskell (</span>その<span class="ascii">4) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/03</span></p>
<p><strong><a href="https://qiita.com/rounddelta/items/8b7d2a200a932e761fa3"><span class="ascii">Haskell</span> 初心者へのアドバイス <span class="ascii">(</span>和訳<span class="ascii">) - Qiita</span></a></strong><br />
<span class="ascii">by rounddelta on</span> <a href="http://qiita.com/advent-calendar/2017/haskell4"><span class="ascii">Haskell (</span>その<span class="ascii">4) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/04</span></p>
<p><strong><a href="https://qiita.com/rounddelta/items/31b835b493abf5be3549">将来も使えるテストスイート <span class="ascii">(</span>和訳<span class="ascii">) - Qiita</span></a></strong><br />
<span class="ascii">by rounddelta on</span> <a href="http://qiita.com/advent-calendar/2017/haskell4"><span class="ascii">Haskell (</span>その<span class="ascii">4) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/05</span></p>
<p><strong><a href="https://qiita.com/rounddelta/items/27c12237d9ef1c5569ba"><span class="ascii">VS Code</span> で <span class="ascii">Ghcid</span> を使う <span class="ascii">(</span>和訳<span class="ascii">) - Qiita</span></a></strong><br />
<span class="ascii">by rounddelta on</span> <a href="http://qiita.com/advent-calendar/2017/haskell4"><span class="ascii">Haskell (</span>その<span class="ascii">4) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/06</span></p>
<p><strong><a href="https://qiita.com/rounddelta/items/4584f5486c1061c93f0b"><span class="ascii">HLint</span> のルールを理解する <span class="ascii">(</span>和訳<span class="ascii">) - Qiita</span></a></strong><br />
<span class="ascii">by rounddelta on</span> <a href="http://qiita.com/advent-calendar/2017/haskell4"><span class="ascii">Haskell (</span>その<span class="ascii">4) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/07</span></p>
<p><strong><a href="https://qiita.com/Pythonissam/items/41f8121795f5d8954802"><span class="ascii">SPJ</span> の憂鬱 <span class="ascii">(</span>和訳<span class="ascii">) - Qiita</span></a></strong><br />
<span class="ascii">by rounddelta on</span> <a href="http://qiita.com/advent-calendar/2017/haskell4"><span class="ascii">Haskell (</span>その<span class="ascii">4) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/17</span></p>
<p><strong><a href="https://qiita.com/reotasosan/items/d9fdfab10e24eabfefda"><span class="ascii">SPJ</span>と<span class="ascii">Haskell</span>のエコシステム（和訳） <span class="ascii">- Qiita</span></a></strong><br />
<span class="ascii">by reotasosan on</span> <a href="http://qiita.com/advent-calendar/2017/haskell4"><span class="ascii">Haskell (</span>その<span class="ascii">4) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/18</span></p>
<p><strong><a href="https://haskell.e-bigmoon.com/posts/2017-12-27-haskell-performance-debugging"><span class="ascii">Haskell</span> のパフォーマンスをデバッグする</a></strong><br />
<span class="ascii">by waddlaw on</span> <a href="http://qiita.com/advent-calendar/2017/haskell5"><span class="ascii">Haskell (</span>その<span class="ascii">5) Advent Calendar 2017 - Qiita</span></a> <span class="ascii">12/01</span></p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2018/unordered-containers-hash-dos.html" lang="ja">hashdos脆弱性とunordered-containers</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2017/windows-gotchas.html" style="margin-left: auto;" lang="ja">WindowsでHaskellを扱う時によく遭遇するエラーと対処法</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>WindowsでHaskellを扱う時によく遭遇するエラーと対処法</title>
    <link href="https://haskell.jp/blog/posts/2017/windows-gotchas.html" />
    <id>https://haskell.jp/blog/posts/2017/windows-gotchas.html</id>
    <published>2017-12-25T00:00:00Z</published>
    <updated>2017-12-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>この記事は、<a href="https://qiita.com/advent-calendar/2017/haskell4"><span class="ascii">Haskell (</span>その<span class="ascii">4) Advent Calendar 2017</span></a><span class="ascii">14</span>日目の記事です。<br />
枠が空いていたので埋めるために登録しました。<br />
長くかかった割には実験自体は失敗気味な、<a href="https://haskell.jp/blog/posts/2017/typesafe-precure2.html">昨日のこちらの記事</a>よりは有用な情報じゃないかと思います。<br />
ほかの言語でもありそうな話ですしね。</p>
<p>すごく簡潔にまとめるとこの間の下記のツイートに収まるのですが、もう少し丁寧に補足するために書きます。</p>
<blockquote class="twitter-tweet" data-lang="ja">
<p lang="ja" dir="ltr">
学んだことをまとめると<br><span class="ascii">- Invalid character</span>と言われたら<span class="ascii">chcp 65001</span>しよう<br><span class="ascii">- Permission Denied</span>と言われたらビルドし直そう<br><span class="ascii">-</span> 日本語のパスが混ざらないよう気をつけよう<br><span class="ascii">- C</span>のライブラリーはものによる<br>ですか。多分 <a href="https://twitter.com/hashtag/haskell?src=hash&amp;ref_src=twsrc%5Etfw"><span class="ascii">#haskell</span></a> 以外でも有益な話。
</p>
— <span class="ascii">Yuji Yamamoto:</span> 山本悠滋 <span class="ascii">(</span><span class="citation" data-cites="igrep"><span class="ascii">@igrep</span></span><span class="ascii">)</span> <a href="https://twitter.com/igrep/status/938056578934042626?ref_src=twsrc%5Etfw"><span class="ascii">2017</span>年<span class="ascii">12</span>月<span class="ascii">5</span>日</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<h1 id="invalid-characterと言われたらchcp-65001しよう"><span class="ascii">Invalid character</span>と言われたら<span class="ascii">chcp 65001</span>しよう</h1>
<p>恐らく一番高確率で遭遇する <span class="ascii">&amp;</span> 知らないと回避できないのがこれ。<br />
あ、ほらまた<span class="ascii">hakyll</span>でビルドしたら起きた！</p>
<pre><code>&gt; stack exec -- site rebuild
...
  [ERROR] preprocessed-site\posts/2017/01-first.md: hGetContents: invalid argument (invalid byte sequence)</code></pre>
<p><span class="ascii">GHC</span>がファイルを読み書きする時に使う<a href="https://www.stackage.org/haddock/lts-10.0/base-4.10.1.0/System-IO.html#t:Handle"><code>Handle</code></a>というオブジェクトには、文字コードの情報が含まれています。</p>
<p>これは<span class="ascii">Ruby</span>の<a href="https://docs.ruby-lang.org/ja/latest/class/IO.html"><code>IO</code></a>や<span class="ascii">Perl</span>のファイルハンドラーにあるような仕組みと大体似ていて、<code>Handle</code>といったデータの「入り口」を表すオブジェクトに文字コードを紐付けることで、外から入ってくる文字列の文字コードを確実に内部の統一された文字コードに変換してくれます。<br />
<span class="ascii">Haskell</span>の<code>Char</code>型の場合は<span class="ascii">UTF-32</span>（この場合その言い方でよかったっけ？）のはずです。</p>
<p>この<code>Handle</code>に紐付ける文字コード、当然のごとくデフォルトでは<span class="ascii">OS</span>のロケール設定に従って設定されるようになってまして、日本語版の<span class="ascii">Windows</span>ではそう、<span class="ascii">Windows-31J</span>（またの名を<span class="ascii">CP932</span>）ですね。<br />
でも今はもうすぐ<span class="ascii">2018</span>年。あなたが「メモ帳」でプログラムを書く人でもない限り、新しく作るファイルの大半は<span class="ascii">UTF-8</span>でしょう。<br />
<span class="ascii">UTF-8</span>と<span class="ascii">Windows-31J</span>は全然違う体系の文字コードなので、<span class="ascii">UTF-8</span>なファイルを<span class="ascii">Windows-31J</span>のファイルとして読もうとしてもうまくいかないわけです。<br />
冒頭にあげた<code>invalid byte sequence</code>というエラーはまさにそうした場合に起こるエラーです。<br />
ファイルの読み書きだけでなく標準入出力でもしばしば発生するので覚えておいてください。</p>
<h2 id="対策">対策</h2>
<h3 id="ユーザーとして出くわした場合">ユーザーとして出くわした場合</h3>
<p>多くの場合、このエラーは以下のコマンドをあらかじめ実行しておけば回避できます。</p>
<pre><code>&gt; chcp 65001
&gt; stack exec -- site rebuild
... 動くはず！</code></pre>
<p>これは、現在開いているコマンドプロンプトで一時的に文字コードを切り替えるコマンドです。<br />
<code>65001</code>という数字が<span class="ascii">UTF-8</span>を指しているようです。<br />
もとに戻したい場合は<code>chcp 932</code>と実行しましょう。</p>
<pre><code>&gt; chcp 932</code></pre>
<p>どうやら「<span class="ascii">CP932</span>」の「<span class="ascii">932</span>」はここで出てくる「<span class="ascii">932</span>」と同じものを指しているようですね！</p>
<p>どういう仕様なのか分かりませんが、このコマンド、<span class="ascii">MSYS2</span>の<span class="ascii">bash</span>でも使用できます。<br />
ただし<code>chcp</code>コマンドは<code>C:\Windows\System32\</code>という、<span class="ascii">MSYS2</span>ユーザーにとってはあまり<code>PATH</code>に入れたくない場所に入っています。<br />
このディレクトリーには、<code>find.exe</code>など、<span class="ascii">Unix</span>な方が好んで使うコマンドと同じ名前の非互換なコマンドがゴロゴロ転がっているのです！</p>
<p>なので私は<span class="ascii">MSYS2</span>を使う時は<code>C:\Windows\System32\</code>は<code>PATH</code>から抜いています。<br />
私と同じような方は下記のようにフルパスで実行しましょう。</p>
<pre><code>/c/Windows/System32/chcp.com 932</code></pre>
<h3 id="それでもダメな場合あるいはライブラリーなどの開発者として出くわした場合">それでもダメな場合、あるいはライブラリーなどの開発者として出くわした場合</h3>
<p>残念ながら、<code>chcp 65001</code>してもこのエラーが消えないことはあります<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>。<br />
私の推測なんですが、どうも<code>chcp 65001</code>は<code>chcp 65001</code>したコマンドプロンプト（とか<span class="ascii">bash</span>）の孫プロセス（つまり、あなたが入力したコマンドの子プロセス）には届かないことがあるようです。</p>
<p>そんなときは、実際にエラーが起きているコマンドの開発元にバグ報告するか、自分で直してみましょう。<br />
バグ報告する場合は、「<code>chcp 932</code>してから実行してみて」とお願いすると、バグ報告を受けた開発者も再現しやすくて助かるかも知れません（残念ながら私はやったことがありません）。<br />
自分で直す場合、いろいろ方法はありますが、対象の<code>Handle</code>オブジェクトの文字コードを変えることで対処するのが、一番直接的で確実でしょう。</p>
<p>この問題は<code>Handle</code>に設定された文字コードと実際にやりとりされる文字列の文字コードに食い違いが発生しているため起こるものなのですから、適切な文字コードに変えてしまえばいいのです。<br />
状況にもよりますがエラーが起きた<code>Handle</code>が普通の<span class="ascii">UTF-8</span>なファイルを読み書きするものである場合、下記のようにすれば、問題は回避できるはずです。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">import</span> <span class="dt">System.IO</span> (hSetEncoding)</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="kw">import</span> <span class="dt">GHC.IO.Encoding</span> (utf8)</a>
<a class="sourceLine" id="cb5-3" data-line-number="3"></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">hSetEncoding handle utf8</a></code></pre></div>
<p>それから、<a href="https://github.com/haskell/haddock/pull/566">実際に私が<span class="ascii">haddock</span>のバグを直した時</a>を例に標準出力（または標準エラー出力）でこのエラーが発生した時の対応も紹介しておきます。<br />
コードだけ貼り付けると、下記のようにすれば少なくともエラーが起こらないようにすることはできます（<a href="https://github.com/haskell/haddock/pull/566/commits/855118ee45e323fd9b2ee32103c7ba3eb1fbe4f2">このコミット</a>とほぼ同じ内容です）。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">{-# LANGUAGE CPP #-}</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">import</span> <span class="dt">System.IO</span> (hSetEncoding, stdout)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="ot">#if defined(mingw32_HOST_OS)</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="kw">import</span> <span class="dt">GHC.IO.Encoding.CodePage</span> (mkLocaleEncoding)</a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="kw">import</span> <span class="dt">GHC.IO.Encoding.Failure</span> (<span class="dt">CodingFailureMode</span>(<span class="dt">TransliterateCodingFailure</span>))</a>
<a class="sourceLine" id="cb6-8" data-line-number="8"><span class="ot">#endif</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9"></a>
<a class="sourceLine" id="cb6-10" data-line-number="10"><span class="fu">...</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11"></a>
<a class="sourceLine" id="cb6-12" data-line-number="12"><span class="ot">#if defined(mingw32_HOST_OS)</span></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">  liftIO <span class="fu">$</span> hSetEncoding stdout <span class="fu">$</span> mkLocaleEncoding <span class="dt">TransliterateCodingFailure</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14"><span class="ot">#endif</span></a></code></pre></div>
<p><span class="ascii">Windows</span>でしか使用できないモジュールを<code>import</code>している関係上、<span class="ascii">CPP</span>のマクロが混ざって読みにくいですが、重要な部分だけ切り出すと、</p>
<pre><code>hSetEncoding stdout $ mkLocaleEncoding TransliterateCodingFailure</code></pre>
<p>とすればよいのです。</p>
<p>一つ一つ解説しましょう。<br />
まず<code>hSetEncoding</code>は先ほども触れたとおり指定した<code>Handle</code>の文字コードを変更する関数です。<br />
そして<code>stdout</code>は名前の通り標準出力を表す<code>Handle</code>です。<br />
最後の<code>mkLocaleEncoding TransliterateCodingFailure</code>ですが、これは<span class="ascii">Windows</span>で設定された文字コード（<code>chcp</code>された文字コードと同じ）を作って、「もし（<span class="ascii">Unicode</span>から、あるいは<span class="ascii">Unicode</span>に）変換できない文字があった場合、エラーにせず、それっぽい文字に変換する」という設定で返す、という意味です。</p>
<p>結果、<code>chcp 932</code>な状態で<span class="ascii">GHC</span>のエラーメッセージにも使われる</p>
<pre><code>↓この文字
• No instance for (Transformation Nagisa CardCommune_Mepple)
↑</code></pre>
<p>が、</p>
<pre><code>? No instance for (Transformation Nagisa CardCommune_Mepple)</code></pre>
<p>のように、クエスチョンマークに変換されるようになります。そう、日本語の<span class="ascii">Windows</span>で<span class="ascii">GHC</span>をお使いの方は一度は目にした「<span class="ascii">?</span>」ではないでしょうか😅<br />
つまり<span class="ascii">GHC</span>はデフォルトで<code>hSetEncoding stderr $ mkLocaleEncoding TransliterateCodingFailure</code>しているものと推測されます。<br />
いずれにせよ、エラーでプログラムが異常終了しないだけマシですね。</p>
<p>更に補足すると、<span class="ascii">GHC</span>の文字コードについてより詳しい情報は、<a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/GHC-IO-Encoding.html"><span class="ascii">GHC.IO.Encoding</span>のドキュメント</a>をご覧ください。</p>
<h1 id="permission-deniedと言われたらビルドし直そう"><span class="ascii">Permission Denied</span>と言われたらビルドし直そう</h1>
<p>雑なまとめと言いつつ最初の一つ目が長くなってしまいましたが、ここからは簡単に言います。<br />
<span class="ascii">Windows</span>で<code>stack build</code>なり<code>ghc</code>なり<code>elm-make</code>なりとにかくいろいろ動かしていると、「<span class="ascii">Permission Denied</span>」と言ったエラー（あるいはこれと似たようなメッセージのエラー）に出遭います。<br />
正直に言って私は原因はサッパリ分かってないのですが、このエラーは大抵の場合何度も同じコマンドを実行すれば再現しませんでした。<br />
一度や二度ではめげず、繰り返すのがポイントです 😅<br />
問題が起きているディレクトリーをウィルス対策ソフトのスキャン対象から外してみるとか、<span class="ascii">Dropbox</span>の同期を一時的に止めてみる、といったこともやってみるといいかもしれません。</p>
<p>あ、あと、「<span class="ascii">Directory not empty</span>」みたいなのもあったかな。これは同類のはずです。</p>
<h1 id="cのライブラリーは-まぁ頑張れ"><span class="ascii">C</span>のライブラリーは… まぁ、頑張れ。</h1>
<p><span class="ascii">Pure Haskell</span>なライブラリーであれば大体<span class="ascii">OK</span>なんですが、残念ながら<span class="ascii">C</span>のライブラリー（<code>lib***</code>みたいな名前でよく<span class="ascii">OS</span>のパッケージマネージャーに登録されているやつですね）に依存したライブラリーは、<span class="ascii">Windows</span>でインストールするのは結構トラブることが多いです。<br />
まぁ、これは<span class="ascii">Haskell</span>に限った話ではないでしょう。</p>
<p>対応方法は私が知る限り完全にケースバイケースなので、ここでは知っている対応例をいくつか挙げておきましょう。</p>
<ul>
<li><span class="ascii">HDBC-sqlite3:</span>
<ul>
<li><a href="https://qiita.com/igrep/items/d947ab871eb5b20b57e4"><span class="ascii">Windows</span>版<span class="ascii">stack</span>でも<span class="ascii">HDBC-sqlite3</span>をビルドする <span class="ascii">- Qiita</span></a></li>
<li><a href="http://hiratara.hatenadiary.jp/entry/2017/01/29/110100"><span class="ascii">MSYS2</span>で<span class="ascii">HDBC-sqlite3</span>をコンパイル <span class="ascii">-</span> 北海道苫小牧市出身の初老<span class="ascii">PG</span>が書くブログ</a></li>
</ul></li>
<li><a href="https://teratail.com/questions/102462"><span class="ascii">Haskell - Haskell</span>にて<span class="ascii">stack</span>で<span class="ascii">iconv</span>パッケージを利用する方法【<span class="ascii">Windows</span>環境】<span class="ascii">(102462)</span>｜<span class="ascii">teratail</span></a></li>
</ul>
<p>以上です！<br />
それでは<span class="ascii">2018</span>年も<span class="ascii">Haskell on Windows 10</span>で<span class="ascii">Happy Hacking!! WSL</span>なんて知らないぜ！🏁🏁🏁</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>敢えて脚注に書きますが、<a href="http://eta-lang.org/"><span class="ascii">Eta</span></a>のコンパイラーをビルドしている時（のはず）、<code>chcp 65001</code>でもダメで<code>chcp 20127</code>ならうまくいったことがあります。<br />
<code>chcp 20127</code>は<span class="ascii">US-ASCII</span>に切り替えるためのコマンドですが、やっぱり<span class="ascii">Eta</span>の開発者の手元（？）ではそうなっているからなのでしょうか…？<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2017/advent-calendar-2017.html" lang="ja">Haskell Advent Calendar 2017 まとめ</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2017/typesafe-precure2.html" style="margin-left: auto;" lang="ja">タイプセーフプリキュア！を支える技術 その2</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>

</feed>
