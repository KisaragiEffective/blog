<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Haskell-jp Blog</title>
    <link href="https://haskell.jp/blog/feed.xml" rel="self" />
    <link href="https://haskell.jp/blog" />
    <id>https://haskell.jp/blog/feed.xml</id>
    <author>
        <name>Haskell-jp</name>
        <email></email>
    </author>
    <updated>2020-06-11T00:00:00Z</updated>
    <entry>
    <title>Strict拡張を使用する際の注意点</title>
    <link href="https://haskell.jp/blog/posts/2020/strict-gotchas.html" />
    <id>https://haskell.jp/blog/posts/2020/strict-gotchas.html</id>
    <published>2020-06-11T00:00:00Z</published>
    <updated>2020-06-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p><span class="ascii">Haskell</span>は他の多くのプログラミング言語と異なった特徴を備えており、しばしばそれらが議論を呼ぶことがあります。その中でも特によく俎上に上がるのが、遅延評価です。遅延評価は、適切に扱えば不要な計算を行わず、計算資源を節約してくれるステキな仕組みですが、一歩使い方を間違うと「サンク」という「これから実行する<small>（かも知れない）</small>計算」を表すオブジェクトが無駄に作られてしまい、却ってメモリー消費量が増えてしまう、などといった問題を抱えています。この現象は「スペースリーク」と呼ばれ、かつて<a href="https://qiita.com/advent-calendar/2015/haskell-space-leaks">専門の<span class="ascii">Advent Calendar</span></a>が作られたことがあるほど、<span class="ascii">Haskeller</span>達の関心を集めてきました。</p>
<p>そんな<span class="ascii">Haskeller</span>達の悩みの種を軽減しようと、<span class="ascii">GHC 8.0</span>以降、<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#strict-by-default-pattern-bindings"><code>Strict</code></a>と<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#strict-data"><code>StrictData</code></a>という言語拡張が搭載されました。これらの拡張は、大雑把に言うと、</p>
<ul>
<li><code>StrictData</code><span class="ascii">:</span> 値コンストラクターにおいて、引数の値が弱頭正規形（<span class="ascii">Weak Head Normal Form</span>。以降慣習に従い「<span class="ascii">WHNF</span>」と呼びます）まで評価されるようになる</li>
<li><code>Strict</code><span class="ascii">:</span> <code>StrictData</code>の効果に加え、あらゆる関数の引数やローカル変数の定義において、パターンマッチで代入した変数の値が<span class="ascii">WHNF</span>まで評価されるようになる</li>
</ul>
<p>というものです。</p>
<p>このうち、<code>StrictData</code>は比較的リスクが少なく大変有用<small>（もはや標準であって欲しいぐらい）</small>という声をよく聞きますが<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>、<code>Strict</code>については様々な問題点があることが知られています。今回はその各種問題点をまとめて共有することで、思い切って<code>Strict</code>を有効にするときに参考になる情報を提供したいと思います！</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#前提知識とその参考資料" title="前提知識とその参考資料">前提知識とその参考資料</a></li>
<li><a href="#サンプルコードの試し方" title="サンプルコードの試し方">サンプルコードの試し方</a></li>
<li><a href="#case-1-where句だろうとなんだろうと評価" title="case-1-where句だろうとなんだろうと評価"><span class="ascii">Case 1:</span> <code>where</code>句だろうとなんだろうと評価</a></li>
<li><a href="#case-2-ポイントフリースタイルかどうかで変わる" title="case-2-ポイントフリースタイルかどうかで変わる"><span class="ascii">Case 2:</span> ポイントフリースタイルかどうかで変わる！</a></li>
<li><a href="#case-3-内側のパターンはやっぱりダメ" title="case-3-内側のパターンはやっぱりダメ"><span class="ascii">Case 3:</span> 内側のパターンはやっぱりダメ</a></li>
<li><a href="#case-4-foldrに渡す関数" title="case-4-foldrに渡す関数"><span class="ascii">Case 4:</span> <code>foldr</code>に渡す関数</a></li>
<li><a href="#case-5-undefinedを受け取るメソッド" title="case-5-undefinedを受け取るメソッド"><span class="ascii">Case 5:</span> <code>undefined</code>を受け取るメソッド</a></li>
<li><a href="#おわりに-やっぱりstrictは使う使わない" title="おわりに-やっぱりstrictは使う使わない">おわりに<span class="ascii">:</span> やっぱり<code>Strict</code>は使う？使わない？</a></li>
</ul>
</div>
</div>
<h1 id="前提知識とその参考資料"><span class="link-to-here-outer"><a href="#前提知識とその参考資料" title="前提知識とその参考資料"><span class="link-to-here">Link to<br />
here</span></a></span>前提知識とその参考資料</h1>
<p>以下の知識について、ざっくり理解しているものとして進めます。参考になりそうな日本語のページも付記したので、ご覧ください。</p>
<ul>
<li><span class="ascii">Haskell</span>の遅延評価について
<ul>
<li><a href="https://itchyny.hatenablog.com/entry/20130209/1360417348">実装して理解する遅延評価の仕組み 〜 <span class="ascii">thunk</span>を絵に描いて理解しよう・<span class="ascii">JavaScript</span>で<span class="ascii">Haskell</span>を実装！？ <span class="ascii">-</span> プログラムモグモグ</a>が詳しくて分かりやすいでしょう</li>
</ul></li>
<li><span class="ascii">Haskell</span>の正格評価、および<code>BangPatterns</code>について
<ul>
<li><a href="https://haskell.e-bigmoon.com/posts/2018/06-25-all-about-strictness">正格性のすべて <span class="ascii">(</span>翻訳<span class="ascii">)</span></a></li>
</ul></li>
<li><code>Strict</code>と<code>StrictData</code>について
<ul>
<li><a href="https://kazu-yamamoto.hatenablog.jp/entry/20151117/1447726679"><span class="ascii">Strict Haskell -</span> あどけない話</a></li>
</ul></li>
<li>その他、<a href="https://qiita.com/advent-calendar/2015/haskell-space-leaks"><span class="ascii">Haskell</span>スペースリーク <span class="ascii">Advent Calendar 2015 - Qiita</span></a>の記事にも有用なものがたくさんあります。</li>
</ul>
<h1 id="サンプルコードの試し方"><span class="link-to-here-outer"><a href="#サンプルコードの試し方" title="サンプルコードの試し方"><span class="link-to-here">Link to<br />
here</span></a></span>サンプルコードの試し方</h1>
<p>これから紹介するコードは、すべて<a href="https://github.com/haskell-jp/blog/tree/master/examples/2020/strict-gotchas">このブログのリポジトリーの、<code>examples</code>ディレクトリー</a>に置いておきました。下記のコマンドを実行すれば実際に試すことができます<small>（一部実行する際のコマンドが異なりますので、適宜例示します）</small>。</p>
<pre><code>git clone https://github.com/haskell-jp/blog.git
cd blog/examples/2020/strict-gotchas
stack exec runghc -- &lt;これから紹介するコードのファイル&gt;.hs</code></pre>
<p>実際に試すときは<code>--ghc-arg=-XStrict</code>というオプションを<code>runghc</code>に付けた場合と付けなかった場合両方で実行して、違いを確かめてみてください。</p>
<p>なお、使用した<span class="ascii">GHC</span>のバージョンは<span class="ascii">8.10.1</span>で、<span class="ascii">OS</span>は<span class="ascii">Windows 10 ver. 1909</span>です。</p>
<h1 id="case-1-where句だろうとなんだろうと評価"><span class="link-to-here-outer"><a href="#case-1-where句だろうとなんだろうと評価" title="case-1-where句だろうとなんだろうと評価"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Case 1:</span> <code>where</code>句だろうとなんだろうと評価</h1>
<p>サンプル<span class="ascii">:</span> <a href="https://github.com/haskell-jp/blog/blob/master/examples/2020/strict-gotchas/where.hs"><span class="ascii">where.hs</span></a></p>
<p>最初のケースは、遅延評価で当たり前に享受できていたメリットが、<code>Strict</code>を有効にしている状態では得られなくなってしまう、というものです。<a href="https://qiita.com/pxfnc/items/a26bda6d11402daba675"><span class="ascii">pxfnc</span>さんの<span class="ascii">Strict</span>拡張でハマったお話</a>という記事でも紹介されてはいますが、まとめ記事なのでここでも改めて取り上げます。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1">main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> div10 <span class="dv">0</span></a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="ot">div10 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-4" title="4">div10 n</a>
<a class="sourceLine" id="cb2-5" title="5">  <span class="op">|</span> n <span class="op">==</span> <span class="dv">0</span>    <span class="ot">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb2-6" title="6">  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> result</a>
<a class="sourceLine" id="cb2-7" title="7"> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-8" title="8">  result <span class="ot">=</span> <span class="dv">10</span> <span class="ot">`div`</span> n</a></code></pre></div>
<p>ご覧のとおり、本当にほとんど<span class="ascii">pxfnc</span>さんの記事のサンプルそのままで恐縮ですが、このプログラム、👇のように<code>Strict</code>拡張を有効にして実行するとエラーが起こります。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" title="1"><span class="op">&gt;</span> <span class="ex">stack</span> exec -- runghc --ghc-arg=-XStrict where.hs</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="ex">where.hs</span>: divide by zero</a></code></pre></div>
<p>一方、<code>Strict</code>拡張を有効にしなかった場合、エラーは起こりません。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" title="1"><span class="op">&gt;</span> <span class="ex">stack</span> exec -- runghc where.hs</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="ex">0</span></a></code></pre></div>
<p>なぜこんなことが起こるのでしょう？</p>
<p>これは、<code>Strict</code>拡張がパターンマッチで代入したあらゆる変数の値を<span class="ascii">WHNF</span>まで評価するようになった結果、<code>where</code>句で代入した変数まで必ず<span class="ascii">WHNF</span>まで評価してしまうために発生したエラーです。すなわち、<code>where</code>における、</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1">  result <span class="ot">=</span> <span class="dv">10</span> <span class="ot">`div`</span> n</a></code></pre></div>
<p>までもが、</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1">  <span class="op">!</span>result <span class="ot">=</span> <span class="dv">10</span> <span class="ot">`div`</span> n</a></code></pre></div>
<p>と<span class="ascii">Bang</span>パターンを付けた代入であるかのように解釈されたのです<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>。</p>
<p>こうなると、<code>result</code>を使用しないケース、すなわち<code>n == 0</code>の場合であっても<code>result</code>に <small>（<span class="ascii">WHNF</span>まで評価した）</small>値を代入するのに必要な計算は実行され、結果<code>10 `div` 0</code>が計算されようとして<code>divide by zero</code>が発生するのです。</p>
<p>⚠️<code>where</code>句は関数定義の後ろの方に書くという性格上、見落としがちかも知れません。注意しましょう。</p>
<h1 id="case-2-ポイントフリースタイルかどうかで変わる"><span class="link-to-here-outer"><a href="#case-2-ポイントフリースタイルかどうかで変わる" title="case-2-ポイントフリースタイルかどうかで変わる"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Case 2:</span> ポイントフリースタイルかどうかで変わる！</h1>
<p>サンプル<span class="ascii">:</span> <a href="https://github.com/haskell-jp/blog/blob/master/examples/2020/strict-gotchas/const.hs"><span class="ascii">const.hs</span></a></p>
<p>続いて、<span class="ascii">Haskell</span>に慣れた方なら誰もが一度は試したくなる、ポイントフリースタイルに関する落とし穴です。まずは次の二つの関数をご覧ください。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="ot">dontReferArgs ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb7-2" title="2">dontReferArgs <span class="ot">=</span> <span class="fu">const</span></a>
<a class="sourceLine" id="cb7-3" title="3"></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="ot">referArgs ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb7-5" title="5">referArgs x _ <span class="ot">=</span> x</a></code></pre></div>
<p>この関数、どちらもやっていることは<code>const</code>と変わりません。<code>dontReferArgs</code>は<code>const</code>をそのまま使うことでポイントフリースタイルにしていますが、<code>referArgs</code>は自前で引数に言及することで<code>const</code>と同等の定義となっています。ポイントフリースタイルに変えると言うことは原則として元の関数の挙動を変えないワケですから、<code>dontReferArgs</code>と<code>referArgs</code>の意味は変わらないはず、ですよね<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>？</p>
<p>ところがこれらの関数を<code>Strict</code>拡張を有効にした上で定義すると、なんと挙動が異なってしまいます！</p>
<p>使用例<span class="ascii">:</span></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb8-2" title="2">main <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-3" title="3">  <span class="fu">print</span> <span class="op">$</span> dontReferArgs <span class="st">&quot;dontReferArgs&quot;</span> (<span class="fu">undefined</span><span class="ot"> ::</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb8-4" title="4">  <span class="fu">print</span> <span class="op">$</span> referArgs <span class="st">&quot;referArgs&quot;</span> (<span class="fu">undefined</span><span class="ot"> ::</span> <span class="dt">Int</span>)</a></code></pre></div>
<p>実行結果（<span class="ascii">Strict</span>拡張を有効にしなかった場合）<span class="ascii">:</span></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb9-1" title="1"><span class="op">&gt;</span> <span class="ex">stack</span> exec runghc const.hs</a>
<a class="sourceLine" id="cb9-2" title="2"><span class="st">&quot;dontReferArgs&quot;</span></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="st">&quot;referArgs&quot;</span></a></code></pre></div>
<p>実行結果（<span class="ascii">Strict</span>拡張を有効にした場合）<span class="ascii">:</span></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb10-1" title="1"><span class="op">&gt;</span> <span class="ex">stack</span> exec -- runghc --ghc-arg=-XStrict const.hs</a>
<a class="sourceLine" id="cb10-2" title="2"><span class="st">&quot;dontReferArgs&quot;</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="ex">const.hs</span>: Prelude.undefined</a>
<a class="sourceLine" id="cb10-4" title="4"><span class="ex">CallStack</span> (from HasCallStack)<span class="bu">:</span></a>
<a class="sourceLine" id="cb10-5" title="5">  <span class="ex">error</span>, called at libraries\base\GHC\Err.hs:79:14 in base:GHC.Err</a>
<a class="sourceLine" id="cb10-6" title="6">  <span class="ex">undefined</span>, called at const.hs:10:34 in main:Main</a></code></pre></div>
<p>はい、<code>where</code>句のケースと同様、<code>Strict</code>拡張を有効にした場合、例外が発生してしまいました❗️<code>Strict</code>拡張を有効にした結果、意図せず例外を発生させる値<small>（今回の場合<code>undefined</code>）</small>が評価されてしまったのです。</p>
<p>例外を発生させた関数はそう、ポイントフリースタイルでない、<code>referArgs</code>関数の方です！なぜ<code>referArgs</code>でのみ例外が発生してしまったのかというと、<code>referArgs</code>が<code>Strict</code>拡張を有効にしたモジュールで、引数に言及<small>（パターンマッチ）</small>しているからです。<code>Strict</code>拡張を有効にした結果「あらゆる関数やローカル変数の定義において、パターンマッチで代入した変数の値」が評価されるとおり、<code>referArgs</code>の引数<code>x</code>・<code>_</code>も必ず評価されるようになり、このような例外が発生したのです。たとえ使用しない変数<code>_</code>でも関係ありません！</p>
<p>そのため、原因の本質は引数に言及<small>（パターンマッチ）</small>しているか否かであり、<code>Prelude</code>の<code>const</code>を使用しているか否かではありません。こちら👇のように引数に言及した上で<code>const</code>を使っても、結果は同じなのです。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="ot">referArgsByConst ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb11-2" title="2">referArgsByConst x y <span class="ot">=</span> <span class="fu">const</span> x y</a></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="fu">print</span> <span class="op">$</span> referArgsByConst <span class="st">&quot;referArgsByConst&quot;</span> (<span class="fu">undefined</span><span class="ot"> ::</span> <span class="dt">Int</span>)</a></code></pre></div>
<p>一方、<code>dontReferArgs</code>については、引数に言及せず、<code>Prelude</code>にある<code>const</code>をそのまま使っています。<code>Strict</code>拡張はあくまでも「パターンマッチした変数」のみを<span class="ascii">WHNF</span>まで評価するものであり、あらゆる関数が正格に呼び出されるわけではありません。なので通常の<code>Prelude</code>における<code>const</code>と同様、<code>dontReferArgs</code>も第<span class="ascii">2</span>引数は評価しないため、<code>undefined</code>を渡しても例外は起こらなかったのです。</p>
<p>このことは、「<strong><code>Strict</code>拡張を有効にしているモジュールの中でも、<code>Strict</code>を有効にしていないモジュール<small>（この場合は<code>Prelude</code>）</small>から<code>import</code>した関数は、引数を正格に評価しない</strong>」という忘れてはならないポイントも示しています。例えば<code>const</code>よりももっと頻繁に使われるであろう、言及する引数を一つ削除する演算子の代表、関数合成<code>.</code>を使ったケースを考えてみてください。</p>
<p>ポイントフリースタイルに慣れた方なら、関数適用<code>$</code>を次👇のように使って定義した<code>f</code>を見ると、</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1">f xs <span class="ot">=</span> <span class="fu">map</span> (<span class="op">+</span> <span class="dv">3</span>) <span class="op">$</span> <span class="fu">filter</span> (<span class="op">&gt;</span> <span class="dv">2</span>) xs</a>
<a class="sourceLine" id="cb13-2" title="2"></a>
<a class="sourceLine" id="cb13-3" title="3"><span class="co">-- あるいは、`$`を使わないでこのように書いた場合も:</span></a>
<a class="sourceLine" id="cb13-4" title="4">f xs <span class="ot">=</span> <span class="fu">map</span> (<span class="op">+</span> <span class="dv">3</span>) (<span class="fu">filter</span> (<span class="op">&gt;</span> <span class="dv">2</span>) xs)</a></code></pre></div>
<p>こちら👇のように書き換えたくなってうずうずするでしょう。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1">f <span class="ot">=</span> <span class="fu">map</span> (<span class="op">+</span> <span class="dv">3</span>) <span class="op">.</span> <span class="fu">filter</span> (<span class="op">&gt;</span> <span class="dv">2</span>)</a></code></pre></div>
<p>しかし、<code>Strict</code>を有効にしたモジュールでこのような書き換えを行うと、<code>f</code>の挙動が変わってしまいます。引数<code>.</code>を使って書き換える前は、引数<code>xs</code>に言及していたところ<code>.</code>を使って引数<code>xs</code>に言及しなくなったからです。<code>filter</code>も<code>map</code>も<code>Strict</code>拡張を有効にしたモジュールで定義されているわけではないので、引数を正格に評価しないんですね。結果、こうした書き換えによって、<strong><code>Strict</code>拡張を有効にしていても意図せず遅延評価してしまう</strong>、というリスクがあるので、リファクタリングの際はくれぐれも気をつけてください<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>。ざっくりまとめると、<code>Strict</code>拡張を有効にしているモジュールでは、「引数や変数を宣言することすなわち<span class="ascii">WHNF</span>まで評価すること」、あるいは「引数や変数を宣言しなければ、評価されない」と意識しましょう。</p>
<p>ちなみに、<code>referArgs</code>における<code>_</code>のように「<code>Strict</code>拡張を有効にした場合さえ、使用していない引数が評価されてしまうのは困る！」という場合は、引数名の前にチルダ<code>~</code>を付けてください。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="ot">referArgs ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb15-2" title="2">referArgs x <span class="op">~</span>_ <span class="ot">=</span> x</a></code></pre></div>
<h1 id="case-3-内側のパターンはやっぱりダメ"><span class="link-to-here-outer"><a href="#case-3-内側のパターンはやっぱりダメ" title="case-3-内側のパターンはやっぱりダメ"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Case 3:</span> 内側のパターンはやっぱりダメ</h1>
<p>サンプル<span class="ascii">:</span> 今回は<span class="ascii">GHCi</span>ですべて紹介するのでサンプルはありません。</p>
<p>続いては、<code>Strict</code>拡張のドキュメントでも触れられている、入れ子になったパターンマッチにおける問題を紹介します。一言で言うと、<code>let (a, b) = ...</code>のような、データ構造<small>（この場合タプルですね）</small>の「内側」に対するパターンマッチは、<code>Strict</code>拡張を有効にしていても正格に評価しないよ、という話です。</p>
<p>例えば、下記のコードを<code>Strict</code>拡張付きで実行しても、パターンマッチしている<code>a</code>・<code>b</code>ともに代入した時点では正格評価されず、<code>error "a"</code>・<code>error "b"</code>による例外はいずれも発生しません。次のコードを<span class="ascii">GHCi</span>で試してみてください。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="op">&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XStrict</span></a>
<a class="sourceLine" id="cb16-2" title="2"><span class="op">&gt;</span> (a, b) <span class="ot">=</span> (<span class="fu">error</span> <span class="st">&quot;a&quot;</span>, <span class="fu">error</span> <span class="st">&quot;b&quot;</span>)</a>
<a class="sourceLine" id="cb16-3" title="3"><span class="co">-- 何も起きない</span></a></code></pre></div>
<p>先ほどの節における「<code>Strict</code>拡張を有効にしているモジュールでは、『引数や変数を宣言することすなわち<span class="ascii">WHNF</span>まで評価すること」』、あるいは『引数や変数を宣言しなければ、評価されない』と意識しましょう」という主張を真に受けてしまうと、意図せず遅延評価させてしまい、ハマりそうです😰。⚠️繰り返しますが「<strong>内側のパターンにおける変数は正格評価されない</strong>」ということも意識してください。</p>
<p>一方、<code>StrictData</code>や正格性フラグを用いるなどして、各要素を正格評価するよう定義した値コンストラクターでは、ちゃんと評価して例外を発生させます。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="op">&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XStrict</span></a>
<a class="sourceLine" id="cb17-2" title="2"><span class="op">&gt;</span> <span class="kw">data</span> <span class="dt">MyTuple</span> a b <span class="ot">=</span> <span class="dt">MyTuple</span> a b <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb17-3" title="3"><span class="op">&gt;</span> <span class="kw">let</span> <span class="dt">MyTuple</span> a b <span class="ot">=</span> <span class="dt">MyTuple</span> (<span class="fu">error</span> <span class="st">&quot;a&quot;</span>) (<span class="fu">error</span> <span class="st">&quot;b&quot;</span>)</a>
<a class="sourceLine" id="cb17-4" title="4"><span class="op">***</span> <span class="dt">Exception</span><span class="op">:</span> b</a>
<a class="sourceLine" id="cb17-5" title="5"><span class="dt">CallStack</span> (from <span class="dt">HasCallStack</span>)<span class="op">:</span></a>
<a class="sourceLine" id="cb17-6" title="6">  <span class="fu">error</span>, called at <span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">10</span><span class="op">:</span><span class="dv">40</span> <span class="kw">in</span> interactive<span class="op">:</span><span class="dt">Ghci7</span></a></code></pre></div>
<p><code>Strict</code>拡張を有効にすると<code>StrictData</code>も自動的に有効になるので、👆における<code>MyTuple</code>値コンストラクターは各要素を正格評価するようになったわけです。なので<code>Strict</code>拡張を有効にしたモジュールにおいて、なおかつそこで定義した型で完結している限りは平和でしょう。</p>
<p>ただし、<span class="ascii">GHCi</span>で試す場合に特に注意していただきたいのですが、<span class="ascii">GHCi</span>で<strong><code>let</code>をつけないでパターンマッチした場合は正格評価されない</strong>、という点に注意してください。<code>let</code>をつけないとトップレベルでの定義と見なされるからです。<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#strict-by-default-pattern-bindings"><span class="ascii">Strict</span>拡張のドキュメント</a>にも、「<span class="ascii">Top level bindings are unaffected by</span> <code>Strict</code>」とありますとおり、トップレベルでの定義は例外扱いされているのです。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1"><span class="op">&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XStrict</span></a>
<a class="sourceLine" id="cb18-2" title="2"><span class="op">&gt;</span> <span class="kw">data</span> <span class="dt">MyTuple</span> a b <span class="ot">=</span> <span class="dt">MyTuple</span> a b <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb18-3" title="3"><span class="op">&gt;</span> <span class="dt">MyTuple</span> a b <span class="ot">=</span> <span class="dt">MyTuple</span> (<span class="fu">error</span> <span class="st">&quot;a&quot;</span>) (<span class="fu">error</span> <span class="st">&quot;b&quot;</span>)</a>
<a class="sourceLine" id="cb18-4" title="4"><span class="co">-- 何も起きない</span></a></code></pre></div>
<h1 id="case-4-foldrに渡す関数"><span class="link-to-here-outer"><a href="#case-4-foldrに渡す関数" title="case-4-foldrに渡す関数"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Case 4:</span> <code>foldr</code>に渡す関数</h1>
<p>サンプル<span class="ascii">:</span> <a href="https://github.com/haskell-jp/blog/blob/master/examples/2020/strict-gotchas/stackoverflow-foldr.hs"><span class="ascii">stackoverflow-foldr.hs</span></a></p>
<p>ここの話はちょっと難しいので、先に守るべきルールを述べておきます。</p>
<p>「遅延評価する関数を受け取る前提の高階関数に、（<code>Strict</code>拡張などで）引数を正格に評価するよう定義された関数を渡すのは止めましょう。」</p>
<p>なんだかこう書くと半ばトートロジーのようにも聞こえますが、より具体的には、例えば<code>foldr</code>に引数を正格に評価するよう定義された関数を渡すのは止めましょう、という話です。<code>Strict</code>拡張を有効にした状態では、ラムダ式にも注意しないといけないもポイントです。</p>
<p>※あらかじめおことわり<span class="ascii">:</span> この節のお話は、あくまでもリストに対する<code>foldr</code>の場合のお話です。他の<code>Foldable</code>な型では必ずしも当てはまらないのでご注意ください。</p>
<p>論より証拠で、サンプルコードの中身（抜粋）とその実行結果を見てみましょう。</p>
<pre class="main"><code>-- ...
evaluate . length $ foldr (:) [] [1 .. size]
putStrLn &quot;DONE: foldr 1&quot;

evaluate . length $ foldr (\x z -&gt; x : z) [] [1 .. size]
putStrLn &quot;DONE: foldr 2&quot;</code></pre>
<p>今回のサンプルコードを実行する際は、<span class="ascii">GHC</span>のランタイムオプションを設定して、スタック領域のサイズを減らしてください。そうでなければ、処理するリストがあまり大きくないので<code>Strict</code>拡張を有効にしても問題の現象は再現されないでしょう<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a>。<a href="https://stackoverflow.com/questions/29339643/how-can-i-pass-rts-options-to-runghc">こちらの<span class="ascii">Stackoverflow</span>の質問</a>曰く、<code>runghc</code>で実行する際にランタイムオプションを設定する場合は、<code>GHCRTS</code>環境変数を使用するしかないそうです。</p>
<p>実行結果（<span class="ascii">Strict</span>拡張を有効にしなかった場合）<span class="ascii">:</span></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb20-1" title="1"><span class="op">&gt;</span> <span class="va">GHCRTS=</span>-K100k <span class="ex">stack</span> exec runghc -- ./stackoverflow-foldr.hs</a>
<a class="sourceLine" id="cb20-2" title="2"><span class="ex">DONE</span>: foldr 1</a>
<a class="sourceLine" id="cb20-3" title="3"><span class="ex">DONE</span>: foldr 2</a></code></pre></div>
<p>実行結果（<span class="ascii">Strict</span>拡張を有効にした場合）<span class="ascii">:</span></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb21-1" title="1"><span class="op">&gt;</span> <span class="va">GHCRTS=</span>-K100k <span class="ex">stack</span> exec runghc -- --ghc-arg=-XStrict ./stackoverflow-foldr.hs</a>
<a class="sourceLine" id="cb21-2" title="2"><span class="ex">DONE</span>: foldr 1</a>
<a class="sourceLine" id="cb21-3" title="3"><span class="ex">stackoverflow-foldr.hs</span>: stack overflow</a></code></pre></div>
<p>サンプルコードは整数のリストに対して特に何も変換せず<code>foldr</code>する<small>（そして、<code>length</code>関数でリスト全体を評価してから捨てる）</small>だけのことを<span class="ascii">2</span>回繰り返したコードです。最初の<code>foldr</code>は<code>Strict</code>拡張があろうとなかろうと無事実行できたにもかかわらず、<code>Strict</code>拡張を有効にした二つめの<code>foldr</code>は、<code>stack overflow</code>というエラーを起こしてしまいました💥！</p>
<p>なぜこんなエラーが発生したのかを知るために、<code>foldr</code>の定義を見直しましょう。こちら👇は<a href="http://hackage.haskell.org/package/base-4.14.0.0/docs/src/GHC.Base.html#foldr"><span class="ascii">GHC 8.10.1</span>における、リストに対する<code>foldr</code>の定義</a>です<small>（コメントは省略しています）</small>。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" title="1"><span class="fu">foldr</span><span class="ot">            ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb22-2" title="2"><span class="fu">foldr</span> k z <span class="ot">=</span> go</a>
<a class="sourceLine" id="cb22-3" title="3">          <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-4" title="4">            go []     <span class="ot">=</span> z</a>
<a class="sourceLine" id="cb22-5" title="5">            go (y<span class="op">:</span>ys) <span class="ot">=</span> y <span class="ot">`k`</span> go ys</a></code></pre></div>
<p><code>go</code>という補助関数を再帰的に呼び出すことで、第一引数として渡した関数<code>k</code>を用いてリストの要素<span class="ascii">(</span><code>y</code><span class="ascii">)</span>を一つずつ変換しています。呼び出す度にリストの残りの要素をチェックして、最終的に空のリストを受け取ったときは<code>foldr</code>の第二引数<code>z</code>を返していますね。</p>
<p>このとき<code>k</code>が第二引数を遅延評価する関数であった場合、 — サンプルコードで言えば<code>(:)</code>の場合 — 受け取った<code>go ys</code>という式は直ちには評価されません。サンプルコードの<code>(:)</code>に置き換えると、<code>(:)</code>の第二引数、つまりリストの残りの要素を取り出す度に<code>go ys</code>を一回計算して、一個ずつ要素を作り出すイメージです。</p>
<p>一方、<code>k</code>が第二引数を正格評価する関数であった場合、 — サンプルコードで言うところの、<code>Strict</code>拡張を有効にした<code>(\x z -&gt; x : z)</code>の場合 — <code>k</code>は受け取った<code>go ys</code>をすぐに評価しようとします。このとき、<span class="ascii">GHC</span>は<code>k</code>や<code>go</code>に渡されている引数をスタック領域に積みます<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a>。そうして<code>go</code>と、<code>go</code>に呼ばれた<code>k</code>が次々と引数をスタック領域に積んだ結果、スタックサイズの上限に達し、スタックオーバーフローが発生してしまうのです。</p>
<p>これは他の多くのプログラミング言語で<small>（末尾再帰じゃない、普通の）</small>再帰呼び出しを行った場合とよく似た振る舞いです。間違って無限再帰呼び出しをしてしまってスタック領域があふれる、なんて経験は多くのプログラマーがお持ちでしょう。つまり単純に、<code>Strict</code>拡張を有効にした場合の<code>foldr (\x z -&gt; x : z) []</code>は、再帰呼び出しをしすぎてしまう関数となるのです。</p>
<p>なお、今回は<code>length</code>関数を使ってリスト全体を使用するコードにしましたが、遅延リストらしく<code>foldr</code>の結果を一部しか使わない、という場合、<code>foldr</code>に渡した関数がリストを都度正格評価してしまうので、無駄な評価が占める割合はもっと増えることになります。やはり<code>foldr</code>は遅延評価を前提とした高階関数と言えるでしょう。</p>
<p>以上のとおり、<span class="ascii">Haskell</span>には<code>foldr</code>のような、遅延評価を前提とした関数が<code>Strict</code>拡張より遥か昔から存在しています。それらを<code>Strict</code>拡張を有効にした状態で使うと、思わぬ衝突が起きてしまうので、くれぐれも気をつけましょう。</p>
<p>こういう「使ってはいけない関数」を引いてしまわないための方法についても一点補足します。<span class="ascii">HLint</span>を細かく設定したり、カスタム<code>Prelude</code>を設定したりしてみるのは、一つの作戦です。なんとプロジェクト全体で、<code>foldr</code>を禁止することができます<small>（一部のモジュールでは例外的に許可する、なんてこともできます）</small>。詳しくは<a href="https://haskell.e-bigmoon.com/posts/2018/01-29-awesome-hlint.html">「素晴らしき <span class="ascii">HLint</span> を使いこなす」</a>や<a href="https://haskell.e-bigmoon.com/posts/2018/05-23-extended-prelude.html">「<span class="ascii">Prelude</span> を カスタム<span class="ascii">Prelude</span> で置き換える」</a>をご覧ください。</p>
<h1 id="case-5-undefinedを受け取るメソッド"><span class="link-to-here-outer"><a href="#case-5-undefinedを受け取るメソッド" title="case-5-undefinedを受け取るメソッド"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Case 5:</span> <code>undefined</code>を受け取るメソッド</h1>
<p>サンプル<span class="ascii">:</span> <a href="https://github.com/haskell-jp/blog/blob/master/examples/2020/strict-gotchas/storable.hs"><span class="ascii">storable.hs</span></a></p>
<p>最後はちょっとレアケースではありますが、こちら👇の<span class="ascii">Issue</span>で発覚した問題を解説しましょう。</p>
<p><a href="https://gitlab.haskell.org/ghc/ghc/issues/16810"><span class="ascii">#16810: Use explicit lazy binding around undefined in inlinable functions · Issues · Glasgow Haskell Compiler / GHC · GitLab</span></a></p>
<p>問題を簡単に再現するために、次のサンプルコードを用意しました。</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" title="1"><span class="co">-- importなどは当然省略！</span></a>
<a class="sourceLine" id="cb23-2" title="2"><span class="kw">data</span> <span class="dt">Test</span> <span class="ot">=</span> <span class="dt">Test</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb23-3" title="3"></a>
<a class="sourceLine" id="cb23-4" title="4"><span class="kw">instance</span> <span class="dt">Storable</span> <span class="dt">Test</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-5" title="5">  sizeOf _ <span class="ot">=</span> sizeOf (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>) <span class="op">*</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb23-6" title="6">  alignment _ <span class="ot">=</span> <span class="dv">8</span></a>
<a class="sourceLine" id="cb23-7" title="7">  peek <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;This should not be called in this program&quot;</span></a>
<a class="sourceLine" id="cb23-8" title="8">  poke <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;This should not be called in this program&quot;</span></a>
<a class="sourceLine" id="cb23-9" title="9"></a>
<a class="sourceLine" id="cb23-10" title="10">main <span class="ot">=</span> alloca <span class="op">$</span> \(<span class="ot">_ ::</span> <span class="dt">Ptr</span> <span class="dt">Test</span>) <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> <span class="st">&quot;This won&#39;t be printed when Strict is enabled&quot;</span></a></code></pre></div>
<p>はい、適当な型を定義して<a href="https://downloads.haskell.org/~ghc/8.10.1/docs/html/libraries/base-4.14.0.0/Foreign-Storable.html#t:Storable"><code>Storable</code></a>のインスタンスにして、それに対して<a href="https://downloads.haskell.org/~ghc/8.10.1/docs/html/libraries/base-4.14.0.0/Foreign-Marshal-Alloc.html#v:alloca"><code>alloca</code></a>を呼ぶだけのコードです。インスタンス定義をはじめかなり手抜きな感じになっちゃってますが、まぁ今回の問題を再現するのにはこれで十分なので、ご了承ください🙏。</p>
<p>このコード、残念ながら<code>Strict</code>拡張を有効にした状態で実行すると、<code>undefined</code>による例外が発生してしまいます💥。</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb24-1" title="1"><span class="op">&gt;</span> <span class="ex">stack</span> exec -- runghc --ghc-arg=-XStrict storable.hs</a>
<a class="sourceLine" id="cb24-2" title="2"><span class="ex">storable.hs</span>: Prelude.undefined</a>
<a class="sourceLine" id="cb24-3" title="3"><span class="ex">CallStack</span> (from HasCallStack)<span class="bu">:</span></a>
<a class="sourceLine" id="cb24-4" title="4">  <span class="ex">error</span>, called at libraries\base\GHC\Err.hs:79:14 in base:GHC.Err</a>
<a class="sourceLine" id="cb24-5" title="5">  <span class="ex">undefined</span>, called at libraries\base\Foreign\Marshal\Alloc.hs:117:31 in base:Foreign.Marshal.Alloc</a></code></pre></div>
<p>こちらは<code>Strict</code>を有効にしなかった場合。やはり例外は起きてませんね😌。</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb25-1" title="1"><span class="op">&gt;</span> <span class="ex">stack</span> exec -- runghc storable.hs</a>
<a class="sourceLine" id="cb25-2" title="2"><span class="ex">This</span> won<span class="st">&#39;t be printed when Strict is enabled</span></a></code></pre></div>
<p>さてこの、<code>Strict</code>拡張を有効にした場合に発生した、<code>undefined</code>による例外はどこからやってきたのでしょう？上記のコードにはいくつか<code>error</code>関数を使用している箇所がありますが、発生した例外はあくまでも<code>undefined</code>です。見た限り上記のコードそのものから発生した例外ではなさそうですね…🤔。</p>
<p>その答えはなんと、<code>main</code>関数で呼んでいる<a href="https://downloads.haskell.org/~ghc/8.10.1/docs/html/libraries/base-4.14.0.0/src/Foreign-Marshal-Alloc.html#alloca"><code>alloca</code>の定義</a>にありました！</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" title="1"><span class="ot">alloca ::</span> <span class="kw">forall</span> a b <span class="op">.</span> <span class="dt">Storable</span> a <span class="ot">=&gt;</span> (<span class="dt">Ptr</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> <span class="dt">IO</span> b</a>
<a class="sourceLine" id="cb26-2" title="2">alloca  <span class="ot">=</span></a>
<a class="sourceLine" id="cb26-3" title="3">  allocaBytesAligned (sizeOf (<span class="fu">undefined</span><span class="ot"> ::</span> a)) (alignment (<span class="fu">undefined</span><span class="ot"> ::</span> a))</a></code></pre></div>
<p>確かに、<code>sizeOf</code>メソッドや<code>alignment</code>メソッドに<code>undefined</code>を渡しています。これらはいずれも<code>Storable</code>型クラスのメソッドなので、上記の<code>Test</code>型でももちろん実装しています。そう、実はこの<code>sizeOf</code>メソッドと<code>alignment</code>メソッドの実装で、下👇のように引数<code>_</code>を宣言しているのが問題なのです！</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" title="1"><span class="kw">instance</span> <span class="dt">Storable</span> <span class="dt">Test</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-2" title="2">  sizeOf _ <span class="ot">=</span> sizeOf (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>) <span class="op">*</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb27-3" title="3">  alignment _ <span class="ot">=</span> <span class="dv">8</span></a>
<a class="sourceLine" id="cb27-4" title="4">  <span class="co">-- ...</span></a></code></pre></div>
<p><a href="#case-2-ポイントフリースタイルかどうかで変わる">「<span class="ascii">Case 2:</span> ポイントフリースタイルかどうかで変わる！」の節</a>で、「<code>Strict</code>拡張を有効にしているモジュールでは、『引数や変数を宣言することすなわち<span class="ascii">WHNF</span>まで評価すること」』、あるいは『引数や変数を宣言しなければ、評価されない』」と述べたことを再び思い出してください。こちらの<code>sizeOf</code>・<code>alignment</code>の定義でも同様に、引数<code>_</code>を宣言しているため、引数を必ず<span class="ascii">WHNF</span>まで評価することになっています。結果、<code>alloca</code>関数がそれぞれを呼ぶ際<code>undefined</code>を渡しているため、<code>undefined</code>を評価してしまい、<code>undefined</code>による例外が発生してしまうのです💥。</p>
<p>なぜこのように、<code>alloca</code>関数では<code>sizeOf</code>や<code>alignment</code>に<code>undefined</code>をわざわざ渡しているのでしょう？それは、これらのメソッドがそもそも<code>undefined</code>を渡して使うことを前提に設計されているからです。<code>sizeOf</code>・<code>alignment</code>はともに<code>Storable a =&gt; a -&gt; Int</code>という型の関数なので、第一引数に<code>Storable</code>のインスタンスである型<code>a</code>の値を受け取るのですが、このとき<strong>渡される<code>a</code>型の値は、使わない</strong>こととなっています。<a href="https://downloads.haskell.org/~ghc/8.10.1/docs/html/libraries/base-4.14.0.0/Foreign-Storable.html#v:sizeOf">それぞれのメソッドの説明</a>にも「<span class="ascii">The value of the argument is not used.</span>」と書かれていますね。これは、<code>sizeOf</code>も<code>alignment</code>も、型毎に一意な値として定まる<small>（引数の値によって<code>sizeOf</code>や<code>alignment</code>の結果が変わることがない）</small>ので、第一引数の<code>a</code>は、単に「この型の<code>sizeOf</code>を呼んでくださいね」という<strong>型の</strong>情報を渡すためのものでしかないからです。だから値には関心がないので<code>undefined</code>を渡しているわけです。そもそも、<code>alloca</code>関数のように引数として<code>Storable a =&gt; a</code>型の値をとらない関数では、<code>a</code>型の値を用意することができませんし。</p>
<p>現代では通常、このように「値に関心がなく、何の型であるかという情報だけを受け取りたい」という場合は、<a href="https://downloads.haskell.org/~ghc/8.10.1/docs/html/libraries/base-4.14.0.0/Data-Proxy.html#t:Proxy"><code>Proxy</code></a>型を使うのが一般的です。<code>Storable</code>は恐らく<code>Proxy</code>が発明される前に生まれたため、<code>undefined</code>を渡すことになってしまっているのでしょう。なので、<code>Storable</code>型クラスのインスタンスを自前で定義したりしない限り、こうしたケースに出遭うことはまれだと思います。ただ、それでも<code>Proxy</code>を<code>import</code>するのを面倒くさがって<code>undefined</code>を代わりに渡す、なんてケースはありえるので、<code>Proxy</code>を使って定義した型クラスでも同じ問題にハマることはあるかも知れません…。</p>
<p>⚠️結論として、<code>Storable</code>型クラスや、<code>Proxy</code>を受け取るメソッドを持つ型クラスのインスタンスを、<code>Strict</code>拡張を有効にした状態で定義する場合は、<code>Proxy</code>にあたる引数を評価しないよう、<code>~_</code>などを使って定義しましょう。</p>
<h1 id="おわりに-やっぱりstrictは使う使わない"><span class="link-to-here-outer"><a href="#おわりに-やっぱりstrictは使う使わない" title="おわりに-やっぱりstrictは使う使わない"><span class="link-to-here">Link to<br />
here</span></a></span>おわりに<span class="ascii">:</span> やっぱり<code>Strict</code>は使う？使わない？</h1>
<p>さて、ここまで<code>Strict</code>拡張を有効にすることによって犯しうる、数々のミスを紹介してきました。ここまで書いた個人的な印象としては、「敢えて有効にする必要はないんじゃないか」といったところです<small>（まぁ、悪いところばかり調べた結果のため、とてもフェアな視点での判断とは言えないのですが…）</small>。<code>foldr</code>の例でも触れたとおり、<span class="ascii">Haskell</span>には遅延評価を前提とした、遅延評価を存分に活かした機能が溢れています。当然それらは<code>Strict</code>拡張ができるよりはるか昔からあり、<code>Strict</code>拡張のことなど一切考えないで作られたものです。動的型付け言語に後から静的型検査を導入するのが大変なように、相対する機能を後付けすると衝突が起こるのは仕方のないことですが、こと<code>Strict</code>拡張については想像以上に大きな衝突のようです😞。</p>
<p>それでも使いたいという方に、今回の記事が助けになれば幸いです💪それでは<code>Strict</code>な方も<code>NoStrict</code>な方も<span class="ascii">Happy Haskell Hacking!!</span></p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>例えば<span class="ascii">fumieval</span>さんによる<a href="http://fumieval.hatenablog.com/entry/2015/12/10/200630">この記事</a>より<span class="ascii">:</span> 「もっとも、日常ではここまで気にしなければいけない場面は少ないので、ほとんどの場合は気にせず感嘆符をつけて大丈夫だろう。<span class="ascii">GHC 8.0</span>からは、全フィールドをデフォルトで正格にする<code>StrictData</code>という拡張が入るため、こちらを使おう」<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p><code>BangPatterns</code>言語拡張を有効にした上で上記のように書き換えてみると、<code>Strict</code>拡張の有無に関わらずエラーが発生します。試してみましょう。<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>実際のところ今回紹介するケース以外にも、ポイントフリースタイルにするかしないかで実行効率などが変わる場合があります。例えば、<a href="https://treszkai.github.io/2019/07/13/haskell-eval"><span class="ascii">Evaluation of function calls in Haskell</span></a>をご覧ください。<a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p>もっとも、この例では引数はリストでしょうから、<span class="ascii">WHNF</span>までのみ正格評価するメリットは少なそうですが。<a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p>大きなリストにすると、今度はエラーが発生するまでに時間がかかってしまうので…。ちなみに、このようにスタック領域を小さくすることでスペースリークを検出する手法は、<a href="https://github.com/ndmitchell/spaceleak"><span class="ascii">ndmitchell/spaceleak: Notes on space leaks</span></a>でも紹介されています。<a href="#fnref5" class="footnote-back">↩</a></p></li>
<li id="fn6"><p><span class="ascii">GHC</span>がどのように評価し、スタック領域を消費するかは<a href="https://takenobu-hs.github.io/downloads/haskell_ghc_illustrated.pdf"><span class="ascii">GHC illustrated</span></a>や、その参考文献をご覧ください。<a href="#fnref6" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2020/haskell-casually-at-work.html" style="margin-left: auto;" lang="ja">Haskellを業務で使う、カジュアルに</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>Haskellを業務で使う、カジュアルに</title>
    <link href="https://haskell.jp/blog/posts/2020/haskell-casually-at-work.html" />
    <id>https://haskell.jp/blog/posts/2020/haskell-casually-at-work.html</id>
    <published>2020-04-26T00:00:00Z</published>
    <updated>2020-04-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#はじめに" title="はじめに">はじめに</a></li>
<li><a href="#作業の支援加速にhaskellを使う" title="作業の支援加速にhaskellを使う">🔧「作業」の支援・加速に、<span class="ascii">Haskell</span>を使う</a>
<ul>
<li><a href="#テストデータ生成" title="テストデータ生成">テストデータ生成</a></li>
<li><a href="#パーサー" title="パーサー">パーサー</a></li>
<li><a href="#階層データ処理" title="階層データ処理">階層データ処理</a></li>
<li><a href="#高機能電卓" title="高機能電卓">高機能電卓</a></li>
<li><a href="#その他" title="その他">その他</a></li>
</ul></li>
<li><a href="#思考の支援加速にhaskellを使う" title="思考の支援加速にhaskellを使う">💡「思考」の支援・加速に、<span class="ascii">Haskell</span>を使う</a>
<ul>
<li><a href="#仕様理解" title="仕様理解">仕様理解</a></li>
<li><a href="#モデル確認" title="モデル確認">モデル確認</a></li>
<li><a href="#モデル探索" title="モデル探索">モデル探索</a></li>
<li><a href="#その他-1" title="その他-1">その他</a></li>
</ul></li>
<li><a href="#おわりに" title="おわりに">おわりに</a></li>
</ul>
</div>
</div>
<h1 id="はじめに"><span class="link-to-here-outer"><a href="#はじめに" title="はじめに"><span class="link-to-here">Link to<br />
here</span></a></span>はじめに</h1>
<p>この記事では、<span class="ascii">Haskell</span>を業務でカジュアルに使う観点やヒントについて、簡単に紹介します。</p>
<p><span class="ascii">Haskell</span>を業務で使える局面は、以下のようにいくつか考えられます。</p>
<ol type="1">
<li>「プロダクト」の開発用言語として、<span class="ascii">Haskell</span>を使う</li>
<li>「作業」の支援・加速用に、<span class="ascii">Haskell</span>を使う</li>
<li>「思考」の支援・加速用に、<span class="ascii">Haskell</span>を使う</li>
</ol>
<p>つまり、プロダクトの開発用言語として<span class="ascii">Haskell</span>を用いない業務形態においても、上記<span class="ascii">2</span>や<span class="ascii">3</span>のケースとして、<span class="ascii">Haskell</span>を使用できます。すなわち、<span class="ascii">Haskell</span>は幅広い局面でカジュアルに、つまり気軽に手軽に使用できます。</p>
<p>本記事では、特に、上記の<span class="ascii">2</span>と<span class="ascii">3</span>について、いくつかの観点やヒントや例を紹介します。</p>
<p>なお、上記は、<span class="ascii">Haskell</span>を用いる場合には限りません。<span class="ascii">Python, Perl, Ruby, Rust, Scala, OCaml, Clojure, Go, Elixir,</span> … といった、様々なプログラミング言語に置き換えて本記事を解釈してもらって構いません。</p>
<hr />
<h1 id="作業の支援加速にhaskellを使う"><span class="link-to-here-outer"><a href="#作業の支援加速にhaskellを使う" title="作業の支援加速にhaskellを使う"><span class="link-to-here">Link to<br />
here</span></a></span>🔧「作業」の支援・加速に、<span class="ascii">Haskell</span>を使う</h1>
<p><span class="ascii">Haskell</span>（を含むプログラミング言語）は、開発などの日常業務において、「作業」の支援・加速用に使うことが出来ます。</p>
<p>つまり、電卓や<span class="ascii">Excel</span>などのように、<span class="ascii">Haskell</span>を日常ツールの一つとして使えます。</p>
<p>特に、直近の業務作業を加速するために、書き捨てのツールを高品質で素早く欲しい場合や、ちょっとした対話ツールを欲しい場合などにも、<span class="ascii">Haskell</span>を便利に活用できます。</p>
<p>例えば具体的には、以下の場合に<span class="ascii">Haskell</span>を便利に使えます。</p>
<ul>
<li>テストデータ生成</li>
<li>パーサー</li>
<li>階層データ処理</li>
<li>高機能電卓</li>
</ul>
<p>以下、それぞれについて簡単に紹介します。</p>
<h2 id="テストデータ生成"><span class="link-to-here-outer"><a href="#テストデータ生成" title="テストデータ生成"><span class="link-to-here">Link to<br />
here</span></a></span>テストデータ生成</h2>
<p>例えば、解析事案が発生し、至急<span class="ascii">10</span>分程度でテストデータを複数用意したい、というような場合に、<span class="ascii">Haskell</span>でデータを生成させることは有効です。</p>
<p><span class="ascii">Haskell</span>は、関数合成や部分適用や高階関数や多相関数などの言語的な特徴により、小さな関数を組み合わせて、より大きな関数として作り上げることが容易です。</p>
<p>対話環境（<span class="ascii">REPL</span>）である<span class="ascii">GHCi</span>を用いて、それら小さな関数を素早く高品質に確認した上で、徐々に大きな関数として組み合わせることにより、高品質な結果を素早く得ることがでできます。</p>
<p>特にバイナリデータや複雑なデータを、一刻も早く高品質に生成することが重要な局面で、<span class="ascii">Haskell</span>は威力を発揮します。</p>
<h2 id="パーサー"><span class="link-to-here-outer"><a href="#パーサー" title="パーサー"><span class="link-to-here">Link to<br />
here</span></a></span>パーサー</h2>
<p>日常業務において、各種ログなどのデータを解析したい局面は頻繁に有ります。 単純なデータであれば、<span class="ascii">grep</span>コマンドや<span class="ascii">Perl</span>などの正規表現を用いて手早く仕事を済ませることも出来ます。</p>
<p>しかし、データの構造が複雑であったり再帰的な構造である場合には、正規表現をデバッグするよりも、<span class="ascii">Haskell</span>で思い切ってパーサーを書いてしまう方が手早く済ませられることがあります。</p>
<p><span class="ascii">Haskell</span>では、関数の組み立てが容易であることや<span class="ascii">do</span>記法といった言語的な特徴を活かし、簡潔にパーサーを記述することができます。 言語的な特徴を活かした便利なパーサーコンビネータ関連のライブラリ（<a href="https://hackage.haskell.org/package/parsec"><code>Parsec</code></a>や<a href="https://hackage.haskell.org/package/megaparsec"><code>Megaparsec</code></a>や<a href="https://hackage.haskell.org/package/replace-attoparsec"><code>replace-attoparsec</code></a>など）が豊富に存在します。</p>
<p>一度パーサーの骨格を用意してしまえば、流用は容易であるため、強力な日常ツールとして<span class="ascii">Haskell</span>を便利に使用できます。</p>
<h2 id="階層データ処理"><span class="link-to-here-outer"><a href="#階層データ処理" title="階層データ処理"><span class="link-to-here">Link to<br />
here</span></a></span>階層データ処理</h2>
<p>例えばモジュールの構造に対応したデータのように、データが再帰的・階層的に表現されている場合は多くあります。</p>
<p><span class="ascii">Haskell</span>は、代数的データ型を用いて再帰的なデータ構造を簡潔に表現できます。また、簡潔なパターンマッチの記法と再帰的な関数により、これらの処理を容易に記述できる傾向にあります。</p>
<p>もちろん、この再帰的なデータ構造も、コンパイル時の静的な型チェックの対象となるため、多くの不用意なミスを事前に抽出できます。</p>
<p>素早く、非常に高品質にデータ処理を行うことが重要な局面で、<span class="ascii">Haskell</span>は有効に機能します。</p>
<h2 id="高機能電卓"><span class="link-to-here-outer"><a href="#高機能電卓" title="高機能電卓"><span class="link-to-here">Link to<br />
here</span></a></span>高機能電卓</h2>
<p>日常業務において、なんらかの変換テーブルや、計算式、定数値などの値を、散発的に直ちに得たい局面があります。 その都度、電卓で計算したり、<span class="ascii">Excel</span>などの計算フォームを用意することで、手軽に業務を済ませられる場合もあります。</p>
<p>しかし、繰り返し必要となる計算式や、ある程度複雑な計算であれば、これらの計算式などを、<span class="ascii">Haskell</span>の関数群として定義しておき、対話環境<span class="ascii">GHCi</span>から用いることで、使い勝手良く素早く値を得ることができます。</p>
<p>数値や対話操作などを補助する便利なライブラリ<span class="ascii">(</span><a href="https://hackage.haskell.org/package/base/docs/Numeric.html"><code>Numeric</code></a>や<a href="https://hackage.haskell.org/package/base/docs/Data-Bits.html"><code>Data.Bits</code></a>や<a href="http://hackage.haskell.org/package/ghci-hexcalc/docs/Data-GHex.html"><code>Data.GHex</code></a><span class="ascii">)</span>や言語拡張<span class="ascii">(</span><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#binary-integer-literals"><code>BinaryLiterals</code></a>や<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#numeric-underscores"><code>NumericUnderscores</code></a><span class="ascii">)</span>などが豊富に存在します。</p>
<p><span class="ascii">Haskell</span>における関数の組み立てが容易な特徴は、対話環境における対話的な操作との相性が良いため、試行錯誤的な計算作業にも有用です。</p>
<h2 id="その他"><span class="link-to-here-outer"><a href="#その他" title="その他"><span class="link-to-here">Link to<br />
here</span></a></span>その他</h2>
<p>他にも、定型的なファイル処理や<span class="ascii">CLI</span>コマンドや<span class="ascii">DSL</span>の構築などを、<span class="ascii">Haskell</span>を用いて便利に実現出来ます。 手元に各種雛形を蓄積していると、作業の素早さと正確さが求められる場合に、有益でしょう。</p>
<p>もちろん、これらは<span class="ascii">Haskell</span>に限らず、多くのプログラミング言語にも言えます。</p>
<p><span class="ascii">Haskell</span>は、型システムに守られながら、関数を容易に組み立てられる特徴を持ちます。また、代数的データ型とパターンマッチの特徴により、直感的・シンプルで高品質なデータ表現・処理が可能です。さらに、<span class="ascii">GHCi</span>を用いる対話操作により、日常作業を高品質かつ手早く行えます。</p>
<p><span class="ascii">Haskell</span>は、（型システムの高度な機能などを使わない）基本的な機能のみにおいても、日常業務において有効に活用できるツールの一つです。</p>
<hr />
<h1 id="思考の支援加速にhaskellを使う"><span class="link-to-here-outer"><a href="#思考の支援加速にhaskellを使う" title="思考の支援加速にhaskellを使う"><span class="link-to-here">Link to<br />
here</span></a></span>💡「思考」の支援・加速に、<span class="ascii">Haskell</span>を使う</h1>
<p><span class="ascii">Haskell</span>（を含むプログラミング言語）は、開発などの日常業務において、「思考」の支援・加速用にも使うことが出来ます。</p>
<p>つまり、紙と鉛筆などのように、<span class="ascii">Haskell</span>を思考ツールの一つとして使えます。</p>
<p>特に、試行錯誤的な思考フェーズや、探索フェーズにおいて、思考を整理・加速する場合などに、<span class="ascii">Haskell</span>は便利です。</p>
<p>例えば具体的には、以下の場合に<span class="ascii">Haskell</span>を便利に使えます。</p>
<ul>
<li>仕様理解</li>
<li>モデル確認</li>
<li>モデル探索</li>
</ul>
<p>以下、それぞれについて簡単に紹介します。</p>
<h2 id="仕様理解"><span class="link-to-here-outer"><a href="#仕様理解" title="仕様理解"><span class="link-to-here">Link to<br />
here</span></a></span>仕様理解</h2>
<p>ハードウェアやソフトウェア開発過程などでは、例えば、自然言語と図表や式の組み合わせで表現された仕様書を理解する事が必要な局面が多くあります。</p>
<p>設計の上流工程で思考を広く深く及ばせておくことにより、仕様に対する思わぬ考え漏れや勘違いを防ぐことは、開発全体の質や開発速度を上げる観点で非常に有効です。</p>
<p><span class="ascii">Haskell</span>は、代数的データ型やパターンマッチを簡潔に記述できる言語的な特徴を持つため、仕様を簡潔に表現することに向いています。さらに、対話環境<span class="ascii">GHCi</span>を用いて、自分の考えを試行錯誤的に確認できます。</p>
<p>自然言語等の仕様を、プログラミング言語を用いて表現・写経する過程は、単純ですが、対象への理解を深める上で、意外に大きな投資対効果があります。<span class="ascii">Haskell</span>は、このような場合に強力なツールとなります。</p>
<h2 id="モデル確認"><span class="link-to-here-outer"><a href="#モデル確認" title="モデル確認"><span class="link-to-here">Link to<br />
here</span></a></span>モデル確認</h2>
<p>設計の初期段階において、自分の考えミスを抽出するために、設計の中核部分を簡単なモデルで表現して確認することは、開発全体の質や開発速度を上げる観点で非常に有効です。</p>
<p>前節の仕様理解の場合と同様に、設計の中核モデルを簡潔に記述する目的で、<span class="ascii">Haskell</span>を用いることが出来る場合があります。</p>
<p><span class="ascii">Haskell</span>の代数的データ型とパターンマッチは、モデルの簡潔表現にもフィットする場合が多く、自分の考えを手早く確認することに有効に使用できます。</p>
<p>さらに、<span class="ascii">Haskell</span>で記述したモデルを、<a href="https://hackage.haskell.org/package/QuickCheck"><code>QuickCheck</code></a>ライブラリなどによるランダムテストパターンを用いて簡易検査することにより、値の範囲や特性に対する考え不足を、容赦なく効率的に抽出できます。</p>
<h2 id="モデル探索"><span class="link-to-here-outer"><a href="#モデル探索" title="モデル探索"><span class="link-to-here">Link to<br />
here</span></a></span>モデル探索</h2>
<p>設計の初期段階において、モデルのパラメータなどについての設計空間を、試行錯誤しながら探索したい局面があります。</p>
<p>前節のモデル理解の場合と同様に、設計空間を探索する目的で、<span class="ascii">Haskell</span>を用いることが出来る場合があります。</p>
<p><span class="ascii">Haskell</span>の代数的データ型とパターンマッチを用いてモデルを簡潔に記述できれば、系の大きさなどの多くのパラメータを振りながら、最適な設計値を探索することに活用できます。</p>
<h2 id="その他-1"><span class="link-to-here-outer"><a href="#その他-1" title="その他-1"><span class="link-to-here">Link to<br />
here</span></a></span>その他</h2>
<p>思考フェーズでは、記述したプログラムの実行速度よりも、思考内容をコードで表現する速さや、試行錯誤的にコードの内容を確認・変更する速さの方が重要なことが有ります。</p>
<p>各々の人の思考特性によりますが、<span class="ascii">Haskell</span>の代数的データ型とパターンマッチなどの言語的な特徴は、実行可能仕様書・実行可能思考表現として、思考を整理することに向いています。</p>
<p>以下のように、<span class="ascii">Haskell</span>を用いて、簡潔に、素早く、手軽に、思考作業を支援・加速できます。</p>
<ul>
<li>モデルなどの思考を、代数的データ型で直感的・簡潔に記述する</li>
<li>処理をパターンマッチを用いて簡潔に記述する</li>
<li>対話環境<span class="ascii">GHCi</span>で、挙動と思考を手早く試行錯誤的に確認する</li>
</ul>
<p>便利ですね。</p>
<hr />
<h1 id="おわりに"><span class="link-to-here-outer"><a href="#おわりに" title="おわりに"><span class="link-to-here">Link to<br />
here</span></a></span>おわりに</h1>
<p>この記事では、<span class="ascii">Haskell</span>を業務でカジュアルに使う観点やヒントについて紹介しました。 「作業」や「思考」が必要な、よりたくさんの局面で<span class="ascii">Haskell</span>を使用できます。</p>
<p>関数合成、部分適用、高階関数、多相関数などの言語的な特徴は、関数をボトムアップや対話的に、素早くかつ高品質に組み上げるのに便利です。代数的データ型などの言語的な特徴は、ある種の思考パターン（選択、非一様、入れ子など）をストレートに表現するのに便利です。対話環境<span class="ascii">GHCi</span>は、試行錯誤的に作業や思考を進めるのに便利です。</p>
<p><span class="ascii">Haskell</span>に限らず、自分の思考特性にあったプログラミング言語を、業務を加速する日常的なツールとして備えておくことは有用です。</p>
<p>しかし、そもそもプログラミング言語の可能性・適用範囲は非常に広いものです。その適用範囲を、「業務」に狭めてしまう必要もありません。</p>
<p>プログラミング言語は、業務のみに限らず、日々の「思考」の支援・加速に広く使用できるものです。</p>
<p>以上、 <span class="ascii">Enjoy programming</span>！</p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2020/strict-gotchas.html" lang="ja">Strict拡張を使用する際の注意点</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2020/io-monad-and-sideeffect.html" style="margin-left: auto;" lang="ja">IO モナドと副作用</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>IO モナドと副作用</title>
    <link href="https://haskell.jp/blog/posts/2020/io-monad-and-sideeffect.html" />
    <id>https://haskell.jp/blog/posts/2020/io-monad-and-sideeffect.html</id>
    <published>2020-04-05T00:00:00Z</published>
    <updated>2020-04-05T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p><span class="ascii">Haskell</span> は他のプログラミング言語には見られない特徴を多く持っている。その中の<span class="ascii">1</span>つが純粋性だ。<span class="ascii">Haskell</span> は純粋関数型プログラミング言語であることを、売りの<span class="ascii">1</span>つにしている。しかし、純粋性は多くの場合表現力の縮小を招く。ところが <span class="ascii">Haskell</span> は、<span class="ascii">IO</span>モナドの導入により、通常のプログラミング言語と変わらぬ表現力を持てるようになっている。これは、とても驚くべきことだ。しかし、同時にこれは <span class="ascii">Haskell</span> 入門者にとって、大きな混乱を招いているようだ。</p>
<p>今回は、そもそも純粋性とはなんなのか、なぜ他の言語は純粋性を担保できないのか、そして <span class="ascii">Haskell</span> はどうやって <span class="ascii">IO</span> モナドにより純粋性を担保しつつ他の言語と変わらない表現力を持てるようにしているのかについて、触れていきたいと思う。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#純粋性とは何か" title="純粋性とは何か">純粋性とは何か</a></li>
<li><a href="#動作を扱う関数" title="動作を扱う関数">動作を扱う関数</a></li>
<li><a href="#io-モナド" title="io-モナド"><span class="ascii">IO</span> モナド</a></li>
<li><a href="#動作を第一級で取り扱う" title="動作を第一級で取り扱う">動作を第一級で取り扱う</a></li>
<li><a href="#まとめ" title="まとめ">まとめ</a></li>
<li><a href="#おまけ-ioモナドの実装" title="おまけ-ioモナドの実装">おまけ<span class="ascii">: IO</span>モナドの実装</a></li>
</ul>
</div>
</div>
<h2 id="純粋性とは何か"><span class="link-to-here-outer"><a href="#純粋性とは何か" title="純粋性とは何か"><span class="link-to-here">Link to<br />
here</span></a></span>純粋性とは何か</h2>
<p><span class="ascii">Haskell</span> は純粋関数型プログラミング言語 <span class="ascii">(purely functional programming language)</span> を売りにしている。関数型 <span class="ascii">(functional)</span> の部分は他に任せるとして、ここでは<strong>純粋 <span class="ascii">(purely)</span></strong> の部分に着目しよう。純粋とはなんだろうか？ どういう条件を満たせば、プログラミング言語は純粋と言えるんだろうか？ <a href="https://www.haskell.org/"><span class="ascii">Haskell</span> の公式サイト</a> ではこう述べられている<span class="ascii">:</span></p>
<blockquote>
<p><span class="ascii">Every function in Haskell is a function in the mathematical sense (i.e.,</span> “<span class="ascii">pure</span>”<span class="ascii">).</span></p>
<p><span class="ascii">Haskell</span> の全ての関数は、数学の意味での関数 <span class="ascii">(</span>つまり「純粋」<span class="ascii">)</span> です。</p>
<p>– <a href="https://www.haskell.org/"><span class="ascii">haskell.org</span></a> <span class="ascii">Features: Purely functional</span> より</p>
</blockquote>
<p>ふむ、どうやら全ての関数が、数学的な意味での関数であれば、そのプログラミング言語は純粋と言えるようだ。ところで、数学的な意味での関数とはなんだろうか？ 関数が純粋とはどういうことを指すんだろうか？ これは噛み砕くと、</p>
<ol type="1">
<li><p>関数はどんな時も、同じ引数を与えられたら同じ結果を返す</p>
<p>つまり、関数は毎回まっさらな状態で始まり、前にどんなことがあったのか、今巷でどういうことが起きてるのかを全く考慮に入れず、ただ受け取った引数から得られる情報だけを使って結果を計算する。</p></li>
<li><p>関数は、副作用を持たない</p>
<p>つまり、関数は計算の結果を返す以外の役割を持たない。例えば、関数を<span class="ascii">1</span>回呼び出すのと、関数を<span class="ascii">1</span>回呼び出してその結果を捨てまたもう<span class="ascii">1</span>回呼び出すので結果が変わることはない。</p></li>
</ol>
<p>という<span class="ascii">2</span>つの性質にまとめられる <a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>。具体的には、関数 <code>f</code> が、</p>
<ul>
<li><span class="ascii">1</span>回目の <code>f 1</code> では <code>2</code> を返し、<span class="ascii">2</span>回目の <code>f 1</code> では <code>3</code> を返す</li>
</ul>
<p>という動作をするなら、これは <span class="ascii">1</span> の条件にも <span class="ascii">2</span> の条件にも違反することになる。では、関数 <code>printString</code> が</p>
<ul>
<li>受け取った文字列をターミナルに出力し、<code>()</code> を結果として返す</li>
</ul>
<p>ことを考えよう。関数 <code>printString</code> は常に <code>()</code> を返すので <span class="ascii">1</span> の条件にはマッチする。しかし、この関数は、与えられた文字列をターミナルに出力するので、<span class="ascii">1</span>回呼び出すか<span class="ascii">2</span>回呼び出すかは重要な違いになる。よって、<span class="ascii">2</span> 番目の条件を満たさないため、純粋ではない。逆に、関数 <code>getNowYear</code> が、</p>
<ul>
<li>完全に副作用を持たず、何回呼び出しても他には何の影響もないが、今の年数を返す関数で、年が変わるごとに結果が変わる</li>
</ul>
<p>となると <span class="ascii">1</span> の条件に違反するため、やはり純粋ではない。関数が純粋になるためには、何の面白味もないかもしれないが、<span class="ascii">1</span> と <span class="ascii">2</span> の条件を守らないといけない。決して夕日が沈むと突然結果を出さなくなったり、関数を呼ぶ度に近所の犬が吠えたり静かになったりしてはいけない。</p>
<p>さて、このような定義なら、多くのプログラミング言語の関数が純粋性を持たないのは納得できるだろう。同じ引数でも呼ぶタイミングによって結果が変わる関数、関数を呼ぶと全く予期しなかったスイッチが作動し、別の関数の結果が突然変わるようなプログラムを思いつく人は少なくないはずだ。ただ、その人たちは同時にこうも思うだろう。</p>
<blockquote>
<p>そのような関数はプログラミングでは必要不可欠だ。<span class="ascii">Haskell</span> はその必要不可欠な関数を、純粋性のためだけに書けないようにしてるのだろうか？</p>
</blockquote>
<p>その疑問は至極妥当で、当然のものだ。そして安心して欲しい。その質問に対する答えは <span class="ascii">NO</span> だ。<span class="ascii">Haskell</span> は純粋性を保ちながら、そのような必要不可欠な関数を表現する方法を持っている。</p>
<h2 id="動作を扱う関数"><span class="link-to-here-outer"><a href="#動作を扱う関数" title="動作を扱う関数"><span class="link-to-here">Link to<br />
here</span></a></span>動作を扱う関数</h2>
<p><span class="ascii">Haskell</span> には、ターミナルに出力する動作を扱う関数や、ターミナルへの入力を受け取る動作を扱う関数が存在する。これは、どうも先ほどまでの純粋性の定義とは相容れないように見える。<span class="ascii">Haskell</span> の純粋関数型プログラミング言語という性質は、そのような関数を除いては純粋という意味なんだろうか？ それなら他のプログラミング言語でも事情は変わらない。ところが、<span class="ascii">Haskell</span> はそのような関数まで純粋なのだ。そのカラクリについて、見ていこう。</p>
<p><span class="ascii">Haskell</span> でターミナルに文字列を <span class="ascii">(</span>改行付きで<span class="ascii">)</span> 出力する動作を扱う関数として、<code>putStrLn</code> という関数がある。これを題材として扱っていこう。この関数はどういう型を持っているのだろう？ もし、</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="fu">putStrLn</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> ()</a></code></pre></div>
<p>という型になっていたら、この場合は文字列を受け取り <code>()</code> 型の値を返す関数になる。<code>()</code> 型は次のように定義される <a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a><span class="ascii">:</span></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">data</span> () <span class="ot">=</span> ()</a></code></pre></div>
<p>つまり、<code>()</code> というたった一つの値を持つ型になる。なので、<code>putStrLn</code> が <code>putStrLn :: String -&gt; ()</code> という型を持っていた場合は、常に <code>()</code> という値を返す関数となり、純粋性の <span class="ascii">1</span> 番目の条件を満たす。しかし、<code>putStrLn</code> は呼び出し回数に応じて文字列をターミナルに出力していくので、副作用を持ち、<span class="ascii">2</span> 番目の条件には到底当てはまらない。では、<span class="ascii">2</span> 番目の条件に当てはまるようにするにはどうすればいいだろう？ そのような選択肢は到底ないように見える。</p>
<p>実際には、<span class="ascii">Haskell</span> の <code>putStrLn</code> は</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="fu">putStrLn</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a></code></pre></div>
<p>という型を持つ。つまり、返る値は <code>IO ()</code> という不思議な型を持つ。こうすると純粋に文字列をターミナルに出力できるんだろうか？ 答えは <span class="ascii">NO</span> だ。<span class="ascii">Haskell</span> の <code>putStrLn</code> 関数は、</p>
<ul>
<li>受け取った文字列をターミナルに出力する</li>
</ul>
<p>関数ではない。<span class="ascii">Haskell</span> は、到底純粋性を持たないような操作をする関数を、そもそも関数の見方を変えて提供することで純粋性を保っている。この関数 <code>putStrLn</code> は</p>
<ul>
<li>受け取った文字列から、「ターミナルにその文字列を出力する動作」を返す</li>
</ul>
<p>関数だ。そして、「ターミナルにその文字列を出力する動作」は <code>IO ()</code> という型を持つ。動作 <span class="ascii">(action)</span> とは、文字通り「何をするか」 <a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a> を表す。<code>IO a</code> は、</p>
<ul>
<li>動作、つまり「何をするか」を表す値を持つ</li>
<li>その動作をした結果、得られる値の型が <code>a</code> であることを表す</li>
</ul>
<p>型だ。抽象的すぎてあまりピンとこないかもしれない。もし、その動作が結果を返す以外に何もしないなら、それは純粋な操作であるから、次のように書ける<span class="ascii">:</span></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">data</span> <span class="dt">PureAction</span> a <span class="ot">=</span> <span class="dt">PureAction</span> (() <span class="ot">-&gt;</span> a)</a></code></pre></div>
<p>つまり、引数が何もない純粋関数だ。例えば、整数を<span class="ascii">2</span>つ受け取って、その和を計算する動作を返す関数は次のように書けるだろう<span class="ascii">:</span></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="ot">addAction ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">PureAction</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-2" title="2">addAction x y <span class="ot">=</span> <span class="dt">PureAction</span> (\_ <span class="ot">-&gt;</span> x <span class="op">+</span> y)</a></code></pre></div>
<p><code>putStrLn</code> も <code>addAction</code> と同じように、値そのものではなくその値を計算する<strong>動作</strong>それ自体を返す。ただ、<code>putStrLn</code> が返す <code>IO</code> の動作は、<code>PureAction</code> の動作よりもっと一般的なものだ。つまり、純粋な動作ではないかもしれないということだ。もしかしたらそれは、今の時刻で結果を変えるかもしれないし、結果は常に変わらなくても何回呼び出すかでターミナルに表示する文字を変えるかもしれない。つまり、完全に純粋な関数では表せないかもしれない。でも、動作自体は不変的だ。<code>putStrLn "str"</code> は</p>
<ul>
<li>ターミナルに <code>"str"</code> を出力する動作</li>
</ul>
<p>を表す。これが、<span class="ascii">10</span>時にはこういう動作を返してきたのが、<span class="ascii">12</span>時には</p>
<ul>
<li>ターミナルに <code>"str"</code> を出力し、お昼の鐘を鳴らす動作</li>
</ul>
<p>を返すようになるということはないし、この動作を返す以外に</p>
<ul>
<li>勝手にターミナルに文字列を出力する</li>
</ul>
<p>ということもない。例えば、<span class="ascii">GHCi</span> で以下のようなプログラムの出力を見てみよう<span class="ascii">:</span></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">let</span> _ <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="st">&quot;str&quot;</span> <span class="kw">in</span> ()</a>
<a class="sourceLine" id="cb6-2" title="2">()</a></code></pre></div>
<p>これは</p>
<ol type="1">
<li><code>putStrLn "str"</code> を計算し、</li>
<li>結果を捨て</li>
<li><code>()</code> を返す</li>
</ol>
<p>というプログラムだ。このプログラムを評価しても、<code>()</code> だけしか目にしないはずで、何回実行しても同じ結果が得られるはずだ。つまり、<code>putStrLn</code> は余計なことを何もしていないと言えるだろう。そう説明すると、ちょっと <span class="ascii">Haskell</span> をかじった人は</p>
<blockquote>
<p>この説明は間違っている。この式は <code>putStrLn "str"</code> を全く評価していないので、実際に <code>putStrLn "str"</code> が余計なことを何もしていないかは分からない</p>
</blockquote>
<p>と言うだろう。その通りだ。この説明は間違っている。それを確認してみよう<span class="ascii">:</span></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">let</span> _ <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;something happened!&quot;</span> <span class="kw">in</span> ()</a>
<a class="sourceLine" id="cb7-2" title="2">()</a></code></pre></div>
<p>もし、さっきの <code>putStrLn "str"</code> がちゃんと計算されていたなら、今回は <code>something happened!</code> というエラーが見れるはずだ。ところが、全く何の問題もなく式の実行は終わり、<code>()</code> が出力されてしまった。<span class="ascii">Haskell</span> は遅延評価により、最終結果に本当に必要な部分しか計算してくれないので、<code>putStrLn "str"</code> の部分は計算されず無視されてしまっていただけのようだ。では、ちゃんと修正してみよう。修正は、<code>seq</code> という魔法の関数を使うことで可能だ。<code>seq :: a -&gt; b -&gt; b</code> は一番最初に渡された引数を <span class="ascii">(</span>必要かどうかに関わらず、強制的に<span class="ascii">)</span> 計算し、その後<span class="ascii">2</span>番目の引数を返す関数だ。この関数を使うと、次のように修正が可能だ<span class="ascii">:</span></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="fu">putStrLn</span> <span class="st">&quot;str&quot;</span> <span class="ot">`seq`</span> ()</a>
<a class="sourceLine" id="cb8-2" title="2">()</a>
<a class="sourceLine" id="cb8-3" title="3"><span class="op">&gt;&gt;&gt;</span> <span class="fu">error</span> <span class="st">&quot;something happened!&quot;</span> <span class="ot">`seq`</span> ()</a>
<a class="sourceLine" id="cb8-4" title="4"><span class="op">***</span> <span class="dt">Exception</span><span class="op">:</span> something happened<span class="op">!</span></a></code></pre></div>
<p>今度は大丈夫だろう。<code>putStrLn "str"</code> の部分をエラーに変えると、ちゃんとエラーが出力されている。<code>putStrLn "str"</code> は計算されているようだ。そう、<code>putStrLn "str"</code> が実行されて実際に行われるのは、その定義通り</p>
<ul>
<li>「ターミナルに <code>"str"</code> を出力する動作」を返す</li>
</ul>
<p>ということだけで、他には何もしない。常に同じ動作を返すし、副作用を起こしたりもしない。これは純粋関数の定義に当てはまっている。<code>putStrLn</code> は純粋な関数なのだ。そして、その動作には、動作の結果の型によって型が決まっていて、それが <code>IO</code> 型ということになる。</p>
<blockquote>
<p>では、実際に <code>putStrLn</code> はどういう定義になるんだろう？ その定義は純粋な枠組みで定義できるんだろうか？</p>
</blockquote>
<p>と疑問を持つ人はいるかもしれない。その疑問はとても良いところをついている。そう、<code>putStrLn</code> は、<span class="ascii">Haskell</span> では定義できない。もしくは、定義するならば「文字列をターミナルに出力する動作」を表す値の作成方法を、何らかの仕組みで提供する必要がある。もし、</p>
<ul>
<li>「文字列 <code>s</code> をターミナルに出力する動作」を <code>PutStrLn s :: IO ()</code> と書ける</li>
</ul>
<p>なら、その時は、<code>putStrLn</code> を次のように定義できる<span class="ascii">:</span></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="fu">putStrLn</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb9-2" title="2"><span class="fu">putStrLn</span> s <span class="ot">=</span> <span class="dt">PutStrLn</span> s</a></code></pre></div>
<p>ただ、今度は <code>PutStrLn</code> を <span class="ascii">Haskell</span> で定義するにはどうすればいいのだろう？ という話になり、この話は延々と続くことになるだろう。現実世界の純粋なエミュレータを <span class="ascii">Haskell</span> 内部で実装すれば収束するかもしれない。しかし、私たちは、現実世界をコストなく扱いたいわけであり、純粋かどうかは重要なことではない。そして、別に <code>putStrLn</code> を <span class="ascii">Haskell</span> 内で純粋に定義したいのではなく、「文字列 <code>s</code> をターミナルに出力する動作」を扱いたいだけなのだ。なので、<span class="ascii">Haskell</span> は純粋な部分だけは目に見える範囲で提供し、非純粋な部分は隠蔽し、純粋に扱うことだけをできるようにしている。</p>
<p>では、実際にこの動作を実行したい時はどうすればいいんだろう？ <code>putStrLn "str"</code> が純粋に、「<code>"str"</code> をターミナルに出力する動作」を返してきて、それを純粋に扱うことしかできないとなると、実際にターミナルに出力することはできないのではないだろうか？ それもその通りだ。では、<span class="ascii">Haskell</span> ではその問題をどう解決するか。実は <span class="ascii">Haskell</span> の <code>main</code> プログラムは、<code>IO</code> 型の値で定義するようになっている。つまり、</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb10-2" title="2">main <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="st">&quot;str&quot;</span></a></code></pre></div>
<p>というように、<code>main</code> を何らかの <code>IO</code> 動作で定義する。そして、実際にこのプログラムからコンパイルされた実行ファイルは、定義された動作をそのまま行うようになっている。こうすることで、<span class="ascii">Haskell</span> は純粋性を保ちながら、非純粋な動作を扱えるようになっている。</p>
<h2 id="io-モナド"><span class="link-to-here-outer"><a href="#io-モナド" title="io-モナド"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">IO</span> モナド</h2>
<p><span class="ascii">Haskell</span> の <code>putStrLn</code> が純粋な理由は分かってもらえただろうか？ さて中には、</p>
<blockquote>
<p>主張は分かったが、純粋に扱うだけに制限するということは、普通のプログラミング言語より非純粋な動作を上手く扱えないんじゃないか</p>
</blockquote>
<p>と疑問に思う人もいるだろう。これも当然の疑問だ。普通のプログラミング言語は、表現力豊かで、様々な制御構文を持ち、それぞれの構文が純粋性に拘らないため、とてもユニークな非純粋なプログラムを書くことができる。ただ、安心して欲しい。<span class="ascii">Haskell</span> も、それに負けない表現力で、非純粋な動作を作成することができる。さて、<span class="ascii">Haskell</span> は、普通のプログラミング言語の機構の基盤は</p>
<ul>
<li><span class="ascii">2</span>つの動作を上手く結合できること</li>
</ul>
<p>ではないかと考えた。そして、このうまく結合する機構を、<code>IO</code> 動作の上で実現する方法を考えた。結果、<span class="ascii">Haskell</span> では<span class="ascii">2</span>つの特殊な操作が組み込まれている<span class="ascii">:</span></p>
<ul>
<li>純粋な計算を、<code>IO</code> 動作に変換する<span class="ascii">:</span> <code>pure :: a -&gt; IO a</code></li>
<li><span class="ascii">2</span>つの <code>IO</code> 動作を繋げる<span class="ascii">:</span> <code>(&gt;&gt;=) :: IO a -&gt; (a -&gt; IO b) -&gt; IO b</code></li>
</ul>
<p><code>(&gt;&gt;=)</code> については少し説明が必要だろう。<span class="ascii">2</span>つの <code>IO</code> 動作を繋げるというのは、<code>(&gt;&gt;=) :: IO a -&gt; IO b -&gt; IO b</code> となった方が自然そうである。しかし、普通のプログラミング言語は、</p>
<ul>
<li>前の動作の結果により、次に行う動作を変える <span class="ascii">(</span><code>if</code> 文や <code>while</code> 文など<span class="ascii">)</span></li>
</ul>
<p>ということが可能だ。そして、前の動作の結果は変数束縛などにより自由に参照できる。<span class="ascii">Haskell</span> は、<code>IO</code> 動作を純粋性により実際に実行することはできない。その代わり、上の動作の制御機構を、繋げる操作に組み入れることで代用しようとしたのだ。つまり、</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="ot">(&gt;&gt;=) ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> <span class="dt">IO</span> b</a></code></pre></div>
<p>の操作は、</p>
<ol type="1">
<li>最初に受け取った <code>IO</code> 動作を実行し、</li>
<li>その結果から、次に行う <code>IO</code> 動作を<strong>純粋に</strong>生成し、</li>
<li>生成された動作を行う</li>
</ol>
<p>という動作全体を表す <code>IO</code> 動作を生成する。この結果から次に行う <code>IO</code> 動作を生成する部分をうまく定義すれば、<code>(&gt;&gt;=)</code> によって様々な制御構文を模倣できるのではないかと考えたのだ。この仕組みはとても上手くいった。<span class="ascii">Haskell</span> では、非純粋な動作を<code>if</code> 文や <code>while</code> 文で任意に実行することを、次のような純粋に動作を切り替える関数で代用する<span class="ascii">:</span></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="ot">ifIO ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb12-2" title="2">ifIO b act1 act2 <span class="ot">=</span> <span class="kw">case</span> b <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-3" title="3">  <span class="dt">True</span>  <span class="ot">-&gt;</span> act1</a>
<a class="sourceLine" id="cb12-4" title="4">  <span class="dt">False</span> <span class="ot">-&gt;</span> act2</a>
<a class="sourceLine" id="cb12-5" title="5"></a>
<a class="sourceLine" id="cb12-6" title="6"><span class="ot">whileIO ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb12-7" title="7">whileIO isEnd x0 act <span class="ot">=</span> go x0 <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-8" title="8">  go x <span class="ot">=</span> ifIO (isEnd x)</a>
<a class="sourceLine" id="cb12-9" title="9">    (<span class="fu">pure</span> ())</a>
<a class="sourceLine" id="cb12-10" title="10">    (</a>
<a class="sourceLine" id="cb12-11" title="11">        act x <span class="op">&gt;&gt;=</span> \nx <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb12-12" title="12">        go nx</a>
<a class="sourceLine" id="cb12-13" title="13">    )</a></code></pre></div>
<p>これらの関数を使えば、</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb13-2" title="2">main <span class="ot">=</span></a>
<a class="sourceLine" id="cb13-3" title="3">  <span class="fu">getLine</span> <span class="op">&gt;&gt;=</span> \loopCmd <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb13-4" title="4">  ifIO (loopCmd <span class="op">/=</span> <span class="st">&quot;loop&quot;</span>)</a>
<a class="sourceLine" id="cb13-5" title="5">    (<span class="fu">putStrLn</span> <span class="st">&quot;No loop&quot;</span>)</a>
<a class="sourceLine" id="cb13-6" title="6">    (whileIO (\(b, _) <span class="ot">-&gt;</span> b) (<span class="dt">False</span>, <span class="dv">0</span>) (\(_, i) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb13-7" title="7">        <span class="fu">putStrLn</span> (<span class="st">&quot;loop &quot;</span> <span class="op">++</span> <span class="fu">show</span> i) <span class="op">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb13-8" title="8">        <span class="fu">getLine</span> <span class="op">&gt;&gt;=</span> \loopEndCmd <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb13-9" title="9">        ifIO (loopEndCmd <span class="op">==</span> <span class="st">&quot;end&quot;</span>)</a>
<a class="sourceLine" id="cb13-10" title="10">          (<span class="fu">pure</span> (<span class="dt">True</span>, i))</a>
<a class="sourceLine" id="cb13-11" title="11">          (<span class="fu">pure</span> (<span class="dt">False</span>, i <span class="op">+</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb13-12" title="12">    ))</a></code></pre></div>
<p>のようなプログラムが書ける。このプログラムは、</p>
<ol type="1">
<li>最初にターミナルへの入力を待ち、<code>loop</code> と打たれれば、ループに入る。それ以外の場合は <code>"No loop"</code> と出力し、プログラムを終了する。</li>
<li>今のループの回数を出力し、ターミナルへの入力を待つ。</li>
<li>ターミナルに <code>end</code> と打たれれば、プログラムを終了する。それ以外の場合、ループカウントを<span class="ascii">1</span>増加させて、<span class="ascii">2</span> に戻る。</li>
</ol>
<p>ということを行う。このように、純粋な範囲内で繋げる操作を工夫することで、普通のプログラミング言語の機構を <code>IO</code> 動作内に組み込めるようになっている。ただ、このプログラムは大変見にくい。なので、<span class="ascii">Haskell</span> はさらに、この繋げる操作を元に、次のような <span class="ascii">DSL</span> を提供している<span class="ascii">:</span></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb14-2" title="2">main <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb14-3" title="3">  loopCmd <span class="ot">&lt;-</span> <span class="fu">getLine</span></a>
<a class="sourceLine" id="cb14-4" title="4">  ifIO (loopCmd <span class="op">/=</span> <span class="st">&quot;loop&quot;</span>)</a>
<a class="sourceLine" id="cb14-5" title="5">    (<span class="fu">putStrLn</span> <span class="st">&quot;No loop&quot;</span>)</a>
<a class="sourceLine" id="cb14-6" title="6">    (whileIO (\(b, _) <span class="ot">-&gt;</span> b) (<span class="dt">False</span>, <span class="dv">0</span>) (\(_, i) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb14-7" title="7">        <span class="fu">putStrLn</span> (<span class="st">&quot;loop &quot;</span> <span class="op">++</span> <span class="fu">show</span> i)</a>
<a class="sourceLine" id="cb14-8" title="8">        loopEndCmd <span class="ot">&lt;-</span> <span class="fu">getLine</span></a>
<a class="sourceLine" id="cb14-9" title="9">        ifIO (loopEndCmd <span class="op">==</span> <span class="st">&quot;end&quot;</span>)</a>
<a class="sourceLine" id="cb14-10" title="10">          (<span class="fu">pure</span> (<span class="dt">True</span>, i))</a>
<a class="sourceLine" id="cb14-11" title="11">          (<span class="fu">pure</span> (<span class="dt">False</span>, i <span class="op">+</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb14-12" title="12">    ))</a></code></pre></div>
<p>少しは見やすくなっただろうか？ この操作は、そこまで特別な操作をしてるわけではない。インデントを解析して、</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb15-2" title="2">main <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb15-3" title="3">  x1 <span class="ot">&lt;-</span> e1</a>
<a class="sourceLine" id="cb15-4" title="4">  x2 <span class="ot">&lt;-</span> e2</a>
<a class="sourceLine" id="cb15-5" title="5">  e3</a></code></pre></div>
<p>というのを、</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb16-2" title="2">main <span class="ot">=</span></a>
<a class="sourceLine" id="cb16-3" title="3">  e1 <span class="op">&gt;&gt;=</span> \x1 <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-4" title="4">  x2 <span class="ot">&lt;-</span> e2</a>
<a class="sourceLine" id="cb16-5" title="5">  e3</a></code></pre></div>
<p>に変形して、さらに</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb17-2" title="2">main <span class="ot">=</span></a>
<a class="sourceLine" id="cb17-3" title="3">  e1 <span class="op">&gt;&gt;=</span> \x1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb17-4" title="4">  e2 <span class="op">&gt;&gt;=</span> \x2 <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb17-5" title="5">  e3</a></code></pre></div>
<p>と変形して、</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb18-2" title="2">main <span class="ot">=</span></a>
<a class="sourceLine" id="cb18-3" title="3">  e1 <span class="op">&gt;&gt;=</span> \x1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb18-4" title="4">  e2 <span class="op">&gt;&gt;=</span> \x2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb18-5" title="5">  e3</a></code></pre></div>
<p>と変形する、というように最初から<span class="ascii">1</span>行<span class="ascii">1</span>行変形して、<code>do</code> がなくなるまで変形を行うだけだ。つまり一行一行の動作を <code>(&gt;&gt;=)</code> で繋げていくのだ。なお、一番最後以外は <code>x &lt;- e</code> という形になっているのが基本で、もしそのような形になっていない <code>e</code> は、<code>_ &lt;- e</code> と変換される <a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a> 。なので、</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb19-2" title="2">main <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb19-3" title="3">  <span class="fu">putStrLn</span> <span class="st">&quot;str1&quot;</span></a>
<a class="sourceLine" id="cb19-4" title="4">  <span class="fu">putStrLn</span> <span class="st">&quot;str2&quot;</span></a></code></pre></div>
<p>は、</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb20-2" title="2">main <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb20-3" title="3">  _ <span class="ot">&lt;-</span> <span class="fu">putStrLn</span> <span class="st">&quot;str1&quot;</span></a>
<a class="sourceLine" id="cb20-4" title="4">  <span class="fu">putStrLn</span> <span class="st">&quot;str2&quot;</span></a></code></pre></div>
<p>と変換された後、先ほどの変換によって、</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb21-2" title="2">main <span class="ot">=</span></a>
<a class="sourceLine" id="cb21-3" title="3">  <span class="fu">putStrLn</span> <span class="st">&quot;str1&quot;</span> <span class="op">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb21-4" title="4">  <span class="fu">putStrLn</span> <span class="st">&quot;str2&quot;</span></a></code></pre></div>
<p>となる。このようにして、<span class="ascii">Haskell</span> は他のプログラミング言語の非純粋な動作を、純粋な枠組みでも同じように扱えるようになっている <a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a> 。<span class="ascii">Haskell</span> は、この仕組みをモナディック<code>IO</code>と名付け、<code>IO</code> 型を <code>IO</code> モナドと呼んでいる。モナドとは何か、どういう便利な側面があるのかについては、他の記事に譲る。</p>
<h2 id="動作を第一級で取り扱う"><span class="link-to-here-outer"><a href="#動作を第一級で取り扱う" title="動作を第一級で取り扱う"><span class="link-to-here">Link to<br />
here</span></a></span>動作を第一級で取り扱う</h2>
<p>どうやら、<span class="ascii">Haskell</span> の <code>IO</code> 動作の仕組みが、純粋な枠組みでも他のプログラミング言語とそう劣るものではないということが分かってもらえただろうか？ ところで、先ほどの <code>ifIO</code> や <code>whileIO</code> は、<code>IO</code> 動作を何事もなく引数にとって返したりしていた。<code>ifIO</code> の定義をもう一度よく見てみよう<span class="ascii">:</span></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" title="1"><span class="ot">ifIO ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb22-2" title="2">ifIO b act1 act2 <span class="ot">=</span> <span class="kw">case</span> b <span class="kw">of</span></a>
<a class="sourceLine" id="cb22-3" title="3">  <span class="dt">True</span>  <span class="ot">-&gt;</span> act1</a>
<a class="sourceLine" id="cb22-4" title="4">  <span class="dt">False</span> <span class="ot">-&gt;</span> act2</a></code></pre></div>
<p>このプログラムは、条件を表す引数と、<code>IO</code> 動作を<span class="ascii">2</span>個受け取り、条件によって<span class="ascii">2</span>つの動作のうちのどちらかを返していた。これは考えてみれば、とても不思議で強力なことだと思わないだろうか？ 普通のプログラミング言語の <code>if</code> 文は、条件から書かれたプログラムのどちらかを実行する。一方、<code>ifIO</code> は実行を制御しているわけではない。単に、普通の関数と同じように、<span class="ascii">2</span>つの動作を受け取って、そのうちの片方を関数の返り値として返すだけだ。<code>ifIO</code> を呼び出したプログラマは、返ってきた動作をゴミ箱に捨ててもいいし、<code>(&gt;&gt;=)</code> で繋げて「<span class="ascii">2</span>回続けて同じ動作をする」<span class="ascii">1</span>つの動作にしてもいい。もちろんその動作も <code>main</code> に組み入れるかはプログラマ次第だ。なんなら、<code>main</code> 以外にライブラリの一部としてグローバルに定義してもいい。ライブラリを使うユーザは、やっぱりそれを使うも使わないも自由だ。<code>main</code> に組み入れない限り、その動作は単なるデータであり、実行もされない。</p>
<p><code>IO</code> 動作がデータであることは、プログラムをより豊かにする。さっきの <code>ifIO</code> は、条件によって片方の動作を返していた。<code>IO</code>動作はもっと多彩に制御できる。例えば、条件によって動作の順番を変えたかったら次のように書けばいい<span class="ascii">:</span></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" title="1"><span class="ot">chooseOrderIO ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb23-2" title="2">chooseOrderIO b act1 act2 <span class="ot">=</span> <span class="kw">case</span> b <span class="kw">of</span></a>
<a class="sourceLine" id="cb23-3" title="3">  <span class="dt">True</span>  <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb23-4" title="4">    act1</a>
<a class="sourceLine" id="cb23-5" title="5">    act2</a>
<a class="sourceLine" id="cb23-6" title="6">  <span class="dt">False</span> <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb23-7" title="7">    act2</a>
<a class="sourceLine" id="cb23-8" title="8">    act1</a></code></pre></div>
<p><code>chooseOrderIO</code> は条件によって、受け取った動作を実行する順番を変え、その順序で結合した動作を返す。順番が同じで結果だけ選ぶといったこともできる<span class="ascii">:</span></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" title="1"><span class="ot">ifResultIO ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb24-2" title="2">ifResultIO b act1 act2 <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb24-3" title="3">  x1 <span class="ot">&lt;-</span> act1</a>
<a class="sourceLine" id="cb24-4" title="4">  x2 <span class="ot">&lt;-</span> act2</a>
<a class="sourceLine" id="cb24-5" title="5">  <span class="kw">case</span> b <span class="kw">of</span></a>
<a class="sourceLine" id="cb24-6" title="6">    <span class="dt">True</span>  <span class="ot">-&gt;</span> x1</a>
<a class="sourceLine" id="cb24-7" title="7">    <span class="dt">False</span> <span class="ot">-&gt;</span> x2</a></code></pre></div>
<p><code>ifIO</code> は条件によって動作そのものを選んでいたが、<code>ifResultIO</code> はどの条件でも <code>act1</code> と <code>act2</code> の順に動作をすること自体は変えない。代わりに、その動作の結果をどっちにするかだけを変える。このように、<span class="ascii">Haskell</span> は <code>IO</code> 動作を、多彩に、しかも純粋にコーディネートすることができる。これは、他の多くのプログラミング言語にはなく、しかも強力な機能だ。そう、<span class="ascii">Haskell</span> の <code>IO</code> 動作は、それが単なるデータであるがゆえに、通常のプログラミングの範囲で自由に加工できるのだ。</p>
<p>これを、動作が第一級であるという。第一級とは、つまり他のデータと全く同じように扱えるということだ。</p>
<h2 id="まとめ"><span class="link-to-here-outer"><a href="#まとめ" title="まとめ"><span class="link-to-here">Link to<br />
here</span></a></span>まとめ</h2>
<p>この記事では、</p>
<ol type="1">
<li>純粋とは何か</li>
<li><span class="ascii">Haskell</span> は、どうして純粋なのか</li>
<li><span class="ascii">Haskell</span> は、純粋な中で、他の言語の機構をどうやって実現しているのか</li>
<li><span class="ascii">Haskell</span> が、その中で獲得した強力な機能とは何か</li>
</ol>
<p>について紹介した。どうだろう？ <span class="ascii">Haskell</span> の <span class="ascii">IO</span> モナドについて、少しでも理解の補助になっただろうか？</p>
<p><span class="ascii">Haskell</span> の <span class="ascii">IO</span> モナドとは、動作そのものを値に持つ型だった。そして、その値は、特別な繋げる操作により他の言語と同じように加工でき、しかも通常のプログラミングの範囲で加工が可能になっている。しかも、加工自体は純粋にでき、動作の生成も純粋にできる。これが、<span class="ascii">Haskell</span> が純粋であると言われる所以だった。</p>
<p>この <span class="ascii">Haskell</span> の根幹をなす機能が、どういう点で魅力的なのか分かってもらえたら、この記事を書いた甲斐があるというものだ。もし、あなたもこの機能の魅力に取り憑かれたらなら、ぜひ <code>IO</code> 動作をふんだんに加工してプログラミングをしていって欲しい。では、楽しい <span class="ascii">Haskell</span> ライフを。</p>
<h2 id="おまけ-ioモナドの実装"><span class="link-to-here-outer"><a href="#おまけ-ioモナドの実装" title="おまけ-ioモナドの実装"><span class="link-to-here">Link to<br />
here</span></a></span>おまけ<span class="ascii">: IO</span>モナドの実装</h2>
<p>ところで、もしかしたら、読者の中には、</p>
<blockquote>
<p><span class="ascii">Haskell</span> の <span class="ascii">IO</span> モナドは、現実世界を状態にする <span class="ascii">State</span> モナドだ</p>
</blockquote>
<p>という主張を、見たことがある人がいるかもしれない。最後におまけとしてこの話に触れておこうと思う。気になる人は、この後も呼んでみると、<code>IO</code> モナドの理解の助けになるかもしれない <span class="ascii">(</span>または、むしろ混乱するかもしれない。もし、混乱したなら、とりあえずこの話は忘れることをお勧めする。ここに書いてある話を理解しなくても、<code>IO</code> モナドの利用に関して全く支障はない。そういう話もあるぐらいの事柄だ。なので、安心してまずは <span class="ascii">Haskell</span> プログラミングを楽しんでほしい。いつか楽しみ飽きたら戻ってきてもいいかもしれない<span class="ascii">)</span>。</p>
<p>まず、この話は、</p>
<ul>
<li>非純粋な世界の話だということ</li>
<li>単なる <span class="ascii">State</span> モナドではないということ</li>
</ul>
<p>を押さえておいて欲しい。さて、<span class="ascii">Haskell</span> の代表的な処理系 <span class="ascii">GHC</span> は、標準の範囲では純粋関数型プログラミングを提供するが、全体としては非純粋な計算も許容している。そして、その計算を <code>IO</code> モナドの内部に使っている。<span class="ascii">GHC</span> では <code>IO</code> モナドは、通常の言語内の一部として定義されている<span class="ascii">:</span></p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" title="1"><span class="kw">newtype</span> <span class="dt">IO</span> a <span class="ot">=</span> <span class="dt">IO</span> (<span class="dt">State</span><span class="op">#</span> <span class="dt">RealWorld</span> <span class="ot">-&gt;</span> (<span class="op">#</span> <span class="dt">State</span><span class="op">#</span> <span class="dt">RealWorld</span>, a <span class="op">#</span>))</a></code></pre></div>
<p>この型は、詳細は省くが、本質的には、</p>
<ul>
<li><code>State# RealWorld</code> 型の値を受け取り、<code>State# RealWorld</code> 型の値と <code>a</code> 型の値のタプルを返す関数</li>
</ul>
<p>の <code>newtype</code> になっている。<code>State</code> モナドについて知ってる人は、これは <code>State (State# RealWorld) a</code> と同じだと思うだろう。しかし、<code>IO a</code> の値は、他に <span class="ascii">Haskell</span> の型では表現できない契約を持つ。それは、</p>
<ul>
<li><code>State# RealWorld</code> の型の値は、必ず<span class="ascii">1</span>回だけ使用される</li>
</ul>
<p>という契約だ。なので、</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" title="1"><span class="dt">IO</span> <span class="op">$</span> \s<span class="op">#</span> <span class="ot">-&gt;</span> (<span class="op">#</span> s<span class="op">#</span>, \() <span class="ot">-&gt;</span> s<span class="op">#</span> <span class="op">#</span>)</a></code></pre></div>
<p>は <a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a> <code>s#</code> を<span class="ascii">2</span>箇所で使ってるため <code>IO (() -&gt; State# RealWorld)</code> の値になれないし、</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" title="1"><span class="dt">IO</span> <span class="op">$</span> \s<span class="op">#</span> <span class="ot">-&gt;</span> (<span class="op">#</span> s<span class="op">#</span>, <span class="dt">IO</span> <span class="op">$</span> \_ <span class="ot">-&gt;</span> (<span class="op">#</span> s<span class="op">#</span>, () <span class="op">#</span>) <span class="op">#</span>)</a></code></pre></div>
<p>は一番外側の <code>IO</code> は <code>s#</code> を <span class="ascii">2</span> 箇所で使っているため契約違反で、内側の <code>IO</code> は受け取った引数を一度も使っていないのでやはり契約違反ということになる。この定義を使って、例えば <span class="ascii">Haskell</span> で可変参照を扱う <code>IORef</code> のフレームワークは、次のように定義されている <a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a> <span class="ascii">:</span></p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" title="1"><span class="kw">data</span> <span class="dt">IORef</span> a <span class="ot">=</span> <span class="dt">IORef</span> (<span class="dt">MutVar</span><span class="op">#</span> <span class="dt">RealWorld</span> a)</a>
<a class="sourceLine" id="cb28-2" title="2"></a>
<a class="sourceLine" id="cb28-3" title="3"><span class="ot">newIORef ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">IORef</span> a)</a>
<a class="sourceLine" id="cb28-4" title="4">newIORef <span class="fu">init</span> <span class="ot">=</span> <span class="dt">IO</span> <span class="op">$</span> \s1<span class="op">#</span> <span class="ot">-&gt;</span> <span class="kw">case</span> newMutVar<span class="op">#</span> <span class="fu">init</span> s1<span class="op">#</span> <span class="kw">of</span></a>
<a class="sourceLine" id="cb28-5" title="5">  (<span class="op">#</span> s2<span class="op">#</span>, var <span class="op">#</span>) <span class="ot">-&gt;</span> (s2<span class="op">#</span>, <span class="dt">IORef</span> var)</a>
<a class="sourceLine" id="cb28-6" title="6"></a>
<a class="sourceLine" id="cb28-7" title="7"><span class="ot">readIORef ::</span> <span class="dt">IORef</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb28-8" title="8">readIORef (<span class="dt">IORef</span> var) <span class="ot">=</span> <span class="dt">IO</span> <span class="op">$</span> \s1<span class="op">#</span> <span class="ot">-&gt;</span> readMutVar<span class="op">#</span> var<span class="op">#</span> s1<span class="op">#</span></a>
<a class="sourceLine" id="cb28-9" title="9"></a>
<a class="sourceLine" id="cb28-10" title="10"><span class="ot">writeIORef ::</span> <span class="dt">IORef</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb28-11" title="11">writeIORef (<span class="dt">IORef</span> var<span class="op">#</span>) val <span class="ot">=</span> <span class="dt">IO</span> <span class="op">$</span> \s1<span class="op">#</span> <span class="ot">-&gt;</span> <span class="kw">case</span> writeMutVar<span class="op">#</span> var<span class="op">#</span> val s1<span class="op">#</span> <span class="kw">of</span></a>
<a class="sourceLine" id="cb28-12" title="12">  s2<span class="op">#</span> <span class="ot">-&gt;</span> (<span class="op">#</span> s2<span class="op">#</span>, () <span class="op">#</span>)</a></code></pre></div>
<p>この定義は、ちゃんと <code>IO</code> 型の制約を守っている。なおここで出てくる、<code>#</code> が付く関数やデータ型は、<span class="ascii">GHC</span> の中で特別扱いされ、プリミティブな関数やデータ型になっている。それぞれ、以下の型の関数として扱える<span class="ascii">:</span></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" title="1">newMutVar<span class="op">#</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">State</span><span class="op">#</span> s <span class="ot">-&gt;</span> (<span class="op">#</span> <span class="dt">State</span><span class="op">#</span> s, <span class="dt">MutVar</span><span class="op">#</span> s a <span class="op">#</span>)</a>
<a class="sourceLine" id="cb29-2" title="2"></a>
<a class="sourceLine" id="cb29-3" title="3">readMutVar<span class="op">#</span><span class="ot"> ::</span> <span class="dt">MutVar</span><span class="op">#</span> s a <span class="ot">-&gt;</span> <span class="dt">State</span><span class="op">#</span> s <span class="ot">-&gt;</span> (<span class="op">#</span> <span class="dt">State</span><span class="op">#</span> s, a <span class="op">#</span>)</a>
<a class="sourceLine" id="cb29-4" title="4"></a>
<a class="sourceLine" id="cb29-5" title="5">writeMutVar<span class="op">#</span><span class="ot"> ::</span> <span class="dt">MutVar</span><span class="op">#</span> s a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">State</span><span class="op">#</span> s <span class="ot">-&gt;</span> <span class="dt">State</span><span class="op">#</span> s</a></code></pre></div>
<p>注意して欲しいのは、これらの関数は純粋ではないということだ。これは、<span class="ascii">GHCi</span> 上で次のように確認できる<span class="ascii">:</span></p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XMagicHash</span> <span class="op">-</span><span class="dt">XUnboxedTuples</span></a>
<a class="sourceLine" id="cb30-2" title="2"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span><span class="kw">module</span> <span class="dt">GHC.Prim</span> <span class="dt">GHC.Types</span></a>
<a class="sourceLine" id="cb30-3" title="3"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>{</a>
<a class="sourceLine" id="cb30-4" title="4"><span class="dt">IO</span> <span class="op">$</span> \r0<span class="op">#</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb30-5" title="5">  <span class="kw">let</span> (<span class="op">#</span> r1<span class="op">#</span>, var<span class="op">#</span> <span class="op">#</span>) <span class="ot">=</span> newMutVar<span class="op">#</span> <span class="dt">False</span> r0<span class="op">#</span> <span class="kw">in</span></a>
<a class="sourceLine" id="cb30-6" title="6">  <span class="kw">let</span> (<span class="op">#</span> r2<span class="op">#</span>, b1 <span class="op">#</span>) <span class="ot">=</span> readMutVar<span class="op">#</span> var<span class="op">#</span> r1<span class="op">#</span></a>
<a class="sourceLine" id="cb30-7" title="7">      r3<span class="op">#</span> <span class="ot">=</span> writeMutVar<span class="op">#</span> var<span class="op">#</span> <span class="dt">True</span> r2<span class="op">#</span></a>
<a class="sourceLine" id="cb30-8" title="8">  <span class="kw">in</span></a>
<a class="sourceLine" id="cb30-9" title="9">  <span class="kw">let</span> (<span class="op">#</span> _, b2 <span class="op">#</span>) <span class="ot">=</span> readMutVar<span class="op">#</span> var<span class="op">#</span> r1<span class="op">#</span> <span class="kw">in</span></a>
<a class="sourceLine" id="cb30-10" title="10">  (<span class="op">#</span> r3<span class="op">#</span>, b1 <span class="op">==</span> b2 <span class="op">#</span>)</a>
<a class="sourceLine" id="cb30-11" title="11"><span class="op">:</span>}</a>
<a class="sourceLine" id="cb30-12" title="12"><span class="dt">False</span></a></code></pre></div>
<p><code>b1</code> と <code>b2</code> は両方とも <code>readMutVar# var# r1#</code> から得た値になる。ところが、これらを比較してみると <code>False</code> になる <a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a> 。もし、<code>readMutVar#</code> が純粋なら、<code>b1</code> と <code>b2</code> の結果は同じになるため、上の評価結果は <code>True</code> になるはずだ。しかし、残念ながら <code>readMutVar#</code> は純粋ではないので、<code>b1</code> と <code>b2</code> は異なる値になってしまう。なお、この式は、<code>IO</code> 型で定義しているが、実際には</p>
<ul>
<li><span class="ascii">2</span> 回目の <code>readMutVar#</code> の呼び出しで <code>r1#</code> を <span class="ascii">2</span> 回使用しているし、</li>
<li>返ってきた <code>State# RealWorld</code> の値を捨てている</li>
</ul>
<p>ので契約違反であることに注意だ。<span class="ascii">GHCi</span> 上で、うまく評価結果を確認するために、<code>IO</code> を使っている。</p>
<p>さて、純粋性を守れないなら、<span class="ascii">GHC</span> は一体全体何のためにこのような定義をしているんだろう？ 関数が純粋でなくてもいいなら、単に</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" title="1"><span class="kw">newtype</span> <span class="dt">IO</span> a <span class="ot">=</span> <span class="dt">IO</span> (() <span class="ot">-&gt;</span> a)</a></code></pre></div>
<p>と定義しても問題ないのではないだろうか？ この方が自然に動作を表しているように思える。ところが、このような定義は、ある問題を招くのだ。<span class="ascii">Haskell</span> は純粋関数型プログラミング言語という売りの他に、遅延評価という他の言語にはあまり見られない評価機構を採用している。もちろん、<span class="ascii">GHC</span> も遅延評価が基本だ。正確には、<span class="ascii">Haskell</span> の評価順序は、</p>
<blockquote>
<p><span class="ascii">The order of evaluation of expressions in Haskell is constrained only by data dependencies; an implementation has a great deal of freedom in choosing this order.</span></p>
<p><span class="ascii">Haskell</span> の式の評価順序は、データ依存によってのみ縛られます。これは、実装がこの順序の選択において、大きな自由度を持つことを意味します。</p>
<p>– <a href="https://www.haskell.org/onlinereport/haskell2010/haskellch7.html#x14-1420007"><span class="ascii">Haskell Language Report - Chapter 7 Basic Input/Output</span></a></p>
</blockquote>
<p>とあるように、データ依存関係によってのみ制御できる。ところが、<code>IO</code>動作は違う。例えば、</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb32-2" title="2">main <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb32-3" title="3">  <span class="fu">putStrLn</span> <span class="st">&quot;str1&quot;</span></a>
<a class="sourceLine" id="cb32-4" title="4">  <span class="fu">putStrLn</span> <span class="st">&quot;str2&quot;</span></a></code></pre></div>
<p>という式において、<code>putStrLn "str1"</code> と <code>putStrLn "str2"</code> の動作の間には、何らのデータ依存関係も存在しない。しかしながら、<code>main</code> は</p>
<ul>
<li><code>"str1"</code> をターミナルに出力した後、<code>"str2"</code> をターミナルに出力する</li>
</ul>
<p>という動作を表して欲しいはずだ。つまり、<code>IO</code>動作はデータ依存関係によってのみ順序が決まるわけではなく、その繋げ方によって順序が決まって欲しいのだ。ところが、単純に</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" title="1"><span class="kw">newtype</span> <span class="dt">IO</span> a <span class="ot">=</span> <span class="dt">IO</span> (() <span class="ot">-&gt;</span> a)</a></code></pre></div>
<p>という定義を採用してしまうと、<code>IO</code>の中身は繋げ方の順序を情報として持たないため、動作の実行順序を制御するのに、別途工夫が必要になる。そこで、元の定義の登場だ<span class="ascii">:</span></p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" title="1"><span class="kw">newtype</span> <span class="dt">IO</span> a <span class="ot">=</span> <span class="dt">IO</span> (<span class="dt">State</span><span class="op">#</span> <span class="dt">RealWorld</span> <span class="ot">-&gt;</span> (<span class="op">#</span> <span class="dt">State</span><span class="op">#</span> <span class="dt">RealWorld</span>, a <span class="op">#</span>))</a></code></pre></div>
<p>この <code>State# RealWorld</code> は、実際には <code>()</code> 型と同じく単一の値を持つほぼ何の意味も持たない型になる。しかし、この型の値を計算度に付与することで、データ依存を作ることができる。具体的には、この <code>IO</code> に対して次のように <code>pure</code> <span class="ascii">/</span> <code>(&gt;&gt;=)</code> を定義するのだ<span class="ascii">:</span></p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" title="1"><span class="fu">pure</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb35-2" title="2"><span class="fu">pure</span> x <span class="ot">=</span> <span class="dt">IO</span> <span class="op">$</span> \r<span class="op">#</span> <span class="ot">-&gt;</span> (<span class="op">#</span> r<span class="op">#</span>, x <span class="op">#</span>)</a>
<a class="sourceLine" id="cb35-3" title="3"></a>
<a class="sourceLine" id="cb35-4" title="4"><span class="ot">(&gt;&gt;=) ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> <span class="dt">IO</span> b</a>
<a class="sourceLine" id="cb35-5" title="5"><span class="dt">IO</span> f <span class="op">&gt;&gt;=</span> g <span class="ot">=</span> <span class="dt">IO</span> <span class="op">$</span> \r0<span class="op">#</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb35-6" title="6">  <span class="kw">let</span> (<span class="op">#</span> r1<span class="op">#</span>, x <span class="op">#</span>) <span class="ot">=</span> f r0<span class="op">#</span></a>
<a class="sourceLine" id="cb35-7" title="7">      <span class="dt">IO</span> g&#39; <span class="ot">=</span> g x</a>
<a class="sourceLine" id="cb35-8" title="8">  <span class="kw">in</span> g&#39; r1<span class="op">#</span></a></code></pre></div>
<p>特に、<code>(&gt;&gt;=)</code> の定義が重要になる。<code>(&gt;&gt;=)</code> が返してくる <code>IO</code> の中身は、</p>
<ol type="1">
<li>受け取った <code>State# RealWorld</code> をまず最初の <code>IO</code> 動作に渡す</li>
<li>その結果を <code>g</code> に渡して、次の <code>IO</code> 動作を生成する</li>
<li>生成した <code>IO</code> 動作に、最初の <code>IO</code> 動作が返してきた <code>State# RealWorld</code> を渡す</li>
</ol>
<p>ということを行っている。これにより、</p>
<ol type="1">
<li>受け取った <code>State# RealWorld</code></li>
<li><code>f</code> の結果の <code>State# RealWorld</code></li>
<li><code>g'</code> の結果の <code>State# RealWorld</code></li>
</ol>
<p>という順で <code>State# RealWorld</code> のデータ依存関係が出来上がる。つまり、通常の <span class="ascii">Haskell</span> の評価の枠組みで、評価順序を保証できるようになるのだ。実際に、<code>IORef</code> を例に考えてみよう。</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb36-2" title="2">main <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb36-3" title="3">  x <span class="ot">&lt;-</span> newIORef <span class="dt">False</span></a>
<a class="sourceLine" id="cb36-4" title="4">  b1 <span class="ot">&lt;-</span> readIORef x</a>
<a class="sourceLine" id="cb36-5" title="5">  writeIORef <span class="dt">True</span> x</a>
<a class="sourceLine" id="cb36-6" title="6">  b2 <span class="ot">&lt;-</span> readIORef x</a>
<a class="sourceLine" id="cb36-7" title="7">  <span class="fu">pure</span> <span class="op">$</span> b1 <span class="op">==</span> b2</a></code></pre></div>
<p>というプログラムにおいて、最終的な <code>pure $ b1 == b2</code> からのデータ依存関係に、一見 <code>writeIORef True x</code> は関与していないように見える。ところが、内部を見てみると、上のプログラムは、</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb37-2" title="2">main <span class="ot">=</span> <span class="dt">IO</span> <span class="op">$</span> \r0<span class="op">#</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb37-3" title="3">  <span class="kw">let</span> (<span class="op">#</span> r1<span class="op">#</span>, x<span class="op">#</span> <span class="op">#</span>) <span class="ot">=</span> newMutVar<span class="op">#</span> <span class="dt">False</span> r0<span class="op">#</span></a>
<a class="sourceLine" id="cb37-4" title="4">      (<span class="op">#</span> r2<span class="op">#</span>, b1 <span class="op">#</span>) <span class="ot">=</span> readMutVar<span class="op">#</span> x<span class="op">#</span> r1<span class="op">#</span></a>
<a class="sourceLine" id="cb37-5" title="5">      r3<span class="op">#</span> <span class="ot">=</span> writeMutVar<span class="op">#</span> <span class="dt">True</span> x<span class="op">#</span> r2<span class="op">#</span></a>
<a class="sourceLine" id="cb37-6" title="6">      (<span class="op">#</span> r4<span class="op">#</span>, b2 <span class="op">#</span>) <span class="ot">=</span> readMutVar<span class="op">#</span> x<span class="op">#</span> r3<span class="op">#</span></a>
<a class="sourceLine" id="cb37-7" title="7">  <span class="kw">in</span> (<span class="op">#</span> r4<span class="op">#</span>, b1 <span class="op">==</span> b2 <span class="op">#</span>)</a></code></pre></div>
<p>と同じ意味を持ち、全て隠れた <code>State# RealWorld</code> によってデータ依存で紐づいている。もちろん、<code>let</code> 内の定義の順番を変えても何の問題もない。重要なのは <code>r0#</code> から <code>r1#</code> の結果が得られ、<code>r1#</code> から <code>r2#</code> の結果が得られ、というようなデータ依存だけだ。これにより、<span class="ascii">GHC</span> は <span class="ascii">Haskell</span> の評価順序に特別な規則を設けない <a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a> <a href="#fn10" class="footnote-ref" id="fnref10"><sup>10</sup></a> で、<code>IO</code> を実装しているのだ。</p>
<p>なお、こうなると <code>IO</code> の</p>
<ul>
<li><code>State# RealWorld</code> の型の値は、必ず<span class="ascii">1</span>回だけ使用される</li>
</ul>
<p>という契約も意義が見えてくる。もし、この契約が破られると、途中でデータ依存が分岐したり、または途中で途絶えたりすることになる。そうなると、動作がどういう挙動をするかは、<span class="ascii">Haskell</span> 内では規定されなくなってしまう。実際に、最適化によってどう動作するかが変わってきてしまう例も作れる。<code>IO</code> の契約とは、データ依存が必ず一本の線で繋がり、<span class="ascii">Haskell</span> の評価の枠できちんと順番が規定されるということを保証しているのだ。</p>
<p>これが、<span class="ascii">GHC</span> がこのような定義を <code>IO</code> で採用している理由になる。もちろん、アナロジーとして現実世界全体を表す架空の状態を <code>State# RealWorld</code> と見立て、<code>IO</code>動作の実行により新たな現実世界全体の状態が手に入るという見方は可能だ。名前の由来もそこから来ている。ただ、基本的には、<span class="ascii">GHC</span> において、特別な仕組みを入れずに <code>IO</code> を実装するためのやり方であるということを押さえておいて欲しい。</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>定義は、 <a href="https://www.schoolofhaskell.com/school/starting-with-haskell/basics-of-haskell/3-pure-functions-laziness-io"><span class="ascii">School of Haskell</span> のチュートリアル</a> から拝借している。<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>この定義は、<a href="https://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1220006.1.5"><span class="ascii">Haskell Language Report 6.1.5 The Unit Datatype</span></a> で述べられているが、実際には <span class="ascii">Haskell</span> の構文規則に違反している特別な構文が使われている。なので、実際に <span class="ascii">Haskell</span> でこのように定義できるわけではなく、擬似的に書くとこうなるという意味になる。<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>動作は、計算 <span class="ascii">(computation)</span> とも呼ばれる。また、日本の <span class="ascii">Haskell</span> コミュニティでは、英語そのままで「アクション」とも呼ばれている。<a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p>厳密には、<code>(&gt;&gt;)</code> という別の関数を使って定義されるんだが、意味的にはそのような変換と思ってもらって構わない。正式な変換方法は、<a href="https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14"><span class="ascii">Haskell Language Report 3.14 Do Expressions</span></a> を参照するといいだろう。<a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p>多くの言語では、<code>main</code> プログラム以外の、例えばライブラリが勝手にスレッドを<span class="ascii">1</span>つ立てるなどの挙動をサポートしている。そのような挙動は、<span class="ascii">Haskell</span> では残念ながらできない。なぜなら、<span class="ascii">Haskell</span> では <code>main</code> に動作を組み入れない限りその動作は実行されないからだ。この点では、他の言語より表現力は劣っているということもできる。しかし、そのような機能は、多くの場合明示的に模倣できる。<a href="#fnref5" class="footnote-back">↩</a></p></li>
<li id="fn6"><p><code>(# x, y #)</code> は <code>(# a, b #)</code> 型の値を表す特別な構文だ。ここでは詳細は述べないので、<code>x</code> と <code>y</code> のタプルの特別な表記方法だと思ってもらって構わない。<a href="#fnref6" class="footnote-back">↩</a></p></li>
<li id="fn7"><p>実際には <code>ST</code> モナドとの兼ね合いで、直接こう定義はされていないが、分かりやすさのため簡略化している。<a href="#fnref7" class="footnote-back">↩</a></p></li>
<li id="fn8"><p>実際には、最適化次第で結果が変わることもある。<a href="#fnref8" class="footnote-back">↩</a></p></li>
<li id="fn9"><p>さらに、<code>State# RealWorld</code> は <span class="ascii">unlifted</span> なデータ型になっており、サンクを持たない。このため、強制的に正格評価になるようになっており、<code>IO</code>動作が遅延され、最後に一気に評価されるということを防いでいる。これも、通常の <span class="ascii">GHC</span> の枠組みの中で提供されているのは、とても興味深い。<a href="#fnref9" class="footnote-back">↩</a></p></li>
<li id="fn10"><p>厳密には、残念ながら全てを特別扱いせずに済ませられているわけではない。<span class="ascii">GHC</span> では、<code>State# RealWorld</code> に関して一部の最適化で特別な処理を施している。<a href="#fnref10" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2020/haskell-casually-at-work.html" lang="ja">Haskellを業務で使う、カジュアルに</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2020/property-io.html" style="margin-left: auto;" lang="ja">HspecでQuickCheckするときもshouldBeなどが使えます</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>HspecでQuickCheckするときもshouldBeなどが使えます</title>
    <link href="https://haskell.jp/blog/posts/2020/property-io.html" />
    <id>https://haskell.jp/blog/posts/2020/property-io.html</id>
    <published>2020-02-27T00:00:00Z</published>
    <updated>2020-02-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>タイトルがほとんどすべてなんですが詳細を解説します。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#shouldbeなどはpropertyの中でも使えるので使ってください" title="shouldbeなどはpropertyの中でも使えるので使ってください">📣<code>shouldBe</code>などは<code>property</code>の中でも使えるので使ってください！</a></li>
<li><a href="#なぜ使える" title="なぜ使える">😕なぜ使える？</a></li>
</ul>
</div>
</div>
<h1 id="shouldbeなどはpropertyの中でも使えるので使ってください"><span class="link-to-here-outer"><a href="#shouldbeなどはpropertyの中でも使えるので使ってください" title="shouldbeなどはpropertyの中でも使えるので使ってください"><span class="link-to-here">Link to<br />
here</span></a></span>📣<code>shouldBe</code>などは<code>property</code>の中でも使えるので使ってください！</h1>
<p>みなさんは<span class="ascii">Hspec</span>で<span class="ascii">QuickCheck</span>を使った<span class="ascii">property test</span>を書く際、どのように書いているでしょうか？<br />
例えば<a href="https://hspec.github.io/quickcheck.html"><span class="ascii">Hspec</span>のマニュアル</a>のように、<span class="ascii">Hspec</span>に<span class="ascii">property test</span>を組み込む例として、次のような例を挙げています。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1">describe <span class="st">&quot;read&quot;</span> <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-2" title="2">  it <span class="st">&quot;is inverse to show&quot;</span> <span class="op">$</span> property <span class="op">$</span></a>
<a class="sourceLine" id="cb1-3" title="3">    \x <span class="ot">-&gt;</span> (<span class="fu">read</span> <span class="op">.</span> <span class="fu">show</span>) x <span class="op">==</span> (<span class="ot">x ::</span> <span class="dt">Int</span>)</a></code></pre></div>
<p>※<a href="https://github.com/hspec/hspec/blob/9f3f4c38952f526701a67b6e26336a3a5aec0e89/doc/quickcheck.md">こちらのコミット</a>の時点での話です。</p>
<p><code>property</code>関数に渡した関数<small>（以下、「<code>porperty</code>ブロック」と呼びます）</small>の中では<span class="ascii">Hspec</span>でおなじみの<code>shouldBe</code>などの<span class="ascii">expectation</span>用関数を使わず、<code>==</code>で結果を判定してますよね。<br />
このサンプルに倣って、<span class="ascii">Hspec</span>で書いたテストに<span class="ascii">property test</span>を書くときは、<code>==</code>を使ってる方が多いんじゃないでしょうか？</p>
<p>ところが、この記事のタイトルに書いたとおり、実際のところ<code>property</code>ブロックの中でも<code>shouldBe</code>は利用できます。<br />
つまりは、こちら👇のようにも書ける、ということです！</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1">describe <span class="st">&quot;read&quot;</span> <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-2" title="2">  it <span class="st">&quot;is inverse to show&quot;</span> <span class="op">$</span> property <span class="op">$</span></a>
<a class="sourceLine" id="cb2-3" title="3">    \x <span class="ot">-&gt;</span> (<span class="fu">read</span> <span class="op">.</span> <span class="fu">show</span>) x <span class="ot">`shouldBe`</span> (<span class="ot">x ::</span> <span class="dt">Int</span>)</a></code></pre></div>
<p>このように<code>property</code>ブロックの中でも<code>shouldBe</code>や<code>shouldSatisfy</code>といった、<span class="ascii">Hspec</span>固有の<span class="ascii">expectation</span>関数を使うことの利点は、単に構文を他のテストと一貫させることができる、だけではありません。<br />
<strong>テストが失敗したときのエラーが分かりやすくなる</strong>、という遥かに重大なメリットがあるのです。</p>
<p>試しにわざとテストを失敗させてみましょう。<br />
先ほどの例<span class="ascii">:</span></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1">describe <span class="st">&quot;read&quot;</span> <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-2" title="2">  it <span class="st">&quot;is inverse to show&quot;</span> <span class="op">$</span> property <span class="op">$</span></a>
<a class="sourceLine" id="cb3-3" title="3">    \x <span class="ot">-&gt;</span> (<span class="fu">read</span> <span class="op">.</span> <span class="fu">show</span>) x <span class="op">==</span> (<span class="ot">x ::</span> <span class="dt">Int</span>)</a></code></pre></div>
<p>における<code>(x :: Int)</code>という式を<code>(x + 1 :: Int)</code>に変えれば、必ず失敗するはずです。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1">describe <span class="st">&quot;read&quot;</span> <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-2" title="2">  it <span class="st">&quot;is inverse to show&quot;</span> <span class="op">$</span> property <span class="op">$</span></a>
<a class="sourceLine" id="cb4-3" title="3">    \x <span class="ot">-&gt;</span> (<span class="fu">read</span> <span class="op">.</span> <span class="fu">show</span>) x <span class="op">==</span> (x <span class="op">+</span> <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>)</a></code></pre></div>
<p>※お手元で試す場合は<a href="https://github.com/hspec/hspec/blob/9f3f4c38952f526701a67b6e26336a3a5aec0e89/doc/_includes/QuickCheck.hs">こちら</a>から元のコードを持ってきて、<code>stack build hspec</code>なりを実行した上で修正・実行するのが簡単でしょう。</p>
<p>結果、下記のようなエラーメッセージとなるでしょう。</p>
<pre><code>...
  1) read, when used with ints, is inverse to show
       Falsifiable (after 1 test):
         0</code></pre>
<p>このエラーでは「テストが失敗したこと」と「どんな入力を<span class="ascii">QuickCheck</span>が生成したか」までしか教えてくれず、わかりづらいですよね。</p>
<p>一方、<code>shouldBe</code>を使用して以下のように書き換えると…</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1">describe <span class="st">&quot;read&quot;</span> <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-2" title="2">  it <span class="st">&quot;is inverse to show&quot;</span> <span class="op">$</span> property <span class="op">$</span></a>
<a class="sourceLine" id="cb6-3" title="3">    \x <span class="ot">-&gt;</span> (<span class="fu">read</span> <span class="op">.</span> <span class="fu">show</span>) x <span class="ot">`shouldBe`</span> (x <span class="op">+</span> <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>)</a></code></pre></div>
<p>エラーメッセージはこう👇なります。</p>
<pre><code>  1) read, when used with ints, is inverse to show
       Falsifiable (after 1 test):
         0
       expected: 1
        but got: 0</code></pre>
<p>「テストが失敗したこと」と「どんな入力を<span class="ascii">QuickCheck</span>が生成したか」に加えて、<code>shouldBe</code>に与えた両辺の式がどのような値を返したか、まで教えてくれました！<br />
今回の例は極めて単純なのであまり役に立たないかも知れませんが、あなたが書いた関数をテストするときはやっぱり「期待される結果」と「実際の結果」両方がわかる方がデバッグしやすいですよね！</p>
<p>と、いうわけで今後は<code>property</code>関数<small>（あるいはその省略版の<code>prop</code>関数）</small>に渡した関数の中でも<code>shouldBe</code>などを必ず使ってください！<br />
<small>（せっかくなんで、今回紹介したドキュメントを<a href="https://github.com/hspec/hspec/pull/429">修正するための<span class="ascii">Pull request</span></a>を送っておきました。これがマージされればこの記事の情報の大半は時代遅れになります）</small></p>
<h1 id="なぜ使える"><span class="link-to-here-outer"><a href="#なぜ使える" title="なぜ使える"><span class="link-to-here">Link to<br />
here</span></a></span>😕なぜ使える？</h1>
<p>しかしここで、一つ疑問が残ります。<br />
<span class="ascii">QuickCheck</span>や<span class="ascii">Hspec</span>のドキュメントをつぶさに読んだことがある方はお気づきでしょう。<br />
<span class="ascii">QuickCheck</span>の<a href="http://hackage.haskell.org/package/QuickCheck-2.13.2/docs/Test-QuickCheck.html#t:Testable"><code>property</code>関数は、<code>Testable</code>という型クラスのメソッド</a>であるため、<code>Testable</code>のインスタンスでなければ使えないはずです。<br />
<span class="ascii">Hspec</span>の<code>shouldBe</code>などが返す値は型シノニムのたらい回しをたどればわかるとおり、結局のところ<code>IO ()</code>型の値です。<br />
ところが<code>Testable</code>のインスタンス一覧を見る限り、<code>IO a</code>は<code>Testable</code>のインスタンスではありません。<br />
先ほどの例のように</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1">property <span class="op">$</span> \x <span class="ot">-&gt;</span> (<span class="fu">read</span> <span class="op">.</span> <span class="fu">show</span>) x <span class="ot">`shouldBe`</span> (x <span class="op">+</span> <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>)</a></code></pre></div>
<p>と書いた場合における、関数型<code>(a -&gt; prop)</code>のインスタンスは、<code>(Arbitrary a, Show a, Testable prop) =&gt; Testable (a -&gt; prop)</code>という定義のとおり、関数の戻り値の型が<code>Testable</code>のインスタンスでないと、型チェックを通らないはずです。<br />
<code>Testable</code>のインスタンスでない、<code>IO ()</code>を返しているにも関わらず型エラーが起きなかったのは、一体なぜでしょうか？</p>
<p>その秘密を探るべく、<span class="ascii">GHCi</span>を立ち上げましょう。<br />
先ほどの例のソースコードを<code>ghci</code>コマンドに読ませれば、まとめて<span class="ascii">Hspec</span>のモジュールも<code>import</code>できるので簡単です。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb9-1" title="1"><span class="op">&gt;</span> <span class="ex">stack</span> exec ghci .\QuickCheck.hs</a></code></pre></div>
<p><span class="ascii">GHCi</span>が起動したら、<code>:i Testable</code>と入力して、<code>Testable</code>型クラスのインスタンス一覧を出力しましょう。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="op">&gt;</span> <span class="op">:</span>i <span class="dt">Testable</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="kw">class</span> <span class="dt">Testable</span> prop <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="ot">  property ::</span> prop <span class="ot">-&gt;</span> <span class="dt">Property</span></a>
<a class="sourceLine" id="cb10-4" title="4">  <span class="ot">{-# MINIMAL property #-}</span></a>
<a class="sourceLine" id="cb10-5" title="5">        <span class="co">-- Defined in ‘Test.QuickCheck.Property’</span></a>
<a class="sourceLine" id="cb10-6" title="6"><span class="kw">instance</span> [safe] <span class="dt">Testable</span> <span class="dt">Property</span></a>
<a class="sourceLine" id="cb10-7" title="7">  <span class="co">-- Defined in ‘Test.QuickCheck.Property’</span></a>
<a class="sourceLine" id="cb10-8" title="8"><span class="kw">instance</span> [safe] <span class="dt">Testable</span> prop <span class="ot">=&gt;</span> <span class="dt">Testable</span> (<span class="dt">Gen</span> prop)</a>
<a class="sourceLine" id="cb10-9" title="9">  <span class="co">-- Defined in ‘Test.QuickCheck.Property’</span></a>
<a class="sourceLine" id="cb10-10" title="10"><span class="kw">instance</span> [safe] <span class="dt">Testable</span> <span class="dt">Discard</span></a>
<a class="sourceLine" id="cb10-11" title="11">  <span class="co">-- Defined in ‘Test.QuickCheck.Property’</span></a>
<a class="sourceLine" id="cb10-12" title="12"><span class="kw">instance</span> [safe] <span class="dt">Testable</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb10-13" title="13">  <span class="co">-- Defined in ‘Test.QuickCheck.Property’</span></a>
<a class="sourceLine" id="cb10-14" title="14"><span class="kw">instance</span> [safe] (<span class="dt">Arbitrary</span> a, <span class="dt">Show</span> a, <span class="dt">Testable</span> prop) <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb10-15" title="15">                <span class="dt">Testable</span> (a <span class="ot">-&gt;</span> prop)</a>
<a class="sourceLine" id="cb10-16" title="16">  <span class="co">-- Defined in ‘Test.QuickCheck.Property’</span></a>
<a class="sourceLine" id="cb10-17" title="17"><span class="kw">instance</span> [safe] <span class="dt">Testable</span> ()</a>
<a class="sourceLine" id="cb10-18" title="18">  <span class="co">-- Defined in ‘Test.QuickCheck.Property’</span></a>
<a class="sourceLine" id="cb10-19" title="19"><span class="kw">instance</span> [safe] <span class="dt">Testable</span> <span class="dt">Test.HUnit.Lang.Assertion</span></a>
<a class="sourceLine" id="cb10-20" title="20">  <span class="co">-- Defined in ‘Test.QuickCheck.IO’</span></a></code></pre></div>
<p>ありました！💡 最後の方にある<code>instance [safe] Testable Test.HUnit.Lang.Assertion</code>という行に注目してください。<br />
<a href="http://hackage.haskell.org/package/HUnit-1.6.0.0/docs/Test-HUnit-Lang.html#t:Assertion"><code>Test.HUnit.Lang.Assertion</code></a>は、<code>IO ()</code>の型シノニムであり、<span class="ascii">Hspec</span>でも間接的に型シノニムとして参照されています<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>。<br />
要するに<code>instance [safe] Testable Test.HUnit.Lang.Assertion</code>という行は<code>instance [safe] Testable (IO ())</code>と読み替えることができます<small>（<code>[safe]</code>という表記が指しているものについてはここでは省略します！すみません！）</small>。</p>
<p>紹介したとおり<code>Testable</code>のドキュメントには<code>Testable Assertion</code>なんて記載はありませんし、じゃあ一体どこで定義したのか、というとそう、続く行に<code>-- Defined in ‘Test.QuickCheck.IO’</code>と書かれているとおり、<a href="https://hackage.haskell.org/package/quickcheck-io-0.2.0/docs/Test-QuickCheck-IO.html"><code>Test.QuickCheck.IO</code></a>というモジュールで定義されています！</p>
<p><code>Test.QuickCheck.IO</code>は、名前のとおり<span class="ascii">QuickCheck</span>の<code>Testable</code>について、<code>IO</code>の<span class="ascii">orphan instance</span>を定義するためのモジュールです。<br />
これを<a href="https://github.com/hspec/hspec/blob/226510631f24b674827e99d17d10f9f92440c5a9/hspec-core/src/Test/Hspec/Core/QuickCheckUtil.hs#L18"><code>import</code>している</a>が故に、<span class="ascii">Hspec</span>では<code>property</code>ブロックの中で<code>shouldBe</code>などが利用できるんですね！</p>
<p>結論<span class="ascii">:</span></p>
<ul>
<li><span class="ascii">orphan instance</span>わかりづらい😥</li>
<li><span class="ascii">GHCi</span>の<code>:i</code>は<span class="ascii">orphan instance</span>であろうとインスタンスを定義した箇所を見つけてくれるから便利！</li>
</ul>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>この節の冒頭で「型シノニムのたらい回し」と呼んだものを追いかけてみましょう。<br />
おなじみ<a href="http://hackage.haskell.org/package/hspec-expectations-0.8.2/docs/Test-Hspec-Expectations.html#v:shouldBe"><code>shouldBe</code></a>は<a href="http://hackage.haskell.org/package/hspec-expectations-0.8.2/docs/Test-Hspec-Expectations.html#t:Expectation"><code>Expectation</code></a>という型の値を返します。<br />
そして<code>Expectation</code>は<code>Assertion</code>の型シノニムであり、クリックすると<a href="http://hackage.haskell.org/package/HUnit-1.6.0.0/docs/Test-HUnit-Lang.html#t:Assertion"><code>Test.HUnit.Lang.Assertion</code></a>であることがわかります。<br />
そして<code>Assertion</code>はそう、<code>type Assertion = IO ()</code>とあるとおり<code>IO ()</code>なのです。やっと知ってる型にたどり着きました😌。<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2020/io-monad-and-sideeffect.html" lang="ja">IO モナドと副作用</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2020/revenge-of-hourly-antenna.html" style="margin-left: auto;" lang="ja">リベンジ・オブ・毎時更新 Haskell Antenna</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>リベンジ・オブ・毎時更新 Haskell Antenna</title>
    <link href="https://haskell.jp/blog/posts/2020/revenge-of-hourly-antenna.html" />
    <id>https://haskell.jp/blog/posts/2020/revenge-of-hourly-antenna.html</id>
    <published>2020-01-19T00:00:00Z</published>
    <updated>2020-01-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p><span class="ascii">Haskell-jp</span>のコンテンツの一つとして<a href="https://haskell.jp/antenna/"><span class="ascii">Haskell Antenna</span></a>という<span class="ascii">Web</span>ページの開発・運用をしております。</p>
<p><img src="../../img/2019/hourly-antenna/antenna-page.jpg" style="width: 100%;"></p>
<p><a href="https://haskell.jp/blog/posts/2019/hourly-antenna.html"><span class="ascii">2019</span>年の今頃、これを自動毎時更新しようと <span class="ascii">Drone Cloud</span>による毎時更新を設定しました</a>。</p>
<p>しかし。。。なんと去年の<span class="ascii">3</span>月ぐらいからこれが止まっています（どうやら、<a href="https://discourse.drone.io/t/cron-on-cloud-drone-io/3899/2"><span class="ascii">Drone Cloud</span>のこの機能を利用してマイニングをした人がいたらしく止めてしまった</a>ようです）。 現在は<strong>僕がだいたい毎朝<span class="ascii">1</span>回、手動で<span class="ascii">CI</span>を回しています</strong>。。。</p>
<p>ずっとなんとかしなきゃなぁと思い続けてはや<span class="ascii">9</span>ヶ月。 やっと重い腰をあげてなんとかしました！ というよりは、なんとかする方法を思い付いたので実装してみました。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#どうするか" title="どうするか">どうするか？</a></li>
<li><a href="#実装する" title="実装する">実装する</a>
<ul>
<li><a href="#オプションの整理" title="オプションの整理">オプションの整理</a></li>
<li><a href="#git-コマンドを呼ぶ" title="git-コマンドを呼ぶ"><span class="ascii">git</span> コマンドを呼ぶ</a></li>
<li><a href="#毎時実行" title="毎時実行">毎時実行</a></li>
</ul></li>
<li><a href="#インスタンスで起動する" title="インスタンスで起動する">インスタンスで起動する</a></li>
<li><a href="#今後やりたいこと" title="今後やりたいこと">今後やりたいこと</a></li>
</ul>
</div>
</div>
<h1 id="どうするか"><span class="link-to-here-outer"><a href="#どうするか" title="どうするか"><span class="link-to-here">Link to<br />
here</span></a></span>どうするか？</h1>
<p><a href="https://cloud.google.com/free/docs/gcp-free-tier?hl=ja#always-free"><span class="ascii">GCP</span>には<span class="ascii">always free</span>プランというのがあり</a>、<span class="ascii">GCE</span>インスタンスの場合は<span class="ascii">f1-micro</span>であれば一台だけ無料です（<span class="ascii">2020/1</span>現在）。 これに、毎時実行して更新をプッシュする<span class="ascii">antenna</span>プログラムを仕込んでおけば良いではないかということに気づきました。</p>
<p><span class="ascii">Haskell Antenna</span>自体は<span class="ascii">GitHub Pages</span>であり、<span class="ascii">HTML</span>などは<a href="https://github.com/haskell-jp/antenna"><span class="ascii">haskell-jp/antenna</span></a>という <span class="ascii">Haskell</span>製<span class="ascii">CLI</span>アプリケーションで生成しています。 これを<span class="ascii">cron</span>か何かで毎時実行すればいいんですけど</p>
<ol type="1">
<li><span class="ascii">cron</span>と<span class="ascii">Docker</span>の組み合わせが割とめんどくさい（<span class="ascii">antenna</span>は<span class="ascii">Docker Image</span>として提供している）</li>
<li><span class="ascii">cron</span>にした場合更新を<span class="ascii">GitHub</span>にどうやってプッシュしようかなどを考えるのがめんどくさい</li>
</ol>
<p>という問題があります。</p>
<p>そこで、<span class="ascii">(2)</span> のプッシュの部分も含めて毎時実行の処理を<span class="ascii">antenna</span>アプリケーションに閉じ込めてしまえば、<code>docker run</code> しておくだけで良いのではないか？というのを思い付きました！ ということで、そういう風に<span class="ascii">antenna</span>を改良します。</p>
<h1 id="実装する"><span class="link-to-here-outer"><a href="#実装する" title="実装する"><span class="link-to-here">Link to<br />
here</span></a></span>実装する</h1>
<p><span class="ascii">antenna</span>プログラムに「<span class="ascii">git</span>コマンドを使って<span class="ascii">GitHub</span>リポジトリに更新をプッシュする機能」と「全てを毎時実行する機能」の<span class="ascii">2</span>つを組み込む必要があります。 ここで後方互換性を維持するために、これらはオプションでオンする機能にしましょう。 なのでまずは、<span class="ascii">antenna CLI</span>アプリケーションのオプションを整理するところから始めます。</p>
<h2 id="オプションの整理"><span class="link-to-here-outer"><a href="#オプションの整理" title="オプションの整理"><span class="link-to-here">Link to<br />
here</span></a></span>オプションの整理</h2>
<p>改修前の<span class="ascii">antenna</span>はオプションを持っていません。 <code>getArgs</code> で引数（設定ファイルのパス）を受け取るだけです</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">import</span> <span class="dt">System.Environment</span> (getArgs)</a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="co">-- generate 関数が設定から HTML ファイル群を生成する IO アクション</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-5" title="5">main <span class="ot">=</span> (listToMaybe <span class="op">&lt;$&gt;</span> getArgs) <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb1-6" title="6">  <span class="dt">Nothing</span>   <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;please input config file path.&quot;</span></a>
<a class="sourceLine" id="cb1-7" title="7">  <span class="dt">Just</span> path <span class="ot">-&gt;</span> generate path <span class="op">=&lt;&lt;</span> readConfig path</a></code></pre></div>
<p>これを <a href="https://hackage.haskell.org/package/extensible-0.7/docs/Data-Extensible-GetOpt.html"><span class="ascii">extensible</span> の <code>GetOpt</code></a> を使ってオプションを貰えるように拡張します</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="co">-- withGetOpt&#39; は usage を独自で扱えるように拡張した Data.Extensible.withGetOpt です</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-3" title="3">main <span class="ot">=</span> withGetOpt&#39; <span class="st">&quot;[options] [input-file]&quot;</span> opts <span class="op">$</span> \r args usage <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb2-4" title="4">  <span class="kw">if</span> <span class="op">|</span> r <span class="op">^.</span> <span class="op">#</span>help    <span class="ot">-&gt;</span> hPutBuilder stdout (fromString usage)</a>
<a class="sourceLine" id="cb2-5" title="5">     <span class="op">|</span> r <span class="op">^.</span> <span class="op">#</span>version <span class="ot">-&gt;</span> hPutBuilder stdout (Version.build version)</a>
<a class="sourceLine" id="cb2-6" title="6">     <span class="op">|</span> <span class="fu">otherwise</span>     <span class="ot">-&gt;</span> runCmd r <span class="op">$</span> listToMaybe args</a>
<a class="sourceLine" id="cb2-7" title="7">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-8" title="8">    opts <span class="ot">=</span> <span class="op">#</span>help    <span class="op">@=</span> helpOpt</a>
<a class="sourceLine" id="cb2-9" title="9">        <span class="op">&lt;:</span> <span class="op">#</span>version <span class="op">@=</span> versionOpt</a>
<a class="sourceLine" id="cb2-10" title="10">        <span class="op">&lt;:</span> <span class="op">#</span>verbose <span class="op">@=</span> verboseOpt</a>
<a class="sourceLine" id="cb2-11" title="11">        <span class="op">&lt;:</span> nil</a>
<a class="sourceLine" id="cb2-12" title="12"></a>
<a class="sourceLine" id="cb2-13" title="13"><span class="kw">type</span> <span class="dt">Options</span> <span class="ot">=</span> <span class="dt">Record</span></a>
<a class="sourceLine" id="cb2-14" title="14">  &#39;[ <span class="st">&quot;help&quot;</span>    <span class="op">&gt;:</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-15" title="15">   , <span class="st">&quot;version&quot;</span> <span class="op">&gt;:</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-16" title="16">   , <span class="st">&quot;verbose&quot;</span> <span class="op">&gt;:</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-17" title="17">   ]</a>
<a class="sourceLine" id="cb2-18" title="18"></a>
<a class="sourceLine" id="cb2-19" title="19"><span class="ot">helpOpt ::</span> <span class="dt">OptDescr&#39;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-20" title="20">helpOpt <span class="ot">=</span> optFlag [<span class="ch">&#39;h&#39;</span>] [<span class="st">&quot;help&quot;</span>] <span class="st">&quot;Show this help text&quot;</span></a>
<a class="sourceLine" id="cb2-21" title="21"></a>
<a class="sourceLine" id="cb2-22" title="22"><span class="ot">versionOpt ::</span> <span class="dt">OptDescr&#39;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-23" title="23">versionOpt <span class="ot">=</span> optFlag [] [<span class="st">&quot;version&quot;</span>] <span class="st">&quot;Show version&quot;</span></a>
<a class="sourceLine" id="cb2-24" title="24"></a>
<a class="sourceLine" id="cb2-25" title="25"><span class="ot">verboseOpt ::</span> <span class="dt">OptDescr&#39;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-26" title="26">verboseOpt <span class="ot">=</span> optFlag [<span class="ch">&#39;v&#39;</span>] [<span class="st">&quot;verbose&quot;</span>] <span class="st">&quot;Enable verbose mode: verbosity level \&quot;debug\&quot;&quot;</span></a></code></pre></div>
<p>差分全体はこの<a href="https://github.com/haskell-jp/antenna/pull/20"><span class="ascii">PR</span></a>で確認することができます。 興味のある人はみてみてください。 <code>generate</code> 関数は以下の <code>runCmd</code> 関数から呼ばれています</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">import</span> <span class="dt">Mix</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="kw">import</span> <span class="dt">Mix.Plugin.Logger</span> <span class="kw">as</span> <span class="dt">MixLogger</span></a>
<a class="sourceLine" id="cb3-3" title="3"></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="ot">runCmd ::</span> <span class="dt">Options</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb3-5" title="5">runCmd _ <span class="dt">Nothing</span>        <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;please input config file path.&quot;</span></a>
<a class="sourceLine" id="cb3-6" title="6">runCmd opts (<span class="dt">Just</span> path) <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-7" title="7">  config <span class="ot">&lt;-</span> readConfig path</a>
<a class="sourceLine" id="cb3-8" title="8">  <span class="kw">let</span> plugin <span class="ot">=</span> hsequence</a>
<a class="sourceLine" id="cb3-9" title="9">             <span class="op">$</span> <span class="op">#</span>logger <span class="op">&lt;@=&gt;</span> MixLogger.buildPlugin logOpts</a>
<a class="sourceLine" id="cb3-10" title="10">            <span class="op">&lt;:</span> <span class="op">#</span>config <span class="op">&lt;@=&gt;</span> <span class="fu">pure</span> config</a>
<a class="sourceLine" id="cb3-11" title="11">            <span class="op">&lt;:</span> nil</a>
<a class="sourceLine" id="cb3-12" title="12">  Mix.run plugin <span class="op">$</span> generate path</a>
<a class="sourceLine" id="cb3-13" title="13">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-14" title="14">    logOpts <span class="ot">=</span> <span class="op">#</span>handle  <span class="op">@=</span> stdout</a>
<a class="sourceLine" id="cb3-15" title="15">           <span class="op">&lt;:</span> <span class="op">#</span>verbose <span class="op">@=</span> (opts <span class="op">^.</span> <span class="op">#</span>verbose)</a>
<a class="sourceLine" id="cb3-16" title="16">           <span class="op">&lt;:</span> nil</a></code></pre></div>
<p><code>runCmd</code> 関数は<a href="https://github.com/matsubara0507/mix.hs"><span class="ascii">mix.hs</span></a>を使って <code>RIO env ()</code> のボイラーテンプレートを減らしています。</p>
<h2 id="git-コマンドを呼ぶ"><span class="link-to-here-outer"><a href="#git-コマンドを呼ぶ" title="git-コマンドを呼ぶ"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">git</span> コマンドを呼ぶ</h2>
<p><span class="ascii">Haskell</span>アプリケーションから<span class="ascii">git</span>コマンドを実行するには<a href="https://hackage.haskell.org/package/shelly"><span class="ascii">Shelly</span></a>を使うことにします。 <span class="ascii">Shelly</span>は<span class="ascii">mix.hs</span>の<span class="ascii">shell</span>プラグインを使うことで簡単に使用することができます。 まずはコミットを作る部分を実装しましょう</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Git</span> <span class="co">-- 自作Shelly製gitコマンド関数群</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Mix.Plugin.Shell</span> <span class="kw">as</span> <span class="dt">MixShell</span></a>
<a class="sourceLine" id="cb4-3" title="3"></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="ot">runCmd ::</span> <span class="dt">Options</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-5" title="5">runCmd opts (<span class="dt">Just</span> path) <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-6" title="6">  config <span class="ot">&lt;-</span> readConfig path</a>
<a class="sourceLine" id="cb4-7" title="7">  <span class="kw">let</span> plugin <span class="ot">=</span> hsequence</a>
<a class="sourceLine" id="cb4-8" title="8">             <span class="op">$</span> <span class="op">#</span>logger <span class="op">&lt;@=&gt;</span> MixLogger.buildPlugin logOpts</a>
<a class="sourceLine" id="cb4-9" title="9">            <span class="op">&lt;:</span> <span class="op">#</span>config <span class="op">&lt;@=&gt;</span> <span class="fu">pure</span> config</a>
<a class="sourceLine" id="cb4-10" title="10">            <span class="op">&lt;:</span> <span class="op">#</span>work   <span class="op">&lt;@=&gt;</span> <span class="fu">pure</span> <span class="st">&quot;.&quot;</span></a>
<a class="sourceLine" id="cb4-11" title="11">            <span class="op">&lt;:</span> nil</a>
<a class="sourceLine" id="cb4-12" title="12">  Mix.run plugin <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-13" title="13">    when (opts <span class="op">^.</span> <span class="op">#</span>withCommit) <span class="op">$</span> MixShell.exec (Git.pull [])</a>
<a class="sourceLine" id="cb4-14" title="14">    generate path</a>
<a class="sourceLine" id="cb4-15" title="15">    when (opts <span class="op">^.</span> <span class="op">#</span>withCommit) <span class="op">$</span> commitGeneratedFiles</a>
<a class="sourceLine" id="cb4-16" title="16">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-17" title="17">    logOpts <span class="ot">=</span> <span class="op">...</span></a>
<a class="sourceLine" id="cb4-18" title="18"></a>
<a class="sourceLine" id="cb4-19" title="19"><span class="ot">commitGeneratedFiles ::</span> <span class="dt">RIO</span> <span class="dt">Env</span> ()</a>
<a class="sourceLine" id="cb4-20" title="20">commitGeneratedFiles <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-21" title="21">  files <span class="ot">&lt;-</span> view <span class="op">#</span>files <span class="op">&lt;$&gt;</span> asks (gitConfig <span class="op">.</span> view <span class="op">#</span>config)</a>
<a class="sourceLine" id="cb4-22" title="22">  MixShell.exec <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-23" title="23">    Git.add files</a>
<a class="sourceLine" id="cb4-24" title="24">    changes <span class="ot">&lt;-</span> Git.diffFileNames [<span class="st">&quot;--staged&quot;</span>]</a>
<a class="sourceLine" id="cb4-25" title="25">    when (<span class="fu">not</span> <span class="op">$</span> <span class="fu">null</span> changes) <span class="op">$</span> Git.commit [<span class="st">&quot;-m&quot;</span>, message]</a>
<a class="sourceLine" id="cb4-26" title="26">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-27" title="27">    message <span class="ot">=</span> <span class="op">...</span></a></code></pre></div>
<p>全ての差分はこの<a href="https://github.com/haskell-jp/antenna/pull/21"><span class="ascii">PR</span></a>から確認できます。 <code>runCmd</code> 関数に追記したのは <code>when (opts ^. #withCommit)</code> から始まる<span class="ascii">2</span>行です（<code>Options</code> に <code>#withCommit</code> を追加しています）。 <span class="ascii">mix.hs</span>の<span class="ascii">shell</span>プラグインを使うことで<span class="ascii">Shelly</span>のログをだいたいそれっぽく<span class="ascii">rio</span>のロガーに流してくれます。</p>
<p>次に、<code>git push</code>も実装します</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="ot">runCmd ::</span> <span class="dt">Options</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb5-2" title="2">runCmd opts (<span class="dt">Just</span> path) <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-3" title="3">  <span class="op">...</span></a>
<a class="sourceLine" id="cb5-4" title="4">  Mix.run plugin <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-5" title="5">    when (opts <span class="op">^.</span> <span class="op">#</span>withCommit) <span class="op">$</span> MixShell.exec (Git.pull [])</a>
<a class="sourceLine" id="cb5-6" title="6">    generate path</a>
<a class="sourceLine" id="cb5-7" title="7">    when (opts <span class="op">^.</span> <span class="op">#</span>withCommit) <span class="op">$</span> commitGeneratedFiles</a>
<a class="sourceLine" id="cb5-8" title="8">    when (opts <span class="op">^.</span> <span class="op">#</span>withPush)   <span class="op">$</span> pushCommit</a>
<a class="sourceLine" id="cb5-9" title="9"></a>
<a class="sourceLine" id="cb5-10" title="10"><span class="ot">pushCommit ::</span> <span class="dt">RIO</span> <span class="dt">Env</span> ()</a>
<a class="sourceLine" id="cb5-11" title="11">pushCommit <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-12" title="12">  branch <span class="ot">&lt;-</span> view <span class="op">#</span>branch <span class="op">&lt;$&gt;</span> asks (gitConfig <span class="op">.</span> view <span class="op">#</span>config)</a>
<a class="sourceLine" id="cb5-13" title="13">  MixShell.exec (Git.push [<span class="st">&quot;origin&quot;</span>, branch])</a></code></pre></div>
<p>前から使っている <code>gitConfig</code> は設定ファイルから<span class="ascii">git</span>コマンドに関する設定を取ってきています（例えば、どのファイルをコミットするかやどのブランチにプッシュするかなど）。</p>
<p>これで、差分があった場合は<code>git commit</code>を実行し、最後に<code>git push</code>するようなオプション、<code>--with-commit</code>と<code>--with-push</code>を実装できました（他にも実装していますが割愛）。</p>
<h2 id="毎時実行"><span class="link-to-here-outer"><a href="#毎時実行" title="毎時実行"><span class="link-to-here">Link to<br />
here</span></a></span>毎時実行</h2>
<p>メインディッシュである毎時実行です。 <span class="ascii">Haskell-jp Slack</span>で、スケジューリング実行を<span class="ascii">Haskell</span>アプリケーション内で行うのにちょうど良いパッケージはありますか？と尋ねたところ<a href="https://hackage.haskell.org/package/cron"><span class="ascii">cron</span></a>というパッケージを紹介してもらいました（名前がややこしい笑）。 調べてみたところ、ちょうど良さそうなのでこれを使うことにします</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">import</span> <span class="dt">System.Cron</span> (addJob, execSchedule)</a>
<a class="sourceLine" id="cb6-2" title="2"></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb6-4" title="4">main <span class="ot">=</span> withGetOpt&#39; <span class="st">&quot;[options] [input-file]&quot;</span> opts <span class="op">$</span> \r args usage <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-5" title="5">  <span class="kw">if</span> <span class="op">|</span> r <span class="op">^.</span> <span class="op">#</span>help     <span class="ot">-&gt;</span> hPutBuilder stdout (fromString usage)</a>
<a class="sourceLine" id="cb6-6" title="6">     <span class="op">|</span> r <span class="op">^.</span> <span class="op">#</span>version  <span class="ot">-&gt;</span> hPutBuilder stdout (Version.build version)</a>
<a class="sourceLine" id="cb6-7" title="7">     <span class="op">|</span> r <span class="op">^.</span> <span class="op">#</span>hourly   <span class="ot">-&gt;</span> runCmd r (listToMaybe args) <span class="ot">`withCron`</span> <span class="st">&quot;0 * * * *&quot;</span></a>
<a class="sourceLine" id="cb6-8" title="8">     <span class="op">|</span> <span class="fu">otherwise</span>      <span class="ot">-&gt;</span> runCmd r (listToMaybe args)</a>
<a class="sourceLine" id="cb6-9" title="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-10" title="10">    opts <span class="ot">=</span> <span class="op">...</span></a>
<a class="sourceLine" id="cb6-11" title="11"></a>
<a class="sourceLine" id="cb6-12" title="12"><span class="ot">withCron ::</span> <span class="dt">IO</span> () <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb6-13" title="13">withCron act t <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-14" title="14">  _ <span class="ot">&lt;-</span> execSchedule <span class="op">$</span> addJob act t</a>
<a class="sourceLine" id="cb6-15" title="15">  forever <span class="op">$</span> threadDelay <span class="fu">maxBound</span> <span class="co">-- 無限ループ</span></a></code></pre></div>
<p>全ての差分はこの<a href="https://github.com/haskell-jp/antenna/pull/22"><span class="ascii">PR</span></a>から確認できます。 すっごい簡単ですね。 ついでに、毎日実行と毎分実行するオプションも追加しています。</p>
<p>これでアプリケーションの方は出来上がったので、こいつを<span class="ascii">GCE</span>インスタンスで動作させてみましょう。</p>
<h1 id="インスタンスで起動する"><span class="link-to-here-outer"><a href="#インスタンスで起動する" title="インスタンスで起動する"><span class="link-to-here">Link to<br />
here</span></a></span>インスタンスで起動する</h1>
<p>まずは<span class="ascii">GCP Console</span>からインスタンス作成します。 構成は次の通りです</p>
<ul>
<li><span class="ascii">f1-micro</span></li>
<li>オレゴンリージョン</li>
<li><span class="ascii">30GB</span>の標準ストレージ</li>
<li><span class="ascii">OS</span>は<span class="ascii">Ubuntu 18.04</span></li>
</ul>
<p><span class="ascii">GCP Console</span>から<span class="ascii">SSH</span>して、<span class="ascii">docker</span> コマンドをインストールします（やり方は<a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">公式サイト</a>のをそのまま）。 ここまでできたら試しに <code>sudo docker pull haskelljp/antenna</code> して最新のイメージを取得してみましょう。</p>
<p>次に、<span class="ascii">GitHub</span>にプッシュするために<span class="ascii">SSH Key</span>を生成してデプロイキーを <span class="ascii">haskell-jp/antenna</span> リポジトリに設定します。 できたら適当に <code>git clone git@github.com:haskell-jp/antenna.git</code> してブランチを <code>gh-pages</code> に切り替えます。</p>
<p>あとは次のコマンドで<span class="ascii">antenna</span>プログラムを実行するだけです</p>
<pre><code>$ sudo docker run -d \
  -v `pwd`:/work
  -v `echo $HOME`/.ssh:/root/.ssh \
  haskelljp/antenna antenna --verbose --with-commit --with-push --with-copy --hourly sites.yaml</code></pre>
<p><code>docker logs</code> を使って様子をみてましたが、うまくいってるようです！</p>
<h1 id="今後やりたいこと"><span class="link-to-here-outer"><a href="#今後やりたいこと" title="今後やりたいこと"><span class="link-to-here">Link to<br />
here</span></a></span>今後やりたいこと</h1>
<p><span class="ascii">igrep</span>氏が<a href="https://github.com/haskell-jp/antenna/issues/16"><span class="ascii">Issue</span></a>にしてくれてるように、<span class="ascii">Haskell Antenna</span>の正しい差分を<span class="ascii">Haskell-jp Slack</span>に通知する仕組みを整備しようと考えてます。</p>
<p>実はコミットを<span class="ascii">Haskell</span>アプリケーション内で組み立てるようになった結果、<span class="ascii">Haskell</span>アプリケーション側でいい感じに差分を調べ上げ、その結果をコミットメッセージに組み込むことができるようになりました。 さすがに<span class="ascii">HTML</span>やフィードの <code>git diff</code> を解析するのは大変なので、いい感じに各サイトの最終更新ログを残すようにしてみようかなって考えてます。</p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2020/property-io.html" lang="ja">HspecでQuickCheckするときもshouldBeなどが使えます</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/regex-applicative.html" style="margin-left: auto;" lang="ja">regex-applicative: 内部DSLとしての正規表現（ブログ記事版）</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>regex-applicative: 内部DSLとしての正規表現（ブログ記事版）</title>
    <link href="https://haskell.jp/blog/posts/2019/regex-applicative.html" />
    <id>https://haskell.jp/blog/posts/2019/regex-applicative.html</id>
    <published>2019-12-30T00:00:00Z</published>
    <updated>2019-12-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>先日、といっても<span class="ascii">2019</span>年<span class="ascii">10</span>月<span class="ascii">18</span>日のことなんでもう<span class="ascii">2</span>ヶ月以上も経ってしまいましたが、私は<a href="https://opt.connpass.com/event/140566/"><span class="ascii">Regex Festa</span></a>というイベントで、「<a href="http://hackage.haskell.org/package/regex-applicative"><span class="ascii">regex-applicative</span></a>」というパッケージの紹介を致しました。<br />
今回は<a href="https://the.igreque.info/slides/2019-10-18-regex-applicative.html">その際使用したスライド</a>を、ブログ記事として詳しく共有させていただきたいと思います！<br />
発表時のスライドと比べて、より<span class="ascii">Haskell</span>を知っている人向けになってしまいますが、<span class="ascii">regex-applicative</span>の魅力を明確に伝えるために必要なのでご了承ください。<br />
<span class="ascii">Applicative</span>スタイルを前提知識とします。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#はじめにまとめ" title="はじめにまとめ">はじめにまとめ</a></li>
<li><a href="#regex-applicativeって" title="regex-applicativeって"><span class="ascii">regex-applicative</span>って？</a></li>
<li><a href="#regex-applicativeのapi概要" title="regex-applicativeのapi概要"><span class="ascii">regex-applicative</span>の<span class="ascii">API</span>概要</a></li>
<li><a href="#regex-applicativeの使用例" title="regex-applicativeの使用例"><span class="ascii">regex-applicative</span>の使用例</a>
<ul>
<li><a href="#ただの文字-sym-eq-s-s---re-s-s" title="ただの文字-sym-eq-s-s---re-s-s">ただの文字<span class="ascii">:</span> <code>sym :: Eq s =&gt; s -&gt; RE s s</code></a></li>
<li><a href="#空文字ε-pure-a---re-s-a" title="空文字ε-pure-a---re-s-a">空文字（ε）<span class="ascii">:</span> <code>pure :: a -&gt; RE s a</code></a></li>
<li><a href="#連接-re-s-a---re-s-b---re-s-bstring-eq-a-a---re-a-a" title="連接-re-s-a---re-s-b---re-s-bstring-eq-a-a---re-a-a">連接<span class="ascii">:</span> <code>(*&gt;) :: RE s a -&gt; RE s b -&gt; RE s b</code>・<code>string :: Eq a =&gt; [a] -&gt; RE a [a]</code></a></li>
<li><a href="#選択-re-s-a---re-s-a---re-s-a" title="選択-re-s-a---re-s-a---re-s-a">選択<span class="ascii">:</span> <code>(&lt;|&gt;) :: RE s a -&gt; RE s a -&gt; RE s a</code></a></li>
<li><a href="#繰り返し-many-re-s-a---re-s-asome-re-s-a---re-s-a" title="繰り返し-many-re-s-a---re-s-asome-re-s-a---re-s-a">繰り返し<span class="ascii">:</span> <code>many :: RE s a -&gt; RE s [a]</code>・<code>some :: RE s a -&gt; RE s [a]</code></a></li>
<li><a href="#オプショナルなマッチ-optional-re-s-a---re-s-maybe-a" title="オプショナルなマッチ-optional-re-s-a---re-s-maybe-a">オプショナルなマッチ<span class="ascii">:</span> <code>optional :: RE s a -&gt; RE s (Maybe a)</code></a></li>
<li><a href="#マッチした結果をhaskellの値に割り当て" title="マッチした結果をhaskellの値に割り当て">マッチした結果を<span class="ascii">Haskell</span>の値に割り当て</a>
<ul>
<li><a href="#組み込みの正規表現を使う" title="組み込みの正規表現を使う">組み込みの正規表現を使う</a></li>
<li><a href="#a---b---re-s-a---re-s-b-任意の一引数の関数を適用する" title="a---b---re-s-a---re-s-b-任意の一引数の関数を適用する"><code>(&lt;$&gt;) :: (a -&gt; b) -&gt; RE s a -&gt; RE s b</code><span class="ascii">:</span> 任意の（一引数の）関数を適用する</a></li>
<li><a href="#re-s-a---b---re-s-a---re-s-b-任意の関数を適用する" title="re-s-a---b---re-s-a---re-s-b-任意の関数を適用する"><code>(&lt;*&gt;) :: RE s (a -&gt; b) -&gt; RE s a -&gt; RE s b</code><span class="ascii">:</span> 任意の関数を適用する</a></li>
</ul></li>
<li><a href="#もうちょっと複雑な例" title="もうちょっと複雑な例">もうちょっと複雑な例</a></li>
</ul></li>
<li><a href="#regex-applicativeのメリット" title="regex-applicativeのメリット">👍<span class="ascii">regex-applicative</span>のメリット</a></li>
<li><a href="#regex-applicativeのデメリット" title="regex-applicativeのデメリット">👎<span class="ascii">regex-applicative</span>のデメリット</a></li>
<li><a href="#regex-applicativeの仕組み" title="regex-applicativeの仕組み">⚙️<span class="ascii">regex-applicative</span>の仕組み</a>
<ul>
<li><a href="#正規表現エンジンの分類" title="正規表現エンジンの分類">📑正規表現エンジンの分類</a></li>
<li><a href="#regex-applicativeの実際の実装" title="regex-applicativeの実際の実装"><span class="ascii">regex-applicative</span>の実際の実装</a></li>
</ul></li>
<li><a href="#類似のライブラリーとの比較を軽く" title="類似のライブラリーとの比較を軽く">類似のライブラリーとの比較を軽く</a>
<ul>
<li><a href="#各種パーサーコンビネーター" title="各種パーサーコンビネーター">各種パーサーコンビネーター</a>
<ul>
<li><a href="#番外編-replace-attoparsecreplace-megaparsec" title="番外編-replace-attoparsecreplace-megaparsec">番外編<span class="ascii">: replace-attoparsec</span>・<span class="ascii">replace-megaparsec</span></a></li>
</ul></li>
<li><a href="#verbalexpressions" title="verbalexpressions"><span class="ascii">VerbalExpressions</span></a></li>
</ul></li>
<li><a href="#まとめ" title="まとめ">まとめ</a></li>
</ul>
</div>
</div>
<h1 id="はじめにまとめ"><span class="link-to-here-outer"><a href="#はじめにまとめ" title="はじめにまとめ"><span class="link-to-here">Link to<br />
here</span></a></span>はじめにまとめ</h1>
<ul>
<li><span class="ascii">regex-applicative</span>は、<span class="ascii">Haskell</span>の式で正規表現を書ける内部<span class="ascii">DSL</span></li>
<li>パーサーコンビネーターっぽく使えて、かつ正規表現の良さ — 中間マッチが簡単にできる点など — を持ち合わせている</li>
<li>内部は「文字を受け取って続きの状態のリストを返す関数」として表現された<span class="ascii">NFA</span>で実装されている</li>
</ul>
<h1 id="regex-applicativeって"><span class="link-to-here-outer"><a href="#regex-applicativeって" title="regex-applicativeって"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">regex-applicative</span>って？</h1>
<p><a href="http://hackage.haskell.org/package/regex-applicative"><span class="ascii">regex-applicative</span></a>は、正規表現を<span class="ascii">Haskell</span>の内部<span class="ascii">DSL</span>として表現したライブラリーです。<br />
名前のとおり、いわゆる「<code>Applicative</code>スタイル」で正規表現を書くことができます。</p>
<h1 id="regex-applicativeのapi概要"><span class="link-to-here-outer"><a href="#regex-applicativeのapi概要" title="regex-applicativeのapi概要"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">regex-applicative</span>の<span class="ascii">API</span>概要</h1>
<p><span class="ascii">regex-applicative</span>には、正規表現オブジェクト<a href="http://hackage.haskell.org/package/regex-applicative-0.3.3.1/docs/Text-Regex-Applicative.html#t:RE"><code>RE</code>型</a>の値とマッチさせる文字列を受け取って、その結果を返す関数がいくつかあります。<br />
今回はそのうち最も単純な<code>match</code>関数を使用します。👇のような型定義となっています。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="ot">match ::</span> <span class="dt">RE</span> s a <span class="ot">-&gt;</span> [s] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a></code></pre></div>
<p>定義のとおり、<code>RE</code>型は型引数としてマッチさせる文字の型<code>s</code>と、マッチした結果にも使われる「正規表現の結果」を表す型<code>a</code>を受け取ります。<br />
<code>RE</code>型を<code>Applicative</code>のインスタンスにするためには、その結果を表す型が必須なのです。この後出す例でこの「正規表現の結果」を好きな値に変える方法を示しましょう。</p>
<p>そして第<span class="ascii">2</span>引数がマッチさせる文字列に当たります。<code>[s]</code>と<code>RE</code>型の第<span class="ascii">1</span>型引数<code>s</code>のリストになっているとおり、<code>match</code>関数<small>（と、その他の<span class="ascii">regex-applicative</span>において文字列をマッチさせる<span class="ascii">API</span>）</small>は任意のリストに対して使用することができます。<br />
<span class="ascii">Haskell</span>の標準の文字列<code>String</code>の実態は<code>[Char]</code>、すなわち<code>Char</code>のリストなので、通常<span class="ascii">regex-applicative</span>を使用する場合<code>s</code>には<code>Char</code>が割り当てられます。<br />
型変数なので、当然他の型のリストに対しても使用できます。これは他の正規表現ライブラリーではあまりない特性でしょう。</p>
<p>戻り値はおなじみの<code>Maybe</code>型です。マッチが成功すれば、引数に渡した正規表現<code>RE s a</code>型の「結果」、<code>a</code>型の値を<code>Just</code>にくるんで返します。そして失敗すればもちろん<code>Nothing</code>を返します。</p>
<p>⚠️<code>match</code>関数について特筆すべきことをもう一つ。他のよくある正規表現ライブラリーと異なり、<code>match</code>関数は完全一致じゃないとマッチしないのでご注意ください。<br />
<span class="ascii">regex-applicative</span>には完全一致じゃないといけない関数と完全一致じゃなくてもよい関数両方があるので、少し混乱します😰</p>
<h1 id="regex-applicativeの使用例"><span class="link-to-here-outer"><a href="#regex-applicativeの使用例" title="regex-applicativeの使用例"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">regex-applicative</span>の使用例</h1>
<p>それではいよいよ<span class="ascii">regex-applicative</span>パッケージを使ってみましょう。<br />
👇のコマンドでインストールして、<span class="ascii">GHCi</span>で試します。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" title="1"><span class="ex">stack</span> build regex-applicative</a>
<a class="sourceLine" id="cb2-2" title="2"><span class="ex">stack</span> exec ghci</a></code></pre></div>
<p><small>（最近の）</small><code>cabal</code>の場合は👇を実行すればできるはずです。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" title="1"><span class="ex">cabal</span> v2-install --lib regex-applicative</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="ex">cabal</span> v2-repl -b regex-applicative</a></code></pre></div>
<p><span class="ascii">GHCi</span>が起動したら、こちらの<code>import</code>文を張って、本記事のサンプルを実行する準備をしてください。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">import</span> <span class="dt">Text.Regex.Applicative</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="kw">import</span> <span class="dt">Text.Regex.Applicative.Common</span></a></code></pre></div>
<h2 id="ただの文字-sym-eq-s-s---re-s-s"><span class="link-to-here-outer"><a href="#ただの文字-sym-eq-s-s---re-s-s" title="ただの文字-sym-eq-s-s---re-s-s"><span class="link-to-here">Link to<br />
here</span></a></span>ただの文字<span class="ascii">:</span> <code>sym :: Eq s =&gt; s -&gt; RE s s</code></h2>
<p>ここからは、正規表現の基本的な機能を利用するための<span class="ascii">regex-applicative</span>の<span class="ascii">API</span>を紹介します。<br />
まずはただの文字一つにマッチする<code>sym</code>から<span class="ascii">:</span></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="op">&gt;</span> match (sym <span class="ch">&#39;a&#39;</span>) <span class="st">&quot;a&quot;</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="dt">Just</span> <span class="ch">&#39;a&#39;</span></a>
<a class="sourceLine" id="cb5-3" title="3"></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="op">&gt;</span> match (sym <span class="ch">&#39;a&#39;</span>) <span class="st">&quot;b&quot;</span></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="dt">Nothing</span></a></code></pre></div>
<p><code>sym :: Eq s =&gt; s -&gt; RE s s</code>という型定義のとおり、引数として受け取った文字と文字列における文字が等しいかチェックして、等しければマッチした文字をそのまま返す正規表現を作ります。</p>
<p>また、より一般化したバージョンとして、<code>psym</code>という関数もあります。<br />
こちらは<code>psym :: (s -&gt; Bool) -&gt; RE s s</code>という型定義のとおり、「文字を受け取ってブール値を返す関数」を受け取って、受け取った関数が文字に対して<code>True</code>を返したらマッチする、という正規表現を作ります。</p>
<p>なので例えば、</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="op">&gt;</span> match (psym (<span class="op">==</span> <span class="ch">&#39;a&#39;</span>)) <span class="st">&quot;a&quot;</span></a></code></pre></div>
<p>と書けば<code>sym</code>関数と全く同じことができますし、</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="op">&gt;</span> match (psym (<span class="ot">`elem`</span> <span class="st">&quot;abcdef&quot;</span>)) <span class="st">&quot;a&quot;</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="dt">Just</span> <span class="ch">&#39;a&#39;</span></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="op">&gt;</span> match (psym (<span class="ot">`elem`</span> <span class="st">&quot;abcdef&quot;</span>)) <span class="st">&quot;b&quot;</span></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="dt">Just</span> <span class="ch">&#39;b&#39;</span></a></code></pre></div>
<p>と書けば、文字クラスっぽいことができます。</p>
<h2 id="空文字ε-pure-a---re-s-a"><span class="link-to-here-outer"><a href="#空文字ε-pure-a---re-s-a" title="空文字ε-pure-a---re-s-a"><span class="link-to-here">Link to<br />
here</span></a></span>空文字（ε）<span class="ascii">:</span> <code>pure :: a -&gt; RE s a</code></h2>
<p>正規表現に欠かせない、空文字（ε）を表す正規表現も作れます。<br />
<code>Applicative</code>型クラスの<code>pure</code>で表現します。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="op">&gt;</span> match (<span class="fu">pure</span> <span class="ch">&#39;a&#39;</span>) <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="dt">Just</span> <span class="ch">&#39;a&#39;</span></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="op">&gt;</span> match (<span class="fu">pure</span> <span class="ch">&#39;a&#39;</span>) <span class="st">&quot;b&quot;</span></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="dt">Nothing</span></a></code></pre></div>
<p>もちろん、<code>pure</code>は任意の値を受け取って「受け取った値をそのまま返すもの」を作ることができるので、結果として文字（列）以外の値を返す正規表現も、簡単に作ることができます。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="op">&gt;</span> match (<span class="fu">pure</span> <span class="dt">True</span>) <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb9-2" title="2"><span class="dt">Just</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="op">&gt;</span> match (<span class="fu">pure</span> <span class="dv">42</span>) <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb9-4" title="4"><span class="dt">Just</span> <span class="dv">42</span></a></code></pre></div>
<h2 id="連接-re-s-a---re-s-b---re-s-bstring-eq-a-a---re-a-a"><span class="link-to-here-outer"><a href="#連接-re-s-a---re-s-b---re-s-bstring-eq-a-a---re-a-a" title="連接-re-s-a---re-s-b---re-s-bstring-eq-a-a---re-a-a"><span class="link-to-here">Link to<br />
here</span></a></span>連接<span class="ascii">:</span> <code>(*&gt;) :: RE s a -&gt; RE s b -&gt; RE s b</code>・<code>string :: Eq a =&gt; [a] -&gt; RE a [a]</code></h2>
<p>続いて連接、つまり「二つ以上の正規表現を続けてマッチさせる正規表現を作る」処理です。<br />
<span class="ascii">regex-applicative</span>では、<code>Applicative</code>型クラスの<code>*&gt;</code>がそのまま連接として使えるようになっています。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="op">&gt;</span> match (sym <span class="ch">&#39;a&#39;</span> <span class="op">*&gt;</span> sym <span class="ch">&#39;b&#39;</span>) <span class="st">&quot;ab&quot;</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="dt">Just</span> <span class="ch">&#39;b&#39;</span></a></code></pre></div>
<p>当然、単なる文字の正規表現を並べることはありふれたことなので、<code>string</code>関数という文字列を渡すだけのバージョンも用意されています。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="co">-- マッチする文字列は同じ、より分かりやすいバージョン</span></a>
<a class="sourceLine" id="cb11-2" title="2"><span class="op">&gt;</span> match (string <span class="st">&quot;ab&quot;</span>) <span class="st">&quot;ab&quot;</span></a>
<a class="sourceLine" id="cb11-3" title="3"><span class="dt">Just</span> <span class="st">&quot;ab&quot;</span></a></code></pre></div>
<p>さらに、<span class="ascii">regex-applicative</span>の正規表現オブジェクトは<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:IsString"><code>IsString</code></a>型クラスのインスタンスでもあるので、<code>OverloadedStrings</code>言語拡張を使えば文字列リテラルだけで正規表現オブジェクトを作ることができます。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="op">&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XOverloadedStrings</span></a>
<a class="sourceLine" id="cb12-2" title="2"><span class="op">&gt;</span> match <span class="st">&quot;ab&quot;</span> <span class="st">&quot;ab&quot;</span></a>
<a class="sourceLine" id="cb12-3" title="3"><span class="dt">Just</span> <span class="st">&quot;ab&quot;</span></a></code></pre></div>
<h2 id="選択-re-s-a---re-s-a---re-s-a"><span class="link-to-here-outer"><a href="#選択-re-s-a---re-s-a---re-s-a" title="選択-re-s-a---re-s-a---re-s-a"><span class="link-to-here">Link to<br />
here</span></a></span>選択<span class="ascii">:</span> <code>(&lt;|&gt;) :: RE s a -&gt; RE s a -&gt; RE s a</code></h2>
<p>正規表現の「選択」、すなわち「二つの正規表現のうちどちらか一方にマッチする正規表現を作る」処理は、<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Alternative"><code>Alternative</code></a>型クラスでおなじみの<code>&lt;|&gt;</code>を使います<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="op">&gt;</span> match (sym <span class="ch">&#39;a&#39;</span> <span class="op">&lt;|&gt;</span> sym <span class="ch">&#39;b&#39;</span>) <span class="st">&quot;a&quot;</span></a>
<a class="sourceLine" id="cb13-2" title="2"><span class="dt">Just</span> <span class="ch">&#39;a&#39;</span></a>
<a class="sourceLine" id="cb13-3" title="3"><span class="op">&gt;</span> match (sym <span class="ch">&#39;a&#39;</span> <span class="op">&lt;|&gt;</span> sym <span class="ch">&#39;b&#39;</span>) <span class="st">&quot;b&quot;</span></a>
<a class="sourceLine" id="cb13-4" title="4"><span class="dt">Just</span> <span class="ch">&#39;b&#39;</span></a></code></pre></div>
<h2 id="繰り返し-many-re-s-a---re-s-asome-re-s-a---re-s-a"><span class="link-to-here-outer"><a href="#繰り返し-many-re-s-a---re-s-asome-re-s-a---re-s-a" title="繰り返し-many-re-s-a---re-s-asome-re-s-a---re-s-a"><span class="link-to-here">Link to<br />
here</span></a></span>繰り返し<span class="ascii">:</span> <code>many :: RE s a -&gt; RE s [a]</code>・<code>some :: RE s a -&gt; RE s [a]</code></h2>
<p>正規表現の「繰り返し」、指定した正規表現を繰り返しマッチさせる正規表現を作る処理は、これまた<code>Alternative</code>の<code>many</code>メソッド・<code>some</code>メソッドによって実装されています。<br />
<code>Alternative</code>型クラスのデフォルトの定義どおり、<code>many</code>が<span class="ascii">0</span>回以上の繰り返し、<code>some</code>が<span class="ascii">1</span>回以上の繰り返しを表しています。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="op">&gt;</span> match (many (sym <span class="ch">&#39;a&#39;</span>)) <span class="st">&quot;aaaaaaaaaa&quot;</span></a>
<a class="sourceLine" id="cb14-2" title="2"><span class="dt">Just</span> <span class="st">&quot;aaaaaaaaaa&quot;</span></a>
<a class="sourceLine" id="cb14-3" title="3"><span class="op">&gt;</span> match (some (sym <span class="ch">&#39;a&#39;</span>)) <span class="st">&quot;aaaaaaaaaa&quot;</span></a>
<a class="sourceLine" id="cb14-4" title="4"><span class="dt">Just</span> <span class="st">&quot;aaaaaaaaaa&quot;</span></a>
<a class="sourceLine" id="cb14-5" title="5"></a>
<a class="sourceLine" id="cb14-6" title="6"><span class="op">&gt;</span> match (many (sym <span class="ch">&#39;a&#39;</span>)) <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb14-7" title="7"><span class="dt">Just</span> <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb14-8" title="8"><span class="op">&gt;</span> match (some (sym <span class="ch">&#39;a&#39;</span>)) <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb14-9" title="9"><span class="dt">Nothing</span></a></code></pre></div>
<h2 id="オプショナルなマッチ-optional-re-s-a---re-s-maybe-a"><span class="link-to-here-outer"><a href="#オプショナルなマッチ-optional-re-s-a---re-s-maybe-a" title="オプショナルなマッチ-optional-re-s-a---re-s-maybe-a"><span class="link-to-here">Link to<br />
here</span></a></span>オプショナルなマッチ<span class="ascii">:</span> <code>optional :: RE s a -&gt; RE s (Maybe a)</code></h2>
<p>それから、いわゆる「正規表現の基本三演算」には含まれてませんが<small>（選択と<code>pure</code>で実装できるので）</small>、この後の例で使用するので「オプショナルなマッチ」を実現する方法を紹介しておきます。<br />
名前のとおり<code>optional</code>という関数を使います。これも<code>Alternative</code>型クラスに対して使える関数ですね！</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="op">&gt;</span> match (sym <span class="ch">&#39;a&#39;</span> <span class="op">*&gt;</span> optional (sym <span class="ch">&#39;b&#39;</span>)) <span class="st">&quot;ab&quot;</span></a>
<a class="sourceLine" id="cb15-2" title="2"><span class="dt">Just</span> (<span class="dt">Just</span> <span class="ch">&#39;b&#39;</span>)</a>
<a class="sourceLine" id="cb15-3" title="3"><span class="op">&gt;</span> match (sym <span class="ch">&#39;a&#39;</span> <span class="op">*&gt;</span> optional (sym <span class="ch">&#39;b&#39;</span>)) <span class="st">&quot;a&quot;</span></a>
<a class="sourceLine" id="cb15-4" title="4"><span class="dt">Just</span> <span class="dt">Nothing</span></a></code></pre></div>
<h2 id="マッチした結果をhaskellの値に割り当て"><span class="link-to-here-outer"><a href="#マッチした結果をhaskellの値に割り当て" title="マッチした結果をhaskellの値に割り当て"><span class="link-to-here">Link to<br />
here</span></a></span>マッチした結果を<span class="ascii">Haskell</span>の値に割り当て</h2>
<p>ここからは、他の正規表現ライブラリーでは珍しい、「正規表現でマッチした結果を<span class="ascii">Haskell</span>の値に割り当てる方法」をより詳しく紹介します。</p>
<h3 id="組み込みの正規表現を使う"><span class="link-to-here-outer"><a href="#組み込みの正規表現を使う" title="組み込みの正規表現を使う"><span class="link-to-here">Link to<br />
here</span></a></span>組み込みの正規表現を使う</h3>
<p>例えば、<a href="http://hackage.haskell.org/package/regex-applicative-0.3.3.1/docs/Text-Regex-Applicative-Common.html#v:digit"><code>Text.Regex.Applicative.Common</code>モジュールにある<code>digit</code></a>は、一桁の数字<small>（つまり<code>0</code>から<code>9</code>）</small>にマッチした上で、結果としてマッチした値を<strong>文字ではなく、整数として</strong>返す正規表現を提供します。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="op">&gt;</span> match digit <span class="st">&quot;1&quot;</span></a>
<a class="sourceLine" id="cb16-2" title="2"><span class="dt">Just</span> <span class="dv">1</span></a></code></pre></div>
<p>加えて、先ほど紹介した<code>many</code>関数と組み合わせると、マッチした結果を整数のリストとして取得することもできます。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="op">&gt;</span> match (many digit) <span class="st">&quot;12345&quot;</span></a>
<a class="sourceLine" id="cb17-2" title="2"><span class="dt">Just</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]</a></code></pre></div>
<h3 id="a---b---re-s-a---re-s-b-任意の一引数の関数を適用する"><span class="link-to-here-outer"><a href="#a---b---re-s-a---re-s-b-任意の一引数の関数を適用する" title="a---b---re-s-a---re-s-b-任意の一引数の関数を適用する"><span class="link-to-here">Link to<br />
here</span></a></span><code>(&lt;$&gt;) :: (a -&gt; b) -&gt; RE s a -&gt; RE s b</code><span class="ascii">:</span> 任意の（一引数の）関数を適用する</h3>
<p><span class="ascii">regex-applicative</span>は、名前のとおり正規表現を<span class="ascii">Applicative</span>スタイルで利用できるようにするためのライブラリーです。<br />
当然ながら<code>Applicative</code>スタイルに必須の<code>&lt;$&gt;</code>関数も使用できます。<br />
正規表現オブジェクト<code>RE s a</code>型の返す「マッチした結果」に、あなたの好きな関数を適用して変換した正規表現を作れるのです。</p>
<p>先ほどの<code>many digit</code>の例を再利用して、マッチした整数の合計値を求めてみましょう。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1"><span class="op">&gt;</span> match (<span class="fu">sum</span> <span class="op">&lt;$&gt;</span> many digit) <span class="st">&quot;12345&quot;</span></a>
<a class="sourceLine" id="cb18-2" title="2"><span class="dt">Just</span> <span class="dv">15</span></a></code></pre></div>
<h3 id="re-s-a---b---re-s-a---re-s-b-任意の関数を適用する"><span class="link-to-here-outer"><a href="#re-s-a---b---re-s-a---re-s-b-任意の関数を適用する" title="re-s-a---b---re-s-a---re-s-b-任意の関数を適用する"><span class="link-to-here">Link to<br />
here</span></a></span><code>(&lt;*&gt;) :: RE s (a -&gt; b) -&gt; RE s a -&gt; RE s b</code><span class="ascii">:</span> 任意の関数を適用する</h3>
<p><span class="ascii">Applicative</span>スタイルのもう一つの重要な関数といえば、やっぱり<code>&lt;*&gt;</code>でしょう。<br />
<code>many digit</code>を再利用して、「先頭に書かれた桁数だけ数字を取得する」という例を書いてみます。</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" title="1"><span class="op">&gt;</span> match (<span class="fu">take</span> <span class="op">&lt;$&gt;</span> digit <span class="op">&lt;*&gt;</span> many digit) <span class="st">&quot;312345&quot;</span></a>
<a class="sourceLine" id="cb19-2" title="2"><span class="dt">Just</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a></code></pre></div>
<h2 id="もうちょっと複雑な例"><span class="link-to-here-outer"><a href="#もうちょっと複雑な例" title="もうちょっと複雑な例"><span class="link-to-here">Link to<br />
here</span></a></span>もうちょっと複雑な例</h2>
<p>ここまで紹介した例を使用してもうちょっと複雑な例を書いてみましょう。<br />
小さな正規表現を組み合わせて、<span class="ascii">http</span>か<span class="ascii">https</span>の<span class="ascii">URL</span>における、オリジンにマッチする正規表現を簡単に書いてみます。</p>
<p>まずは部品作りです。</p>
<p><span class="ascii">URL</span>のスキームにマッチさせるために、「<code>http</code>の後にオプショナルな<code>s</code>、続けて<code>://</code>」という文字列にマッチする正規表現を作ります。</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" title="1"><span class="op">&gt;</span> schemeRe <span class="ot">=</span></a>
<a class="sourceLine" id="cb20-2" title="2">    ((<span class="op">++</span>) <span class="op">&lt;$&gt;</span> string <span class="st">&quot;http&quot;</span> <span class="op">&lt;*&gt;</span> (string <span class="st">&quot;s&quot;</span> <span class="op">&lt;|&gt;</span> <span class="fu">pure</span> <span class="st">&quot;&quot;</span>))</a>
<a class="sourceLine" id="cb20-3" title="3">      <span class="op">&lt;*</span> string <span class="st">&quot;://&quot;</span></a></code></pre></div>
<p><code>&lt;*</code>を使うことで、<code>://</code>の部分にはマッチしてもマッチした結果は無視している点にご注意ください。<br />
<span class="ascii">regex-applicative</span>はこのように、「マッチしたら関数に渡す文字列」と「マッチしても関数に渡さない文字列」をユーザーが書き分けられるようになっているので、他の正規表現ライブラリーにあるようなキャプチャー<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>や、先読み言明・後読み言明などの機能が必要ないのです。</p>
<p>続けて、ホスト名にマッチする正規表現を作ります。<br />
ここでは単純化して、「アルファベットの小文字かピリオド<span class="ascii">1</span>文字以上」という文字列にしておきます。</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" title="1"><span class="op">&gt;</span> hostRe <span class="ot">=</span> some (psym (<span class="ot">`elem`</span> [<span class="ch">&#39;a&#39;</span><span class="op">..</span><span class="ch">&#39;z&#39;</span>] <span class="op">++</span> <span class="st">&quot;.&quot;</span>))</a></code></pre></div>
<p>最後はポート番号です。<br />
<code>:</code>という文字の後に<a href="http://hackage.haskell.org/package/regex-applicative-0.3.3.1/docs/Text-Regex-Applicative-Common.html#v:decimal"><code>Text.Regex.Applicative.Common</code>に入った<code>decimal</code></a>、すなわち一桁以上の<span class="ascii">10</span>進数にマッチする正規表現を使います。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" title="1"><span class="op">&gt;</span> portRe <span class="ot">=</span> sym <span class="ch">&#39;:&#39;</span> <span class="op">*&gt;</span> decimal</a></code></pre></div>
<p>以上で正規表現のパーツができました。<br />
早速使ってみる… 前に、マッチした結果を割り当てるレコード型を定義します。</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" title="1"><span class="kw">data</span> <span class="dt">Origin</span> <span class="ot">=</span></a>
<a class="sourceLine" id="cb23-2" title="2">  <span class="dt">Origin</span> {<span class="ot"> scheme ::</span> <span class="dt">String</span>,<span class="ot"> host ::</span> <span class="dt">String</span>,<span class="ot"> port ::</span> <span class="dt">Int</span> }</a>
<a class="sourceLine" id="cb23-3" title="3">  <span class="kw">deriving</span> <span class="dt">Show</span></a></code></pre></div>
<p>あとは<code>&lt;$&gt;</code>や<code>&lt;*&gt;</code>を使って組み合わせて、<code>Origin</code>値コンストラクターに食わせるだけです！<br />
ポート番号はオリジンにおいてはなくても良いので、省略した場合は仮に<code>80</code>としておきましょう<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>。</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" title="1">originRe <span class="ot">=</span> <span class="dt">Origin</span>   <span class="op">&lt;$&gt;</span></a>
<a class="sourceLine" id="cb24-2" title="2">           schemeRe <span class="op">&lt;*&gt;</span></a>
<a class="sourceLine" id="cb24-3" title="3">           hostRe   <span class="op">&lt;*&gt;</span></a>
<a class="sourceLine" id="cb24-4" title="4">           (portRe <span class="op">&lt;|&gt;</span> <span class="fu">pure</span> <span class="dv">80</span>)</a></code></pre></div>
<p>今度こそ使ってみます。</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" title="1"><span class="op">&gt;</span> match originRe <span class="st">&quot;https://example.com:8080&quot;</span></a>
<a class="sourceLine" id="cb25-2" title="2"><span class="dt">Just</span> (<span class="dt">Origin</span> {scheme <span class="ot">=</span> <span class="st">&quot;https&quot;</span>, host <span class="ot">=</span> <span class="st">&quot;example.com&quot;</span>, port <span class="ot">=</span> <span class="dv">8080</span>})</a>
<a class="sourceLine" id="cb25-3" title="3"><span class="op">&gt;</span> match originRe <span class="st">&quot;http://example.com&quot;</span></a>
<a class="sourceLine" id="cb25-4" title="4"><span class="dt">Just</span> (<span class="dt">Origin</span> {scheme <span class="ot">=</span> <span class="st">&quot;http&quot;</span>, host <span class="ot">=</span> <span class="st">&quot;example.com&quot;</span>, port <span class="ot">=</span> <span class="dv">80</span>})</a></code></pre></div>
<p><span class="ascii">regex-applicative</span>を使うことで、<span class="ascii">URL</span>のオリジンにマッチさせるだけでなく、マッチした結果を<code>Origin</code>型の値として割り当てる正規表現が作れました！🎉</p>
<h1 id="regex-applicativeのメリット"><span class="link-to-here-outer"><a href="#regex-applicativeのメリット" title="regex-applicativeのメリット"><span class="link-to-here">Link to<br />
here</span></a></span>👍<span class="ascii">regex-applicative</span>のメリット</h1>
<p><span class="ascii">regex-applicative</span>パッケージには、他の正規表現ライブラリーと比べて、以下のメリットがあります。</p>
<ul>
<li>文字列以外の扱いにも強い
<ul>
<li>マッチした結果から（文字列以外の）<span class="ascii">Haskell</span>の値に割り当てるのが簡単！
<ul>
<li>「生のデータ」からアプリケーションにおける「コアの処理が欲しいデータ」への変換がワンストップ</li>
</ul></li>
<li>文字列だけでなく、任意のリストに対してマッチできる</li>
</ul></li>
<li>内部<span class="ascii">DSL</span>として書けるので、コンパイラーによる型チェックの恩恵を受けやすい
<ul>
<li>前述の「マッチした結果から（文字列以外の）<span class="ascii">Haskell</span>の値に割り当てる」処理も、すべて型チェックされる</li>
</ul></li>
</ul>
<h1 id="regex-applicativeのデメリット"><span class="link-to-here-outer"><a href="#regex-applicativeのデメリット" title="regex-applicativeのデメリット"><span class="link-to-here">Link to<br />
here</span></a></span>👎<span class="ascii">regex-applicative</span>のデメリット</h1>
<p>一方<span class="ascii">regex-applicative</span>パッケージには、他の正規表現ライブラリーに対する以下のデメリットがあります。</p>
<ul>
<li>コードは長い
<ul>
<li>内部<span class="ascii">DSL</span>なのでやむなし</li>
<li>専用のメタキャラクターより分かりやすい、とも言える</li>
</ul></li>
<li>ユーザーからの入力として、正規表現を受け取ることは難しい
<ul>
<li>これも内部<span class="ascii">DSL</span>なのでやむなし</li>
</ul></li>
<li>おそらく<span class="ascii">C</span>とかで書いたものほど速くはない
<ul>
<li>そんなに細かい最適化をしているわけではないし、<span class="ascii">Pure Haskell</span>なので…</li>
</ul></li>
<li><code>String</code>以外の文字列にはマッチできない…
<ul>
<li>これが<span class="ascii">Haskeller</span>にとって一番痛い</li>
<li><code>Text</code>や<code>ByteString</code>向けのものも、原理的に実装できないというわけではないはず</li>
<li>参考<span class="ascii">:</span> <a href="http://bicycle1885.hatenablog.com/entry/2012/12/24/234707"><span class="ascii">Haskell Tips (</span>文字列編<span class="ascii">) -</span> りんごがでている</a></li>
</ul></li>
</ul>
<h1 id="regex-applicativeの仕組み"><span class="link-to-here-outer"><a href="#regex-applicativeの仕組み" title="regex-applicativeの仕組み"><span class="link-to-here">Link to<br />
here</span></a></span>⚙️<span class="ascii">regex-applicative</span>の仕組み</h1>
<p>ここからは、<span class="ascii">regex-applicative</span>における正規表現エンジンがどのように作られているか、『<a href="https://gihyo.jp/book/2015/978-4-7741-7270-5">正規表現技術入門</a>』における正規表現エンジンの分類を参考に説明しましょう。</p>
<h2 id="正規表現エンジンの分類"><span class="link-to-here-outer"><a href="#正規表現エンジンの分類" title="正規表現エンジンの分類"><span class="link-to-here">Link to<br />
here</span></a></span>📑正規表現エンジンの分類</h2>
<p>『正規表現技術入門』の<span class="ascii">p.56</span>では、正規表現エンジンを次の二つに分類しています。</p>
<ul>
<li><span class="ascii">DFA</span>型
<ul>
<li>正規表現を決定性有限オートマトン（<span class="ascii">deterministic finite automaton</span>）と呼ばれるものに変換して正規表現マッチングを行う</li>
</ul></li>
<li><span class="ascii">VM</span>型
<ul>
<li>正規表現をバイトコード（<span class="ascii">bytecode</span>）と呼ばれるものに変換して正規表現マッチングを行う</li>
</ul></li>
</ul>
<p>さて、<span class="ascii">regex-applicative</span>の場合はどちらなのでしょうか？<br />
<a href="https://github.com/feuerbach/regex-applicative/">ソースコード</a>を読んでみると、どうやらどちらでもなさそうなことがわかります。<br />
というのも、正規表現オブジェクト<code>RE s a</code>を<span class="ascii">NFA</span>に<a href="https://github.com/feuerbach/regex-applicative/blob/5e9a06622d33c7657353ddaccfe101b96946027a/Text/Regex/Applicative/Object.hs#L110-L111"><code>compile</code></a>という関数で変換した後、<span class="ascii">DFA</span>に変換しないでそのまま使っているからです。<br />
一般的に、<span class="ascii">NFA</span>は<span class="ascii">DFA</span>に変換可能で、変換してからマッチさせた方がしばしば高速にマッチできることが知られています。<br />
ところが<span class="ascii">regex-applicative</span>ではその変換を行わず、<span class="ascii">NFA</span>として使用しているのです。</p>
<p>なぜそうした仕様になっているかについて、私の推測を述べましょう<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>。<br />
<span class="ascii">regex-applicative</span>では先ほど紹介した<code>psym</code>関数のように、「任意の文字を受け取る関数」を正規表現オブジェクトに含められなければなりません。<br />
結果、関数がどんな文字の時にどんな値を返すのか<small>（マッチが成功するのかしないのか）</small>、正規表現オブジェクトをコンパイルする関数にはわからなくなってしまうのです。<br />
一方、効率の良い<span class="ascii">DFA</span>の実装では、<span class="ascii">DFA</span>の一つ一つの状態ごとに「どの文字を受け取ったら次はどの状態に遷移するか」という情報を、連想配列として持っておかなければなりません<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a>。<br />
そのため、どの文字を受け取ったらマッチが成功するのかわからない箇所が正規表現オブジェクトに混ざっている限り、効率の良い<span class="ascii">DFA</span>の実装にはできないのです。</p>
<p>その分、<span class="ascii">regex-applicative</span>では任意の文字を受け取る関数が使えるので、普通の正規表現ライブラリーよりも柔軟に書くことができるようになっています。<br />
その点を考慮したトレードオフなんでしょう。</p>
<h2 id="regex-applicativeの実際の実装"><span class="link-to-here-outer"><a href="#regex-applicativeの実際の実装" title="regex-applicativeの実際の実装"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">regex-applicative</span>の実際の実装</h2>
<p>さらに<span class="ascii">regex-applicative</span>の実装を掘ってみましょう。<br />
先ほど紹介した<code>compile</code>関数は、正規表現オブジェクト<code>RE s a</code>を<a href="https://github.com/feuerbach/regex-applicative/blob/5e9a06622d33c7657353ddaccfe101b96946027a/Text/Regex/Applicative/Object.hs#L38-L43"><code>ReObject s r</code></a>という型の、<a href="https://github.com/feuerbach/regex-applicative/blob/5e9a06622d33c7657353ddaccfe101b96946027a/Text/Regex/Applicative/Types.hs#L9-L16"><code>Thread s r</code></a>型の値のキューに変換します。<br />
これが<span class="ascii">regex-applicative</span>における<span class="ascii">NFA</span>と呼べそうですね。</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" title="1"><span class="kw">newtype</span> <span class="dt">ReObject</span> s r <span class="ot">=</span> <span class="dt">ReObject</span> (<span class="dt">SQ.StateQueue</span> (<span class="dt">Thread</span> s r))</a></code></pre></div>
<p><code>Thread s r</code>型の値は、<span class="ascii">NFA</span>における状態遷移を表します。</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" title="1"><span class="kw">data</span> <span class="dt">Thread</span> s r</a>
<a class="sourceLine" id="cb27-2" title="2">    <span class="ot">=</span> <span class="dt">Thread</span></a>
<a class="sourceLine" id="cb27-3" title="3">        {<span class="ot"> threadId_ ::</span> <span class="dt">ThreadId</span></a>
<a class="sourceLine" id="cb27-4" title="4">        ,<span class="ot"> _threadCont ::</span> s <span class="ot">-&gt;</span> [<span class="dt">Thread</span> s r]</a>
<a class="sourceLine" id="cb27-5" title="5">        }</a>
<a class="sourceLine" id="cb27-6" title="6">    <span class="op">|</span> <span class="dt">Accept</span> r</a></code></pre></div>
<p>型定義のとおり、<code>Thread</code>と<code>Accept</code>という二通りの値をとります<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a>。</p>
<ul>
<li>⏩<code>Thread</code>はその用途からして、事実上<code>s -&gt; [Thread s r]</code>という関数と同等の型です。<span class="ascii">regex-applicative</span>は<code>ReObject</code>によって文字列<code>[s]</code>の値をマッチさせる際、この<code>s -&gt; [Thread s r]</code>に文字を渡します。
<ul>
<li>➡️そして、関数が結果として返した、<code>Thread s r</code>型の値を<small>（そのリストから）</small>一つずつキューに追加して、また次の文字にマッチさせます。</li>
<li>↩️一方、関数が空リストを返した場合は — そう、マッチが失敗した、ということなのです。その場合は、キューからさらに<code>Thread s r</code>の値を取り出して<small>（値コンストラクターが<code>Thread</code>であれば）</small>マッチしなかった文字をまた<code>s -&gt; [Thread s r]</code>に渡します。</li>
<li>なお、<code>threadId_</code>はキューに追加する際同じ<code>threadId_</code>の<code>Thread</code>を追加してしまうのを防ぐためのキーです。詳細は割愛します。</li>
</ul></li>
<li>✅<code>Accept r</code>は名前のとおり<span class="ascii">NFA</span>の受理状態を表しています。<code>s -&gt; [Thread s r]</code>を繰り返し適用して最終的に<code>Accept r</code>を返した<code>Thread</code>のみが「マッチした」と解釈されます。</li>
</ul>
<p>このように、<span class="ascii">regex-applicative</span>における<span class="ascii">NFA</span>は<code>s -&gt; [Thread s r]</code>を返す関数、すなわち「文字を受け取って次の状態のリストを返す継続」として作られています。</p>
<p>ただ実際に実行する際の流れを見てみると、<code>ReObject</code>に含まれる<code>Thread</code>を一つずつ実行してみて、結果が条件に合うものを選ぶ、といった方が近いです。<br />
例えば<a href="https://github.com/feuerbach/regex-applicative/blob/5e9a06622d33c7657353ddaccfe101b96946027a/Text/Regex/Applicative/Interface.hs#L81-L85"><code>match</code>関数</a>では、<code>ReObject</code>に文字を一文字ずつ与えた結果の中から、<code>listToMaybe</code>を使って最初に<code>Accept</code>にたどり着く<code>Thread</code>を取得しています。<br />
それから、最長マッチする部分文字列を検索する<a href="https://github.com/feuerbach/regex-applicative/blob/5e9a06622d33c7657353ddaccfe101b96946027a/Text/Regex/Applicative/Interface.hs#L141-L149"><code>findLongestPrefix</code>関数</a>は、マッチが失敗するか残りの文字列が空になるまで繰り返し文字を<code>ReObject</code>に与えることで、できるだけ長いマッチが返るように調整しています。<br />
このように<span class="ascii">regex-applicative</span>は、<code>ReObject</code><span class="ascii">(NFA)</span>に文字を一つずつ与えてマッチ結果を生成する処理と、そのマッチ結果を選び取る処理とを分離することで、様々な方針でマッチできるようになっているのです。</p>
<h1 id="類似のライブラリーとの比較を軽く"><span class="link-to-here-outer"><a href="#類似のライブラリーとの比較を軽く" title="類似のライブラリーとの比較を軽く"><span class="link-to-here">Link to<br />
here</span></a></span>類似のライブラリーとの比較を軽く</h1>
<h2 id="各種パーサーコンビネーター"><span class="link-to-here-outer"><a href="#各種パーサーコンビネーター" title="各種パーサーコンビネーター"><span class="link-to-here">Link to<br />
here</span></a></span>各種パーサーコンビネーター</h2>
<p>さて、ここまでこの文章を読んでいただけた方の中には、「これって<span class="ascii">megaparsec</span>とか<span class="ascii">attoparsec</span>とかのパーサーコンビネーターライブラリーと何が違うんだ？」という疑問をお持ちの方も多いでしょう。<br />
そう、大抵の場合、パーサーコンビネーターライブラリーも下記のような特徴を持ち合わせています。</p>
<ul>
<li><span class="ascii">Haskell</span>の内部<span class="ascii">DSL</span>として実装されている
<ul>
<li><code>Applicative</code>や<code>Alternative</code>型クラスのメソッドを利用した<span class="ascii">API</span></li>
</ul></li>
<li>マッチした結果から（文字列以外の）<span class="ascii">Haskell</span>の値に割り当てるのが簡単</li>
<li>「文字<span class="ascii">(</span><code>Char</code><span class="ascii">)</span>」の列以外にもマッチできる</li>
</ul>
<p>特に「<code>Applicative</code>や<code>Alternative</code>型クラスのメソッドを利用した<span class="ascii">API</span>」である点は興味深く、場合によっては、使うライブラリーだけ換えて式をコピペしてもコンパイルは通る、なんてことが普通にあり得るくらい似ています。<br />
ただし、当然コンパイルが通るだけでは意図通りに動くとは限りません。<br />
<span class="ascii">regex-alternative</span>と一般的なパーサーコンビネーターライブラリーには、「<strong>自動的にバックトラックをするかしないか</strong>」という違いがあるためです。</p>
<p>例えば、次の式は<span class="ascii">regex-applicative</span>でも<span class="ascii">attoparsec</span>でも有効な式ですが、<span class="ascii">regex-applicative</span>の<code>match</code>関数では、「<code>ab</code>が<span class="ascii">1</span>回以上繰り返される文字列」にマッチして最後の<code>ab</code>を返すことができるのに、<span class="ascii">attoparsec</span>の<code>parse</code>関数ではパースに失敗してしまいます。</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" title="1">many (string <span class="st">&quot;ab&quot;</span>) <span class="op">*&gt;</span> string <span class="st">&quot;ab&quot;</span></a></code></pre></div>
<p><code>stack build regex-applicative attoparsec</code>した上で以下のように書いて試してみましょう。<br />
まずは<span class="ascii">regex-applicative</span>で試す場合<span class="ascii">:</span></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" title="1"><span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">Text.Regex.Applicative</span></a>
<a class="sourceLine" id="cb29-2" title="2"></a>
<a class="sourceLine" id="cb29-3" title="3"><span class="op">&gt;</span> match (many (string <span class="st">&quot;ab&quot;</span>) <span class="op">*&gt;</span> string <span class="st">&quot;ab&quot;</span>) <span class="st">&quot;abab&quot;</span></a>
<a class="sourceLine" id="cb29-4" title="4"><span class="dt">Just</span> <span class="st">&quot;ab&quot;</span></a>
<a class="sourceLine" id="cb29-5" title="5"></a>
<a class="sourceLine" id="cb29-6" title="6"><span class="op">&gt;</span> match (many (string <span class="st">&quot;ab&quot;</span>) <span class="op">*&gt;</span> string <span class="st">&quot;ab&quot;</span>) <span class="st">&quot;ab&quot;</span></a>
<a class="sourceLine" id="cb29-7" title="7"><span class="dt">Just</span> <span class="st">&quot;ab&quot;</span></a>
<a class="sourceLine" id="cb29-8" title="8"></a>
<a class="sourceLine" id="cb29-9" title="9"><span class="op">&gt;</span> match (many (string <span class="st">&quot;ab&quot;</span>) <span class="op">*&gt;</span> string <span class="st">&quot;ab&quot;</span>) <span class="st">&quot;ababab&quot;</span></a>
<a class="sourceLine" id="cb29-10" title="10"><span class="dt">Just</span> <span class="st">&quot;ab&quot;</span></a></code></pre></div>
<p>いずれの文字列でも<code>Just "ab"</code>が返ってきてますね😌。</p>
<p>続いて<span class="ascii">attoparsec</span>で試す場合<span class="ascii">:</span></p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" title="1"><span class="co">-- attoparsecは`String`をサポートしてないのでOverloadedStringsでTextとして扱う</span></a>
<a class="sourceLine" id="cb30-2" title="2"><span class="op">&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XOverloadedStrings</span></a>
<a class="sourceLine" id="cb30-3" title="3"></a>
<a class="sourceLine" id="cb30-4" title="4"><span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">Control.Applicative</span></a>
<a class="sourceLine" id="cb30-5" title="5"><span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">Data.Attoparsec.Text</span></a>
<a class="sourceLine" id="cb30-6" title="6"></a>
<a class="sourceLine" id="cb30-7" title="7"><span class="co">-- 文字列の終端であることを明確にするために、空文字列をfeedしておく</span></a>
<a class="sourceLine" id="cb30-8" title="8"><span class="op">&gt;</span> feed (parse (many (string <span class="st">&quot;ab&quot;</span>) <span class="op">*&gt;</span> string <span class="st">&quot;ab&quot;</span>) <span class="st">&quot;abab&quot;</span>) <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb30-9" title="9"><span class="dt">Fail</span> <span class="st">&quot;&quot;</span> [] <span class="st">&quot;not enough input&quot;</span></a>
<a class="sourceLine" id="cb30-10" title="10"></a>
<a class="sourceLine" id="cb30-11" title="11"><span class="op">&gt;</span> feed (parse (many (string <span class="st">&quot;ab&quot;</span>) <span class="op">*&gt;</span> string <span class="st">&quot;ab&quot;</span>) <span class="st">&quot;ab&quot;</span>) <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb30-12" title="12"><span class="dt">Fail</span> <span class="st">&quot;&quot;</span> [] <span class="st">&quot;not enough input&quot;</span></a>
<a class="sourceLine" id="cb30-13" title="13"></a>
<a class="sourceLine" id="cb30-14" title="14"><span class="op">&gt;</span> feed (parse (many (string <span class="st">&quot;ab&quot;</span>) <span class="op">*&gt;</span> string <span class="st">&quot;ab&quot;</span>) <span class="st">&quot;ababab&quot;</span>) <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb30-15" title="15"><span class="dt">Fail</span> <span class="st">&quot;&quot;</span> [] <span class="st">&quot;not enough input&quot;</span></a></code></pre></div>
<p>いずれの文字列でも失敗になってしまいました。なぜうまくいかないのでしょう？<br />
それは文字列<code>"ababab"</code>における<code>ab</code>を、<code>many (string "ab")</code>が消費してしまい、<code>*&gt;</code>の右辺に書いた<code>string "ab"</code>が処理できなくなってしまうためです。<br />
対する<span class="ascii">regex-applicative</span>における<code>many (string "ab") *&gt; string "ab"</code>では、正規表現全体がマッチするよう、自動でバックトラックしてくれます。<br />
<span class="ascii">regex-applicative</span>でも最初に<code>many (string "ab")</code>が<code>"ababab"</code>全体を消費した直後では、<code>*&gt;</code>の右辺に書いた<code>string "ab"</code>のマッチは当然失敗してしまいます。<br />
しかし、<span class="ascii">regex-applicative</span>はそれではあきらめません。<code>*&gt;</code>の右辺に書いた<code>string "ab"</code>が成功するまで、失敗する度に<code>many (string "ab")</code>が消費した文字を<span class="ascii">1</span>文字ずつ返却してくれるのです。これがバックトラックです。<br />
<span class="ascii">regex-alternative</span>に限らず、大抵の正規表現エンジンがこのように自動的なバックトラックを行います。</p>
<p>こうした性質の違いにより、<span class="ascii">regex-applicative</span>は<strong>文字列の中間に指定したパターンをマッチさせる</strong>のが、パーサーコンビネーターライブラリーよりも得意です。</p>
<p>例えば「文字列の中間にある<span class="ascii">1</span>桁以上の<span class="ascii">10</span>進数」にマッチさせる場合、<span class="ascii">regex-alternative</span>では次のように書きます。</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" title="1"><span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">Text.Regex.Applicative.Common</span></a>
<a class="sourceLine" id="cb31-2" title="2"><span class="op">&gt;</span> match (few anySym <span class="op">*&gt;</span> decimal <span class="op">&lt;*</span> few anySym) <span class="st">&quot;abc12345def&quot;</span></a>
<a class="sourceLine" id="cb31-3" title="3"><span class="dt">Just</span> <span class="dv">12345</span></a></code></pre></div>
<p><code>few</code>は「控えめな繰り返し」を実現するための関数です。引数で指定した正規表現を<span class="ascii">0</span>回以上マッチさせる、という点では<code>many</code>と同じですが、前後にある正規表現がなるべく長くマッチするよう、優先してマッチさせてくれます。<br />
<code>few anySym</code>は普通の正規表現ライブラリーでいうところの<code>.*?</code>に相当します。</p>
<p>同じことを<span class="ascii">attoparsec</span>で実現するために<code>many anyChar *&gt; decimal &lt;* many anyChar</code>と書いてみても、やはりうまくいきません。</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" title="1"><span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">Data.Attoparsec.Text</span></a>
<a class="sourceLine" id="cb32-2" title="2"></a>
<a class="sourceLine" id="cb32-3" title="3"><span class="op">&gt;</span> feed (parse (many anyChar <span class="op">*&gt;</span> decimal <span class="op">&lt;*</span> many anyChar) <span class="st">&quot;abc12345def&quot;</span>) <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb32-4" title="4"><span class="dt">Fail</span> <span class="st">&quot;&quot;</span> [] <span class="st">&quot;not enough input&quot;</span></a></code></pre></div>
<p>理由は先ほどと同様で、最初に書いた<code>many anyChar</code>がすべての文字列を消費してしまい、それ以降の<code>decimal</code>などがマッチできないためです。<br />
正しく処理するには、「<code>decimal</code>の先頭以外の文字列」、すなわち「数字以外の文字列」が<code>many</code>であることを明示する方法をとるしかありません<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a>。</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" title="1"><span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">Data.Char</span></a>
<a class="sourceLine" id="cb33-2" title="2"></a>
<a class="sourceLine" id="cb33-3" title="3"><span class="op">&gt;</span> nonDigits <span class="ot">=</span> many (satisfy (<span class="fu">not</span> <span class="op">.</span> <span class="fu">isDigit</span>))</a>
<a class="sourceLine" id="cb33-4" title="4"><span class="op">&gt;</span> feed ((parse (nonDigits <span class="op">*&gt;</span> decimal <span class="op">&lt;*</span> nonDigits)) <span class="st">&quot;abc12345def&quot;</span>) <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb33-5" title="5"><span class="dt">Done</span> <span class="st">&quot;&quot;</span> <span class="dv">12345</span></a></code></pre></div>
<p>そんなわけで、<span class="ascii">regex-applicative</span>は、<span class="ascii">Haskell</span>によくあるパーサーコンビネーターのように<strong><span class="ascii">Applicative</span>スタイルで書けて、なおかつ他の正規表現ライブラリーのように中間マッチがしやすい</strong>という、両方の良さを持ち合わせていると言えます。</p>
<h3 id="番外編-replace-attoparsecreplace-megaparsec"><span class="link-to-here-outer"><a href="#番外編-replace-attoparsecreplace-megaparsec" title="番外編-replace-attoparsecreplace-megaparsec"><span class="link-to-here">Link to<br />
here</span></a></span>番外編<span class="ascii">: replace-attoparsec</span>・<span class="ascii">replace-megaparsec</span></h3>
<p>…と、<span class="ascii">regex-applicative</span>のよさを語ったところで舌の根も乾かぬうちに恐縮ですが、実は<span class="ascii">attoparsec</span>をはじめパーサーコンビネーターライブラリーの「中間マッチがやりにくい」という弱点を改善するためのパッケージがあります。<br />
<a href="http://hackage.haskell.org/package/replace-attoparsec"><span class="ascii">replace-attoparsec</span></a>や<a href="http://hackage.haskell.org/package/replace-megaparsec"><span class="ascii">replace-megaparsec</span></a>といいます<a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a>。<br />
名前のとおり<span class="ascii">replace-attoparsec</span>が<span class="ascii">attoparsec</span>を改善するパッケージで、<span class="ascii">replace-megaparsec</span>が<span class="ascii">megaparsec</span>を改善するパッケージです。<br />
名前も<span class="ascii">API</span>もお互いそっくりなんで<small>（作者も同じですしね）</small>、今回は<span class="ascii">replace-attoparsec</span>の方を紹介しましょう。</p>
<p><span class="ascii">replace-attoparsec</span>を使えば、次のように書くだけで「文字列の中間にある<span class="ascii">1</span>桁以上の<span class="ascii">10</span>進数」を取り出すことができます。</p>
<pre class="hakell"><code>import Replace.Attoparsec.Text

&gt; feed (parse (sepCap decimal) &quot;abc12345def&quot;) &quot;&quot;
Done &quot;&quot; [Left &quot;abc&quot;,Right 12345,Left &quot;def&quot;]</code></pre>
<p><code>"abc12345def"</code>の中間にある<code>12345</code>だけでなく、パースできなかった<code>abc</code>、<code>def</code>という文字列もおまけで取得できました！<br />
<code>decimal</code>がパースできた箇所が<code>Right</code>として、パースできなかった箇所が<code>Left</code>として返却されていることに注意してください。</p>
<p><span class="ascii">replace-attoparsec</span>の<code>sepCap</code><small>（「<span class="ascii">Separate and Capture</span>」の略だそうです）</small>は、引数として受け取ったパーサーを、</p>
<ol type="1">
<li>とりあえず先頭からマッチさせてみて、</li>
<li>失敗したら先頭の一文字をスキップして、次の文字からまたマッチさせてみる</li>
</ol>
<p>という処理を繰り返しています。<br />
結果的にパースできない文字列はすべてスキップして、文字列の中間にある、パースできる文字列のみにパーサーを適用できるのです。</p>
<h2 id="verbalexpressions"><span class="link-to-here-outer"><a href="#verbalexpressions" title="verbalexpressions"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">VerbalExpressions</span></h2>
<p>そろそろ力尽きてきたのでここからはスライドのコピペで失礼します…🙏</p>
<ul>
<li>詳細わかりませんが作りはよく似てる
<ul>
<li><a href="https://github.com/VerbalExpressions/JSVerbalExpressions#examples"><span class="ascii">JavaScript</span>の例がこちら</a></li>
</ul></li>
<li>変な記号の演算子ではなく英語でつけられた関数なので、こちらの方が分かりやすいという人は多そう</li>
<li><a href="https://github.com/VerbalExpressions"><span class="ascii">Haskell</span>を含むいろんな言語で提供されてるらしい</a></li>
<li>さっと<a href="http://hackage.haskell.org/package/verbalexpressions-1.0.0.0/docs/Text-Regex-VerbalExpressions.html"><span class="ascii">Haskell</span>版のドキュメント</a>読んだ感じ、文字列のマッチに特化してるっぽい？</li>
</ul>
<h1 id="まとめ"><span class="link-to-here-outer"><a href="#まとめ" title="まとめ"><span class="link-to-here">Link to<br />
here</span></a></span>まとめ</h1>
<p>以上です！👋<br />
まとめもスライドからのコピペで！</p>
<ul>
<li><span class="ascii">regex-applicative</span>は、<span class="ascii">Haskell</span>の式で正規表現を書ける内部<span class="ascii">DSL</span></li>
<li>パーサーコンビネーターっぽく使えて、かつ正規表現の良さを持ち合わせている</li>
<li>内部は「文字を受け取って続きの状態のリストを返す関数」として表現された<span class="ascii">NFA</span>で実装されている</li>
</ul>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p><code>Alternative</code>は、<code>Applicative</code>より強力な（できることが多い）型クラスです。そういう意味で、<span class="ascii">regex-applicative</span>は本当は「<span class="ascii">regex-alternative</span>」と呼んだ方が適切なのかも知れません。<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>正確には、キャプチャーした文字列を正規表現の中で再利用することができないので、他の正規表現ライブラリーのキャプチャー機能と完全に同等のことができるわけではありません。これは現状の<span class="ascii">regex-applicative</span>の制限です。<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>もちろん、実際のところ<span class="ascii">https</span>の場合デフォルトのポート番号は<span class="ascii">443</span>であるべきですが、ちゃんと実装しようとすると結構複雑になるのでご容赦を！<a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p>この記事の最後の方を書いていて思い出しました。<span class="ascii">regex-applicative</span>は<span class="ascii">DFA</span>ベースの正規表現エンジンでは不可能な「控えめな繰り返し」をサポートしているから、という理由もあるようです。なぜ<span class="ascii">DFA</span>ベースでは「控えめな繰り返し」ができないかは私もうまく説明できません…。<a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p>『正規表現技術入門』の<span class="ascii">p. 132</span>における実装例では、これを状態と文字による二次元配列として実装しています。<a href="#fnref5" class="footnote-back">↩</a></p></li>
<li id="fn6"><p>並行並列プログラミングで出てくるあの「スレッド」とは違うのでご注意ください。<a href="#fnref6" class="footnote-back">↩</a></p></li>
<li id="fn7"><p>ただし、一般に、正規表現ライブラリーであってもこのような書き方をした方が効率よくマッチさせやすいでしょう。<a href="#fnref7" class="footnote-back">↩</a></p></li>
<li id="fn8"><p><a href="https://haskell.jp/blog/posts/2018/substring-parser.html">こちらの記事</a>でも触れているとおり、かつて私も同じ目的のパッケージを作成しました。しかし、これらのパッケージの方が明らかにドキュメントが充実していて、機能も豊富なので今回はこれらを紹介します。将来的には<span class="ascii">substring-parser</span>は<span class="ascii">deprecated</span>にするかも知れません。<a href="#fnref8" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2020/revenge-of-hourly-antenna.html" lang="ja">リベンジ・オブ・毎時更新 Haskell Antenna</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/unicode-show.html" style="margin-left: auto;" lang="ja">日本語をshowしてうまく表示されなかったら</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>日本語をshowしてうまく表示されなかったら</title>
    <link href="https://haskell.jp/blog/posts/2019/unicode-show.html" />
    <id>https://haskell.jp/blog/posts/2019/unicode-show.html</id>
    <published>2019-12-22T00:00:00Z</published>
    <updated>2019-12-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#ℹ️この記事は" title="ℹ️この記事は">ℹ️この記事は🎄</a></li>
<li><a href="#日本語などの話者がhaskellを始めるとあるある" title="日本語などの話者がhaskellを始めるとあるある">日本語（などの）話者が<span class="ascii">Haskell</span>を始めるとあるある</a></li>
<li><a href="#unicode-showを使おう" title="unicode-showを使おう">🌐<span class="ascii">unicode-show</span>を使おう</a></li>
<li><a href="#unicode-showの最近の修正" title="unicode-showの最近の修正"><span class="ascii">unicode-show</span>の最近の修正</a></li>
<li><a href="#番外編pretty-simpleも使おう" title="番外編pretty-simpleも使おう">（番外編）<span class="ascii">pretty-simple</span>も使おう</a></li>
</ul>
</div>
</div>
<h1 id="ℹ️この記事は"><span class="link-to-here-outer"><a href="#ℹ️この記事は" title="ℹ️この記事は"><span class="link-to-here">Link to<br />
here</span></a></span>ℹ️この記事は🎄</h1>
<p>この記事は、<a href="https://qiita.com/advent-calendar/2019/haskell"><span class="ascii">Haskell Advent Calendar 2019</span></a> <span class="ascii">22</span>日目の記事です。<br />
例年どおりタイプセーフプリキュア！の話をするつもりでしたが、ネタが実装できなかったので<a href="http://hackage.haskell.org/package/unicode-show"><span class="ascii">unicode-show</span></a>の話をします<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>。<br />
まぁ、こちらの方がみなさんにとっては有益でしょうし🙃</p>
<h1 id="日本語などの話者がhaskellを始めるとあるある"><span class="link-to-here-outer"><a href="#日本語などの話者がhaskellを始めるとあるある" title="日本語などの話者がhaskellを始めるとあるある"><span class="link-to-here">Link to<br />
here</span></a></span>日本語（などの）話者が<span class="ascii">Haskell</span>を始めるとあるある</h1>
<p><span class="ascii">GHCi</span>に日本語を入力したり…</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1">ghci<span class="op">&gt;</span> <span class="st">&quot;みんなで幸せゲットだよ！&quot;</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="st">&quot;\12415\12435\12394\12391\24184\12379\12466\12483\12488\12384\12424\65281&quot;</span></a></code></pre></div>
<p>日本語を<code>print</code>したり…</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1">ghci<span class="op">&gt;</span> <span class="fu">print</span> <span class="st">&quot;私、堪忍袋の緒が切れました！&quot;</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="st">&quot;\31169\12289\22570\24525\34955\12398\32210\12364\20999\12428\12414\12375\12383\65281&quot;</span></a></code></pre></div>
<p>日本語を<code>show</code>したり…</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1">ghci<span class="op">&gt;</span> iimashita x <span class="ot">=</span> <span class="st">&quot;今、&quot;</span> <span class="op">++</span> <span class="fu">show</span> x <span class="op">++</span> <span class="st">&quot;って言いました！？&quot;</span></a>
<a class="sourceLine" id="cb3-2" title="2">ghci<span class="op">&gt;</span> <span class="fu">putStrLn</span> (iimashita <span class="st">&quot;ハスケル&quot;</span>)</a>
<a class="sourceLine" id="cb3-3" title="3">今、<span class="st">&quot;\12495\12473\12465\12523&quot;</span>って言いました！？</a></code></pre></div>
<p>すると、日本語の大半が変な文字列に変わってしまいました😥。</p>
<p>へ… 変な文字列じゃないし！エスケープシーケンスに変換しただけだから！</p>
<p>これは、<span class="ascii">Haskell</span>標準における<code>show</code>関数の残念な仕様です。<br />
<code>show</code>関数に文字列を渡すと、ダブルクォートで囲った上で、<span class="ascii">ASCII</span>範囲外の文字列や、<span class="ascii">ASCII</span>の非表示文字などをエスケープシーケンスに変換して返します。<br />
これは、<code>show</code>関数をデバッグで使用した際、指定した文字列にどんな文字が含まれているか、簡単にわかるようにするための仕様です。<br />
文字の文字コードを表示すれば、<span class="ascii">NULL</span>文字や制御文字、ゼロ幅文字、特殊なスペースなど、視認しにくいおかしな文字が含まれていても、一目でわかるのです。</p>
<p>しかしこれは日本語話者である我々にとって、少なくとも日本語の文字に関しては「余計なお世話」です。<br />
<span class="ascii">NULL</span>文字や<span class="ascii">ASCII</span>の制御文字といった本来画面に表示することがない文字列ならともかく、<span class="ascii">ASCII</span>範囲外の文字列すべてをエスケープしてしまうのはやり過ぎでしょう。<br />
現代は<span class="ascii">Unicode</span>があるおかげで、日本語に限らずとも<span class="ascii">ASCII</span>範囲外の文字を扱うのは当たり前になりましたから。</p>
<h1 id="unicode-showを使おう"><span class="link-to-here-outer"><a href="#unicode-showを使おう" title="unicode-showを使おう"><span class="link-to-here">Link to<br />
here</span></a></span>🌐<span class="ascii">unicode-show</span>を使おう</h1>
<p>そこで便利なのが<a href="http://hackage.haskell.org/package/unicode-show"><span class="ascii">unicode-show</span></a>です。<br />
<span class="ascii">unicode-show</span>の<code>ushow</code>関数は、<code>show</code>がエスケープシーケンスに変換した日本語などの文字列を、元の文字列に戻してくれます。<br />
なので、新しい型クラスを定義する必要もなく、そのまま<code>Show</code>型クラスのインスタンスを再利用できるのです。</p>
<p>早速先ほどの<code>show</code>を使った例に適用してみましょう。</p>
<p>まずは👇のコマンドでインストールして、<span class="ascii">GHCi</span>を起動します。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" title="1"><span class="ex">stack</span> build unicode-show</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="ex">stack</span> exec ghci</a>
<a class="sourceLine" id="cb4-3" title="3"></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="co"># あるいは、最近のcabalを使っている場合は...</span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="ex">cabal</span> v2-install --lib unicode-show</a>
<a class="sourceLine" id="cb4-6" title="6"><span class="ex">cabal</span> v2-repl -b unicode-show</a></code></pre></div>
<p><code>Text.Show.Unicode</code>モジュールを<code>import</code>して<code>show</code>を使っている箇所を<code>ushow</code>に変えれば、お望みどおりの挙動になります。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1">ghci<span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">Text.Show.Unicode</span></a>
<a class="sourceLine" id="cb5-2" title="2">ghci<span class="op">&gt;</span> iimashita x <span class="ot">=</span> <span class="st">&quot;今、&quot;</span> <span class="op">++</span> ushow x <span class="op">++</span> <span class="st">&quot;って言いました！？&quot;</span></a>
<a class="sourceLine" id="cb5-3" title="3">ghci<span class="op">&gt;</span> <span class="fu">putStrLn</span> (iimashita <span class="st">&quot;ハスケル&quot;</span>)</a>
<a class="sourceLine" id="cb5-4" title="4">今、<span class="st">&quot;ハスケル&quot;</span>って言いました！？</a></code></pre></div>
<p>わくわくもんですね！</p>
<p><code>print</code>の例も、<code>uprint</code>に変えれば🆗です。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1">ghci<span class="op">&gt;</span> uprint <span class="st">&quot;私、堪忍袋の緒が切れました！&quot;</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="st">&quot;私、堪忍袋の緒が切れました！&quot;</span></a></code></pre></div>
<p>ウルトラハッピーですね！！</p>
<p>さらに、次のコマンドを<span class="ascii">GHCi</span>に入力すれば、<span class="ascii">GHCi</span>に直接入力した日本語文字列もそのまま表示されるようになります。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1">ghci<span class="op">&gt;</span> <span class="op">:</span>set <span class="op">-</span>interactive<span class="op">-</span><span class="fu">print</span><span class="ot">=</span>uprint</a>
<a class="sourceLine" id="cb7-2" title="2">ghci<span class="op">&gt;</span> <span class="st">&quot;みんなで幸せゲットだよ！&quot;</span></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="st">&quot;みんなで幸せゲットだよ！&quot;</span></a></code></pre></div>
<p>カンペキ✨</p>
<p>えっ、常に<code>uprint</code>したいからいちいち<code>:set -interactive-print=uprint</code>するのが面倒くさい？<br />
そんなあなたは👇を<code>~/.ghci</code>に書くことけって～いでしょう。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Show.Unicode</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="op">:</span>set <span class="op">-</span>interactive<span class="op">-</span><span class="fu">print</span><span class="ot">=</span>Text.Show.Unicode.uprint</a></code></pre></div>
<h1 id="unicode-showの最近の修正"><span class="link-to-here-outer"><a href="#unicode-showの最近の修正" title="unicode-showの最近の修正"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">unicode-show</span>の最近の修正</h1>
<p>そんな<span class="ascii">unicode-show</span>ですが、残念ながら一昨年、作者である村主崇行さんが亡くなってしまいました<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>。<br />
日本に住む<span class="ascii">Haskeller</span>をサポートする日本<span class="ascii">Haskell</span>ユーザーグループとしては、このパッケージをメンテナンスし続けることに大きな意義があると判断し、私はこのパッケージを<a href="https://github.com/haskell-jp/"><span class="ascii">Haskell-jp</span></a>の<span class="ascii">GitHub</span>リポジトリーでメンテナンスすることにしました。<br />
以下がそのリポジトリーです。</p>
<p><a href="https://github.com/haskell-jp/unicode-show" class="uri"><span class="ascii">https://github.com/haskell-jp/unicode-show</span></a></p>
<p>といっても、メンテナーの名前や<code>LICENSE</code>ファイルを書き換えて最新版をアップロードして以降特に何もしていなかったのですが<small>（<a href="https://github.com/nushio3/unicode-show/issues/2">バグはあるけど直すのも難しそう</a>だし、概ね使えるし）</small>、なんと先日、<span class="ascii">Pull request</span>が来ました！</p>
<p><a href="https://github.com/haskell-jp/unicode-show/pull/4"><span class="ascii">Do not show values eagerly by Kaiepi · Pull Request #4 · haskell-jp/unicode-show</span></a></p>
<p>この修正を適用する前の<span class="ascii">unicode-show</span>は、文字列全体を評価してからエスケープシーケンスを元に戻す、という挙動だったため、長い文字列を与えた場合や無限の長さの文字列を与えた場合に、なかなか<small>（あるいは永遠に）</small>結果が返ってこないという問題がありました。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1">ghci<span class="op">&gt;</span> uprint (<span class="fu">repeat</span> <span class="st">&quot;ああああ！&quot;</span>)</a>
<a class="sourceLine" id="cb9-2" title="2"><span class="co">-- 何も表示されず、Ctrl + C を押すまで処理が返らない</span></a></code></pre></div>
<p>修正後はちゃんと遅延評価を利用することで、無限の長さの文字列でも少しずつ変換することができます。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1">ghci<span class="op">&gt;</span> uprint (<span class="fu">repeat</span> <span class="st">&quot;ああああ！&quot;</span>)</a>
<a class="sourceLine" id="cb10-2" title="2">[<span class="st">&quot;ああああ！&quot;</span>,<span class="st">&quot;ああああ！&quot;</span>, <span class="op">...</span> <span class="st">&quot;ああああ！&quot;</span>,<span class="st">&quot;ああInterrupted.</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="st">-- Ctrl + Cを押すまで出力し続ける</span></a></code></pre></div>
<p>今日記事にした一番の理由はこの話をするためです。<br />
<a href="https://github.com/Kaiepi"><span class="ascii">Kaiepi</span></a>さんありがとうございます！<br />
先ほどリリースしました！🎉</p>
<p><a href="http://hackage.haskell.org/package/unicode-show-0.1.0.4" class="uri"><span class="ascii">http://hackage.haskell.org/package/unicode-show-0.1.0.4</span></a></p>
<h1 id="番外編pretty-simpleも使おう"><span class="link-to-here-outer"><a href="#番外編pretty-simpleも使おう" title="番外編pretty-simpleも使おう"><span class="link-to-here">Link to<br />
here</span></a></span>（番外編）<span class="ascii">pretty-simple</span>も使おう</h1>
<p>時間がないので詳しくは省略しますが、実は<a href="http://hackage.haskell.org/package/pretty-simple"><span class="ascii">pretty-simple</span></a>というパッケージを使えば、日本語をそのまま出力するのに加えて、プリティープリントできます。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1">ghci<span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">Text.Pretty.Simple</span></a>
<a class="sourceLine" id="cb11-2" title="2">ghci<span class="op">&gt;</span> pPrint [<span class="st">&quot;きーらーめーくー♪&quot;</span>, <span class="st">&quot;ほーしーの力でー♪&quot;</span>, <span class="st">&quot;あこがーれのー♪&quot;</span>, <span class="st">&quot;わーたーし描くよー♪&quot;</span>]</a>
<a class="sourceLine" id="cb11-3" title="3">[ <span class="st">&quot;きーらーめーくー♪&quot;</span></a>
<a class="sourceLine" id="cb11-4" title="4">, <span class="st">&quot;ほーしーの力でー♪&quot;</span></a>
<a class="sourceLine" id="cb11-5" title="5">, <span class="st">&quot;あこがーれのー♪&quot;</span></a>
<a class="sourceLine" id="cb11-6" title="6">, <span class="st">&quot;わーたーし描くよー♪&quot;</span></a>
<a class="sourceLine" id="cb11-7" title="7">]</a></code></pre></div>
<p>例ではわかりづらいですが、ちゃんと色も着けてくれます！<br />
それでは<span class="ascii">2020</span>年も、<span class="ascii">Happy Haskell Hacking</span>🎁</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>例年どおりですとプリキュア<span class="ascii">Advent Calendar</span>と同時投稿をしている予定でしたが、例年参加者が減っていたこともあり、今年はプリキュア<span class="ascii">Advent Calendar</span>はなくなってしまいました😞<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>村主崇行さんは「<a href="https://shop.ohmsha.co.jp/shopdetail/000000001926/">すごい<span class="ascii">Haskell</span>たのしく学ぼう！</a>」の翻訳を担当されるなど、<span class="ascii">unicode-show</span>以外にも日本の<span class="ascii">Haskell</span>界に多大な功績をもたらした方でした。<a href="#fnref2" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/regex-applicative.html" lang="ja">regex-applicative: 内部DSLとしての正規表現（ブログ記事版）</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/haskell-in-vrchat.html" style="margin-left: auto;" lang="ja">VRのためにHaskellを使った話</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>VRのためにHaskellを使った話</title>
    <link href="https://haskell.jp/blog/posts/2019/haskell-in-vrchat.html" />
    <id>https://haskell.jp/blog/posts/2019/haskell-in-vrchat.html</id>
    <published>2019-12-03T00:00:00Z</published>
    <updated>2019-12-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#はじめに" title="はじめに">はじめに</a></li>
<li><a href="#vr空間でltがしたい" title="vr空間でltがしたい"><span class="ascii">VR</span>空間で<span class="ascii">LT</span>がしたい</a></li>
<li><a href="#webフレームワーク" title="webフレームワーク"><span class="ascii">Web</span>フレームワーク</a></li>
<li><a href="#はじめてのhaskellペアプロ" title="はじめてのhaskellペアプロ">はじめての<span class="ascii">Haskell</span>ペアプロ</a></li>
<li><a href="#デプロイ" title="デプロイ">デプロイ</a></li>
<li><a href="#実際に開催してみて" title="実際に開催してみて">実際に開催してみて</a></li>
<li><a href="#リポジトリ" title="リポジトリ">リポジトリ</a></li>
</ul>
</div>
</div>
<h1 id="はじめに"><span class="link-to-here-outer"><a href="#はじめに" title="はじめに"><span class="link-to-here">Link to<br />
here</span></a></span>はじめに</h1>
<p>はじめまして。趣味で<span class="ascii">Haskell</span>しているはる<span class="ascii">(haru2036)</span>と申します。まったり進行で開発しているので<span class="ascii">GHC</span>のバージョンアップの速さについていけてない感があります…… さて、今回はあんまり深い話はありません。どちらかと言うとこんなニッチなところに<span class="ascii">Haskell</span>使ったよというネタで書きます。</p>
<h1 id="vr空間でltがしたい"><span class="link-to-here-outer"><a href="#vr空間でltがしたい" title="vr空間でltがしたい"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">VR</span>空間で<span class="ascii">LT</span>がしたい</h1>
<p>突然ですが、私は<a href="https://vrchat.com/"><span class="ascii">VRChat</span></a>（以下<span class="ascii">VRC</span>）というソーシャル<span class="ascii">VR</span>サービス（<span class="ascii">Second Life</span>の<span class="ascii">VR</span>版みたいなものです）にハマっています。<br />
友人との雑談の中で<span class="ascii">VRC</span>の中で<span class="ascii">LT</span>会ができればプログラミングなどの話題で盛り上がれる人が集まってワイワイ楽しくできるのではないかと話して、その場のノリでとりあえず実装してみることにしました。</p>
<figure>
<img src="/img/2019/haskell-in-vrchat/vrc-lt-room.png" title="完成したワールド" alt="完成したワールド" /><figcaption>完成したワールド</figcaption>
</figure>
<p>今回作りたかったのはスライドを表示するためのスクリーンと、ページ送りに使うボタンを実装したワールドです。</p>
<figure>
<img src="/img/2019/haskell-in-vrchat/vrc-lt-control-panel.png" title="発表者用コントロールパネル" alt="発表者用コントロールパネル" /><figcaption>発表者用コントロールパネル</figcaption>
</figure>
<p><span class="ascii">VRC</span>ではアバターやワールドを自由に作ることができるのですが、<span class="ascii">VRC</span>が提供するコンポーネント以外のスクリプトは利用できません。<span class="ascii">Haskell</span>ユーザとしては得意なことを活用しづらい土壌です。<br />
幸いスライドを表示する手段はゲーム内で<span class="ascii">URL</span>から画像を取得し表示する<span class="ascii">VRC_Panorama</span>というコンポーネントを利用することにより確保できましたが、<span class="ascii">VRC_Panorama</span>が取得できる画像はワールド作成時に決め打ちで指定された<span class="ascii">URL</span>のリストに含まれるもののみです。<br />
そのため、スライド画像への<span class="ascii">URL</span>のリストを直接<span class="ascii">VRC_Panorama</span>に渡していると、イベントを開催する際よくある飛び入り参加やスライドの用意が遅れた参加者に対応できなくなってしまいます。</p>
<p>その問題を解決するために、イベント開始時からのページ数とスライドの画像<span class="ascii">URL</span>をマップする<span class="ascii">WebAPI</span>を用意しました。<br />
具体的には、<code>/slides/{pageCount}</code> のような形のエンドポイントを持った<span class="ascii">API</span>を用意し、そこから実際の画像へリダイレクトをかけるという方法を取りました。</p>
<figure>
<img src="/img/2019/haskell-in-vrchat/vrc-lt-image.png" title="実装イメージ図" alt="実装イメージ図" /><figcaption>実装イメージ図</figcaption>
</figure>
<h1 id="webフレームワーク"><span class="link-to-here-outer"><a href="#webフレームワーク" title="webフレームワーク"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Web</span>フレームワーク</h1>
<p>今回は自分で使うだけだしということでさらっとやってみたかったので<span class="ascii">Spock</span>を利用しました。もう少し誰でも使えるサービスにしたいと考えているので<span class="ascii">Servant</span>に載せ替えてかっちり作り直そうかと思い移植しているところです。</p>
<h1 id="はじめてのhaskellペアプロ"><span class="link-to-here-outer"><a href="#はじめてのhaskellペアプロ" title="はじめてのhaskellペアプロ"><span class="link-to-here">Link to<br />
here</span></a></span>はじめての<span class="ascii">Haskell</span>ペアプロ</h1>
<p>じつは<span class="ascii">LT</span>会をやろうと思いついた友人の<a href="https://twitter.com/b0xp2"><span class="ascii">BOXP</span></a>は<span class="ascii">Clojure</span>ユーザで、せっかくだからと<span class="ascii">API</span>の開発を手伝ってくれました。<br />
あまり<span class="ascii">Haskell</span>に馴染みはなかったものの、いわゆる関数型プログラミング的な概念はバッチリなのでスススっと書いてくれました。<br />
書いてくれる上での障壁になったのは、型関連の要素<span class="ascii">(</span><code>data</code>や<code>type</code>や<code>newtype</code>がぱっと見わからなかった、型コンストラクタ、値コンストラクタの概念）に馴染みが薄かったことでした。<br />
<span class="ascii">Discord</span>で画面共有しながら説明を行ったのですが、やはり同じ画面を見ながら説明するのはとてもやりやすいと感じました。<br />
本人からのメッセージはこちら。</p>
<blockquote>
<p>プログラミング<span class="ascii">Haskell</span>を昔読んでかじったことがある程度で素人もいいところでしたが、当人のサポートもあり思いついた数日後には実装が終わっていました。 はるくんの話にもある通り<span class="ascii">Discord</span>で画面共有しながらペアプロし、<span class="ascii">Haskell</span>でのテストコードの書き方も一から教えてもらいながら書きました。これは願ってもない体験だったので根気よく教えてくれたことに非常に感謝しています。</p>
<p>また、個人的には実装以外でのブレストや実際の会場でのデバッグを<span class="ascii">VRChat</span>上でできた事もとてもよかったなと思っています。 単純に実装を確認するためには二人以上で<span class="ascii">VRChat</span>に入る必要があるというのもありましたが、完全リモートでも身振り手振りありでブレストができたことや、アバターのおかげで環境に囚われないコミュニケーションができていたことも<span class="ascii">Good</span>でした。</p>
</blockquote>
<h1 id="デプロイ"><span class="link-to-here-outer"><a href="#デプロイ" title="デプロイ"><span class="link-to-here">Link to<br />
here</span></a></span>デプロイ</h1>
<p>今回は自分で使うだけな上に常時稼働している必要もなく、コストを最小限に抑えたかったので<span class="ascii">Heroku</span>にデプロイしました。<br />
<span class="ascii">Dockerfile</span>を書き、スタティックリンク周りで悩みながらもイメージを生成して<span class="ascii">Heroku</span>のレジストリに<span class="ascii">Push</span>し、後はいつもの<span class="ascii">Heroku</span>という感じでうまくいきました。</p>
<p>余談ですが、最近参加した<span class="ascii">Gotanda.hs</span>というイベントで<code>cabal build --enable-executable-static</code>でいい感じにシングルバイナリが生成できるというお話を聞いたので、最近<span class="ascii">stack</span>ばっかり使ってたのを改めて適材適所で使い分けていきたいなーと思っています。</p>
<h1 id="実際に開催してみて"><span class="link-to-here-outer"><a href="#実際に開催してみて" title="実際に開催してみて"><span class="link-to-here">Link to<br />
here</span></a></span>実際に開催してみて</h1>
<p>ここは<span class="ascii">Haskell</span>ほぼ全く関係ないですが……</p>
<p><img src="/img/2019/haskell-in-vrchat/vrc-lt.png" /> <span class="ascii">VRC-LT</span>という名前で<span class="ascii">6</span>回ほど開催しているのですが、場所の制約を受けずに勉強会ができ、その後の懇親会も会場の撤収時刻や終電を気にせず話したい人はとことん話し続ける事ができるというところが非常に良かったです。<br />
ホワイトボードはまだ未実装ですが、空間に書けるペンも配布されているのでその手のアイテムも取り入れれば懇親会での話も更にはずむのではないでしょうか。</p>
<p><span class="ascii">VRChat</span>は<span class="ascii">PC</span>のみでも利用することができます。 <span class="ascii">VRC-LT</span>はほぼ月イチペースで不定期開催ですので、もしよろしければ参加していただけると嬉しいです。 開催時のアーカイブ等も以下の<span class="ascii">Web</span>サイトにて公開中です。合わせてご覧ください。 <a href="https://vrc-lt.github.io"><span class="ascii">https://vrc-lt.github.io</span></a></p>
<h1 id="リポジトリ"><span class="link-to-here-outer"><a href="#リポジトリ" title="リポジトリ"><span class="link-to-here">Link to<br />
here</span></a></span>リポジトリ</h1>
<p>そんなこんなで開発中のリポジトリはこちらになります。<br />
拙いところもいっぱいですが<span class="ascii">Issue</span>や<span class="ascii">PR</span>などで気になった点を教えていただければ幸いです！<br />
<a href="https://github.com/vrc-lt/VRC-Slide-Server"><span class="ascii">https://github.com/vrc-lt/VRC-Slide-Server</span></a></p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/unicode-show.html" lang="ja">日本語をshowしてうまく表示されなかったら</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/haskell-day-2019.html" style="margin-left: auto;" lang="ja">Haskell Day 2019を開催しました！</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>Haskell Day 2019を開催しました！</title>
    <link href="https://haskell.jp/blog/posts/2019/haskell-day-2019.html" />
    <id>https://haskell.jp/blog/posts/2019/haskell-day-2019.html</id>
    <published>2019-11-29T00:00:00Z</published>
    <updated>2019-11-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <p>先日<span class="ascii">2019</span>年<span class="ascii">11</span>月<span class="ascii">9</span>日、<a href="https://techplay.jp/space"><span class="ascii">TECH PLAY SHIBUYA</span></a>にて<a href="https://techplay.jp/event/727059"><span class="ascii">Haskell Day 2019</span></a>を開催しました。<br />
今回は、各発表の概要や、アンケートの結果をお伝えしたいと思います。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#発表" title="発表">発表</a>
<ul>
<li><a href="#関数型function-typeを見つめるプログラミング" title="関数型function-typeを見つめるプログラミング">関数型<span class="ascii">(function type)</span>を見つめるプログラミング</a></li>
<li><a href="#hkdhigher-kinded-datatype" title="hkdhigher-kinded-datatype"><span class="ascii">HKD(Higher Kinded Datatype)</span></a></li>
<li><a href="#しんさんきぼうのderivingストラテジー" title="しんさんきぼうのderivingストラテジー">「しんさんきぼう」の<span class="ascii">Deriving</span>ストラテジー</a></li>
<li><a href="#haskellメタプログラミングによるegisonのパターンマッチの実装" title="haskellメタプログラミングによるegisonのパターンマッチの実装"><span class="ascii">Haskell</span>メタプログラミングによる<span class="ascii">Egison</span>のパターンマッチの実装</a></li>
<li><a href="#関数と型で理解する自動微分" title="関数と型で理解する自動微分">関数と型で理解する自動微分</a></li>
<li><a href="#ghcjs-によるwebフロントエンド開発" title="ghcjs-によるwebフロントエンド開発"><span class="ascii">GHCJS</span> による<span class="ascii">Web</span>フロントエンド開発</a></li>
<li><a href="#haskellで作る競技型イベントの裏側" title="haskellで作る競技型イベントの裏側"><span class="ascii">Haskell</span>で作る競技型イベントの裏側</a></li>
<li><a href="#大規模数値計算を支える-haskell-pragmatic-haskell-in-large-scale-numerical-computation" title="大規模数値計算を支える-haskell-pragmatic-haskell-in-large-scale-numerical-computation">大規模数値計算を支える <span class="ascii">Haskell</span> ── <span class="ascii">Pragmatic Haskell in Large-Scale Numerical Computation</span>──</a></li>
<li><a href="#cadenza-building-fast-functional-languages-on-the-jvm" title="cadenza-building-fast-functional-languages-on-the-jvm"><span class="ascii">Cadenza: Building fast functional languages on the JVM</span></a></li>
<li><a href="#lt" title="lt"><span class="ascii">LT</span></a></li>
</ul></li>
<li><a href="#アンケート結果" title="アンケート結果">アンケート結果</a>
<ul>
<li><a href="#haskell-以外のプログラミングに関する質問" title="haskell-以外のプログラミングに関する質問"><span class="ascii">Haskell</span> 以外のプログラミングに関する質問</a>
<ul>
<li><a href="#エンジニアの経験年数はどれくらいですか" title="エンジニアの経験年数はどれくらいですか">エンジニアの経験年数はどれくらいですか？</a></li>
<li><a href="#得意なプログラミング言語はなんですか" title="得意なプログラミング言語はなんですか">得意なプログラミング言語はなんですか？</a></li>
<li><a href="#得意好きな技術領域はどれですか" title="得意好きな技術領域はどれですか">得意・好きな技術領域はどれですか？</a></li>
<li><a href="#最近注目している技術があれば記述してください" title="最近注目している技術があれば記述してください">最近注目している技術があれば記述してください</a></li>
</ul></li>
<li><a href="#haskell-に関する質問" title="haskell-に関する質問"><span class="ascii">Haskell</span> に関する質問</a>
<ul>
<li><a href="#haskell-をいつ頃始めましたか" title="haskell-をいつ頃始めましたか"><span class="ascii">Haskell</span> をいつ頃始めましたか？</a></li>
<li><a href="#haskell-を初めてどれくらい経ちますか" title="haskell-を初めてどれくらい経ちますか"><span class="ascii">Haskell</span> を初めてどれくらい経ちますか？</a></li>
<li><a href="#読んだことのある日本語の-haskell-本は" title="読んだことのある日本語の-haskell-本は">読んだことのある日本語の <span class="ascii">Haskell</span> 本は？</a></li>
</ul></li>
</ul></li>
<li><a href="#おわりに" title="おわりに">おわりに</a></li>
<li><a href="#あわせて読みたい" title="あわせて読みたい">あわせて読みたい</a></li>
</ul>
</div>
</div>
<h1 id="発表"><span class="link-to-here-outer"><a href="#発表" title="発表"><span class="link-to-here">Link to<br />
here</span></a></span>発表</h1>
<p>まずは各種発表の紹介から。</p>
<h2 id="関数型function-typeを見つめるプログラミング"><span class="link-to-here-outer"><a href="#関数型function-typeを見つめるプログラミング" title="関数型function-typeを見つめるプログラミング"><span class="link-to-here">Link to<br />
here</span></a></span>関数型<span class="ascii">(function type)</span>を見つめるプログラミング</h2>
<p>「関数型」 — すなわち<span class="ascii">Haskell</span>でいうところの<code>a -&gt; b</code>で表される、<span class="ascii">Haskell</span>の関数について、ちょっと見方を変えた新しい発見を教えてくれました。</p>
<p><a href="https://github.com/nobsun/hday2019/blob/master/doc/ftype.pdf">資料はこちら</a></p>
<p><img src="/img/2019/haskell-day-2019/nobsun.jpg" /></p>
<h2 id="hkdhigher-kinded-datatype"><span class="link-to-here-outer"><a href="#hkdhigher-kinded-datatype" title="hkdhigher-kinded-datatype"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">HKD(Higher Kinded Datatype)</span></h2>
<p><span class="ascii">Higher Kinded Datatype (HKD)</span>という、昨今<span class="ascii">Haskell</span>界で流行りの型定義方法を解説しています。<br />
レコード型を定義する際<span class="ascii">HKD</span>にすることで、より柔軟に扱うことができるようになります。<br />
さらに、<a href="http://hackage.haskell.org/package/barbies"><span class="ascii">barbies</span></a>や<a href="http://hackage.haskell.org/package/extensible"><span class="ascii">extensible</span></a>といった、<span class="ascii">HKD</span>の利用を飛躍的に促進するパッケージも紹介されました。</p>
<p><a href="https://assets.adobe.com/public/b93f214d-58c2-482f-5528-a939d3e83660">資料はこちら</a></p>
<p><img src="/img/2019/haskell-day-2019/fumieval.jpg" /></p>
<h2 id="しんさんきぼうのderivingストラテジー"><span class="link-to-here-outer"><a href="#しんさんきぼうのderivingストラテジー" title="しんさんきぼうのderivingストラテジー"><span class="link-to-here">Link to<br />
here</span></a></span>「しんさんきぼう」の<span class="ascii">Deriving</span>ストラテジー</h2>
<p><span class="ascii">Haskell</span>の<code>deriving</code>機能 — 型を定義したとき、型クラスのインスタンスまで自動で定義してくれるあの機能ですね — の、適用範囲を広げる<span class="ascii">GHC</span>の言語拡張をいろいろ紹介してくれました。</p>
<p><a href="https://aiya000.github.io/Maid/haskell-day-2019-deriving/#/">資料はこちら</a></p>
<p><img src="/img/2019/haskell-day-2019/aiya000.jpg" /></p>
<h2 id="haskellメタプログラミングによるegisonのパターンマッチの実装"><span class="link-to-here-outer"><a href="#haskellメタプログラミングによるegisonのパターンマッチの実装" title="haskellメタプログラミングによるegisonのパターンマッチの実装"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Haskell</span>メタプログラミングによる<span class="ascii">Egison</span>のパターンマッチの実装</h2>
<p>プログラミング言語<a href="https://www.egison.org/ja/"><span class="ascii">Egison</span></a>の核となる機能である強力なパターンマッチを、<span class="ascii">GHC</span>の各種拡張を駆使することで、<span class="ascii">Haskell</span>のソースコードに自然に埋め込めるような形で実装した、という話です。</p>
<p><a href="https://www.egison.org/download/20191109HaskellDay.pdf">資料はこちら</a></p>
<p><a href="https://github.com/egison/egison-haskell">紹介しているライブラリーのソースコードはこちら</a></p>
<p><img src="/img/2019/haskell-day-2019/egison.jpg" /></p>
<h2 id="関数と型で理解する自動微分"><span class="link-to-here-outer"><a href="#関数と型で理解する自動微分" title="関数と型で理解する自動微分"><span class="link-to-here">Link to<br />
here</span></a></span>関数と型で理解する自動微分</h2>
<p>関数の自動微分を行うパッケージ<a href="http://hackage.haskell.org/package/ad"><span class="ascii">ad</span></a>の仕組みを自力で実装してみることで解説してくれました。</p>
<p><a href="https://speakerdeck.com/lotz84/guan-shu-toxing-deli-jie-suruzi-dong-wei-fen">資料はこちら</a></p>
<p><img src="/img/2019/haskell-day-2019/lotz.jpg" /></p>
<h2 id="ghcjs-によるwebフロントエンド開発"><span class="link-to-here-outer"><a href="#ghcjs-によるwebフロントエンド開発" title="ghcjs-によるwebフロントエンド開発"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">GHCJS</span> による<span class="ascii">Web</span>フロントエンド開発</h2>
<p><a href="http://hackage.haskell.org/package/miso"><span class="ascii">miso</span></a>というおいしそうな名前のアプリケーションフレームワークと、<span class="ascii">Firebase</span>と連携する<span class="ascii">miso</span>のサンプルを、ライブコーディングを通して紹介してくれました。<br />
<span class="ascii">miso</span>を使えば、<span class="ascii">GHCJS</span>を使って<span class="ascii">Elm Architecture</span>風の設計に基づいてアプリケーションを作ったり、さらにそのコードを利用してサーバーサイドレンダリングをしたりできます。</p>
<p>ℹ️資料はまだ公開されていません！当日はライブコーディングが大半の時間を占めていたため、同等の解説を文章にして公開したいというチェシャ猫さんの意向によるものです。<br />
現在執筆中のためお待ちください。🙇</p>
<p><a href="https://github.com/y-taka-23/miso-firebase-tutorial">発表中に使用したソースコードはこちら</a></p>
<p><img src="/img/2019/haskell-day-2019/y_taka_23.jpg" /></p>
<h2 id="haskellで作る競技型イベントの裏側"><span class="link-to-here-outer"><a href="#haskellで作る競技型イベントの裏側" title="haskellで作る競技型イベントの裏側"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Haskell</span>で作る競技型イベントの裏側</h2>
<p>「<span class="ascii">mixi git challenge</span>」というイベントにおいてユーザーが投稿した解答を採点するサーバーを、<span class="ascii">Haskell</span>と<span class="ascii">Elm</span>で一から書き直した、という事例を発表してくれました。<br />
<a href="http://hackage.haskell.org/package/rio"><span class="ascii">rio</span></a>や<a href="http://hackage.haskell.org/package/servant"><span class="ascii">servant</span></a>といった著名なパッケージを使うだけでなく、足りないところを自力で補って新しいパッケージとして公開したり、さらに作成したアプリケーション自体を<span class="ascii">OSS</span>として公開したりすることで、大きな資産を残していただけました。</p>
<p><a href="https://www.slideshare.net/noob00/haskell-191796924">資料はこちら</a></p>
<p><a href="https://github.com/matsubara0507/git-plantation">紹介しているアプリケーションのソースコードはこちら</a></p>
<p><img src="/img/2019/haskell-day-2019/matsubara0507.jpg" /></p>
<h2 id="大規模数値計算を支える-haskell-pragmatic-haskell-in-large-scale-numerical-computation"><span class="link-to-here-outer"><a href="#大規模数値計算を支える-haskell-pragmatic-haskell-in-large-scale-numerical-computation" title="大規模数値計算を支える-haskell-pragmatic-haskell-in-large-scale-numerical-computation"><span class="link-to-here">Link to<br />
here</span></a></span>大規模数値計算を支える <span class="ascii">Haskell</span> ── <span class="ascii">Pragmatic Haskell in Large-Scale Numerical Computation</span>──</h2>
<p><a href="https://www.deepflow.co.jp/"><span class="ascii">DeepFlow</span>株式会社</a>における<span class="ascii">Haskell</span>の事例の紹介です。<br />
超高速で大規模な数値計算システムを、<span class="ascii">GHC</span>の多様な言語拡張を駆使して作っているそうです。<br />
<span class="ascii">Tagless Final</span>を活用することで知っているべき領域を区分して仕事を分けることに成功しているという点が印象的でした。</p>
<p><a href="https://speakerdeck.com/konn/da-gui-mo-shu-zhi-ji-suan-wozhi-eru-haskell-nil-nil-pragmatic-haskell-in-large-scale-numerical-computation-nil-nil">資料はこちら</a></p>
<p><img src="/img/2019/haskell-day-2019/mr_konn.jpg" /></p>
<h2 id="cadenza-building-fast-functional-languages-on-the-jvm"><span class="link-to-here-outer"><a href="#cadenza-building-fast-functional-languages-on-the-jvm" title="cadenza-building-fast-functional-languages-on-the-jvm"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Cadenza: Building fast functional languages on the JVM</span></h2>
<p><a href="https://ekmett.github.io/cadenza/cadenza/index.html"><span class="ascii">cadenza</span></a>という、<span class="ascii">Truffle</span>（<span class="ascii">GraalVM</span>に含まれている、高速なインタープリター作成フレームワーク）製の関数型言語の紹介です。<br />
<span class="ascii">Truffle</span>がもたらす強力な<span class="ascii">JIT</span>と「<span class="ascii">Normalization by Evaluation</span>」という技術を応用することで、型検査と実行時両方における高いスピードを得ることが狙いだそうです。 将来的には依存型言語における型チェックや、<span class="ascii">GHC</span>のランタイムの高速化に寄与したいとのことです。</p>
<p><a href="https://drive.google.com/file/d/1bwYO66xUKeHyR4YCNm_1C82JlDNQLUXv/view">資料はこちら</a></p>
<p><a href="https://github.com/ekmett/cadenza">紹介しているアプリケーションのソースコードはこちら</a></p>
<p><img src="/img/2019/haskell-day-2019/ekmett.jpg" /></p>
<h2 id="lt"><span class="link-to-here-outer"><a href="#lt" title="lt"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">LT</span></h2>
<p>今回は<span class="ascii">Hakell Day</span>史上初めての試みとして、<span class="ascii">Lightning Talk</span>を当日公募しました。<br />
残念ながら<span class="ascii">5</span>分間という短い制限時間に収められない発表が大半でしたので、ぜひ👇の資料を読んでみてください！</p>
<p><strong>順番が間違っていたら済みません！ご指摘を！</strong></p>
<ul>
<li><a href="https://docs.google.com/presentation/d/1TiDWz3zLUwEWgpzXfgVZFIib6JtYriB03TVgHsimJC0/edit#slide=id.gc6f73a04f_0_0"><span class="ascii">3D Model in Haskell - Haskell</span>で<span class="ascii">3D</span>モデルに触れる</a></li>
<li><a href="https://speakerdeck.com/cyclone_t/iot-cases-with-haskell"><span class="ascii">Haskell</span>で<span class="ascii">IoT</span>やってます</a></li>
<li><a href="https://www.slideshare.net/jabaraster/haskell-day-2019-lt-tomoyuki-kawano"><span class="ascii">Quora</span>で<span class="ascii">Haskell</span>への愛を語る</a></li>
<li><a href="https://gitpitch.com/coord-e/slide-type-class-impl"><span class="ascii">Haskell</span>で作ってわかる型クラス</a></li>
<li><a href="https://drive.google.com/file/d/1YGKjl8S-LlfuB8yrHnKSK5G5MGsP9xd3/view"><span class="ascii">Abstract Typeclasses - How To Design a Future-Proof Typeclass</span></a></li>
<li><a href="http://www.mew.org/~kazu/material/2019-gc.pdf"><span class="ascii">GHC</span>の<span class="ascii">GC</span></a></li>
</ul>
<h1 id="アンケート結果"><span class="link-to-here-outer"><a href="#アンケート結果" title="アンケート結果"><span class="link-to-here">Link to<br />
here</span></a></span>アンケート結果</h1>
<p><span class="ascii">Haskell Day</span> の各セッションや、参加者のバックグランドなどについてアンケートをとりました。 なので、後者の方の集計結果を載せたいと思います（前者はセッション発表者へのフィードバック）。</p>
<h2 id="haskell-以外のプログラミングに関する質問"><span class="link-to-here-outer"><a href="#haskell-以外のプログラミングに関する質問" title="haskell-以外のプログラミングに関する質問"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Haskell</span> 以外のプログラミングに関する質問</h2>
<p>大きく分けて <span class="ascii">Haskell</span> に関する質問とそうでない質問がありました。 まずは <span class="ascii">Haskell</span> 以外に関する質問の方を集計結果を紹介します。</p>
<h3 id="エンジニアの経験年数はどれくらいですか"><span class="link-to-here-outer"><a href="#エンジニアの経験年数はどれくらいですか" title="エンジニアの経験年数はどれくらいですか"><span class="link-to-here">Link to<br />
here</span></a></span>エンジニアの経験年数はどれくらいですか？</h3>
<p><img src="/img/2019/haskell-day-2019/question1.jpg" /></p>
<h3 id="得意なプログラミング言語はなんですか"><span class="link-to-here-outer"><a href="#得意なプログラミング言語はなんですか" title="得意なプログラミング言語はなんですか"><span class="link-to-here">Link to<br />
here</span></a></span>得意なプログラミング言語はなんですか？</h3>
<p>ちなみに、言語のリストは <a href="https://haskellweekly.news/survey/2019.html"><span class="ascii">Haskell Survey 2019</span></a> を参考にしました。</p>
<p><img src="/img/2019/haskell-day-2019/question2.jpg" /></p>
<h3 id="得意好きな技術領域はどれですか"><span class="link-to-here-outer"><a href="#得意好きな技術領域はどれですか" title="得意好きな技術領域はどれですか"><span class="link-to-here">Link to<br />
here</span></a></span>得意・好きな技術領域はどれですか？</h3>
<p><img src="/img/2019/haskell-day-2019/question3.jpg" /></p>
<h3 id="最近注目している技術があれば記述してください"><span class="link-to-here-outer"><a href="#最近注目している技術があれば記述してください" title="最近注目している技術があれば記述してください"><span class="link-to-here">Link to<br />
here</span></a></span>最近注目している技術があれば記述してください</h3>
<p>自由記述形式にしたところ、ほとんど重複が無かったので箇条書きにします。</p>
<ul>
<li><span class="ascii">FP</span></li>
<li>匿名暗号通貨<span class="ascii">(Monero,Zcash,Dash,Koto)</span></li>
<li><span class="ascii">Cardano ADA</span></li>
<li><span class="ascii">GraphQL</span></li>
<li><span class="ascii">extensible</span></li>
<li><span class="ascii">Enigma</span></li>
<li><span class="ascii">worker</span>ベースの非同期プログラミング</li>
<li>フロント界隈</li>
<li><span class="ascii">Next.js</span></li>
<li>自然言語処理</li>
<li>型レベルプログラミング</li>
<li>自動微分</li>
<li><span class="ascii">AWS</span>によるサーバーレスアーキテクチャでのフルスタック<span class="ascii">Web</span>アプリケーション開発</li>
<li><span class="ascii">Rust</span></li>
<li><span class="ascii">Kubernetes</span></li>
<li><span class="ascii">TLA+</span></li>
<li><span class="ascii">algebraic effects and handlers</span></li>
<li>深層学習コンパイラ</li>
<li><span class="ascii">AR</span></li>
<li>定理証明支援系</li>
</ul>
<h2 id="haskell-に関する質問"><span class="link-to-here-outer"><a href="#haskell-に関する質問" title="haskell-に関する質問"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Haskell</span> に関する質問</h2>
<p>ちなみに、<span class="ascii">Haskell</span> に関する質問は <span class="ascii">Haskell Day 2018</span> でもアンケートしました。</p>
<h3 id="haskell-をいつ頃始めましたか"><span class="link-to-here-outer"><a href="#haskell-をいつ頃始めましたか" title="haskell-をいつ頃始めましたか"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Haskell</span> をいつ頃始めましたか？</h3>
<p><img src="/img/2019/haskell-day-2019/question4.jpg" /></p>
<h3 id="haskell-を初めてどれくらい経ちますか"><span class="link-to-here-outer"><a href="#haskell-を初めてどれくらい経ちますか" title="haskell-を初めてどれくらい経ちますか"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Haskell</span> を初めてどれくらい経ちますか？</h3>
<p><img src="/img/2019/haskell-day-2019/question5.jpg" /></p>
<h3 id="読んだことのある日本語の-haskell-本は"><span class="link-to-here-outer"><a href="#読んだことのある日本語の-haskell-本は" title="読んだことのある日本語の-haskell-本は"><span class="link-to-here">Link to<br />
here</span></a></span>読んだことのある日本語の <span class="ascii">Haskell</span> 本は？</h3>
<p>参照<span class="ascii">:</span> <a href="https://wiki.haskell.jp/Links#書籍" class="uri"><span class="ascii">https://wiki.haskell.jp/Links#</span>書籍</a></p>
<p><img src="/img/2019/haskell-day-2019/question6.jpg" /></p>
<h1 id="おわりに"><span class="link-to-here-outer"><a href="#おわりに" title="おわりに"><span class="link-to-here">Link to<br />
here</span></a></span>おわりに</h1>
<p>以上の発表に加えて今回は、下記のスポンサー企業の皆様や<span class="ascii">@fumieval</span>くんのおかげで、大変満足度の高い懇親会ができました。</p>
<ul>
<li><a href="https://www.mvrck.co.jp/">マーベリック株式会社</a></li>
<li><a href="https://herp.co.jp/">株式会社<span class="ascii">HERP</span></a></li>
<li><a href="https://www.iij.ad.jp/">株式会社インターネットイニシアティブ</a></li>
<li><a href="https://www.cryptact.com/">株式会社クリプタクト</a></li>
</ul>
<figure>
<img src="/img/2019/haskell-day-2019/after-party.jpg" alt="懇親会で振る舞われた料理" /><figcaption>懇親会で振る舞われた料理</figcaption>
</figure>
<p>発表について。<br />
昨年は「<a href="https://haskell-jp.connpass.com/event/92617/"><span class="ascii">Haskell</span>ちょっと興味あるからちょっとできるまで</a>」というテーマを意識して、発表の難易度別に時間帯が分かれるよう調整しましたが、残念ながらうまくいきませんでした。<br />
そこで難易度調整の難しさを痛感したため、今回は敢えて難易度調整を行わなかったのです。<br />
結果、全体として難しい発表に偏ってしまった点は少し反省です。<a href="https://eng-blog.iij.ad.jp/archives/3467">私が会社で開いている<span class="ascii">Haskell</span>勉強会</a>に毎回参加いただいている同僚も、総じて難しくて追いつくのが大変だった、と仰ってました。<br />
次回は特別に難易度を下げた発表枠をいくつか作り、内容を事前に精査する、なんてプランを考えています。</p>
<p>会場について。<br />
<span class="ascii">TECHPLAY SHIBUYA</span>は素晴らしいですね！<br />
我々のようなお金がないコミュニティーが今回の規模のイベントを行うのにうってつけでした。<br />
元々イベントを開催する前提で作られており、受付と演壇が近いため受付しながら発表を聞くことができるのも、持ち回りで受付をしている我々にとって好都合でした。<br />
来年も是非使わせていただきたいです🙏</p>
<p>最後に。<br />
発表者のみなさんはもちろん、支えていただいたスタッフ、スポンサー企業、会場まで足を運んでいただいた参加者の皆様、その他この会の実現に関わったすべての方々に、この場を借りて感謝の意を示したいと思います。<br />
みなさんのご協力おかげで、大きなトラブルもなく、楽しいイベントが開催できました。ありがとうございます。<br />
今後も日本<span class="ascii">Haskell</span>ユーザーグループ（<span class="ascii">a.k.a. Haskell-jp</span>）をよろしくお願いします！<br />
<span class="ascii">hask(_ _)eller</span></p>
<h1 id="あわせて読みたい"><span class="link-to-here-outer"><a href="#あわせて読みたい" title="あわせて読みたい"><span class="link-to-here">Link to<br />
here</span></a></span>あわせて読みたい</h1>
<ul>
<li>参加者による参加レポート<span class="ascii">:</span>
<ul>
<li><a href="http://hiratara.hatenadiary.jp/entry/2019/11/09/110030">今日は <span class="ascii">Haskell Day 2019</span> の日です <span class="ascii">-</span> 北海道苫小牧市出身の初老<span class="ascii">PG</span>が書くブログ</a></li>
<li><a href="https://www.ncaq.net/2019/11/09/20/56/00/"><span class="ascii">Haskell Day 2019</span>に参加しました <span class="ascii">- ncaq</span></a></li>
<li><a href="https://matsubara0507.github.io/posts/2019-11-10-join-haskell-day-2019"><span class="ascii">Haskell Day 2019</span> に参加してきた</a></li>
</ul></li>
<li><a href="https://haskell.jp/blog/posts/2018/haskell-day-2018.html">去年の開催レポート</a></li>
</ul>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/haskell-in-vrchat.html" lang="ja">VRのためにHaskellを使った話</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/hiw-copilot.html" style="margin-left: auto;" lang="ja">HIW 2019で発表された、Copilotという内部DSLについて</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>HIW 2019で発表された、Copilotという内部DSLについて</title>
    <link href="https://haskell.jp/blog/posts/2019/hiw-copilot.html" />
    <id>https://haskell.jp/blog/posts/2019/hiw-copilot.html</id>
    <published>2019-10-01T00:00:00Z</published>
    <updated>2019-10-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p><a href="/posts/2019/hiw-gibbon.html">前回</a>から引き続き、<a href="https://icfp19.sigplan.org/home/hiw-2019#About"><span class="ascii">Haskell Implementors</span>’ <span class="ascii">Workshop 2019</span></a>への参加レポートとして、私の印象に残った発表を紹介します。<br />
今回は、<a href="https://copilot-language.github.io/"><span class="ascii">Copilot</span></a>という、<span class="ascii">C</span>言語のコードを生成する<span class="ascii">Haskell</span>製内部<span class="ascii">DSL</span>についての発表です。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#copilot-3.0-a-haskell-runtime-verification-framework-for-uavs" title="copilot-3.0-a-haskell-runtime-verification-framework-for-uavs"><span class="ascii">Copilot 3.0: a Haskell runtime verification framework for UAVs</span></a></li>
<li><a href="#copilotを試してみる" title="copilotを試してみる"><span class="ascii">Copilot</span>を試してみる</a></li>
</ul>
</div>
</div>
<h1 id="copilot-3.0-a-haskell-runtime-verification-framework-for-uavs"><span class="link-to-here-outer"><a href="#copilot-3.0-a-haskell-runtime-verification-framework-for-uavs" title="copilot-3.0-a-haskell-runtime-verification-framework-for-uavs"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Copilot 3.0: a Haskell runtime verification framework for UAVs</span></h1>
<p>発表者<span class="ascii">: Frank Dedden</span> <em><span class="ascii">Royal Netherlands Aerospace Center</span></em><span class="ascii">, Alwyn Goodloe</span> <em><span class="ascii">NASA Langley Research Center</span></em><span class="ascii">, Ivan Perez</span> <em><span class="ascii">NIA / NASA Formal Methods</span></em></p>
<p><span class="ascii">Haskell</span>製の内部<span class="ascii">DSL</span>から<span class="ascii">C</span>言語のソースコードを生成する、<a href="https://copilot-language.github.io/"><span class="ascii">Copilot</span></a>の紹介です。<br />
似た謳い文句の内部<span class="ascii">DSL</span>として<a href="http://hackage.haskell.org/package/ivory"><span class="ascii">ivory</span></a>がありますが、<span class="ascii">Copilot</span>は、ハードウェアの実行時検証を行う<span class="ascii">C</span>言語のコードを生成することに、より特化しています。<br />
「センサーから信号を受け取って、一定の条件を満たした場合に何らかの処理を実行する」という処理を<span class="ascii">Haskell</span>で宣言的に記述すると、メモリの消費量・実行時間において常に一定な<span class="ascii">C</span>言語のコードを生成することが出来ます。</p>
<p>メモリが限られていて、リアルタイムな処理が必要なハードウェアにとって「邪魔にならない監視」を実現するための必須条件なのでしょう。<br />
現状<span class="ascii">Haskell</span>は<span class="ascii">GC</span>が必要であるといった制約もあり、リアルタイムな処理や厳格なメモリー管理が必要な機器での採用は難しいですが、<span class="ascii">Ivory</span>や今回発表された<span class="ascii">Copilot</span>はあくまでも「<span class="ascii">C</span>言語のコードを生成するだけ」なので、生成する<span class="ascii">Haskell</span>ではメモリー管理をする必要がありません。<br />
にっくきスペースリークに悩まされる心配もないのです。<br />
こういった<span class="ascii">Haskell</span>製内部<span class="ascii">DSL</span>は、<span class="ascii">Haskell</span>の持つ強い型付けによるメリットを享受しながら、変換した言語の実行時におけるパフォーマンスを出しやすい、といういいとこ取りなメリットがあるので、もっと広まってほしいユースケースですね。</p>
<h1 id="copilotを試してみる"><span class="link-to-here-outer"><a href="#copilotを試してみる" title="copilotを試してみる"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Copilot</span>を試してみる</h1>
<ul>
<li>ℹ️ 実際に使用したコードは<a href="https://github.com/haskell-jp/blog/tree/master/examples/2019/hiw-copilot"><span class="ascii">Haskell-jp Blog</span>の<span class="ascii">GitHub</span>のリポジトリー</a>にあります。</li>
<li>ℹ️ 使用した<span class="ascii">copilot</span>パッケージのバージョンは、<span class="ascii">3.0.1</span>です。</li>
<li>ℹ️ サンプルコードの解説については、<span class="ascii">notogawa</span>さんのアドバイスも参考になりました<small>（<a href="https://haskell.jp/slack-log/html/C4M4TT8JJ/46.html#message-1554858057.072700"><span class="ascii">Haskell-jp</span>の<span class="ascii">slack-log</span>ではこのあたり</a>。執筆時点で<span class="ascii">CSS</span>が当たってないため読みづらいですが一応）</small>。ありがとうございます！</li>
</ul>
<p>せっかくなんで<span class="ascii">Copilot</span>を試してみましょう。<br />
公式サイトにあったサンプルコードそのまんまですが、生成される<span class="ascii">C</span>のコードを眺めてみます。</p>
<p>👇のコマンドでサンプルコードが入ったリポジトリーを<span class="ascii">git clone</span>した後、</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" title="1"><span class="fu">git</span> clone https://github.com/haskell-jp/blog</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="bu">cd</span> blog/examples/2019/hiw-copilot</a></code></pre></div>
<p>👇のコマンドでビルド・<span class="ascii">C</span>言語によるコードの生成できるはずです。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" title="1"><span class="ex">stack</span> build copilot</a>
<a class="sourceLine" id="cb2-2" title="2"><span class="ex">stack</span> exec runghc heater.hs</a></code></pre></div>
<p>こちらが生成元の<span class="ascii">Haskell</span>のコードです。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell:heater.hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">import</span> <span class="dt">Language.Copilot</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="kw">import</span> <span class="dt">Copilot.Compile.C99</span></a>
<a class="sourceLine" id="cb3-3" title="3"></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> ((&gt;), (&lt;), div)</a>
<a class="sourceLine" id="cb3-5" title="5"></a>
<a class="sourceLine" id="cb3-6" title="6"><span class="ot">temp ::</span> <span class="dt">Stream</span> <span class="dt">Word8</span></a>
<a class="sourceLine" id="cb3-7" title="7">temp <span class="ot">=</span> extern <span class="st">&quot;temperature&quot;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb3-8" title="8"></a>
<a class="sourceLine" id="cb3-9" title="9"><span class="ot">ctemp ::</span> <span class="dt">Stream</span> <span class="dt">Float</span></a>
<a class="sourceLine" id="cb3-10" title="10">ctemp <span class="ot">=</span> (unsafeCast temp) <span class="op">*</span> (<span class="fl">150.0</span> <span class="op">/</span> <span class="fl">255.0</span>) <span class="op">-</span> <span class="fl">50.0</span></a>
<a class="sourceLine" id="cb3-11" title="11"></a>
<a class="sourceLine" id="cb3-12" title="12">spec <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-13" title="13">  trigger <span class="st">&quot;heaton&quot;</span>  (ctemp <span class="op">&lt;</span> <span class="fl">18.0</span>) [arg ctemp]</a>
<a class="sourceLine" id="cb3-14" title="14">  trigger <span class="st">&quot;heatoff&quot;</span> (ctemp <span class="op">&gt;</span> <span class="fl">21.0</span>) [arg ctemp]</a>
<a class="sourceLine" id="cb3-15" title="15"></a>
<a class="sourceLine" id="cb3-16" title="16">main <span class="ot">=</span> reify spec <span class="op">&gt;&gt;=</span> compile <span class="st">&quot;heater&quot;</span></a></code></pre></div>
<p>まず、<code>temp</code>と<code>ctemp</code>という識別子に定義した式が、センサーが発信する、連続的に変化する値を表しています。<br />
<span class="ascii">Copilot</span>の言葉はこれを<code>Stream</code>と呼んでいます。</p>
<p><code>spec</code>という識別子で定義している式が、「どのセンサーから信号を受け取って、どんな条件を満たした場合にどの処理を実行するか」規定しているようです。<br />
👆の場合、<code>ctemp</code>という<code>Stream</code>が<code>18.0</code>を下回ったら<code>heaton</code>というイベントを発火し、<code>21.0</code>を超えたら<code>heatoff</code>というイベントを発火する、と定めているわけですね。<br />
そして<code>main</code>関数で実行している<code>reify spec &gt;&gt;= compile "heater"</code>という箇所で、<code>.h</code>ファイルと<code>.c</code>ファイルを書き込んでいます。</p>
<p>そして、生成されたヘッダーファイル<code>heater.h</code>がこう👇</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c:heater.h"><code class="sourceCode c"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">extern</span> <span class="dt">uint8_t</span> temperature;</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="dt">void</span> heatoff(<span class="dt">float</span> heatoff_arg0);</a>
<a class="sourceLine" id="cb4-3" title="3"><span class="dt">void</span> heaton(<span class="dt">float</span> heaton_arg0);</a>
<a class="sourceLine" id="cb4-4" title="4"><span class="dt">void</span> step(<span class="dt">void</span>);</a></code></pre></div>
<p>で、肝心の<span class="ascii">C</span>のコード本体<code>heater.c</code>がこちらです。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c:heater.c"><code class="sourceCode c"><a class="sourceLine" id="cb5-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb5-4" title="4"></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="pp">#include </span><span class="im">&quot;heater.h&quot;</span></a>
<a class="sourceLine" id="cb5-6" title="6"></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="dt">static</span> <span class="dt">uint8_t</span> temperature_cpy;</a>
<a class="sourceLine" id="cb5-8" title="8"></a>
<a class="sourceLine" id="cb5-9" title="9"><span class="dt">bool</span> heatoff_guard(<span class="dt">void</span>) {</a>
<a class="sourceLine" id="cb5-10" title="10">  <span class="cf">return</span> ((((<span class="dt">float</span>)(temperature_cpy)) * ((<span class="fl">150.0</span>) / (<span class="fl">255.0</span>))) - (<span class="fl">50.0</span>)) &gt; (<span class="fl">21.0</span>);</a>
<a class="sourceLine" id="cb5-11" title="11">}</a>
<a class="sourceLine" id="cb5-12" title="12"></a>
<a class="sourceLine" id="cb5-13" title="13"><span class="dt">float</span> heatoff_arg0(<span class="dt">void</span>) {</a>
<a class="sourceLine" id="cb5-14" title="14">  <span class="cf">return</span> (((<span class="dt">float</span>)(temperature_cpy)) * ((<span class="fl">150.0</span>) / (<span class="fl">255.0</span>))) - (<span class="fl">50.0</span>);</a>
<a class="sourceLine" id="cb5-15" title="15">}</a>
<a class="sourceLine" id="cb5-16" title="16"></a>
<a class="sourceLine" id="cb5-17" title="17"><span class="dt">bool</span> heaton_guard(<span class="dt">void</span>) {</a>
<a class="sourceLine" id="cb5-18" title="18">  <span class="cf">return</span> ((((<span class="dt">float</span>)(temperature_cpy)) * ((<span class="fl">150.0</span>) / (<span class="fl">255.0</span>))) - (<span class="fl">50.0</span>)) &lt; (<span class="fl">18.0</span>);</a>
<a class="sourceLine" id="cb5-19" title="19">}</a>
<a class="sourceLine" id="cb5-20" title="20"></a>
<a class="sourceLine" id="cb5-21" title="21"><span class="dt">float</span> heaton_arg0(<span class="dt">void</span>) {</a>
<a class="sourceLine" id="cb5-22" title="22">  <span class="cf">return</span> (((<span class="dt">float</span>)(temperature_cpy)) * ((<span class="fl">150.0</span>) / (<span class="fl">255.0</span>))) - (<span class="fl">50.0</span>);</a>
<a class="sourceLine" id="cb5-23" title="23">}</a>
<a class="sourceLine" id="cb5-24" title="24"></a>
<a class="sourceLine" id="cb5-25" title="25"><span class="dt">void</span> step(<span class="dt">void</span>) {</a>
<a class="sourceLine" id="cb5-26" title="26">  (temperature_cpy) = (temperature);</a>
<a class="sourceLine" id="cb5-27" title="27">  <span class="cf">if</span> ((heatoff_guard)()) {</a>
<a class="sourceLine" id="cb5-28" title="28">    (heatoff)(((heatoff_arg0)()));</a>
<a class="sourceLine" id="cb5-29" title="29">  };</a>
<a class="sourceLine" id="cb5-30" title="30">  <span class="cf">if</span> ((heaton_guard)()) {</a>
<a class="sourceLine" id="cb5-31" title="31">    (heaton)(((heaton_arg0)()));</a>
<a class="sourceLine" id="cb5-32" title="32">  };</a>
<a class="sourceLine" id="cb5-33" title="33">}</a></code></pre></div>
<p>先ほど<code>Stream</code>として定義した値のうち、<code>temp</code>は、<code>temperature</code>というグローバル変数と、それを一時的に保存する<code>temperature_cpy</code>という二つの変数に翻訳されました。<br />
<code>spec</code>において<code>trigger</code>という関数で列挙した「どのセンサーから信号を受け取って、どんな条件を満たした場合にどの処理を実行するか」というルールは、<code>step</code>という関数に現れたようです。<br />
この関数を利用する側では、<code>heaton</code>関数と<code>heatoff</code>関数を別途定義した上で、<code>temperature</code>にセンサーから受け取った値を代入して<code>step</code>を呼ぶことによって、<code>temperature</code>の値が条件に一致したとき、<code>heaton</code>関数と<code>heatoff</code>関数を実行してハードウェアの制御ができるのでしょう。<br />
<span class="ascii">Haskell</span>側で定義したもう一つの<code>Stream</code>、<code>ctemp</code>は、<code>heaton_guard</code>、<code>heaton_arg0</code>、<code>heatoff_guard</code>、<code>heatoff_arg0</code>、それぞれの関数に書かれた、<code>temperature_cpy</code>の値を変換する式に現れているようです。</p>
<p>正直なところこの程度であれば、直接<span class="ascii">C</span>で書いた方が余計なカッコもないし読みやすそうではあります。<br />
<code>temp</code>を<code>ctemp</code>に変換する式<code>(150.0 / 255.0) - 50.0</code>が変換後のソースコードでは冗長に適用されていることから、もっと最適化できそうですし。<br />
とはいえ、わざわざ<span class="ascii">DSL</span>を作ったからには、より複雑で、<span class="ascii">Haskell</span>でなければ書いてられないようなケースが、<span class="ascii">Copilot</span>の開発者の現場ではあるのでしょう<small>（なんせ<span class="ascii">NASA</span>の方も関わっているぐらいですから！）</small>。<br />
詳しいユースケースや、ビルド時のフローといった運用方法を聞きたいところですね。</p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/haskell-day-2019.html" lang="ja">Haskell Day 2019を開催しました！</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/haskell-symposium.html" style="margin-left: auto;" lang="ja">Haskell Symposium 2019 レポート</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>

</feed>
