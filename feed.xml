<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Haskell-jp Blog</title>
    <link href="https://haskell.jp/blog/feed.xml" rel="self" />
    <link href="https://haskell.jp/blog" />
    <id>https://haskell.jp/blog/feed.xml</id>
    <author>
        <name>Haskell-jp</name>
        <email></email>
    </author>
    <updated>2019-12-22T00:00:00Z</updated>
    <entry>
    <title>日本語をshowしてうまく表示されなかったら</title>
    <link href="https://haskell.jp/blog/posts/2019/unicode-show.html" />
    <id>https://haskell.jp/blog/posts/2019/unicode-show.html</id>
    <published>2019-12-22T00:00:00Z</published>
    <updated>2019-12-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#ℹ️この記事は" title="ℹ️この記事は">ℹ️この記事は🎄</a></li>
<li><a href="#日本語などの話者がhaskellを始めるとあるある" title="日本語などの話者がhaskellを始めるとあるある">日本語（などの）話者が<span class="ascii">Haskell</span>を始めるとあるある</a></li>
<li><a href="#unicode-showを使おう" title="unicode-showを使おう">🌐<span class="ascii">unicode-show</span>を使おう</a></li>
<li><a href="#unicode-showの最近の修正" title="unicode-showの最近の修正"><span class="ascii">unicode-show</span>の最近の修正</a></li>
<li><a href="#番外編pretty-simpleも使おう" title="番外編pretty-simpleも使おう">（番外編）<span class="ascii">pretty-simple</span>も使おう</a></li>
</ul>
</div>
</div>
<h1 id="ℹ️この記事は"><span class="link-to-here-outer"><a href="#ℹ️この記事は" title="ℹ️この記事は"><span class="link-to-here">Link to<br />
here</span></a></span>ℹ️この記事は🎄</h1>
<p>この記事は、<a href="https://qiita.com/advent-calendar/2019/haskell"><span class="ascii">Haskell Advent Calendar 2019</span></a> <span class="ascii">22</span>日目の記事です。<br />
例年どおりタイプセーフプリキュア！の話をするつもりでしたが、ネタが実装できなかったので<a href="http://hackage.haskell.org/package/unicode-show"><span class="ascii">unicode-show</span></a>の話をします<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>。<br />
まぁ、こちらの方がみなさんにとっては有益でしょうし🙃</p>
<h1 id="日本語などの話者がhaskellを始めるとあるある"><span class="link-to-here-outer"><a href="#日本語などの話者がhaskellを始めるとあるある" title="日本語などの話者がhaskellを始めるとあるある"><span class="link-to-here">Link to<br />
here</span></a></span>日本語（などの）話者が<span class="ascii">Haskell</span>を始めるとあるある</h1>
<p><span class="ascii">GHCi</span>に日本語を入力したり…</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1">ghci<span class="op">&gt;</span> <span class="st">&quot;みんなで幸せゲットだよ！&quot;</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="st">&quot;\12415\12435\12394\12391\24184\12379\12466\12483\12488\12384\12424\65281&quot;</span></a></code></pre></div>
<p>日本語を<code>print</code>したり…</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1">ghci<span class="op">&gt;</span> <span class="fu">print</span> <span class="st">&quot;私、堪忍袋の緒が切れました！&quot;</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="st">&quot;\31169\12289\22570\24525\34955\12398\32210\12364\20999\12428\12414\12375\12383\65281&quot;</span></a></code></pre></div>
<p>日本語を<code>show</code>したり…</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1">ghci<span class="op">&gt;</span> iimashita x <span class="ot">=</span> <span class="st">&quot;今、&quot;</span> <span class="op">++</span> <span class="fu">show</span> x <span class="op">++</span> <span class="st">&quot;って言いました！？&quot;</span></a>
<a class="sourceLine" id="cb3-2" title="2">ghci<span class="op">&gt;</span> <span class="fu">putStrLn</span> (iimashita <span class="st">&quot;ハスケル&quot;</span>)</a>
<a class="sourceLine" id="cb3-3" title="3">今、<span class="st">&quot;\12495\12473\12465\12523&quot;</span>って言いました！？</a></code></pre></div>
<p>すると、日本語の大半が変な文字列に変わってしまいました😥。</p>
<p>へ… 変な文字列じゃないし！エスケープシーケンスに変換しただけだから！</p>
<p>これは、<span class="ascii">Haskell</span>標準における<code>show</code>関数の残念な仕様です。<br />
<code>show</code>関数に文字列を渡すと、ダブルクォートで囲った上で、<span class="ascii">ASCII</span>範囲外の文字列や、<span class="ascii">ASCII</span>の非表示文字などをエスケープシーケンスに変換して返します。<br />
これは、<code>show</code>関数をデバッグで使用した際、指定した文字列にどんな文字が含まれているか、簡単にわかるようにするための仕様です。<br />
文字の文字コードを表示すれば、<span class="ascii">NULL</span>文字や制御文字、ゼロ幅文字、特殊なスペースなど、視認しにくいおかしな文字が含まれていても、一目でわかるのです。</p>
<p>しかしこれは日本語話者である我々にとって、少なくとも日本語の文字に関しては「余計なお世話」です。<br />
<span class="ascii">NULL</span>文字や<span class="ascii">ASCII</span>の制御文字といった本来画面に表示することがない文字列ならともかく、<span class="ascii">ASCII</span>範囲外の文字列すべてをエスケープしてしまうのはやり過ぎでしょう。<br />
現代は<span class="ascii">Unicode</span>があるおかげで、日本語に限らずとも<span class="ascii">ASCII</span>範囲外の文字を扱うのは当たり前になりましたから。</p>
<h1 id="unicode-showを使おう"><span class="link-to-here-outer"><a href="#unicode-showを使おう" title="unicode-showを使おう"><span class="link-to-here">Link to<br />
here</span></a></span>🌐<span class="ascii">unicode-show</span>を使おう</h1>
<p>そこで便利なのが<a href="http://hackage.haskell.org/package/unicode-show"><span class="ascii">unicode-show</span></a>です。<br />
<span class="ascii">unicode-show</span>の<code>ushow</code>関数は、<code>show</code>がエスケープシーケンスに変換した日本語などの文字列を、元の文字列に戻してくれます。<br />
なので、新しい型クラスを定義する必要もなく、そのまま<code>Show</code>型クラスのインスタンスを再利用できるのです。</p>
<p>早速先ほどの<code>show</code>を使った例に適用してみましょう。</p>
<p>まずは👇のコマンドでインストールして、<span class="ascii">GHCi</span>を起動します。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" title="1"><span class="ex">stack</span> build unicode-show</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="ex">stack</span> exec ghci</a>
<a class="sourceLine" id="cb4-3" title="3"></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="co"># あるいは、最近のcabalを使っている場合は...</span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="ex">cabal</span> v2-install --lib unicode-show</a>
<a class="sourceLine" id="cb4-6" title="6"><span class="ex">cabal</span> v2-repl -b unicode-show</a></code></pre></div>
<p><code>Text.Show.Unicode</code>モジュールを<code>import</code>して<code>show</code>を使っている箇所を<code>ushow</code>に変えれば、お望みどおりの挙動になります。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1">ghci<span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">Text.Show.Unicode</span></a>
<a class="sourceLine" id="cb5-2" title="2">ghci<span class="op">&gt;</span> iimashita x <span class="ot">=</span> <span class="st">&quot;今、&quot;</span> <span class="op">++</span> ushow x <span class="op">++</span> <span class="st">&quot;って言いました！？&quot;</span></a>
<a class="sourceLine" id="cb5-3" title="3">ghci<span class="op">&gt;</span> <span class="fu">putStrLn</span> (iimashita <span class="st">&quot;ハスケル&quot;</span>)</a>
<a class="sourceLine" id="cb5-4" title="4">今、<span class="st">&quot;ハスケル&quot;</span>って言いました！？</a></code></pre></div>
<p>わくわくもんですね！</p>
<p><code>print</code>の例も、<code>uprint</code>に変えれば🆗です。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1">ghci<span class="op">&gt;</span> uprint <span class="st">&quot;私、堪忍袋の緒が切れました！&quot;</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="st">&quot;私、堪忍袋の緒が切れました！&quot;</span></a></code></pre></div>
<p>ウルトラハッピーですね！！</p>
<p>さらに、次のコマンドを<span class="ascii">GHCi</span>に入力すれば、<span class="ascii">GHCi</span>に直接入力した日本語文字列もそのまま表示されるようになります。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1">ghci<span class="op">&gt;</span> <span class="op">:</span>set <span class="op">-</span>interactive<span class="op">-</span><span class="fu">print</span><span class="ot">=</span>uprint</a>
<a class="sourceLine" id="cb7-2" title="2">ghci<span class="op">&gt;</span> <span class="st">&quot;みんなで幸せゲットだよ！&quot;</span></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="st">&quot;みんなで幸せゲットだよ！&quot;</span></a></code></pre></div>
<p>カンペキ✨</p>
<p>えっ、常に<code>uprint</code>したいからいちいち<code>:set -interactive-print=uprint</code>するのが面倒くさい？<br />
そんなあなたは👇を<code>~/.ghci</code>に書くことけって～いでしょう。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Show.Unicode</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="op">:</span>set <span class="op">-</span>interactive<span class="op">-</span><span class="fu">print</span><span class="ot">=</span>Text.Show.Unicode.uprint</a></code></pre></div>
<h1 id="unicode-showの最近の修正"><span class="link-to-here-outer"><a href="#unicode-showの最近の修正" title="unicode-showの最近の修正"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">unicode-show</span>の最近の修正</h1>
<p>そんな<span class="ascii">unicode-show</span>ですが、残念ながら一昨年、作者である村主崇行さんが亡くなってしまいました<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>。<br />
日本に住む<span class="ascii">Haskeller</span>をサポートする日本<span class="ascii">Haskell</span>ユーザーグループとしては、このパッケージをメンテナンスし続けることに大きな意義があると判断し、私はこのパッケージを<a href="https://github.com/haskell-jp/"><span class="ascii">Haskell-jp</span></a>の<span class="ascii">GitHub</span>リポジトリーでメンテナンスすることにしました。<br />
以下がそのリポジトリーです。</p>
<p><a href="https://github.com/haskell-jp/unicode-show" class="uri"><span class="ascii">https://github.com/haskell-jp/unicode-show</span></a></p>
<p>といっても、メンテナーの名前や<code>LICENSE</code>ファイルを書き換えて最新版をアップロードして以降特に何もしていなかったのですが<small>（<a href="https://github.com/nushio3/unicode-show/issues/2">バグはあるけど直すのも難しそう</a>だし、概ね使えるし）</small>、なんと先日、<span class="ascii">Pull request</span>が来ました！</p>
<p><a href="https://github.com/haskell-jp/unicode-show/pull/4"><span class="ascii">Do not show values eagerly by Kaiepi · Pull Request #4 · haskell-jp/unicode-show</span></a></p>
<p>この修正を適用する前の<span class="ascii">unicode-show</span>は、文字列全体を評価してからエスケープシーケンスを元に戻す、という挙動だったため、長い文字列を与えた場合や無限の長さの文字列を与えた場合に、なかなか<small>（あるいは永遠に）</small>結果が返ってこないという問題がありました。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1">ghci<span class="op">&gt;</span> uprint (<span class="fu">repeat</span> <span class="st">&quot;ああああ！&quot;</span>)</a>
<a class="sourceLine" id="cb9-2" title="2"><span class="co">-- 何も表示されず、Ctrl + C を押すまで処理が返らない</span></a></code></pre></div>
<p>修正後はちゃんと遅延評価を利用することで、無限の長さの文字列でも少しずつ変換することができます。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1">ghci<span class="op">&gt;</span> uprint (<span class="fu">repeat</span> <span class="st">&quot;ああああ！&quot;</span>)</a>
<a class="sourceLine" id="cb10-2" title="2">[<span class="st">&quot;ああああ！&quot;</span>,<span class="st">&quot;ああああ！&quot;</span>, <span class="op">...</span> <span class="st">&quot;ああああ！&quot;</span>,<span class="st">&quot;ああInterrupted.</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="st">-- Ctrl + Cを押すまで出力し続ける</span></a></code></pre></div>
<p>今日記事にした一番の理由はこの話をするためです。<br />
<a href="https://github.com/Kaiepi"><span class="ascii">Kaiepi</span></a>さんありがとうございます！<br />
先ほどリリースしました！🎉</p>
<p><a href="http://hackage.haskell.org/package/unicode-show-0.1.0.4" class="uri"><span class="ascii">http://hackage.haskell.org/package/unicode-show-0.1.0.4</span></a></p>
<h1 id="番外編pretty-simpleも使おう"><span class="link-to-here-outer"><a href="#番外編pretty-simpleも使おう" title="番外編pretty-simpleも使おう"><span class="link-to-here">Link to<br />
here</span></a></span>（番外編）<span class="ascii">pretty-simple</span>も使おう</h1>
<p>時間がないので詳しくは省略しますが、実は<a href="http://hackage.haskell.org/package/pretty-simple"><span class="ascii">pretty-simple</span></a>というパッケージを使えば、日本語をそのまま出力するのに加えて、プリティープリントできます。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1">ghci<span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">Text.Pretty.Simple</span></a>
<a class="sourceLine" id="cb11-2" title="2">ghci<span class="op">&gt;</span> pPrint [<span class="st">&quot;きーらーめーくー♪&quot;</span>, <span class="st">&quot;ほーしーの力でー♪&quot;</span>, <span class="st">&quot;あこがーれのー♪&quot;</span>, <span class="st">&quot;わーたーし描くよー♪&quot;</span>]</a>
<a class="sourceLine" id="cb11-3" title="3">[ <span class="st">&quot;きーらーめーくー♪&quot;</span></a>
<a class="sourceLine" id="cb11-4" title="4">, <span class="st">&quot;ほーしーの力でー♪&quot;</span></a>
<a class="sourceLine" id="cb11-5" title="5">, <span class="st">&quot;あこがーれのー♪&quot;</span></a>
<a class="sourceLine" id="cb11-6" title="6">, <span class="st">&quot;わーたーし描くよー♪&quot;</span></a>
<a class="sourceLine" id="cb11-7" title="7">]</a></code></pre></div>
<p>例ではわかりづらいですが、ちゃんと色も着けてくれます！<br />
それでは<span class="ascii">2020</span>年も、<span class="ascii">Happy Haskell Hacking</span>🎁</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>例年どおりですとプリキュア<span class="ascii">Advent Calendar</span>と同時投稿をしている予定でしたが、例年参加者が減っていたこともあり、今年はプリキュア<span class="ascii">Advent Calendar</span>はなくなってしまいました😞<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>村主崇行さんは「<a href="https://shop.ohmsha.co.jp/shopdetail/000000001926/">すごい<span class="ascii">Haskell</span>たのしく学ぼう！</a>」の翻訳を担当されるなど、<span class="ascii">unicode-show</span>以外にも日本の<span class="ascii">Haskell</span>界に多大な功績をもたらした方でした。<a href="#fnref2" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/haskell-in-vrchat.html" style="margin-left: auto;" lang="ja">VRのためにHaskellを使った話</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>VRのためにHaskellを使った話</title>
    <link href="https://haskell.jp/blog/posts/2019/haskell-in-vrchat.html" />
    <id>https://haskell.jp/blog/posts/2019/haskell-in-vrchat.html</id>
    <published>2019-12-03T00:00:00Z</published>
    <updated>2019-12-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#はじめに" title="はじめに">はじめに</a></li>
<li><a href="#vr空間でltがしたい" title="vr空間でltがしたい"><span class="ascii">VR</span>空間で<span class="ascii">LT</span>がしたい</a></li>
<li><a href="#webフレームワーク" title="webフレームワーク"><span class="ascii">Web</span>フレームワーク</a></li>
<li><a href="#はじめてのhaskellペアプロ" title="はじめてのhaskellペアプロ">はじめての<span class="ascii">Haskell</span>ペアプロ</a></li>
<li><a href="#デプロイ" title="デプロイ">デプロイ</a></li>
<li><a href="#実際に開催してみて" title="実際に開催してみて">実際に開催してみて</a></li>
<li><a href="#リポジトリ" title="リポジトリ">リポジトリ</a></li>
</ul>
</div>
</div>
<h1 id="はじめに"><span class="link-to-here-outer"><a href="#はじめに" title="はじめに"><span class="link-to-here">Link to<br />
here</span></a></span>はじめに</h1>
<p>はじめまして。趣味で<span class="ascii">Haskell</span>しているはる<span class="ascii">(haru2036)</span>と申します。まったり進行で開発しているので<span class="ascii">GHC</span>のバージョンアップの速さについていけてない感があります…… さて、今回はあんまり深い話はありません。どちらかと言うとこんなニッチなところに<span class="ascii">Haskell</span>使ったよというネタで書きます。</p>
<h1 id="vr空間でltがしたい"><span class="link-to-here-outer"><a href="#vr空間でltがしたい" title="vr空間でltがしたい"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">VR</span>空間で<span class="ascii">LT</span>がしたい</h1>
<p>突然ですが、私は<a href="https://vrchat.com/"><span class="ascii">VRChat</span></a>（以下<span class="ascii">VRC</span>）というソーシャル<span class="ascii">VR</span>サービス（<span class="ascii">Second Life</span>の<span class="ascii">VR</span>版みたいなものです）にハマっています。<br />
友人との雑談の中で<span class="ascii">VRC</span>の中で<span class="ascii">LT</span>会ができればプログラミングなどの話題で盛り上がれる人が集まってワイワイ楽しくできるのではないかと話して、その場のノリでとりあえず実装してみることにしました。</p>
<figure>
<img src="/img/2019/haskell-in-vrchat/vrc-lt-room.png" title="完成したワールド" alt="完成したワールド" /><figcaption>完成したワールド</figcaption>
</figure>
<p>今回作りたかったのはスライドを表示するためのスクリーンと、ページ送りに使うボタンを実装したワールドです。</p>
<figure>
<img src="/img/2019/haskell-in-vrchat/vrc-lt-control-panel.png" title="発表者用コントロールパネル" alt="発表者用コントロールパネル" /><figcaption>発表者用コントロールパネル</figcaption>
</figure>
<p><span class="ascii">VRC</span>ではアバターやワールドを自由に作ることができるのですが、<span class="ascii">VRC</span>が提供するコンポーネント以外のスクリプトは利用できません。<span class="ascii">Haskell</span>ユーザとしては得意なことを活用しづらい土壌です。<br />
幸いスライドを表示する手段はゲーム内で<span class="ascii">URL</span>から画像を取得し表示する<span class="ascii">VRC_Panorama</span>というコンポーネントを利用することにより確保できましたが、<span class="ascii">VRC_Panorama</span>が取得できる画像はワールド作成時に決め打ちで指定された<span class="ascii">URL</span>のリストに含まれるもののみです。<br />
そのため、スライド画像への<span class="ascii">URL</span>のリストを直接<span class="ascii">VRC_Panorama</span>に渡していると、イベントを開催する際よくある飛び入り参加やスライドの用意が遅れた参加者に対応できなくなってしまいます。</p>
<p>その問題を解決するために、イベント開始時からのページ数とスライドの画像<span class="ascii">URL</span>をマップする<span class="ascii">WebAPI</span>を用意しました。<br />
具体的には、<code>/slides/{pageCount}</code> のような形のエンドポイントを持った<span class="ascii">API</span>を用意し、そこから実際の画像へリダイレクトをかけるという方法を取りました。</p>
<figure>
<img src="/img/2019/haskell-in-vrchat/vrc-lt-image.png" title="実装イメージ図" alt="実装イメージ図" /><figcaption>実装イメージ図</figcaption>
</figure>
<h1 id="webフレームワーク"><span class="link-to-here-outer"><a href="#webフレームワーク" title="webフレームワーク"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Web</span>フレームワーク</h1>
<p>今回は自分で使うだけだしということでさらっとやってみたかったので<span class="ascii">Spock</span>を利用しました。もう少し誰でも使えるサービスにしたいと考えているので<span class="ascii">Servant</span>に載せ替えてかっちり作り直そうかと思い移植しているところです。</p>
<h1 id="はじめてのhaskellペアプロ"><span class="link-to-here-outer"><a href="#はじめてのhaskellペアプロ" title="はじめてのhaskellペアプロ"><span class="link-to-here">Link to<br />
here</span></a></span>はじめての<span class="ascii">Haskell</span>ペアプロ</h1>
<p>じつは<span class="ascii">LT</span>会をやろうと思いついた友人の<a href="https://twitter.com/b0xp2"><span class="ascii">BOXP</span></a>は<span class="ascii">Clojure</span>ユーザで、せっかくだからと<span class="ascii">API</span>の開発を手伝ってくれました。<br />
あまり<span class="ascii">Haskell</span>に馴染みはなかったものの、いわゆる関数型プログラミング的な概念はバッチリなのでスススっと書いてくれました。<br />
書いてくれる上での障壁になったのは、型関連の要素<span class="ascii">(</span><code>data</code>や<code>type</code>や<code>newtype</code>がぱっと見わからなかった、型コンストラクタ、値コンストラクタの概念）に馴染みが薄かったことでした。<br />
<span class="ascii">Discord</span>で画面共有しながら説明を行ったのですが、やはり同じ画面を見ながら説明するのはとてもやりやすいと感じました。<br />
本人からのメッセージはこちら。</p>
<blockquote>
<p>プログラミング<span class="ascii">Haskell</span>を昔読んでかじったことがある程度で素人もいいところでしたが、当人のサポートもあり思いついた数日後には実装が終わっていました。 はるくんの話にもある通り<span class="ascii">Discord</span>で画面共有しながらペアプロし、<span class="ascii">Haskell</span>でのテストコードの書き方も一から教えてもらいながら書きました。これは願ってもない体験だったので根気よく教えてくれたことに非常に感謝しています。</p>
<p>また、個人的には実装以外でのブレストや実際の会場でのデバッグを<span class="ascii">VRChat</span>上でできた事もとてもよかったなと思っています。 単純に実装を確認するためには二人以上で<span class="ascii">VRChat</span>に入る必要があるというのもありましたが、完全リモートでも身振り手振りありでブレストができたことや、アバターのおかげで環境に囚われないコミュニケーションができていたことも<span class="ascii">Good</span>でした。</p>
</blockquote>
<h1 id="デプロイ"><span class="link-to-here-outer"><a href="#デプロイ" title="デプロイ"><span class="link-to-here">Link to<br />
here</span></a></span>デプロイ</h1>
<p>今回は自分で使うだけな上に常時稼働している必要もなく、コストを最小限に抑えたかったので<span class="ascii">Heroku</span>にデプロイしました。<br />
<span class="ascii">Dockerfile</span>を書き、スタティックリンク周りで悩みながらもイメージを生成して<span class="ascii">Heroku</span>のレジストリに<span class="ascii">Push</span>し、後はいつもの<span class="ascii">Heroku</span>という感じでうまくいきました。</p>
<p>余談ですが、最近参加した<span class="ascii">Gotanda.hs</span>というイベントで<code>cabal build --enable-executable-static</code>でいい感じにシングルバイナリが生成できるというお話を聞いたので、最近<span class="ascii">stack</span>ばっかり使ってたのを改めて適材適所で使い分けていきたいなーと思っています。</p>
<h1 id="実際に開催してみて"><span class="link-to-here-outer"><a href="#実際に開催してみて" title="実際に開催してみて"><span class="link-to-here">Link to<br />
here</span></a></span>実際に開催してみて</h1>
<p>ここは<span class="ascii">Haskell</span>ほぼ全く関係ないですが……</p>
<p><img src="/img/2019/haskell-in-vrchat/vrc-lt.png" /> <span class="ascii">VRC-LT</span>という名前で<span class="ascii">6</span>回ほど開催しているのですが、場所の制約を受けずに勉強会ができ、その後の懇親会も会場の撤収時刻や終電を気にせず話したい人はとことん話し続ける事ができるというところが非常に良かったです。<br />
ホワイトボードはまだ未実装ですが、空間に書けるペンも配布されているのでその手のアイテムも取り入れれば懇親会での話も更にはずむのではないでしょうか。</p>
<p><span class="ascii">VRChat</span>は<span class="ascii">PC</span>のみでも利用することができます。 <span class="ascii">VRC-LT</span>はほぼ月イチペースで不定期開催ですので、もしよろしければ参加していただけると嬉しいです。 開催時のアーカイブ等も以下の<span class="ascii">Web</span>サイトにて公開中です。合わせてご覧ください。 <a href="https://vrc-lt.github.io"><span class="ascii">https://vrc-lt.github.io</span></a></p>
<h1 id="リポジトリ"><span class="link-to-here-outer"><a href="#リポジトリ" title="リポジトリ"><span class="link-to-here">Link to<br />
here</span></a></span>リポジトリ</h1>
<p>そんなこんなで開発中のリポジトリはこちらになります。<br />
拙いところもいっぱいですが<span class="ascii">Issue</span>や<span class="ascii">PR</span>などで気になった点を教えていただければ幸いです！<br />
<a href="https://github.com/vrc-lt/VRC-Slide-Server"><span class="ascii">https://github.com/vrc-lt/VRC-Slide-Server</span></a></p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/unicode-show.html" lang="ja">日本語をshowしてうまく表示されなかったら</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/haskell-day-2019.html" style="margin-left: auto;" lang="ja">Haskell Day 2019を開催しました！</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>Haskell Day 2019を開催しました！</title>
    <link href="https://haskell.jp/blog/posts/2019/haskell-day-2019.html" />
    <id>https://haskell.jp/blog/posts/2019/haskell-day-2019.html</id>
    <published>2019-11-29T00:00:00Z</published>
    <updated>2019-11-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <p>先日<span class="ascii">2019</span>年<span class="ascii">11</span>月<span class="ascii">9</span>日、<a href="https://techplay.jp/space"><span class="ascii">TECH PLAY SHIBUYA</span></a>にて<a href="https://techplay.jp/event/727059"><span class="ascii">Haskell Day 2019</span></a>を開催しました。<br />
今回は、各発表の概要や、アンケートの結果をお伝えしたいと思います。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#発表" title="発表">発表</a>
<ul>
<li><a href="#関数型function-typeを見つめるプログラミング" title="関数型function-typeを見つめるプログラミング">関数型<span class="ascii">(function type)</span>を見つめるプログラミング</a></li>
<li><a href="#hkdhigher-kinded-datatype" title="hkdhigher-kinded-datatype"><span class="ascii">HKD(Higher Kinded Datatype)</span></a></li>
<li><a href="#しんさんきぼうのderivingストラテジー" title="しんさんきぼうのderivingストラテジー">「しんさんきぼう」の<span class="ascii">Deriving</span>ストラテジー</a></li>
<li><a href="#haskellメタプログラミングによるegisonのパターンマッチの実装" title="haskellメタプログラミングによるegisonのパターンマッチの実装"><span class="ascii">Haskell</span>メタプログラミングによる<span class="ascii">Egison</span>のパターンマッチの実装</a></li>
<li><a href="#関数と型で理解する自動微分" title="関数と型で理解する自動微分">関数と型で理解する自動微分</a></li>
<li><a href="#ghcjs-によるwebフロントエンド開発" title="ghcjs-によるwebフロントエンド開発"><span class="ascii">GHCJS</span> による<span class="ascii">Web</span>フロントエンド開発</a></li>
<li><a href="#haskellで作る競技型イベントの裏側" title="haskellで作る競技型イベントの裏側"><span class="ascii">Haskell</span>で作る競技型イベントの裏側</a></li>
<li><a href="#大規模数値計算を支える-haskell-pragmatic-haskell-in-large-scale-numerical-computation" title="大規模数値計算を支える-haskell-pragmatic-haskell-in-large-scale-numerical-computation">大規模数値計算を支える <span class="ascii">Haskell</span> ── <span class="ascii">Pragmatic Haskell in Large-Scale Numerical Computation</span>──</a></li>
<li><a href="#cadenza-building-fast-functional-languages-on-the-jvm" title="cadenza-building-fast-functional-languages-on-the-jvm"><span class="ascii">Cadenza: Building fast functional languages on the JVM</span></a></li>
<li><a href="#lt" title="lt"><span class="ascii">LT</span></a></li>
</ul></li>
<li><a href="#アンケート結果" title="アンケート結果">アンケート結果</a>
<ul>
<li><a href="#haskell-以外のプログラミングに関する質問" title="haskell-以外のプログラミングに関する質問"><span class="ascii">Haskell</span> 以外のプログラミングに関する質問</a>
<ul>
<li><a href="#エンジニアの経験年数はどれくらいですか" title="エンジニアの経験年数はどれくらいですか">エンジニアの経験年数はどれくらいですか？</a></li>
<li><a href="#得意なプログラミング言語はなんですか" title="得意なプログラミング言語はなんですか">得意なプログラミング言語はなんですか？</a></li>
<li><a href="#得意好きな技術領域はどれですか" title="得意好きな技術領域はどれですか">得意・好きな技術領域はどれですか？</a></li>
<li><a href="#最近注目している技術があれば記述してください" title="最近注目している技術があれば記述してください">最近注目している技術があれば記述してください</a></li>
</ul></li>
<li><a href="#haskell-に関する質問" title="haskell-に関する質問"><span class="ascii">Haskell</span> に関する質問</a>
<ul>
<li><a href="#haskell-をいつ頃始めましたか" title="haskell-をいつ頃始めましたか"><span class="ascii">Haskell</span> をいつ頃始めましたか？</a></li>
<li><a href="#haskell-を初めてどれくらい経ちますか" title="haskell-を初めてどれくらい経ちますか"><span class="ascii">Haskell</span> を初めてどれくらい経ちますか？</a></li>
<li><a href="#読んだことのある日本語の-haskell-本は" title="読んだことのある日本語の-haskell-本は">読んだことのある日本語の <span class="ascii">Haskell</span> 本は？</a></li>
</ul></li>
</ul></li>
<li><a href="#おわりに" title="おわりに">おわりに</a></li>
<li><a href="#あわせて読みたい" title="あわせて読みたい">あわせて読みたい</a></li>
</ul>
</div>
</div>
<h1 id="発表"><span class="link-to-here-outer"><a href="#発表" title="発表"><span class="link-to-here">Link to<br />
here</span></a></span>発表</h1>
<p>まずは各種発表の紹介から。</p>
<h2 id="関数型function-typeを見つめるプログラミング"><span class="link-to-here-outer"><a href="#関数型function-typeを見つめるプログラミング" title="関数型function-typeを見つめるプログラミング"><span class="link-to-here">Link to<br />
here</span></a></span>関数型<span class="ascii">(function type)</span>を見つめるプログラミング</h2>
<p>「関数型」 — すなわち<span class="ascii">Haskell</span>でいうところの<code>a -&gt; b</code>で表される、<span class="ascii">Haskell</span>の関数について、ちょっと見方を変えた新しい発見を教えてくれました。</p>
<p><a href="https://github.com/nobsun/hday2019/blob/master/doc/ftype.pdf">資料はこちら</a></p>
<p><img src="/img/2019/haskell-day-2019/nobsun.jpg" /></p>
<h2 id="hkdhigher-kinded-datatype"><span class="link-to-here-outer"><a href="#hkdhigher-kinded-datatype" title="hkdhigher-kinded-datatype"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">HKD(Higher Kinded Datatype)</span></h2>
<p><span class="ascii">Higher Kinded Datatype (HKD)</span>という、昨今<span class="ascii">Haskell</span>界で流行りの型定義方法を解説しています。<br />
レコード型を定義する際<span class="ascii">HKD</span>にすることで、より柔軟に扱うことができるようになります。<br />
さらに、<a href="http://hackage.haskell.org/package/barbies"><span class="ascii">barbies</span></a>や<a href="http://hackage.haskell.org/package/extensible"><span class="ascii">extensible</span></a>といった、<span class="ascii">HKD</span>の利用を飛躍的に促進するパッケージも紹介されました。</p>
<p><a href="https://assets.adobe.com/public/b93f214d-58c2-482f-5528-a939d3e83660">資料はこちら</a></p>
<p><img src="/img/2019/haskell-day-2019/fumieval.jpg" /></p>
<h2 id="しんさんきぼうのderivingストラテジー"><span class="link-to-here-outer"><a href="#しんさんきぼうのderivingストラテジー" title="しんさんきぼうのderivingストラテジー"><span class="link-to-here">Link to<br />
here</span></a></span>「しんさんきぼう」の<span class="ascii">Deriving</span>ストラテジー</h2>
<p><span class="ascii">Haskell</span>の<code>deriving</code>機能 — 型を定義したとき、型クラスのインスタンスまで自動で定義してくれるあの機能ですね — の、適用範囲を広げる<span class="ascii">GHC</span>の言語拡張をいろいろ紹介してくれました。</p>
<p><a href="https://aiya000.github.io/Maid/haskell-day-2019-deriving/#/">資料はこちら</a></p>
<p><img src="/img/2019/haskell-day-2019/aiya000.jpg" /></p>
<h2 id="haskellメタプログラミングによるegisonのパターンマッチの実装"><span class="link-to-here-outer"><a href="#haskellメタプログラミングによるegisonのパターンマッチの実装" title="haskellメタプログラミングによるegisonのパターンマッチの実装"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Haskell</span>メタプログラミングによる<span class="ascii">Egison</span>のパターンマッチの実装</h2>
<p>プログラミング言語<a href="https://www.egison.org/ja/"><span class="ascii">Egison</span></a>の核となる機能である強力なパターンマッチを、<span class="ascii">GHC</span>の各種拡張を駆使することで、<span class="ascii">Haskell</span>のソースコードに自然に埋め込めるような形で実装した、という話です。</p>
<p><a href="https://www.egison.org/download/20191109HaskellDay.pdf">資料はこちら</a></p>
<p><a href="https://github.com/egison/egison-haskell">紹介しているライブラリーのソースコードはこちら</a></p>
<p><img src="/img/2019/haskell-day-2019/egison.jpg" /></p>
<h2 id="関数と型で理解する自動微分"><span class="link-to-here-outer"><a href="#関数と型で理解する自動微分" title="関数と型で理解する自動微分"><span class="link-to-here">Link to<br />
here</span></a></span>関数と型で理解する自動微分</h2>
<p>関数の自動微分を行うパッケージ<a href="http://hackage.haskell.org/package/ad"><span class="ascii">ad</span></a>の仕組みを自力で実装してみることで解説してくれました。</p>
<p><a href="https://speakerdeck.com/lotz84/guan-shu-toxing-deli-jie-suruzi-dong-wei-fen">資料はこちら</a></p>
<p><img src="/img/2019/haskell-day-2019/lotz.jpg" /></p>
<h2 id="ghcjs-によるwebフロントエンド開発"><span class="link-to-here-outer"><a href="#ghcjs-によるwebフロントエンド開発" title="ghcjs-によるwebフロントエンド開発"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">GHCJS</span> による<span class="ascii">Web</span>フロントエンド開発</h2>
<p><a href="http://hackage.haskell.org/package/miso"><span class="ascii">miso</span></a>というおいしそうな名前のアプリケーションフレームワークと、<span class="ascii">Firebase</span>と連携する<span class="ascii">miso</span>のサンプルを、ライブコーディングを通して紹介してくれました。<br />
<span class="ascii">miso</span>を使えば、<span class="ascii">GHCJS</span>を使って<span class="ascii">Elm Architecture</span>風の設計に基づいてアプリケーションを作ったり、さらにそのコードを利用してサーバーサイドレンダリングをしたりできます。</p>
<p>ℹ️資料はまだ公開されていません！当日はライブコーディングが大半の時間を占めていたため、同等の解説を文章にして公開したいというチェシャ猫さんの意向によるものです。<br />
現在執筆中のためお待ちください。🙇</p>
<p><a href="https://github.com/y-taka-23/miso-firebase-tutorial">発表中に使用したソースコードはこちら</a></p>
<p><img src="/img/2019/haskell-day-2019/y_taka_23.jpg" /></p>
<h2 id="haskellで作る競技型イベントの裏側"><span class="link-to-here-outer"><a href="#haskellで作る競技型イベントの裏側" title="haskellで作る競技型イベントの裏側"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Haskell</span>で作る競技型イベントの裏側</h2>
<p>「<span class="ascii">mixi git challenge</span>」というイベントにおいてユーザーが投稿した解答を採点するサーバーを、<span class="ascii">Haskell</span>と<span class="ascii">Elm</span>で一から書き直した、という事例を発表してくれました。<br />
<a href="http://hackage.haskell.org/package/rio"><span class="ascii">rio</span></a>や<a href="http://hackage.haskell.org/package/servant"><span class="ascii">servant</span></a>といった著名なパッケージを使うだけでなく、足りないところを自力で補って新しいパッケージとして公開したり、さらに作成したアプリケーション自体を<span class="ascii">OSS</span>として公開したりすることで、大きな資産を残していただけました。</p>
<p><a href="https://www.slideshare.net/noob00/haskell-191796924">資料はこちら</a></p>
<p><a href="https://github.com/matsubara0507/git-plantation">紹介しているアプリケーションのソースコードはこちら</a></p>
<p><img src="/img/2019/haskell-day-2019/matsubara0507.jpg" /></p>
<h2 id="大規模数値計算を支える-haskell-pragmatic-haskell-in-large-scale-numerical-computation"><span class="link-to-here-outer"><a href="#大規模数値計算を支える-haskell-pragmatic-haskell-in-large-scale-numerical-computation" title="大規模数値計算を支える-haskell-pragmatic-haskell-in-large-scale-numerical-computation"><span class="link-to-here">Link to<br />
here</span></a></span>大規模数値計算を支える <span class="ascii">Haskell</span> ── <span class="ascii">Pragmatic Haskell in Large-Scale Numerical Computation</span>──</h2>
<p><a href="https://www.deepflow.co.jp/"><span class="ascii">DeepFlow</span>株式会社</a>における<span class="ascii">Haskell</span>の事例の紹介です。<br />
超高速で大規模な数値計算システムを、<span class="ascii">GHC</span>の多様な言語拡張を駆使して作っているそうです。<br />
<span class="ascii">Tagless Final</span>を活用することで知っているべき領域を区分して仕事を分けることに成功しているという点が印象的でした。</p>
<p><a href="https://speakerdeck.com/konn/da-gui-mo-shu-zhi-ji-suan-wozhi-eru-haskell-nil-nil-pragmatic-haskell-in-large-scale-numerical-computation-nil-nil">資料はこちら</a></p>
<p><img src="/img/2019/haskell-day-2019/mr_konn.jpg" /></p>
<h2 id="cadenza-building-fast-functional-languages-on-the-jvm"><span class="link-to-here-outer"><a href="#cadenza-building-fast-functional-languages-on-the-jvm" title="cadenza-building-fast-functional-languages-on-the-jvm"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Cadenza: Building fast functional languages on the JVM</span></h2>
<p><a href="https://ekmett.github.io/cadenza/cadenza/index.html"><span class="ascii">cadenza</span></a>という、<span class="ascii">Truffle</span>（<span class="ascii">GraalVM</span>に含まれている、高速なインタープリター作成フレームワーク）製の関数型言語の紹介です。<br />
<span class="ascii">Truffle</span>がもたらす強力な<span class="ascii">JIT</span>と「<span class="ascii">Normalization by Evaluation</span>」という技術を応用することで、型検査と実行時両方における高いスピードを得ることが狙いだそうです。 将来的には依存型言語における型チェックや、<span class="ascii">GHC</span>のランタイムの高速化に寄与したいとのことです。</p>
<p><a href="https://drive.google.com/file/d/1bwYO66xUKeHyR4YCNm_1C82JlDNQLUXv/view">資料はこちら</a></p>
<p><a href="https://github.com/ekmett/cadenza">紹介しているアプリケーションのソースコードはこちら</a></p>
<p><img src="/img/2019/haskell-day-2019/ekmett.jpg" /></p>
<h2 id="lt"><span class="link-to-here-outer"><a href="#lt" title="lt"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">LT</span></h2>
<p>今回は<span class="ascii">Hakell Day</span>史上初めての試みとして、<span class="ascii">Lightning Talk</span>を当日公募しました。<br />
残念ながら<span class="ascii">5</span>分間という短い制限時間に収められない発表が大半でしたので、ぜひ👇の資料を読んでみてください！</p>
<p><strong>順番が間違っていたら済みません！ご指摘を！</strong></p>
<ul>
<li><a href="https://docs.google.com/presentation/d/1TiDWz3zLUwEWgpzXfgVZFIib6JtYriB03TVgHsimJC0/edit#slide=id.gc6f73a04f_0_0"><span class="ascii">3D Model in Haskell - Haskell</span>で<span class="ascii">3D</span>モデルに触れる</a></li>
<li><a href="https://speakerdeck.com/cyclone_t/iot-cases-with-haskell"><span class="ascii">Haskell</span>で<span class="ascii">IoT</span>やってます</a></li>
<li><a href="https://www.slideshare.net/jabaraster/haskell-day-2019-lt-tomoyuki-kawano"><span class="ascii">Quora</span>で<span class="ascii">Haskell</span>への愛を語る</a></li>
<li><a href="https://gitpitch.com/coord-e/slide-type-class-impl"><span class="ascii">Haskell</span>で作ってわかる型クラス</a></li>
<li><a href="https://drive.google.com/file/d/1YGKjl8S-LlfuB8yrHnKSK5G5MGsP9xd3/view"><span class="ascii">Abstract Typeclasses - How To Design a Future-Proof Typeclass</span></a></li>
<li><a href="http://www.mew.org/~kazu/material/2019-gc.pdf"><span class="ascii">GHC</span>の<span class="ascii">GC</span></a></li>
</ul>
<h1 id="アンケート結果"><span class="link-to-here-outer"><a href="#アンケート結果" title="アンケート結果"><span class="link-to-here">Link to<br />
here</span></a></span>アンケート結果</h1>
<p><span class="ascii">Haskell Day</span> の各セッションや、参加者のバックグランドなどについてアンケートをとりました。 なので、後者の方の集計結果を載せたいと思います（前者はセッション発表者へのフィードバック）。</p>
<h2 id="haskell-以外のプログラミングに関する質問"><span class="link-to-here-outer"><a href="#haskell-以外のプログラミングに関する質問" title="haskell-以外のプログラミングに関する質問"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Haskell</span> 以外のプログラミングに関する質問</h2>
<p>大きく分けて <span class="ascii">Haskell</span> に関する質問とそうでない質問がありました。 まずは <span class="ascii">Haskell</span> 以外に関する質問の方を集計結果を紹介します。</p>
<h3 id="エンジニアの経験年数はどれくらいですか"><span class="link-to-here-outer"><a href="#エンジニアの経験年数はどれくらいですか" title="エンジニアの経験年数はどれくらいですか"><span class="link-to-here">Link to<br />
here</span></a></span>エンジニアの経験年数はどれくらいですか？</h3>
<p><img src="/img/2019/haskell-day-2019/question1.jpg" /></p>
<h3 id="得意なプログラミング言語はなんですか"><span class="link-to-here-outer"><a href="#得意なプログラミング言語はなんですか" title="得意なプログラミング言語はなんですか"><span class="link-to-here">Link to<br />
here</span></a></span>得意なプログラミング言語はなんですか？</h3>
<p>ちなみに、言語のリストは <a href="https://haskellweekly.news/survey/2019.html"><span class="ascii">Haskell Survey 2019</span></a> を参考にしました。</p>
<p><img src="/img/2019/haskell-day-2019/question2.jpg" /></p>
<h3 id="得意好きな技術領域はどれですか"><span class="link-to-here-outer"><a href="#得意好きな技術領域はどれですか" title="得意好きな技術領域はどれですか"><span class="link-to-here">Link to<br />
here</span></a></span>得意・好きな技術領域はどれですか？</h3>
<p><img src="/img/2019/haskell-day-2019/question3.jpg" /></p>
<h3 id="最近注目している技術があれば記述してください"><span class="link-to-here-outer"><a href="#最近注目している技術があれば記述してください" title="最近注目している技術があれば記述してください"><span class="link-to-here">Link to<br />
here</span></a></span>最近注目している技術があれば記述してください</h3>
<p>自由記述形式にしたところ、ほとんど重複が無かったので箇条書きにします。</p>
<ul>
<li><span class="ascii">FP</span></li>
<li>匿名暗号通貨<span class="ascii">(Monero,Zcash,Dash,Koto)</span></li>
<li><span class="ascii">Cardano ADA</span></li>
<li><span class="ascii">GraphQL</span></li>
<li><span class="ascii">extensible</span></li>
<li><span class="ascii">Enigma</span></li>
<li><span class="ascii">worker</span>ベースの非同期プログラミング</li>
<li>フロント界隈</li>
<li><span class="ascii">Next.js</span></li>
<li>自然言語処理</li>
<li>型レベルプログラミング</li>
<li>自動微分</li>
<li><span class="ascii">AWS</span>によるサーバーレスアーキテクチャでのフルスタック<span class="ascii">Web</span>アプリケーション開発</li>
<li><span class="ascii">Rust</span></li>
<li><span class="ascii">Kubernetes</span></li>
<li><span class="ascii">TLA+</span></li>
<li><span class="ascii">algebraic effects and handlers</span></li>
<li>深層学習コンパイラ</li>
<li><span class="ascii">AR</span></li>
<li>定理証明支援系</li>
</ul>
<h2 id="haskell-に関する質問"><span class="link-to-here-outer"><a href="#haskell-に関する質問" title="haskell-に関する質問"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Haskell</span> に関する質問</h2>
<p>ちなみに、<span class="ascii">Haskell</span> に関する質問は <span class="ascii">Haskell Day 2018</span> でもアンケートしました。</p>
<h3 id="haskell-をいつ頃始めましたか"><span class="link-to-here-outer"><a href="#haskell-をいつ頃始めましたか" title="haskell-をいつ頃始めましたか"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Haskell</span> をいつ頃始めましたか？</h3>
<p><img src="/img/2019/haskell-day-2019/question4.jpg" /></p>
<h3 id="haskell-を初めてどれくらい経ちますか"><span class="link-to-here-outer"><a href="#haskell-を初めてどれくらい経ちますか" title="haskell-を初めてどれくらい経ちますか"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Haskell</span> を初めてどれくらい経ちますか？</h3>
<p><img src="/img/2019/haskell-day-2019/question5.jpg" /></p>
<h3 id="読んだことのある日本語の-haskell-本は"><span class="link-to-here-outer"><a href="#読んだことのある日本語の-haskell-本は" title="読んだことのある日本語の-haskell-本は"><span class="link-to-here">Link to<br />
here</span></a></span>読んだことのある日本語の <span class="ascii">Haskell</span> 本は？</h3>
<p>参照<span class="ascii">:</span> <a href="https://wiki.haskell.jp/Links#書籍" class="uri"><span class="ascii">https://wiki.haskell.jp/Links#</span>書籍</a></p>
<p><img src="/img/2019/haskell-day-2019/question6.jpg" /></p>
<h1 id="おわりに"><span class="link-to-here-outer"><a href="#おわりに" title="おわりに"><span class="link-to-here">Link to<br />
here</span></a></span>おわりに</h1>
<p>以上の発表に加えて今回は、下記のスポンサー企業の皆様や<span class="ascii">@fumieval</span>くんのおかげで、大変満足度の高い懇親会ができました。</p>
<ul>
<li><a href="https://www.mvrck.co.jp/">マーベリック株式会社</a></li>
<li><a href="https://herp.co.jp/">株式会社<span class="ascii">HERP</span></a></li>
<li><a href="https://www.iij.ad.jp/">株式会社インターネットイニシアティブ</a></li>
<li><a href="https://www.cryptact.com/">株式会社クリプタクト</a></li>
</ul>
<figure>
<img src="/img/2019/haskell-day-2019/after-party.jpg" alt="懇親会で振る舞われた料理" /><figcaption>懇親会で振る舞われた料理</figcaption>
</figure>
<p>発表について。<br />
昨年は「<a href="https://haskell-jp.connpass.com/event/92617/"><span class="ascii">Haskell</span>ちょっと興味あるからちょっとできるまで</a>」というテーマを意識して、発表の難易度別に時間帯が分かれるよう調整しましたが、残念ながらうまくいきませんでした。<br />
そこで難易度調整の難しさを痛感したため、今回は敢えて難易度調整を行わなかったのです。<br />
結果、全体として難しい発表に偏ってしまった点は少し反省です。<a href="https://eng-blog.iij.ad.jp/archives/3467">私が会社で開いている<span class="ascii">Haskell</span>勉強会</a>に毎回参加いただいている同僚も、総じて難しくて追いつくのが大変だった、と仰ってました。<br />
次回は特別に難易度を下げた発表枠をいくつか作り、内容を事前に精査する、なんてプランを考えています。</p>
<p>会場について。<br />
<span class="ascii">TECHPLAY SHIBUYA</span>は素晴らしいですね！<br />
我々のようなお金がないコミュニティーが今回の規模のイベントを行うのにうってつけでした。<br />
元々イベントを開催する前提で作られており、受付と演壇が近いため受付しながら発表を聞くことができるのも、持ち回りで受付をしている我々にとって好都合でした。<br />
来年も是非使わせていただきたいです🙏</p>
<p>最後に。<br />
発表者のみなさんはもちろん、支えていただいたスタッフ、スポンサー企業、会場まで足を運んでいただいた参加者の皆様、その他この会の実現に関わったすべての方々に、この場を借りて感謝の意を示したいと思います。<br />
みなさんのご協力おかげで、大きなトラブルもなく、楽しいイベントが開催できました。ありがとうございます。<br />
今後も日本<span class="ascii">Haskell</span>ユーザーグループ（<span class="ascii">a.k.a. Haskell-jp</span>）をよろしくお願いします！<br />
<span class="ascii">hask(_ _)eller</span></p>
<h1 id="あわせて読みたい"><span class="link-to-here-outer"><a href="#あわせて読みたい" title="あわせて読みたい"><span class="link-to-here">Link to<br />
here</span></a></span>あわせて読みたい</h1>
<ul>
<li>参加者による参加レポート<span class="ascii">:</span>
<ul>
<li><a href="http://hiratara.hatenadiary.jp/entry/2019/11/09/110030">今日は <span class="ascii">Haskell Day 2019</span> の日です <span class="ascii">-</span> 北海道苫小牧市出身の初老<span class="ascii">PG</span>が書くブログ</a></li>
<li><a href="https://www.ncaq.net/2019/11/09/20/56/00/"><span class="ascii">Haskell Day 2019</span>に参加しました <span class="ascii">- ncaq</span></a></li>
<li><a href="https://matsubara0507.github.io/posts/2019-11-10-join-haskell-day-2019"><span class="ascii">Haskell Day 2019</span> に参加してきた</a></li>
</ul></li>
<li><a href="https://haskell.jp/blog/posts/2018/haskell-day-2018.html">去年の開催レポート</a></li>
</ul>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/haskell-in-vrchat.html" lang="ja">VRのためにHaskellを使った話</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/hiw-copilot.html" style="margin-left: auto;" lang="ja">HIW 2019で発表された、Copilotという内部DSLについて</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>HIW 2019で発表された、Copilotという内部DSLについて</title>
    <link href="https://haskell.jp/blog/posts/2019/hiw-copilot.html" />
    <id>https://haskell.jp/blog/posts/2019/hiw-copilot.html</id>
    <published>2019-10-01T00:00:00Z</published>
    <updated>2019-10-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p><a href="/posts/2019/hiw-gibbon.html">前回</a>から引き続き、<a href="https://icfp19.sigplan.org/home/hiw-2019#About"><span class="ascii">Haskell Implementors</span>’ <span class="ascii">Workshop 2019</span></a>への参加レポートとして、私の印象に残った発表を紹介します。<br />
今回は、<a href="https://copilot-language.github.io/"><span class="ascii">Copilot</span></a>という、<span class="ascii">C</span>言語のコードを生成する<span class="ascii">Haskell</span>製内部<span class="ascii">DSL</span>についての発表です。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#copilot-3.0-a-haskell-runtime-verification-framework-for-uavs" title="copilot-3.0-a-haskell-runtime-verification-framework-for-uavs"><span class="ascii">Copilot 3.0: a Haskell runtime verification framework for UAVs</span></a></li>
<li><a href="#copilotを試してみる" title="copilotを試してみる"><span class="ascii">Copilot</span>を試してみる</a></li>
</ul>
</div>
</div>
<h1 id="copilot-3.0-a-haskell-runtime-verification-framework-for-uavs"><span class="link-to-here-outer"><a href="#copilot-3.0-a-haskell-runtime-verification-framework-for-uavs" title="copilot-3.0-a-haskell-runtime-verification-framework-for-uavs"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Copilot 3.0: a Haskell runtime verification framework for UAVs</span></h1>
<p>発表者<span class="ascii">: Frank Dedden</span> <em><span class="ascii">Royal Netherlands Aerospace Center</span></em><span class="ascii">, Alwyn Goodloe</span> <em><span class="ascii">NASA Langley Research Center</span></em><span class="ascii">, Ivan Perez</span> <em><span class="ascii">NIA / NASA Formal Methods</span></em></p>
<p><span class="ascii">Haskell</span>製の内部<span class="ascii">DSL</span>から<span class="ascii">C</span>言語のソースコードを生成する、<a href="https://copilot-language.github.io/"><span class="ascii">Copilot</span></a>の紹介です。<br />
似た謳い文句の内部<span class="ascii">DSL</span>として<a href="http://hackage.haskell.org/package/ivory"><span class="ascii">ivory</span></a>がありますが、<span class="ascii">Copilot</span>は、ハードウェアの実行時検証を行う<span class="ascii">C</span>言語のコードを生成することに、より特化しています。<br />
「センサーから信号を受け取って、一定の条件を満たした場合に何らかの処理を実行する」という処理を<span class="ascii">Haskell</span>で宣言的に記述すると、メモリの消費量・実行時間において常に一定な<span class="ascii">C</span>言語のコードを生成することが出来ます。</p>
<p>メモリが限られていて、リアルタイムな処理が必要なハードウェアにとって「邪魔にならない監視」を実現するための必須条件なのでしょう。<br />
現状<span class="ascii">Haskell</span>は<span class="ascii">GC</span>が必要であるといった制約もあり、リアルタイムな処理や厳格なメモリー管理が必要な機器での採用は難しいですが、<span class="ascii">Ivory</span>や今回発表された<span class="ascii">Copilot</span>はあくまでも「<span class="ascii">C</span>言語のコードを生成するだけ」なので、生成する<span class="ascii">Haskell</span>ではメモリー管理をする必要がありません。<br />
にっくきスペースリークに悩まされる心配もないのです。<br />
こういった<span class="ascii">Haskell</span>製内部<span class="ascii">DSL</span>は、<span class="ascii">Haskell</span>の持つ強い型付けによるメリットを享受しながら、変換した言語の実行時におけるパフォーマンスを出しやすい、といういいとこ取りなメリットがあるので、もっと広まってほしいユースケースですね。</p>
<h1 id="copilotを試してみる"><span class="link-to-here-outer"><a href="#copilotを試してみる" title="copilotを試してみる"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Copilot</span>を試してみる</h1>
<ul>
<li>ℹ️ 実際に使用したコードは<a href="https://github.com/haskell-jp/blog/tree/master/examples/2019/hiw-copilot"><span class="ascii">Haskell-jp Blog</span>の<span class="ascii">GitHub</span>のリポジトリー</a>にあります。</li>
<li>ℹ️ 使用した<span class="ascii">copilot</span>パッケージのバージョンは、<span class="ascii">3.0.1</span>です。</li>
<li>ℹ️ サンプルコードの解説については、<span class="ascii">notogawa</span>さんのアドバイスも参考になりました<small>（<a href="https://haskell.jp/slack-log/html/C4M4TT8JJ/46.html#message-1554858057.072700"><span class="ascii">Haskell-jp</span>の<span class="ascii">slack-log</span>ではこのあたり</a>。執筆時点で<span class="ascii">CSS</span>が当たってないため読みづらいですが一応）</small>。ありがとうございます！</li>
</ul>
<p>せっかくなんで<span class="ascii">Copilot</span>を試してみましょう。<br />
公式サイトにあったサンプルコードそのまんまですが、生成される<span class="ascii">C</span>のコードを眺めてみます。</p>
<p>👇のコマンドでサンプルコードが入ったリポジトリーを<span class="ascii">git clone</span>した後、</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" title="1"><span class="fu">git</span> clone https://github.com/haskell-jp/blog</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="bu">cd</span> blog/examples/2019/hiw-copilot</a></code></pre></div>
<p>👇のコマンドでビルド・<span class="ascii">C</span>言語によるコードの生成できるはずです。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" title="1"><span class="ex">stack</span> build copilot</a>
<a class="sourceLine" id="cb2-2" title="2"><span class="ex">stack</span> exec runghc heater.hs</a></code></pre></div>
<p>こちらが生成元の<span class="ascii">Haskell</span>のコードです。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell:heater.hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">import</span> <span class="dt">Language.Copilot</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="kw">import</span> <span class="dt">Copilot.Compile.C99</span></a>
<a class="sourceLine" id="cb3-3" title="3"></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> ((&gt;), (&lt;), div)</a>
<a class="sourceLine" id="cb3-5" title="5"></a>
<a class="sourceLine" id="cb3-6" title="6"><span class="ot">temp ::</span> <span class="dt">Stream</span> <span class="dt">Word8</span></a>
<a class="sourceLine" id="cb3-7" title="7">temp <span class="ot">=</span> extern <span class="st">&quot;temperature&quot;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb3-8" title="8"></a>
<a class="sourceLine" id="cb3-9" title="9"><span class="ot">ctemp ::</span> <span class="dt">Stream</span> <span class="dt">Float</span></a>
<a class="sourceLine" id="cb3-10" title="10">ctemp <span class="ot">=</span> (unsafeCast temp) <span class="op">*</span> (<span class="fl">150.0</span> <span class="op">/</span> <span class="fl">255.0</span>) <span class="op">-</span> <span class="fl">50.0</span></a>
<a class="sourceLine" id="cb3-11" title="11"></a>
<a class="sourceLine" id="cb3-12" title="12">spec <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-13" title="13">  trigger <span class="st">&quot;heaton&quot;</span>  (ctemp <span class="op">&lt;</span> <span class="fl">18.0</span>) [arg ctemp]</a>
<a class="sourceLine" id="cb3-14" title="14">  trigger <span class="st">&quot;heatoff&quot;</span> (ctemp <span class="op">&gt;</span> <span class="fl">21.0</span>) [arg ctemp]</a>
<a class="sourceLine" id="cb3-15" title="15"></a>
<a class="sourceLine" id="cb3-16" title="16">main <span class="ot">=</span> reify spec <span class="op">&gt;&gt;=</span> compile <span class="st">&quot;heater&quot;</span></a></code></pre></div>
<p>まず、<code>temp</code>と<code>ctemp</code>という識別子に定義した式が、センサーが発信する、連続的に変化する値を表しています。<br />
<span class="ascii">Copilot</span>の言葉はこれを<code>Stream</code>と呼んでいます。</p>
<p><code>spec</code>という識別子で定義している式が、「どのセンサーから信号を受け取って、どんな条件を満たした場合にどの処理を実行するか」規定しているようです。<br />
👆の場合、<code>ctemp</code>という<code>Stream</code>が<code>18.0</code>を下回ったら<code>heaton</code>というイベントを発火し、<code>21.0</code>を超えたら<code>heatoff</code>というイベントを発火する、と定めているわけですね。<br />
そして<code>main</code>関数で実行している<code>reify spec &gt;&gt;= compile "heater"</code>という箇所で、<code>.h</code>ファイルと<code>.c</code>ファイルを書き込んでいます。</p>
<p>そして、生成されたヘッダーファイル<code>heater.h</code>がこう👇</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c:heater.h"><code class="sourceCode c"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">extern</span> <span class="dt">uint8_t</span> temperature;</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="dt">void</span> heatoff(<span class="dt">float</span> heatoff_arg0);</a>
<a class="sourceLine" id="cb4-3" title="3"><span class="dt">void</span> heaton(<span class="dt">float</span> heaton_arg0);</a>
<a class="sourceLine" id="cb4-4" title="4"><span class="dt">void</span> step(<span class="dt">void</span>);</a></code></pre></div>
<p>で、肝心の<span class="ascii">C</span>のコード本体<code>heater.c</code>がこちらです。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c:heater.c"><code class="sourceCode c"><a class="sourceLine" id="cb5-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb5-4" title="4"></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="pp">#include </span><span class="im">&quot;heater.h&quot;</span></a>
<a class="sourceLine" id="cb5-6" title="6"></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="dt">static</span> <span class="dt">uint8_t</span> temperature_cpy;</a>
<a class="sourceLine" id="cb5-8" title="8"></a>
<a class="sourceLine" id="cb5-9" title="9"><span class="dt">bool</span> heatoff_guard(<span class="dt">void</span>) {</a>
<a class="sourceLine" id="cb5-10" title="10">  <span class="cf">return</span> ((((<span class="dt">float</span>)(temperature_cpy)) * ((<span class="fl">150.0</span>) / (<span class="fl">255.0</span>))) - (<span class="fl">50.0</span>)) &gt; (<span class="fl">21.0</span>);</a>
<a class="sourceLine" id="cb5-11" title="11">}</a>
<a class="sourceLine" id="cb5-12" title="12"></a>
<a class="sourceLine" id="cb5-13" title="13"><span class="dt">float</span> heatoff_arg0(<span class="dt">void</span>) {</a>
<a class="sourceLine" id="cb5-14" title="14">  <span class="cf">return</span> (((<span class="dt">float</span>)(temperature_cpy)) * ((<span class="fl">150.0</span>) / (<span class="fl">255.0</span>))) - (<span class="fl">50.0</span>);</a>
<a class="sourceLine" id="cb5-15" title="15">}</a>
<a class="sourceLine" id="cb5-16" title="16"></a>
<a class="sourceLine" id="cb5-17" title="17"><span class="dt">bool</span> heaton_guard(<span class="dt">void</span>) {</a>
<a class="sourceLine" id="cb5-18" title="18">  <span class="cf">return</span> ((((<span class="dt">float</span>)(temperature_cpy)) * ((<span class="fl">150.0</span>) / (<span class="fl">255.0</span>))) - (<span class="fl">50.0</span>)) &lt; (<span class="fl">18.0</span>);</a>
<a class="sourceLine" id="cb5-19" title="19">}</a>
<a class="sourceLine" id="cb5-20" title="20"></a>
<a class="sourceLine" id="cb5-21" title="21"><span class="dt">float</span> heaton_arg0(<span class="dt">void</span>) {</a>
<a class="sourceLine" id="cb5-22" title="22">  <span class="cf">return</span> (((<span class="dt">float</span>)(temperature_cpy)) * ((<span class="fl">150.0</span>) / (<span class="fl">255.0</span>))) - (<span class="fl">50.0</span>);</a>
<a class="sourceLine" id="cb5-23" title="23">}</a>
<a class="sourceLine" id="cb5-24" title="24"></a>
<a class="sourceLine" id="cb5-25" title="25"><span class="dt">void</span> step(<span class="dt">void</span>) {</a>
<a class="sourceLine" id="cb5-26" title="26">  (temperature_cpy) = (temperature);</a>
<a class="sourceLine" id="cb5-27" title="27">  <span class="cf">if</span> ((heatoff_guard)()) {</a>
<a class="sourceLine" id="cb5-28" title="28">    (heatoff)(((heatoff_arg0)()));</a>
<a class="sourceLine" id="cb5-29" title="29">  };</a>
<a class="sourceLine" id="cb5-30" title="30">  <span class="cf">if</span> ((heaton_guard)()) {</a>
<a class="sourceLine" id="cb5-31" title="31">    (heaton)(((heaton_arg0)()));</a>
<a class="sourceLine" id="cb5-32" title="32">  };</a>
<a class="sourceLine" id="cb5-33" title="33">}</a></code></pre></div>
<p>先ほど<code>Stream</code>として定義した値のうち、<code>temp</code>は、<code>temperature</code>というグローバル変数と、それを一時的に保存する<code>temperature_cpy</code>という二つの変数に翻訳されました。<br />
<code>spec</code>において<code>trigger</code>という関数で列挙した「どのセンサーから信号を受け取って、どんな条件を満たした場合にどの処理を実行するか」というルールは、<code>step</code>という関数に現れたようです。<br />
この関数を利用する側では、<code>heaton</code>関数と<code>heatoff</code>関数を別途定義した上で、<code>temperature</code>にセンサーから受け取った値を代入して<code>step</code>を呼ぶことによって、<code>temperature</code>の値が条件に一致したとき、<code>heaton</code>関数と<code>heatoff</code>関数を実行してハードウェアの制御ができるのでしょう。<br />
<span class="ascii">Haskell</span>側で定義したもう一つの<code>Stream</code>、<code>ctemp</code>は、<code>heaton_guard</code>、<code>heaton_arg0</code>、<code>heatoff_guard</code>、<code>heatoff_arg0</code>、それぞれの関数に書かれた、<code>temperature_cpy</code>の値を変換する式に現れているようです。</p>
<p>正直なところこの程度であれば、直接<span class="ascii">C</span>で書いた方が余計なカッコもないし読みやすそうではあります。<br />
<code>temp</code>を<code>ctemp</code>に変換する式<code>(150.0 / 255.0) - 50.0</code>が変換後のソースコードでは冗長に適用されていることから、もっと最適化できそうですし。<br />
とはいえ、わざわざ<span class="ascii">DSL</span>を作ったからには、より複雑で、<span class="ascii">Haskell</span>でなければ書いてられないようなケースが、<span class="ascii">Copilot</span>の開発者の現場ではあるのでしょう<small>（なんせ<span class="ascii">NASA</span>の方も関わっているぐらいですから！）</small>。<br />
詳しいユースケースや、ビルド時のフローといった運用方法を聞きたいところですね。</p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/haskell-day-2019.html" lang="ja">Haskell Day 2019を開催しました！</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/haskell-symposium.html" style="margin-left: auto;" lang="ja">Haskell Symposium 2019 レポート</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>Haskell Symposium 2019 レポート</title>
    <link href="https://haskell.jp/blog/posts/2019/haskell-symposium.html" />
    <id>https://haskell.jp/blog/posts/2019/haskell-symposium.html</id>
    <published>2019-10-01T00:00:00Z</published>
    <updated>2019-10-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <p><a href="https://icfp19.sigplan.org/home/haskellsymp-2019"><span class="ascii">Haskell Symposium 2019</span></a>に<span class="ascii">IIJ</span>として参加してきました。</p>
<p>聴講した発表についての概要をまとめましたので、どの論文を読んでみるか決めるなどの際にご活用ください。内容については私の聞きまちがい・読みまちがいなどあると思いますのでご了承ください。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#haskell-symposiumとは" title="haskell-symposiumとは"><span class="ascii">Haskell Symposium</span>とは</a></li>
<li><a href="#bidirectional-type-class-instances" title="bidirectional-type-class-instances"><span class="ascii">Bidirectional Type Class Instances</span></a></li>
<li><a href="#generic-and-flexible-defaults-for-verified-law-abiding-type-class-instances" title="generic-and-flexible-defaults-for-verified-law-abiding-type-class-instances"><span class="ascii">Generic and Flexible Defaults for Verified, Law-Abiding Type-Class Instances</span></a></li>
<li><a href="#modular-effects-in-haskell-through-effect-polymorphism-and-explicit-dictionary-applications---a-new-approach-and-the-μverifast-verifier-as-a-case-study" title="modular-effects-in-haskell-through-effect-polymorphism-and-explicit-dictionary-applications---a-new-approach-and-the-μverifast-verifier-as-a-case-study"><span class="ascii">Modular effects in Haskell through effect polymorphism and explicit dictionary applications - A new approach and the</span> μ<span class="ascii">VeriFast verifier as a case study</span></a></li>
<li><a href="#verifying-effectful-haskell-programs-in-coq" title="verifying-effectful-haskell-programs-in-coq"><span class="ascii">Verifying Effectful Haskell Programs in Coq</span></a></li>
<li><a href="#solving-haskell-equality-constraints-using-coq" title="solving-haskell-equality-constraints-using-coq"><span class="ascii">Solving Haskell equality constraints using Coq</span></a></li>
<li><a href="#formal-verification-of-spacecraft-control-programs-an-experience-report" title="formal-verification-of-spacecraft-control-programs-an-experience-report"><span class="ascii">Formal Verification of Spacecraft Control Programs: An Experience Report</span></a></li>
<li><a href="#g2q-haskell-constraint-solving" title="g2q-haskell-constraint-solving"><span class="ascii">G2Q: Haskell Constraint Solving</span></a></li>
<li><a href="#making-a-faster-curry-with-extensional-types" title="making-a-faster-curry-with-extensional-types"><span class="ascii">Making a Faster Curry with Extensional Types</span></a></li>
<li><a href="#multi-stage-programs-in-context" title="multi-stage-programs-in-context"><span class="ascii">Multi-Stage Programs in Context</span></a></li>
<li><a href="#working-with-source-plugins" title="working-with-source-plugins"><span class="ascii">Working with Source Plugins</span></a></li>
<li><a href="#stclang-state-thread-composition-as-a-foundation-for-monadic-dataflow-parallelism" title="stclang-state-thread-composition-as-a-foundation-for-monadic-dataflow-parallelism"><span class="ascii">STCLang: State Thread Composition as a Foundation for Monadic Dataflow Parallelism</span></a></li>
<li><a href="#synthesizing-functional-reactive-programs" title="synthesizing-functional-reactive-programs"><span class="ascii">Synthesizing Functional Reactive Programs</span></a></li>
<li><a href="#the-essence-of-live-coding-change-the-program-keep-the-state" title="the-essence-of-live-coding-change-the-program-keep-the-state"><span class="ascii">The essence of live coding: Change the program, keep the state!</span></a></li>
<li><a href="#monad-transformers-and-modular-algebraic-effects-what-binds-them-together" title="monad-transformers-and-modular-algebraic-effects-what-binds-them-together"><span class="ascii">Monad Transformers and Modular Algebraic Effects: What Binds Them Together</span></a></li>
<li><a href="#scoping-monadic-relational-database-queries" title="scoping-monadic-relational-database-queries"><span class="ascii">Scoping Monadic Relational Database Queries</span></a></li>
</ul>
</div>
</div>
<h1 id="haskell-symposiumとは"><span class="link-to-here-outer"><a href="#haskell-symposiumとは" title="haskell-symposiumとは"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Haskell Symposium</span>とは</h1>
<p><a href="https://icfp19.sigplan.org/"><span class="ascii">International Conference on Functional Programming</span></a>（<span class="ascii">ICFP</span>）に合わせて開催される<span class="ascii">Haskell</span>に関する国際会議です。<span class="ascii">Haskell</span>に関する研究を発表したり、実践的な経験や将来の言語の開発について議論したり、その他の宣言的プログラミングを促進したりします。</p>
<h1 id="bidirectional-type-class-instances"><span class="link-to-here-outer"><a href="#bidirectional-type-class-instances" title="bidirectional-type-class-instances"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Bidirectional Type Class Instances</span></h1>
<ul>
<li>著者：<span class="ascii">Koen Pauwels (KU Leuven), Georgios Karachalias (KU Leuven), Michiel Derhaeg (Guardsquare), Tom Schrijvers (KU Leuven)</span></li>
<li>概要：<a href="https://icfp19.sigplan.org/details/haskellsymp-2019-papers/8/Bidirectional-Type-Class-Instances" class="uri"><span class="ascii">https://icfp19.sigplan.org/details/haskellsymp-2019-papers/8/Bidirectional-Type-Class-Instances</span></a></li>
<li>論文：<a href="https://arxiv.org/abs/1906.12242" class="uri"><span class="ascii">https://arxiv.org/abs/1906.12242</span></a></li>
</ul>
<p><span class="ascii">GADT</span>と型クラスはそれぞれ便利だが混ぜると問題が起きる場合がある。</p>
<p>次のような<code>Term</code>があるとき、その<code>Show</code>インスタンスを考える。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">data</span> <span class="dt">Term</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="dt">Con</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a</a>
<a class="sourceLine" id="cb1-3" title="3">  <span class="dt">Tup</span><span class="ot"> ::</span> <span class="dt">Term</span> b <span class="ot">-&gt;</span> <span class="dt">Term</span> c <span class="ot">-&gt;</span> <span class="dt">Term</span> (b, c)</a></code></pre></div>
<p>次のように<code>Show</code>インスタンスを定義すると型エラーになる。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Term</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="fu">show</span> (<span class="dt">Con</span> a) <span class="ot">=</span> <span class="fu">show</span> a</a>
<a class="sourceLine" id="cb2-3" title="3">  <span class="fu">show</span> (<span class="dt">Tup</span> x y) <span class="ot">=</span> <span class="fu">unwords</span> [<span class="st">&quot;(&quot;</span>, <span class="fu">show</span> x, <span class="st">&quot;,&quot;</span>, <span class="fu">show</span> y, <span class="st">&quot;)&quot;</span>]</a></code></pre></div>
<pre><code>Could not deduce (Show b) arising from a use of `show&#39;
from the context (Show a) or from (a ~ (b, c))</code></pre>
<p>これは<code>Show (b, c)</code>ならば<code>Show b</code>という関係がないために起こる。</p>
<p>一方タプルについての<code>Show</code>は、<code>Show a</code>かつ<code>Show b</code>ならば<code>Show (a, b)</code>という関係である。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">instance</span> (<span class="dt">Show</span> a, <span class="dt">Show</span> b) <span class="ot">=&gt;</span> <span class="dt">Show</span> (a, b) <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" title="2">  …</a></code></pre></div>
<p>この「ならば」を両方向にすれば問題は解決できるのではないかというのが、この論文の主張である。</p>
<h1 id="generic-and-flexible-defaults-for-verified-law-abiding-type-class-instances"><span class="link-to-here-outer"><a href="#generic-and-flexible-defaults-for-verified-law-abiding-type-class-instances" title="generic-and-flexible-defaults-for-verified-law-abiding-type-class-instances"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Generic and Flexible Defaults for Verified, Law-Abiding Type-Class Instances</span></h1>
<ul>
<li>著者：<span class="ascii">Ryan Scott (Indiana University), Ryan R. Newton (Indiana University)</span></li>
<li>概要：<a href="https://icfp19.sigplan.org/details/haskellsymp-2019-papers/3/Generic-and-Flexible-Defaults-for-Verified-Law-Abiding-Type-Class-Instances" class="uri"><span class="ascii">https://icfp19.sigplan.org/details/haskellsymp-2019-papers/3/Generic-and-Flexible-Defaults-for-Verified-Law-Abiding-Type-Class-Instances</span></a></li>
<li>論文：<a href="https://ryanglscott.github.io/papers/verified-classes.pdf" class="uri"><span class="ascii">https://ryanglscott.github.io/papers/verified-classes.pdf</span></a></li>
</ul>
<p>型クラスの法則は依存型を使えば証明できるが、インスタンスごとに書くのはめんどうなので<code>Generics</code>で出来るようにしようという話である。</p>
<h1 id="modular-effects-in-haskell-through-effect-polymorphism-and-explicit-dictionary-applications---a-new-approach-and-the-μverifast-verifier-as-a-case-study"><span class="link-to-here-outer"><a href="#modular-effects-in-haskell-through-effect-polymorphism-and-explicit-dictionary-applications---a-new-approach-and-the-μverifast-verifier-as-a-case-study" title="modular-effects-in-haskell-through-effect-polymorphism-and-explicit-dictionary-applications---a-new-approach-and-the-μverifast-verifier-as-a-case-study"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Modular effects in Haskell through effect polymorphism and explicit dictionary applications - A new approach and the</span> μ<span class="ascii">VeriFast verifier as a case study</span></h1>
<ul>
<li>著者：<span class="ascii">Dominique Devriese (Vrije Universiteit Brussel)</span></li>
<li>概要・論文：<a href="https://icfp19.sigplan.org/details/haskellsymp-2019-papers/1/Modular-effects-in-Haskell-through-effect-polymorphism-and-explicit-dictionary-applic" class="uri"><span class="ascii">https://icfp19.sigplan.org/details/haskellsymp-2019-papers/1/Modular-effects-in-Haskell-through-effect-polymorphism-and-explicit-dictionary-applic</span></a></li>
</ul>
<p>様々な種類の効果が複雑に絡み合うアプリケーションを整理するために、「効果を伴う処理を持った辞書」を明示的に渡す方式の提案である。</p>
<p>提案した方式によって<span class="ascii">VeriFast</span>を再実装してみることで、実際に発生した問題と解決方法を解説している。</p>
<h1 id="verifying-effectful-haskell-programs-in-coq"><span class="link-to-here-outer"><a href="#verifying-effectful-haskell-programs-in-coq" title="verifying-effectful-haskell-programs-in-coq"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Verifying Effectful Haskell Programs in Coq</span></h1>
<ul>
<li>著者：<span class="ascii">Jan Christiansen (Flensburg University of Applied Sciences), Sandra Dylus (University of Kiel), Niels Bunkenburg (University of Kiel)</span></li>
<li>概要：<a href="https://icfp19.sigplan.org/details/haskellsymp-2019-papers/4/Verifying-Effectful-Haskell-Programs-in-Coq" class="uri"><span class="ascii">https://icfp19.sigplan.org/details/haskellsymp-2019-papers/4/Verifying-Effectful-Haskell-Programs-in-Coq</span></a></li>
<li>論文：<a href="https://dl.acm.org/citation.cfm?id=3342592" class="uri"><span class="ascii">https://dl.acm.org/citation.cfm?id=3342592</span></a></li>
</ul>
<p><span class="ascii">Coq</span>による、効果を伴うプログラムの証明に関する話。</p>
<p>効果について直接証明することはせず、<span class="ascii">Free</span>モナドを用いての証明を試みても、そのまま<span class="ascii">Coq</span>に翻訳すると停止性チェックによってエラーになってしまう。</p>
<p>そのために行った工夫に加え、具体例として、<code>trace</code>や（部分関数による）エラーなど、<span class="ascii">Haskell</span>において暗黙に発生する効果を考慮したモデル化について検討した。</p>
<h1 id="solving-haskell-equality-constraints-using-coq"><span class="link-to-here-outer"><a href="#solving-haskell-equality-constraints-using-coq" title="solving-haskell-equality-constraints-using-coq"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Solving Haskell equality constraints using Coq</span></h1>
<ul>
<li>著者：<span class="ascii">Zubin Duggal</span></li>
<li>概要・論文：<a href="https://icfp19.sigplan.org/details/haskellsymp-2019-papers/15/Solving-Haskell-equality-constraints-using-Coq" class="uri"><span class="ascii">https://icfp19.sigplan.org/details/haskellsymp-2019-papers/15/Solving-Haskell-equality-constraints-using-Coq</span></a></li>
</ul>
<p><span class="ascii">data kinds</span>や<span class="ascii">type families</span>といった<span class="ascii">GHC</span>拡張によって厳格なデータ型を定義できるが、それに対する操作を定義すると<span class="ascii">GHC</span>には解けない型レベルの等式が生成されることがある。</p>
<p>制約カインドの型に対する型クラスとして<code>Proven</code>を提供し、この制約がある箇所を<span class="ascii">GHC</span>型検査プラグインが検出して対応する<span class="ascii">Coq</span>コードのテンプレートを生成する。</p>
<p>その<span class="ascii">Coq</span>コードに証明がなければ警告を表示する。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">type</span> <span class="dt">ProofName</span> <span class="ot">=</span> <span class="dt">Symbol</span></a>
<a class="sourceLine" id="cb5-2" title="2"></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="kw">class</span> c <span class="ot">=&gt;</span> <span class="dt">Proven</span> (<span class="ot">prf ::</span> <span class="dt">ProofName</span>) (<span class="ot">c ::</span> <span class="dt">Constraint</span>)</a>
<a class="sourceLine" id="cb5-4" title="4">  <span class="kw">where</span> {}</a>
<a class="sourceLine" id="cb5-5" title="5"></a>
<a class="sourceLine" id="cb5-6" title="6"><span class="ot">applyProof ::</span> <span class="kw">forall</span> prf c a<span class="op">.</span> <span class="dt">Proven</span> prf c <span class="ot">=&gt;</span> (c <span class="ot">=&gt;</span> a) <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb5-7" title="7">applyProof x <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb5-8" title="8"></a>
<a class="sourceLine" id="cb5-9" title="9">lemma3 <span class="ot">=</span> applyProof <span class="op">@</span><span class="st">&quot;nonzero_pop&quot;</span> <span class="op">@</span>(<span class="dt">NNonZero</span> (<span class="dt">Popcount</span> b) <span class="op">~</span> <span class="dt">True</span>) <span class="dt">Refl</span></a></code></pre></div>
<p>いくつか制約があるが<span class="ascii">Haskell</span>の型を<span class="ascii">Coq</span>に自動的に変換している。</p>
<h1 id="formal-verification-of-spacecraft-control-programs-an-experience-report"><span class="link-to-here-outer"><a href="#formal-verification-of-spacecraft-control-programs-an-experience-report" title="formal-verification-of-spacecraft-control-programs-an-experience-report"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Formal Verification of Spacecraft Control Programs: An Experience Report</span></h1>
<ul>
<li>著者：<span class="ascii">Andrey Mokhov (Newcastle University), Georgy Lukyanov (Newcastle University), Jakob Lechner (RUAG Space Austria GmbH)</span></li>
<li>概要：<a href="https://icfp19.sigplan.org/details/haskellsymp-2019-papers/5/Formal-Verification-of-Spacecraft-Control-Programs-An-Experience-Report" class="uri"><span class="ascii">https://icfp19.sigplan.org/details/haskellsymp-2019-papers/5/Formal-Verification-of-Spacecraft-Control-Programs-An-Experience-Report</span></a></li>
<li>論文：<a href="https://dl.acm.org/citation.cfm?id=3342593" class="uri"><span class="ascii">https://dl.acm.org/citation.cfm?id=3342593</span></a></li>
</ul>
<p><span class="ascii">REDFIN</span>という固定小数演算と整数演算のための処理系があるのだが、そのアセンブリーコードに対して形式検証をしたという報告である。</p>
<h1 id="g2q-haskell-constraint-solving"><span class="link-to-here-outer"><a href="#g2q-haskell-constraint-solving" title="g2q-haskell-constraint-solving"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">G2Q: Haskell Constraint Solving</span></h1>
<ul>
<li>著者：<span class="ascii">William T. Hallahan (Yale University), Anton Xue (Yale University), Ruzica Piskac (Yale University)</span></li>
<li>概要：<a href="https://icfp19.sigplan.org/details/haskellsymp-2019-papers/2/G2Q-Haskell-Constraint-Solving" class="uri"><span class="ascii">https://icfp19.sigplan.org/details/haskellsymp-2019-papers/2/G2Q-Haskell-Constraint-Solving</span></a></li>
<li>論文：<a href="https://dl.acm.org/citation.cfm?id=3342590" class="uri"><span class="ascii">https://dl.acm.org/citation.cfm?id=3342590</span></a></li>
</ul>
<p><span class="ascii">G2Q</span>は<span class="ascii">Haskell</span>のソースに<span class="ascii">quasi quote</span>で埋め込む<span class="ascii">DSL</span>である。</p>
<p><span class="ascii">Haskell</span>で書いた条件式を<span class="ascii">symbolic execution</span>して、<span class="ascii">SMT solver</span>に渡す式に変換して、<span class="ascii">SMT solver</span>に条件を満たす関数を導出させる。</p>
<h1 id="making-a-faster-curry-with-extensional-types"><span class="link-to-here-outer"><a href="#making-a-faster-curry-with-extensional-types" title="making-a-faster-curry-with-extensional-types"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Making a Faster Curry with Extensional Types</span></h1>
<ul>
<li>著者：<span class="ascii">Paul Downen (University of Oregon), Zachary Sullivan, Zena M. Ariola (University of Oregon), Simon Peyton Jones (Microsoft)</span></li>
<li>概要：<a href="https://icfp19.sigplan.org/details/haskellsymp-2019-papers/6/Making-a-Faster-Curry-with-Extensional-Types" class="uri"><span class="ascii">https://icfp19.sigplan.org/details/haskellsymp-2019-papers/6/Making-a-Faster-Curry-with-Extensional-Types</span></a></li>
<li>論文：<a href="https://ix.cs.uoregon.edu/~pdownen/publications/eta.pdf" class="uri"><span class="ascii">https://ix.cs.uoregon.edu/~pdownen/publications/eta.pdf</span></a></li>
</ul>
<p>パフォーマンスのためにη変換してほしいところを明示したいことがある。</p>
<p>例えば、次のような意味論上は等価な関数<code>f1</code>と<code>f2</code>があるとする。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1">f1 <span class="ot">=</span> \x <span class="ot">-&gt;</span> <span class="kw">let</span> z <span class="ot">=</span> h x x <span class="kw">in</span> \y <span class="ot">-&gt;</span> e y z</a>
<a class="sourceLine" id="cb6-2" title="2">f2 <span class="ot">=</span> \x <span class="ot">-&gt;</span> \y <span class="ot">-&gt;</span> <span class="kw">let</span> z <span class="ot">=</span> h x x <span class="kw">in</span> e y z</a></code></pre></div>
<p>実際は<code>f1</code>は引数<code>x</code>を取った後クロージャー生成のためにヒープ確保するのに対して、<code>f2</code>はアリティが<span class="ascii">2</span>の関数と解釈されて中間のクロージャーが必要なくなる。</p>
<p><code>~&gt;</code>というアリティの情報を持った関数型を新たに導入して<code>-&gt;</code>の代わりに使えるようにする。</p>
<p><code>TYPE (a :: RuntimeRep (FunRep 2))</code>というような新たなポリモーフィズムを導入する。ここでの<code>2</code>がアリティ。</p>
<p><code>Int</code>に対して<code>Int#</code>があるように基本的にはパフォーマンスが必要なライブラリーなど内部的に使用する想定。</p>
<h1 id="multi-stage-programs-in-context"><span class="link-to-here-outer"><a href="#multi-stage-programs-in-context" title="multi-stage-programs-in-context"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Multi-Stage Programs in Context</span></h1>
<ul>
<li>著者：<span class="ascii">Matthew Pickering (University of Bristol), Nicolas Wu (Imperial College London), Csongor Kiss (Imperial College London)</span></li>
<li>概要：<a href="https://icfp19.sigplan.org/details/haskellsymp-2019-papers/9/Multi-Stage-Programs-in-Context" class="uri"><span class="ascii">https://icfp19.sigplan.org/details/haskellsymp-2019-papers/9/Multi-Stage-Programs-in-Context</span></a></li>
<li>論文：<a href="https://dl.acm.org/citation.cfm?id=3342597" class="uri"><span class="ascii">https://dl.acm.org/citation.cfm?id=3342597</span></a></li>
</ul>
<p>次のような準引用があったときに、組み合わせると元々あったはずの情報が欠落する場合がある。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="ot">qshow ::</span> <span class="dt">Code</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span>)</a>
<a class="sourceLine" id="cb7-2" title="2">qshow <span class="ot">=</span> [q| show |]</a>
<a class="sourceLine" id="cb7-3" title="3"></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="ot">qread ::</span> <span class="dt">Code</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb7-5" title="5">qread <span class="ot">=</span> [q| read |]</a>
<a class="sourceLine" id="cb7-6" title="6"></a>
<a class="sourceLine" id="cb7-7" title="7"><span class="ot">trim ::</span> <span class="dt">Code</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>)</a>
<a class="sourceLine" id="cb7-8" title="8">trim <span class="ot">=</span> [q| $(qshow) . $(qread) |]</a></code></pre></div>
<p><code>qshow</code>と<code>qread</code>にあった<code>Int</code>という情報が、組み合わせて<code>trim</code>とすると欠落してコンパイルエラーになってしまう。</p>
<p><span class="ascii">splice</span>するときに<span class="ascii">Haskell</span>ソースコードの構文木ではなく<span class="ascii">Core</span>に対するものを出力すればそれは型が明示されているし問題がない。</p>
<p>しかも、<span class="ascii">splice</span>後の型検査を省略できるのでコンパイルの高速化にも寄与する。</p>
<h1 id="working-with-source-plugins"><span class="link-to-here-outer"><a href="#working-with-source-plugins" title="working-with-source-plugins"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Working with Source Plugins</span></h1>
<ul>
<li>著者：<span class="ascii">Matthew Pickering (University of Bristol), Nicolas Wu (Imperial College London), Boldizsár Németh (Eötvös Loránd University)</span></li>
<li>概要：<a href="https://icfp19.sigplan.org/details/haskellsymp-2019-papers/11/Working-with-Source-Plugins" class="uri"><span class="ascii">https://icfp19.sigplan.org/details/haskellsymp-2019-papers/11/Working-with-Source-Plugins</span></a></li>
<li>論文：<a href="https://dl.acm.org/citation.cfm?id=3342599" class="uri"><span class="ascii">https://dl.acm.org/citation.cfm?id=3342599</span></a></li>
</ul>
<p><span class="ascii">souce plugins</span>のしくみや、書き方、実装時のテクニックの紹介である。</p>
<h1 id="stclang-state-thread-composition-as-a-foundation-for-monadic-dataflow-parallelism"><span class="link-to-here-outer"><a href="#stclang-state-thread-composition-as-a-foundation-for-monadic-dataflow-parallelism" title="stclang-state-thread-composition-as-a-foundation-for-monadic-dataflow-parallelism"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">STCLang: State Thread Composition as a Foundation for Monadic Dataflow Parallelism</span></h1>
<ul>
<li>著者：<span class="ascii">Sebastian Ertel, Justus Adam (Technische Universität Dresden), Norman A. Rink (TU Dresden), Andrés Goens, Jeronimo Castrillon (TU Dresden)</span></li>
<li>概要：<a href="https://icfp19.sigplan.org/details/haskellsymp-2019-papers/12/STCLang-State-Thread-Composition-as-a-Foundation-for-Monadic-Dataflow-Parallelism" class="uri"><span class="ascii">https://icfp19.sigplan.org/details/haskellsymp-2019-papers/12/STCLang-State-Thread-Composition-as-a-Foundation-for-Monadic-Dataflow-Parallelism</span></a></li>
<li>論文：<a href="https://dl.acm.org/citation.cfm?id=3342600" class="uri"><span class="ascii">https://dl.acm.org/citation.cfm?id=3342600</span></a></li>
</ul>
<p>同じ時刻の<span class="ascii">HIW</span>の発表を聴講していたためこちらは聴講していません。</p>
<h1 id="synthesizing-functional-reactive-programs"><span class="link-to-here-outer"><a href="#synthesizing-functional-reactive-programs" title="synthesizing-functional-reactive-programs"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Synthesizing Functional Reactive Programs</span></h1>
<ul>
<li>著者：<span class="ascii">Bernd Finkbeiner, Felix Klein (Saarland University), Ruzica Piskac (Yale University, Mark Santolucito (Yale University)</span></li>
<li>概要：<a href="https://icfp19.sigplan.org/details/haskellsymp-2019-papers/13/Synthesizing-Functional-Reactive-Programs" class="uri"><span class="ascii">https://icfp19.sigplan.org/details/haskellsymp-2019-papers/13/Synthesizing-Functional-Reactive-Programs</span></a></li>
<li>論文：<a href="https://dl.acm.org/citation.cfm?id=3342601" class="uri"><span class="ascii">https://dl.acm.org/citation.cfm?id=3342601</span></a></li>
</ul>
<p>同じ時刻の<span class="ascii">HIW</span>の発表を聴講していたためこちらは聴講していません。</p>
<h1 id="the-essence-of-live-coding-change-the-program-keep-the-state"><span class="link-to-here-outer"><a href="#the-essence-of-live-coding-change-the-program-keep-the-state" title="the-essence-of-live-coding-change-the-program-keep-the-state"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">The essence of live coding: Change the program, keep the state!</span></h1>
<ul>
<li>著者：<span class="ascii">Manuel Bärenz (sonnen eServices GmbH)</span></li>
<li>概要・論文：<a href="https://icfp19.sigplan.org/details/haskellsymp-2019-papers/14/The-essence-of-live-coding-Change-the-program-keep-the-state-" class="uri"><span class="ascii">https://icfp19.sigplan.org/details/haskellsymp-2019-papers/14/The-essence-of-live-coding-Change-the-program-keep-the-state-</span></a></li>
</ul>
<p>同じ時刻の<span class="ascii">HIW</span>の発表を聴講していたためこちらは聴講していません。</p>
<h1 id="monad-transformers-and-modular-algebraic-effects-what-binds-them-together"><span class="link-to-here-outer"><a href="#monad-transformers-and-modular-algebraic-effects-what-binds-them-together" title="monad-transformers-and-modular-algebraic-effects-what-binds-them-together"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Monad Transformers and Modular Algebraic Effects: What Binds Them Together</span></h1>
<ul>
<li>著者：<span class="ascii">Tom Schrijvers (KU Leuven), Maciej Piróg (University of Wroc</span>ł<span class="ascii">aw), Nicolas Wu (Imperial College London), Mauro Jaskelioff (CONICET)</span></li>
<li>概要：<a href="https://icfp19.sigplan.org/details/haskellsymp-2019-papers/7/Monad-Transformers-and-Modular-Algebraic-Effects-What-Binds-Them-Together" class="uri"><span class="ascii">https://icfp19.sigplan.org/details/haskellsymp-2019-papers/7/Monad-Transformers-and-Modular-Algebraic-Effects-What-Binds-Them-Together</span></a></li>
<li>論文：<a href="https://dl.acm.org/citation.cfm?id=3342595" class="uri"><span class="ascii">https://dl.acm.org/citation.cfm?id=3342595</span></a></li>
</ul>
<p>モナドトランスフォーマーと代数的効果との対比である。</p>
<p>モナドトランスフォーマーから代数的効果への変換またその逆のときにどういう手法があって、それぞれを構成する要素がどう対応しているかを説明している。</p>
<p>モナドトランスフォーマーと代数的効果だとモナドトランスフォーマーの方が表現できるものが大きいのでモナドトランスフォーマーから代数的効果へはどんなものでも変換できるわけではない。</p>
<p>例えば<code>catch</code>や<code>local</code>は代数的効果にできない。</p>
<h1 id="scoping-monadic-relational-database-queries"><span class="link-to-here-outer"><a href="#scoping-monadic-relational-database-queries" title="scoping-monadic-relational-database-queries"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Scoping Monadic Relational Database Queries</span></h1>
<ul>
<li>著者：<span class="ascii">Anton Ekblad (Chalmers University of Technology)</span></li>
<li>概要：<a href="https://icfp19.sigplan.org/details/haskellsymp-2019-papers/10/Scoping-Monadic-Relational-Database-Queries" class="uri"><span class="ascii">https://icfp19.sigplan.org/details/haskellsymp-2019-papers/10/Scoping-Monadic-Relational-Database-Queries</span></a></li>
<li>論文：<a href="https://dl.acm.org/citation.cfm?id=3342598" class="uri"><span class="ascii">https://dl.acm.org/citation.cfm?id=3342598</span></a></li>
</ul>
<p>モナドは<span class="ascii">Haskell</span>界隈で非常に普及しているので<span class="ascii">SQL</span>に対する<span class="ascii">EDSL</span>としてモナドの構造を採用したい。</p>
<p>このとき<span class="ascii">SQL</span>の結合を表現すると、<span class="ascii">SQL</span>としてはスコープ外にもかかわらず<span class="ascii">EDSL</span>としてはスコープ内となって使える変数ができてしまう。</p>
<p>これを<span class="ascii">EDSL</span>としてもエラーとしたい。</p>
<p>例えば、次のような例で実行時エラーとなってしまう。ここで<code>a0</code>は<code>tableA</code>の列とする。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">SELECT</span> a0, b0</a>
<a class="sourceLine" id="cb8-2" title="2"><span class="kw">FROM</span></a>
<a class="sourceLine" id="cb8-3" title="3">  tableA</a>
<a class="sourceLine" id="cb8-4" title="4">    <span class="kw">LEFT</span> <span class="kw">JOIN</span></a>
<a class="sourceLine" id="cb8-5" title="5">      (<span class="kw">SELECT</span> b0 <span class="kw">FROM</span> tableB <span class="kw">WHERE</span> a0 <span class="op">==</span> b1)</a>
<a class="sourceLine" id="cb8-6" title="6">  <span class="kw">ON</span> tableA.a2 <span class="op">==</span> tableb.b2</a></code></pre></div>
<p><code>SELECT b0 FROM tableB WHERE a0 == b1</code>の部分でスコープ外の<code>a0</code>を参照しているためエラーとなる。</p>
<p>単純なモナド<span class="ascii">EDSL</span>だと次のようになりコンパイルが通る。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">do</span></a>
<a class="sourceLine" id="cb9-2" title="2">  a0 <span class="op">:*:</span> a1 <span class="op">:*:</span> a2 <span class="ot">&lt;-</span> from table0</a>
<a class="sourceLine" id="cb9-3" title="3">  leftJoin <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-4" title="4">    b0 <span class="op">:*:</span> b1 <span class="op">:*:</span> b2 <span class="ot">&lt;-</span> from table1</a>
<a class="sourceLine" id="cb9-5" title="5">    ristrict <span class="op">$</span> a0 <span class="op">.==</span> b1</a>
<a class="sourceLine" id="cb9-6" title="6">  on <span class="op">$</span> a2 <span class="op">.==</span> b2</a></code></pre></div>
<p><code>ristrict $ a0 .== b1</code>の部分において<code>a0</code>は<span class="ascii">Haskell</span>としてはスコープ内にある。</p>
<p>この問題を次のような型レベル関数を駆使することで<span class="ascii">EDSL</span>においてもコンパイル時エラーとすることができた。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Cols</span> a</a>
<a class="sourceLine" id="cb10-2" title="2"><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Outer</span> a</a>
<a class="sourceLine" id="cb10-3" title="3"><span class="kw">type</span> <span class="kw">family</span> <span class="dt">UnAggr</span> a</a>
<a class="sourceLine" id="cb10-4" title="4"><span class="kw">type</span> <span class="kw">family</span> <span class="dt">FromRow</span> a</a></code></pre></div>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/hiw-copilot.html" lang="ja">HIW 2019で発表された、Copilotという内部DSLについて</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/hiw-gibbon.html" style="margin-left: auto;" lang="ja">HIW 2019で発表された、Gibbonコンパイラーについて</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>HIW 2019で発表された、Gibbonコンパイラーについて</title>
    <link href="https://haskell.jp/blog/posts/2019/hiw-gibbon.html" />
    <id>https://haskell.jp/blog/posts/2019/hiw-gibbon.html</id>
    <published>2019-09-28T00:00:00Z</published>
    <updated>2019-09-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p><a href="/posts/2019/hiw-ghc-future.html">前回</a>から引き続き、<a href="https://icfp19.sigplan.org/home/hiw-2019#About"><span class="ascii">Haskell Implementors</span>’ <span class="ascii">Workshop 2019</span></a>への参加レポートとして、私の印象に残った発表を紹介します。<br />
今回は、<a href="http://iu-parfunc.github.io/gibbon/"><span class="ascii">Gibbon</span></a>という、<span class="ascii">GHC</span>以外の<span class="ascii">Haskell</span><small>（の、サブセット）</small>の処理系についての発表です。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#the-gibbon-compiler-accelerating-a-small-subset-of-haskell" title="the-gibbon-compiler-accelerating-a-small-subset-of-haskell"><span class="ascii">The Gibbon Compiler: Accelerating a small subset of Haskell</span></a></li>
</ul>
</div>
</div>
<h1 id="the-gibbon-compiler-accelerating-a-small-subset-of-haskell"><span class="link-to-here-outer"><a href="#the-gibbon-compiler-accelerating-a-small-subset-of-haskell" title="the-gibbon-compiler-accelerating-a-small-subset-of-haskell"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">The Gibbon Compiler: Accelerating a small subset of Haskell</span></h1>
<p>発表者<span class="ascii">: Ryan R. Newton</span> <em><span class="ascii">Indiana University</span></em><span class="ascii">, Michael Vollmer</span> <em><span class="ascii">Indiana University, USA</span></em><span class="ascii">, Chaitanya Koparkar</span> <em><span class="ascii">Indiana University</span></em></p>
<p><span class="ascii">Gibbon</span>は最適化の手法を研究するために作られたコンパイラーです。<br />
具体的には、我々<small>（特に<span class="ascii">Haskeller</span>）</small>がよく使う、木構造全体に対する処理の最適化です。</p>
<p>こうした木構造のデータは、通常ポインターを使ってメモリー内にバラバラに格納されますが、<span class="ascii">Gibbon</span>による最適化を行うと、実際にプログラムがどのような順番で木を処理しているのか解析して、（元のデータ構造を配列に変換した上で）その順番に並べられた配列として処理するコードに変換する、という大胆な変換を行います。 図にするとこんなイメージでしょうか？</p>
<figure>
<img src="/img/2019/hiw-gibbon/tree-and-array1.svg" alt="変換前の木構造。各ノードがそれぞれ（レベル順で）A, B, … , Gという値を持っている" /><figcaption>変換前の木構造。各ノードがそれぞれ（レベル順で）<span class="ascii">A, B,</span> … <span class="ascii">, G</span>という値を持っている</figcaption>
</figure>
<p>👆のような木構造があったとして、</p>
<figure>
<img src="/img/2019/hiw-gibbon/tree-and-array2.svg" alt="行きがけ順（A, B, D, E, C, F, Gの順）でアクセスする" /><figcaption>行きがけ順（<span class="ascii">A, B, D, E, C, F, G</span>の順）でアクセスする</figcaption>
</figure>
<p>👆における、赤い線の順番<small>（行きがけ順）</small>にアクセスする関数があったとします。<br />
適当に<span class="ascii">Haskell</span>の再帰関数として書くと、👇こういうコードです。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">data</span> <span class="dt">Tree</span> <span class="ot">=</span> <span class="dt">Node</span> <span class="dt">Char</span> (<span class="dt">Maybe</span> <span class="dt">Tree</span>) (<span class="dt">Maybe</span> <span class="dt">Tree</span>) <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="ot">tree ::</span> <span class="dt">Tree</span></a>
<a class="sourceLine" id="cb1-4" title="4">tree <span class="ot">=</span></a>
<a class="sourceLine" id="cb1-5" title="5">  <span class="dt">Node</span> <span class="ch">&#39;A&#39;</span></a>
<a class="sourceLine" id="cb1-6" title="6">    ( <span class="dt">Just</span></a>
<a class="sourceLine" id="cb1-7" title="7">      ( <span class="dt">Node</span> <span class="ch">&#39;B&#39;</span></a>
<a class="sourceLine" id="cb1-8" title="8">        (<span class="dt">Just</span> (<span class="dt">Node</span> <span class="ch">&#39;D&#39;</span> <span class="dt">Nothing</span> <span class="dt">Nothing</span>))</a>
<a class="sourceLine" id="cb1-9" title="9">        (<span class="dt">Just</span> (<span class="dt">Node</span> <span class="ch">&#39;E&#39;</span> <span class="dt">Nothing</span> <span class="dt">Nothing</span>))</a>
<a class="sourceLine" id="cb1-10" title="10">      )</a>
<a class="sourceLine" id="cb1-11" title="11">    )</a>
<a class="sourceLine" id="cb1-12" title="12">    ( <span class="dt">Just</span></a>
<a class="sourceLine" id="cb1-13" title="13">      ( <span class="dt">Node</span> <span class="ch">&#39;C&#39;</span></a>
<a class="sourceLine" id="cb1-14" title="14">        (<span class="dt">Just</span> (<span class="dt">Node</span> <span class="ch">&#39;F&#39;</span> <span class="dt">Nothing</span> <span class="dt">Nothing</span>))</a>
<a class="sourceLine" id="cb1-15" title="15">        (<span class="dt">Just</span> (<span class="dt">Node</span> <span class="ch">&#39;G&#39;</span> <span class="dt">Nothing</span> <span class="dt">Nothing</span>))</a>
<a class="sourceLine" id="cb1-16" title="16">      )</a>
<a class="sourceLine" id="cb1-17" title="17">    )</a>
<a class="sourceLine" id="cb1-18" title="18"></a>
<a class="sourceLine" id="cb1-19" title="19"><span class="ot">preOrder ::</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()) <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-20" title="20">preOrder access (<span class="dt">Node</span> char mLeft mRight) <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-21" title="21">  access char</a>
<a class="sourceLine" id="cb1-22" title="22"></a>
<a class="sourceLine" id="cb1-23" title="23">  <span class="kw">case</span> mLeft <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-24" title="24">    <span class="dt">Just</span> left <span class="ot">-&gt;</span> preOrder access left</a>
<a class="sourceLine" id="cb1-25" title="25">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">return</span> ()</a>
<a class="sourceLine" id="cb1-26" title="26"></a>
<a class="sourceLine" id="cb1-27" title="27">  <span class="kw">case</span> mRight <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-28" title="28">    <span class="dt">Just</span> right <span class="ot">-&gt;</span> preOrder access right</a>
<a class="sourceLine" id="cb1-29" title="29">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">return</span> ()</a></code></pre></div>
<p><span class="ascii">Gibbon</span>はこの関数と、それが処理する木構造を解析して、</p>
<figure>
<img src="/img/2019/hiw-gibbon/tree-and-array3.svg" alt="変換された配列。A, B, D, E, C, F, Gの順に要素が並んだただの配列" /><figcaption>変換された配列。<span class="ascii">A, B, D, E, C, F, G</span>の順に要素が並んだただの配列</figcaption>
</figure>
<p>👆のような、ただの配列（とそれに対する関数）にまとめて変換してしまう、というのです！</p>
<p>現代のコンピューターは、このような配列の要素にまとめてアクセス処理する方が、ポインターをたどって各要素を処理するより、たいてい遙かに速いです。<br />
<span class="ascii">Gibbon</span>はこの特性を活かすべく、我々<span class="ascii">Haskeller</span>が好んで使うような、ポインターだらけの木構造を可能な限り配列に変換することで、要素をまとめて処理する（<span class="ascii">traverse</span>する）演算の最適化を図るコンパイラーです。</p>
<p>ちなみに、元の木に対するノードの追加に相当する処理は、新しいノードに対するポインターを書き込む処理に変換するそうです。<br />
なので何度も追加を繰り返すと、あまり恩恵が受けられなくなってしまいそうです。</p>
<p>なかなか興味深いアイディアですが、個人的に聞きそびれた疑問が<span class="ascii">2</span>つあります。<br />
一つは、そもそも木構造を定義するような状況というのは、いろいろな順番でアクセスしたいし、新しい要素の追加も繰り返し行いたいケースではないでしょうか？<br />
例えば<a href="http://hackage.haskell.org/package/unordered-containers"><span class="ascii">unordered-containers</span></a>にある<code>HashMap</code>型は探索木を使った頻繁に使われるデータ構造ですが、<code>HashMap</code>を使う場合に行う処理の多くは、ランダムアクセスや要素の追加・削除でしょう。</p>
<p>なので、<span class="ascii">Gibbon</span>が最適化したい「木構造」というのは、どちらかというと探索木のような木ではなく、構文木のような、要素をまとめて処理することを前提とした木のことなのかもしれません。<br />
確かに人間が書く言語の構文木程度であれば、すべてメモリー上で処理できる程度のサイズに収まる<small>（という想定でなければコンパイラー作りがものすごく難しくなる）</small>でしょうし、構文木の処理を高速化できれば、遅い遅いと言われる<span class="ascii">GHC</span>のコンパイル速度も高められるはずです。それはそれでありがたい。</p>
<p>もう一つは、これまた例えば<code>HashMap</code>型のような木をベースにした連想配列も、配列ベースのハッシュテーブルに変換することができるのでしょうか？<br />
もしそうだとすると、ランダムアクセスに対する計算量のオーダーも<span class="ascii">O(log n)</span>から<span class="ascii">O(1)</span>に変わるわけですし、要素をまとめて処理する以外の演算についても劇的な改善が見込めるかもしれません。<br />
もちろんこれも先ほどの推測が正しければ無意味な想像ですが、夢のある話ですね。</p>
<p><span class="ascii">Gibbon</span>は将来的には、<code>Packed</code>という型クラスを提供することで、<span class="ascii">GHC</span>本体への統合も視野に入れているそうです。<br />
<code>Packed</code>を実装した型は、値をどのように配列に変換するのか定義することで、<span class="ascii">Gibbon</span>による最適化のためのヒントを与えることができます。</p>
<p>参考<span class="ascii">:</span> <a href="https://ja.wikipedia.org/w/index.php?title=%E6%9C%A8%E6%A7%8B%E9%80%A0_(%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0)&amp;oldid=72655479">木構造 <span class="ascii">(</span>データ構造<span class="ascii">) - Wikipedia</span></a></p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/haskell-symposium.html" lang="ja">Haskell Symposium 2019 レポート</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/hiw-ghc-future.html" style="margin-left: auto;" lang="ja">HIW 2019で発表された、GHC 8.10に導入されるであろう機能</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>HIW 2019で発表された、GHC 8.10に導入されるであろう機能</title>
    <link href="https://haskell.jp/blog/posts/2019/hiw-ghc-future.html" />
    <id>https://haskell.jp/blog/posts/2019/hiw-ghc-future.html</id>
    <published>2019-09-17T00:00:00Z</published>
    <updated>2019-09-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p><a href="/posts/2019/hiw-ghc8.8.html">前回</a>から引き続き、<a href="https://icfp19.sigplan.org/home/hiw-2019#About"><span class="ascii">Haskell Implementors</span>’ <span class="ascii">Workshop 2019</span></a>への参加レポートとして、私の印象に残った発表をいくつか紹介します。<br />
今回は、「<span class="ascii">GHC 8.10</span>に導入されるであろう機能」です。<br />
いずれも該当する<span class="ascii">Merge Request</span>は<span class="ascii">master</span>ブランチにマージ済みなので、おそらく<span class="ascii">GHC 8.10</span>で提供されるでしょう。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#holefitplugins-and-the-future-of-interactive-development-in-ghc" title="holefitplugins-and-the-future-of-interactive-development-in-ghc"><span class="ascii">HoleFitPlugins and the future of interactive development in GHC</span></a></li>
<li><a href="#visible-dependent-quantification" title="visible-dependent-quantification"><span class="ascii">Visible dependent quantification</span></a></li>
</ul>
</div>
</div>
<h2 id="holefitplugins-and-the-future-of-interactive-development-in-ghc"><span class="link-to-here-outer"><a href="#holefitplugins-and-the-future-of-interactive-development-in-ghc" title="holefitplugins-and-the-future-of-interactive-development-in-ghc"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">HoleFitPlugins and the future of interactive development in GHC</span></h2>
<ul>
<li>発表者<span class="ascii">: Matthías Páll Gissurarson</span> <em><span class="ascii">Chalmers University of Technology, Sweden</span></em></li>
<li>該当の<span class="ascii">Merge Request:</span> <a href="https://gitlab.haskell.org/ghc/ghc/merge_requests/153"><span class="ascii">!153</span></a></li>
<li>該当の<span class="ascii">GHC Proposal:</span> なし</li>
</ul>
<p><a href="https://icfp18.sigplan.org/details/haskellsymp-2018-papers/10/Suggesting-Valid-Hole-Fits-for-Typed-Holes-Experience-Report-">昨年の<span class="ascii">Haskell Symposium</span>でも発表</a>されて<span class="ascii">GHC 8.6</span>で導入された、「<span class="ascii">Valid Hole Fits</span>」という機能のさらなる拡張について。</p>
<p>まず、「<span class="ascii">Valid Hole Fits</span>」という機能について軽く紹介します<small>（詳しくは<a href="https://wataru86.github.io/slides/vhs/">こちらのスライド</a>が参考になるかと思います）</small>。<br />
「<span class="ascii">Valid Hole Fits</span>」はアンダースコア <code>_</code>で始まる識別子を書いたとき、<span class="ascii">GHC</span>が推論した型にマッチする関数をエラーメッセージに付記することで、ユーザーがどんな式を書けばよいか、ヒントを与えてくれるものです。</p>
<p>例えば、</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="fu">map</span> (<span class="fu">length</span> <span class="op">.</span> _someFunc) [<span class="dt">True</span>, <span class="dt">False</span>, <span class="dt">True</span>]</a></code></pre></div>
<p>上記のように、アンダースコア <code>_</code>で始まる識別子を書いたとき、</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">1</span><span class="op">:</span><span class="dv">16</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span></a>
<a class="sourceLine" id="cb2-2" title="2">    <span class="op">...</span></a>
<a class="sourceLine" id="cb2-3" title="3">      <span class="dt">Valid</span> hole fits include</a>
<a class="sourceLine" id="cb2-4" title="4"><span class="ot">        enumFrom ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Enum</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb2-5" title="5">          with <span class="fu">enumFrom</span> <span class="op">@</span><span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-6" title="6">          (imported from ‘<span class="dt">Prelude</span>’ (<span class="fu">and</span> originally defined <span class="kw">in</span> ‘<span class="dt">GHC.Enum</span>’))</a>
<a class="sourceLine" id="cb2-7" title="7"><span class="ot">        show ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb2-8" title="8">          with <span class="fu">show</span> <span class="op">@</span><span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-9" title="9">          (imported from ‘<span class="dt">Prelude</span>’ (<span class="fu">and</span> originally defined <span class="kw">in</span> ‘<span class="dt">GHC.Show</span>’))</a>
<a class="sourceLine" id="cb2-10" title="10"><span class="ot">        repeat ::</span> <span class="kw">forall</span> a<span class="op">.</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb2-11" title="11">          with <span class="fu">repeat</span> <span class="op">@</span><span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-12" title="12">          (imported from ‘<span class="dt">Prelude</span>’ (<span class="fu">and</span> originally defined <span class="kw">in</span> ‘<span class="dt">GHC.List</span>’))</a>
<a class="sourceLine" id="cb2-13" title="13"><span class="ot">        return ::</span> <span class="kw">forall</span> (<span class="ot">m ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>) a<span class="op">.</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb2-14" title="14">          with <span class="fu">return</span> <span class="op">@</span>[] <span class="op">@</span><span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-15" title="15">          (imported from ‘<span class="dt">Prelude</span>’ (<span class="fu">and</span> originally defined <span class="kw">in</span> ‘<span class="dt">GHC.Base</span>’))</a>
<a class="sourceLine" id="cb2-16" title="16"><span class="ot">        pure ::</span> <span class="kw">forall</span> (<span class="ot">f ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>) a<span class="op">.</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb2-17" title="17">          with <span class="fu">pure</span> <span class="op">@</span>[] <span class="op">@</span><span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-18" title="18">          (imported from ‘<span class="dt">Prelude</span>’ (<span class="fu">and</span> originally defined <span class="kw">in</span> ‘<span class="dt">GHC.Base</span>’))</a>
<a class="sourceLine" id="cb2-19" title="19"><span class="ot">        mempty ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> a</a>
<a class="sourceLine" id="cb2-20" title="20">          with <span class="fu">mempty</span> <span class="op">@</span>(<span class="dt">Bool</span> <span class="ot">-&gt;</span> [a0])</a>
<a class="sourceLine" id="cb2-21" title="21">          (imported from ‘<span class="dt">Prelude</span>’ (<span class="fu">and</span> originally defined <span class="kw">in</span> ‘<span class="dt">GHC.Base</span>’))</a></code></pre></div>
<p>といった具合に、アンダースコアで始まる識別子<code>_someFunc</code>の型を<code>Bool -&gt; [a0]</code>と推論した上で<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>、実際にその型に該当する関数を、当該のスコープにおいてアクセスできる関数の中から探して教えてくれる、それが「<span class="ascii">Valid Hole Fits</span>」という機能です。</p>
<p>今回発表された「<span class="ascii">HoleFitPlugins</span>」という機能は、名前のとおりこの「<span class="ascii">Valid Hole Fits</span>」に対するプラグイン機構です。<br />
「<span class="ascii">Valid Hole Fits</span>」が表示する「型にマッチした関数」を探す処理を、<span class="ascii">Haskell</span>のコードで書き換えられるようにしてくれます！</p>
<p>「そこまでする必要あるの？」という気もしてきますが、発表者曰く</p>
<ul>
<li><span class="ascii">Hoogle</span>をはじめ、<span class="ascii">TensorFlow</span>など<span class="ascii">GHC</span>の外部にあるものを利用して「型にマッチした関数」を探せるようにするために必要</li>
<li><span class="ascii">GHCi</span>とこの機構を組み合わせることで、もっとインタラクティブな開発を促進したい</li>
</ul>
<p>という意図があるそうです。</p>
<p>最新安定版の<span class="ascii">GHC</span>では利用できませんが、<a href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/extending_ghc.html#hole-fit-plugins">ドキュメントがこちら</a>にあるので、<span class="ascii">GHC</span>の<span class="ascii">HEAD</span><small>（<span class="ascii">master</span>ブランチで開発中のバージョン）</small>をコンパイルすれば使用できるようです。</p>
<p>加えて発表では、<code>_</code>で始まる識別子を書く際の構文を拡張することで、どのように<span class="ascii">candidate</span>を探すか指定できるようにする、なんて機能も紹介されました<small>（ドキュメントを読む限りこの機能はまだ<span class="ascii">HEAD</span>に入ってない？）</small>。<br />
例えば、<span class="ascii">Hoogle</span>を使って<span class="ascii">Valid Hole Fits</span>を探したいとき、次のように書くことで検索対象を<code>Control.Applicative</code>に限定する、といったことをできるようしてくれます。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="ot">g ::</span> [a] <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb3-2" title="2">g <span class="ot">=</span> _{hoogleLookup <span class="st">&quot;+Control.Applicative&quot;</span>}</a></code></pre></div>
<p><span class="ascii">Valid Hole Fits</span>の検索方法をその場で微調整したい、というときに使うものですね。</p>
<h2 id="visible-dependent-quantification"><span class="link-to-here-outer"><a href="#visible-dependent-quantification" title="visible-dependent-quantification"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Visible dependent quantification</span></h2>
<ul>
<li>発表者<span class="ascii">: Ryan Scott</span> <em><span class="ascii">Indiana University at Bloomington, USA</span></em></li>
<li>該当の<span class="ascii">Merge Request:</span> <a href="https://gitlab.haskell.org/ghc/ghc/merge_requests/378"><span class="ascii">!378</span></a></li>
<li>該当の<span class="ascii">GHC Proposal:</span> <a href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0081-forall-arrow.rst"><span class="ascii">0081-forall-arrow</span></a></li>
</ul>
<p>タイトルのとおり、「<span class="ascii">Visible dependent quantification</span>」という機能の紹介です。</p>
<p>最近のバージョンの<span class="ascii">GHCi</span>における<code>:kind</code>コマンドは、次のような、<span class="ascii">GHC</span>がサポートしていない構文の型注釈を出力することがあります。<br />
例えば</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="op">&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XKindSignatures</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="op">&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XPolyKinds</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="op">&gt;</span> <span class="kw">data</span> <span class="dt">SomeType</span> k (<span class="ot">a ::</span> k)</a>
<a class="sourceLine" id="cb4-4" title="4"><span class="op">&gt;</span> <span class="op">:</span>kind <span class="dt">SomeType</span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="dt">SomeType</span><span class="ot"> ::</span> <span class="kw">forall</span> k <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="op">*</span></a></code></pre></div>
<p>における、<code>SomeType :: forall k -&gt; k -&gt; *</code>の<code>forall k -&gt;</code>という部分です。<br />
現在の<span class="ascii">Haskell</span>で<code>forall k</code>などと書くときは、必ず</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="dt">SomeType</span><span class="ot"> ::</span> <span class="kw">forall</span> k<span class="op">.</span> k <span class="ot">-&gt;</span> <span class="op">*</span></a></code></pre></div>
<p>といった具合に、ピリオドで区切った構文になります。<br />
ところが先ほどの<code>:kind</code>の出力では、<code>forall k -&gt;</code>とあるとおり、<code>forall k</code>に<small>（型ではなく、カインドとしての）</small>関数を表す<code>-&gt;</code>が使われています。<br />
「<span class="ascii">Visible dependent quantification</span>」はまさにこれを、<code>:kind</code>コマンドによって出力される構文だけではなく、ユーザーが直接書ける構文にしよう、というものです。 <span class="ascii">GHC</span>に「依存型」という機能を加える「<span class="ascii">Dependent Haskell</span>」にも必要な機能だそうです。<br />
私自身はこの機能を使う機会がちょっと思い浮かばなかったので省略しますが、より詳しい解説は発表者である<a href="https://ryanglscott.github.io/2019/03/15/visible-dependent-quantification-in-haskell/"><span class="ascii">Ryan</span>自身による記事（英語）</a>をご覧ください。何が「<span class="ascii">Visible</span>」でどう「<span class="ascii">Dependent</span>」なのかわかるはずです。</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>復習<span class="ascii">:</span> この、「アンダースコアで始まる識別子<code>_someFunc</code>の型を<code>Bool -&gt; [a0]</code>と推論した上で」エラーメッセージにおいて<code>Found hole: _someFunc :: Bool -&gt; [a0]</code>と教えてくれるのが「<span class="ascii">Type Hole</span>」という機能なのでした。<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/hiw-gibbon.html" lang="ja">HIW 2019で発表された、Gibbonコンパイラーについて</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/hiw-ghc8.8.html" style="margin-left: auto;" lang="ja">HIW 2019で発表された、GHC 8.8で導入された機能</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>HIW 2019で発表された、GHC 8.8で導入された機能</title>
    <link href="https://haskell.jp/blog/posts/2019/hiw-ghc8.8.html" />
    <id>https://haskell.jp/blog/posts/2019/hiw-ghc8.8.html</id>
    <published>2019-09-11T00:00:00Z</published>
    <updated>2019-09-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>こんにちは。<br />
今回からいくつか、「<a href="https://icfp19.sigplan.org/home/hiw-2019#About"><span class="ascii">Haskell Implementors</span>’ <span class="ascii">Workshop 2019</span></a>」に私が先月参加した際のレポートとして、印象深い発表をテーマごとに分けた短い記事を執筆します。<br />
最近公開された<a href="https://www.haskell.org/ghc/download_ghc_8_8_1.html"><span class="ascii">GHC 8.8</span></a>の話はもちろん、未来の<span class="ascii">GHC</span>やその他の<span class="ascii">Haskell</span>の処理系を知るのによいイベントでしたので、その一部だけでも伝われば幸いです。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#そもそもhaskell-implementors-workshop-hiwとは" title="そもそもhaskell-implementors-workshop-hiwとは">そもそも<span class="ascii">Haskell Implementors</span>’ <span class="ascii">Workshop (HIW)</span>とは？</a></li>
<li><a href="#hie-files-in-ghc-8.8" title="hie-files-in-ghc-8.8"><span class="ascii">HIE files in GHC 8.8</span></a></li>
<li><a href="#ghc-status-report" title="ghc-status-report"><span class="ascii">GHC status report</span></a></li>
<li><a href="#とりあえず今回はここまで" title="とりあえず今回はここまで">とりあえず今回はここまで</a></li>
</ul>
</div>
</div>
<h1 id="そもそもhaskell-implementors-workshop-hiwとは"><span class="link-to-here-outer"><a href="#そもそもhaskell-implementors-workshop-hiwとは" title="そもそもhaskell-implementors-workshop-hiwとは"><span class="link-to-here">Link to<br />
here</span></a></span>そもそも<span class="ascii">Haskell Implementors</span>’ <span class="ascii">Workshop (HIW)</span>とは？</h1>
<p>シリーズ（？）第<span class="ascii">1</span>回目なので、簡単に<span class="ascii">HIW</span>そのものについて紹介しておきましょう。<br />
<span class="ascii">HIW</span>は、<a href="https://icfp19.sigplan.org/home"><span class="ascii">ICFP (International Conference on Functional Programming)</span></a>という関数型プログラミングについての国際会議に併設された、<span class="ascii">Haskell</span>の実装者のためのワークショップです。<br />
名前の通り、<span class="ascii">GHC</span>をはじめとする<span class="ascii">Haskell</span>の処理系<small>（あるいは、<span class="ascii">Haskell</span>で実装された言語処理系）</small>の実装に関する発表だけでなく、かなり緩いテーマの<span class="ascii">Lightning Talk</span>の時間があったり、<span class="ascii">GHC</span>の将来の方向性について自由に議論する時間もあったりしました。</p>
<p>今回はそのうち、掲題のとおり「<span class="ascii">HIW 2019</span>で発表された、<span class="ascii">GHC 8.8</span>で導入された機能」を紹介します。まずは「<span class="ascii">HIE files in GHC 8.8</span>」から。</p>
<h1 id="hie-files-in-ghc-8.8"><span class="link-to-here-outer"><a href="#hie-files-in-ghc-8.8" title="hie-files-in-ghc-8.8"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">HIE files in GHC 8.8</span></h1>
<p>発表者<span class="ascii">: Zubin Duggal, Matthew Pickering</span> <em><span class="ascii">University of Bristol</span></em></p>
<p><span class="ascii">GHC 8.8</span>で新たに追加された、<span class="ascii">HIE</span><small>（「<span class="ascii">Haskell Interface Extended</span>」の略と思われます）</small>ファイルについての発表です。<br />
コンパイル時に<span class="ascii">GHC</span>が得たモジュールの情報を、<a href="https://github.com/haskell/haskell-ide-engine"><span class="ascii">Haskell IDE Engine</span></a>などの<span class="ascii">IDE</span>のバックエンドが再利用しやすい形で出力する機能です。<br />
従来<span class="ascii">Haskell IDE Engine</span><small>（その裏で使われている<span class="ascii">ghc-mod</span>）</small>や<a href="https://github.com/ndmitchell/ghcid"><span class="ascii">ghcid</span></a>、<a href="https://github.com/chrisdone/intero"><span class="ascii">intero</span></a>などの、「<span class="ascii">IDE</span>バックエンド」<small>（エディターが入力の補完や入力したソースコードにおけるエラーを表示する際に通信するソフトウェア）</small>は、自前で<span class="ascii">GHC API</span>や<span class="ascii">GHCi</span>を呼ぶことで、型チェックしたり定義ジャンプに必要な位置情報を収集したりしていたのですが、そうした情報の収集をすべて<span class="ascii">GHC</span>自身が<span class="ascii">HIE</span>ファイルを出力することで賄えるようになる、ということです。</p>
<p>私は従来開発中、<code>stack test --pedantic --file-watch</code>などと<span class="ascii">Neovim</span>のターミナル機能で実行して実行ファイルをビルドしつつ、<span class="ascii">HIE</span>にエラーの表示や入力の補完をさせていたのですが、その際も二重にソースコードが解析されていたんですね！<br />
私がそのようにわざわざ<code>stack test</code>と<span class="ascii">HIE</span>を並行して実行させているのは、<span class="ascii">HIE</span>がしばしばフリーズしてしまったり<small>（<span class="ascii">Neovim</span>ごと再起動すれば直ることも多いんですが…😰）</small>、<span class="ascii">HIE</span>だけでは実行ファイルの作成やテストの実行ができない、という理由があるためです。<br />
<code>stack test</code>だけで<span class="ascii">HIE</span>ファイルが生成されるようになれば、エラーに関する情報やソースコードの解析結果といった情報が一元化されるので、より安定的に、より少ないリソースで<span class="ascii">HIE</span>が使えるようになるでしょう。本家<span class="ascii">Haskell IDE Engine</span>がサポートする日が楽しみです。</p>
<p>この、<span class="ascii">HIE</span>ファイルを利用するアプリケーションの例も紹介されました。<br />
<a href="https://github.com/wz1000/hie-lsp"><span class="ascii">hie-lsp</span></a>という小さな<span class="ascii">Language Server Protocol</span>の実装に加え、<a href="https://github.com/mpickering/hie-lsif"><span class="ascii">hie-lsif</span></a>という、<span class="ascii">HIE</span>ファイルから「<a href="https://github.com/microsoft/language-server-protocol/blob/master/indexFormat/specification.md"><span class="ascii">Language Server Index Format (LSIF)</span></a>」形式のファイルを作成するコマンドが印象的でした。<br />
この<span class="ascii">LSIF</span>というファイルは、例えば<span class="ascii">GitHub</span>のリポジトリ上でブラウザからソースコードを閲覧する際にも、定義ジャンプといった便利な機能を使えるようにするためのものです。リポジトリに置いたソースコードを処理系がどのように解釈したかを保存しておくことで、<span class="ascii">Language Server</span>はじめ処理系を実行することなく利用できるようにするものだそうです。<br />
現状は仕様策定中なためか、実際に<span class="ascii">LSIF</span>を解釈するアプリケーションは見つかりませんでしたが、今後の活用に期待が高まりますね。</p>
<p>加えて、<span class="ascii">HIE</span>ファイルが将来的にサポートしたい機能などについても発表されました。</p>
<ul>
<li>型クラスのインスタンスが、具体的にどの型のインスタンスとして解決されたかの出力
<ul>
<li>定義ジャンプしたときに、型クラス自身の宣言ではなく、実装に飛べるようにするため</li>
</ul></li>
<li>従来<span class="ascii">GHC</span>が分割コンパイルをサポートするために、モジュールの依存情報を出力していた「インターフェースファイル<small>（<code>.hi</code>という拡張子で出力されているあのファイル）</small>」との統合</li>
<li>すべての型推論の結果</li>
</ul>
<h1 id="ghc-status-report"><span class="link-to-here-outer"><a href="#ghc-status-report" title="ghc-status-report"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">GHC status report</span></h1>
<p>発表者<span class="ascii">: Simon Peyton Jones</span> <em><span class="ascii">Microsoft, UK</span></em></p>
<p><span class="ascii">GitLab</span>への移行や<span class="ascii">Hadrian</span>と呼ばれる新しいビルドシステムの導入など、インフラ周りでいろいろ変更があったこともあり、遅れてしまいましたが<span class="ascii">GHC 8.8</span>がもうすぐ出るよ、という内容の発表でした<small>（発表当時。もう<a href="https://www.haskell.org/ghc/blog/20190825-ghc-8.8.1-released.html"><span class="ascii">GHC 8.8</span>はリリースされています</a>）</small>。</p>
<p>言及された主な追加機能は以下のとおりです。</p>
<ul>
<li><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-TypeApplications"><code>TypeApplications</code></a>という言語拡張が、型変数だけでなくカインド変数に対しても適用できるようになりました。<br />
正直に言って、個人的に使いどころがまだまだなさそうな機能ではありますが…。</li>
<li><p><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-ScopedTypeVariables"><code>ScopedTypeVariables</code></a>という言語拡張を使った場合に、パターンマッチした変数に型注釈を付けることができるようになる、という機能がありまして、これが拡張されました。<br />
具体的には、従来下記のように書くことで、関数自体の型注釈にある型変数<code>a</code>と、パターンマッチした変数<code>x</code>に型注釈した<code>b</code>が等しくなるように書くことができたのを、</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="ot">f ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-2" title="2">f (<span class="dt">Just</span> (<span class="ot">x ::</span> b)) <span class="ot">=</span> <span class="co">{- ... -}</span></a></code></pre></div>
<p>さらに拡張して、関数自体の型注釈にある型変数<strong>ではない</strong><code>Int</code>と、パターンマッチした変数<code>x</code>に型注釈した<code>b</code>が等しくなるように書くことができるようにした、という拡張です。<br />
あたかも型変数でパターンマッチしているかのようですね。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="ot">f ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-2" title="2">f (<span class="dt">Just</span> (<span class="ot">x ::</span> b)) <span class="ot">=</span> <span class="co">{- ... -}</span></a></code></pre></div>
<p>一体何の役に立つの？とも思いましたが、<a href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0128-scoped-type-variables-types.rst#128motivation">この修正に向けた提案</a>曰く、</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="ot">f ::</span> <span class="dt">ReallyReallyReallyReallyLongTypeName</span> <span class="ot">-&gt;</span> <span class="dt">T</span></a>
<a class="sourceLine" id="cb3-2" title="2">f (<span class="ot">x ::</span> a) <span class="ot">=</span> … (<span class="fu">read</span> <span class="st">&quot;&quot;</span><span class="ot"> ::</span> a) …</a></code></pre></div>
<p>と書くことで、長い型名に対して別名を付けることができるようになる、というメリットがあるそうです。なるほど💡</p></li>
</ul>
<h1 id="とりあえず今回はここまで"><span class="link-to-here-outer"><a href="#とりあえず今回はここまで" title="とりあえず今回はここまで"><span class="link-to-here">Link to<br />
here</span></a></span>とりあえず今回はここまで</h1>
<p>テーマを絞って短い記事にした方が<span class="ascii">SEO</span>的にいいんじゃないかと思いまして、今回は敢えて紹介する発表を絞りました。<br />
今後は下記のテーマについて紹介する予定です。</p>
<ul>
<li><span class="ascii">HIW 2019</span>で発表された、これからの<span class="ascii">GHC</span>に入るであろう機能</li>
<li><span class="ascii">HIW 2019</span>で発表された、<span class="ascii">GHC</span>以外の言語処理系</li>
</ul>
<p>また、<span class="ascii">HIW</span>と同じく<span class="ascii">ICFP 2019</span>に併設して開催された、<a href="https://icfp19.sigplan.org/home/haskellsymp-2019"><span class="ascii">Haskell Symposium 2019</span></a>の発表についても別途共有する予定です。<br />
乞うご期待。<br />
<span class="ascii">hask(_ _)eller</span></p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/hiw-ghc-future.html" lang="ja">HIW 2019で発表された、GHC 8.10に導入されるであろう機能</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/fallible.html" style="margin-left: auto;" lang="ja">fallibleというパッケージをリリースしました</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>fallibleというパッケージをリリースしました</title>
    <link href="https://haskell.jp/blog/posts/2019/fallible.html" />
    <id>https://haskell.jp/blog/posts/2019/fallible.html</id>
    <published>2019-07-18T00:00:00Z</published>
    <updated>2019-07-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>タイトルの通り、<span class="ascii">fallible</span>というパッケージを紹介します。</p>
<ul>
<li><a href="https://github.com/matsubara0507/fallible"><span class="ascii">matsubara0507/fallible: interface for fallible data type like Maybe and Either. - GitHub</span></a></li>
</ul>
<p>ちなみに、<span class="ascii">fallible</span>は<span class="ascii">Haskell-jp Slack</span>で<span class="ascii">:</span></p>
<p><img src="../../img/2019/fallible/slack.jpg" style="width: 100%;"></p>
<p>と質問したところ、該当するようなパッケージは無さそうだったので作ったという経緯があります。 その際に助言をくれた <a href="https://github.com/fumieval"><span class="ascii">fumieval</span></a>氏のコードをほとんど引用した形になったので、<span class="ascii">Haskell-jp Blog</span>に紹介記事を載せることにしました<span class="ascii">(</span>僕は普段、自分のブログに自作したパッケージを書いています<span class="ascii">)</span>。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#fallibleパッケージ" title="fallibleパッケージ"><span class="ascii">fallible</span>パッケージ</a>
<ul>
<li><a href="#やってること" title="やってること">やってること</a></li>
<li><a href="#基本演算子" title="基本演算子">基本演算子</a></li>
</ul></li>
<li><a href="#サンプルコード" title="サンプルコード">サンプルコード</a></li>
<li><a href="#使い方" title="使い方">使い方</a></li>
<li><a href="#おしまい" title="おしまい">おしまい</a></li>
</ul>
</div>
</div>
<h2 id="fallibleパッケージ"><span class="link-to-here-outer"><a href="#fallibleパッケージ" title="fallibleパッケージ"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">fallible</span>パッケージ</h2>
<p><span class="ascii">Haskell</span>でアプリケーションを記述してると次のようなコードを書くことがありますよね？</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.List</span> <span class="kw">as</span> <span class="dt">L</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="ot">run ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Token</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-4" title="4">run targetName token verbose <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-5" title="5">  users <span class="ot">&lt;-</span> getUsers token</a>
<a class="sourceLine" id="cb1-6" title="6">  <span class="kw">case</span> users <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-7" title="7">    <span class="dt">Left</span> err <span class="ot">-&gt;</span> logDebug&#39; err</a>
<a class="sourceLine" id="cb1-8" title="8">    <span class="dt">Right</span> us <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-9" title="9">      <span class="kw">case</span> userId <span class="op">&lt;$&gt;</span> L.find isTarget us <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-10" title="10">        <span class="dt">Nothing</span>  <span class="ot">-&gt;</span> logDebug&#39; emsg</a>
<a class="sourceLine" id="cb1-11" title="11">        <span class="dt">Just</span> tid <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-12" title="12">          channels <span class="ot">&lt;-</span> getChannels token</a>
<a class="sourceLine" id="cb1-13" title="13">          <span class="kw">case</span> channels <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-14" title="14">            <span class="dt">Left</span> err  <span class="ot">-&gt;</span> logDebug&#39; err</a>
<a class="sourceLine" id="cb1-15" title="15">            <span class="dt">Right</span> chs <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-16" title="16">              <span class="kw">let</span> chs&#39; <span class="ot">=</span> <span class="fu">filter</span> (<span class="fu">elem</span> tid <span class="op">.</span> channelMembers) chs</a>
<a class="sourceLine" id="cb1-17" title="17">              <span class="fu">mapM_</span> (logDebug&#39; <span class="op">.</span> channelName) chs&#39;</a>
<a class="sourceLine" id="cb1-18" title="18">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-19" title="19">    logDebug&#39; <span class="ot">=</span> logDebug verbose</a>
<a class="sourceLine" id="cb1-20" title="20">    emsg <span class="ot">=</span> <span class="st">&quot;user not found: &quot;</span> <span class="op">++</span> targetName</a>
<a class="sourceLine" id="cb1-21" title="21">    isTarget user <span class="ot">=</span> userName user <span class="op">==</span> targetName</a>
<a class="sourceLine" id="cb1-22" title="22"></a>
<a class="sourceLine" id="cb1-23" title="23"><span class="ot">logDebug ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-24" title="24">logDebug verbose msg <span class="ot">=</span> <span class="kw">if</span> verbose <span class="kw">then</span> <span class="fu">putStrLn</span> msg <span class="kw">else</span> <span class="fu">pure</span> ()</a></code></pre></div>
<p><span class="ascii">Slack</span>のようなチャットツールをイメージしてください。 該当の名前<span class="ascii">(</span><code>targetName</code><span class="ascii">)</span>を持つユーザーを与えると、そのユーザーが参加しているチャンネルの一覧を表示するというような振る舞いです。 こう段々になってしまうのは気持ち悪いですよね。 <span class="ascii">fallible</span>の目的はこの段々を次のように平坦にすることです<span class="ascii">(</span><code>where</code> などは割愛<span class="ascii">):</span></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">import</span> <span class="dt">Data.Fallible</span> (evalContT, exit, lift, (!?=), (???))</a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="ot">run ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Token</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-4" title="4">run targetName token verbose <span class="ot">=</span> evalContT <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-5" title="5">  users    <span class="ot">&lt;-</span> lift (getUsers token) <span class="op">!?=</span> exit <span class="op">.</span> logDebug&#39;</a>
<a class="sourceLine" id="cb2-6" title="6">  targetId <span class="ot">&lt;-</span> userId <span class="op">&lt;$&gt;</span> L.find isTarget users <span class="op">???</span> exit (logDebug&#39; emsg)</a>
<a class="sourceLine" id="cb2-7" title="7">  channels <span class="ot">&lt;-</span> lift (getChannels token) <span class="op">!?=</span> exit <span class="op">.</span> logDebug&#39;</a>
<a class="sourceLine" id="cb2-8" title="8">  lift <span class="op">$</span> <span class="fu">mapM_</span> (logDebug&#39; <span class="op">.</span> channelName) <span class="op">$</span></a>
<a class="sourceLine" id="cb2-9" title="9">    <span class="fu">filter</span> (<span class="fu">elem</span> targetId <span class="op">.</span> channelMembers) channels</a></code></pre></div>
<h3 id="やってること"><span class="link-to-here-outer"><a href="#やってること" title="やってること"><span class="link-to-here">Link to<br />
here</span></a></span>やってること</h3>
<p>というか、もともとのアイデアは下記のブログです<span class="ascii">:</span></p>
<ul>
<li><a href="https://haskell.e-bigmoon.com/posts/2018/06-26-cont-param.html"><span class="ascii">ContT</span> を使ってコードを綺麗にしよう！ <span class="ascii">- BIGMOON Haskeller</span>’<span class="ascii">s BLOG</span></a></li>
</ul>
<p>これを一般化<span class="ascii">(</span><code>Maybe a</code> 固有ではなく <code>Either e a</code> でも使う<span class="ascii">)</span>できないかなぁというのがもともとの発想です。</p>
<h3 id="基本演算子"><span class="link-to-here-outer"><a href="#基本演算子" title="基本演算子"><span class="link-to-here">Link to<br />
here</span></a></span>基本演算子</h3>
<p>次の<span class="ascii">4</span>つの演算子を利用します<span class="ascii">:</span></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="ot">(!?=) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m (<span class="dt">Either</span> e a) <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="ot">(!??) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m (<span class="dt">Maybe</span> a) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb3-3" title="3"><span class="ot">(??=) ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Either</span> e a <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> f a) <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb3-4" title="4"><span class="ot">(???) ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a</a></code></pre></div>
<p>ただし、内部実装的には <code>Maybe a</code> や <code>Either e a</code> は <code>Fallible</code> 型クラスで一般化されています<span class="ascii">:</span></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">class</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Fallible</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" title="2">  <span class="kw">type</span> <span class="dt">Failure</span><span class="ot"> f ::</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="ot">  tryFallible ::</span> f a <span class="ot">-&gt;</span> <span class="dt">Either</span> (<span class="dt">Failure</span> f) a</a>
<a class="sourceLine" id="cb4-4" title="4"></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="kw">instance</span> <span class="dt">Fallible</span> <span class="dt">Maybe</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-6" title="6">  <span class="kw">type</span> <span class="dt">Failure</span> <span class="dt">Maybe</span> <span class="ot">=</span> ()</a>
<a class="sourceLine" id="cb4-7" title="7">  tryFallible <span class="ot">=</span> <span class="fu">maybe</span> (<span class="dt">Left</span> ()) <span class="dt">Right</span></a>
<a class="sourceLine" id="cb4-8" title="8"></a>
<a class="sourceLine" id="cb4-9" title="9"><span class="kw">instance</span> <span class="dt">Fallible</span> (<span class="dt">Either</span> e) <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-10" title="10">  <span class="kw">type</span> <span class="dt">Failure</span> (<span class="dt">Either</span> e) <span class="ot">=</span> e</a>
<a class="sourceLine" id="cb4-11" title="11">  tryFallible <span class="ot">=</span> <span class="fu">id</span></a>
<a class="sourceLine" id="cb4-12" title="12"></a>
<a class="sourceLine" id="cb4-13" title="13"><span class="ot">(!?=) ::</span> (<span class="dt">Monad</span> m, <span class="dt">Fallible</span> t) <span class="ot">=&gt;</span> m (t a) <span class="ot">-&gt;</span> (<span class="dt">Failure</span> t <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb4-14" title="14"><span class="ot">(???) ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Fallible</span> t) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a</a></code></pre></div>
<p>これらを継続モナドと組み合わせることで<span class="ascii">IO</span>と失敗系モナド<span class="ascii">(</span><code>Maybe a</code> や <code>Either e a</code><span class="ascii">)</span>を、モナドトランスフォーマーなしに<span class="ascii">Do</span>記法で書くことができます！</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="co">-- 継続モナドに関する関数</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="ot">evalConstT ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ContT</span> r m r <span class="ot">-&gt;</span> m r</a>
<a class="sourceLine" id="cb5-3" title="3"></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="ot">exit ::</span> m r <span class="ot">-&gt;</span> <span class="dt">ContT</span> r m a</a>
<a class="sourceLine" id="cb5-5" title="5">exit <span class="ot">=</span> <span class="dt">ContT</span> <span class="op">.</span> <span class="fu">const</span></a></code></pre></div>
<h2 id="サンプルコード"><span class="link-to-here-outer"><a href="#サンプルコード" title="サンプルコード"><span class="link-to-here">Link to<br />
here</span></a></span>サンプルコード</h2>
<p>疑似的な<span class="ascii">IO</span>で良いなら<a href="https://github.com/matsubara0507/fallible/tree/master/example"><span class="ascii">fallible</span>リポジトリの<span class="ascii">example</span>ディレクトリ</a>にあります<span class="ascii">(</span>上述の例はそれです<span class="ascii">)</span>。</p>
<p>実際の利用例であれば、最近自作した<a href="https://github.com/matsubara0507/mixlogue"><span class="ascii">matsubara0507/mixlogue</span></a>という<span class="ascii">Haskell</span>アプリケーションで多用しています<span class="ascii">(</span><a href="https://github.com/matsubara0507/mixlogue/blob/8afd16ab4048ff62976b8e38347078fdaa7417dd/src/Mixlogue/Cmd.hs#L81-L93">ココ</a>とか<a href="https://github.com/matsubara0507/mixlogue/blob/8afd16ab4048ff62976b8e38347078fdaa7417dd/src/Mixlogue/Message.hs#L15-L25">ココ</a>とか<span class="ascii">)</span>。 ちなみに、<span class="ascii">mixlogue</span>は特定の<span class="ascii">Slack</span>の分報チャンネル<span class="ascii">(</span><code>times_hoge</code><span class="ascii">)</span>の発言を収集するというだけのツールです。</p>
<h2 id="使い方"><span class="link-to-here-outer"><a href="#使い方" title="使い方"><span class="link-to-here">Link to<br />
here</span></a></span>使い方</h2>
<p><span class="ascii">README</span>を参照してください。</p>
<p>現状<span class="ascii">Hackage</span>にはあげてないので、<span class="ascii">stack</span>や<span class="ascii">Cabal</span>で<span class="ascii">GitHub</span>リポジトリから参照する方法を利用してください。</p>
<h2 id="おしまい"><span class="link-to-here-outer"><a href="#おしまい" title="おしまい"><span class="link-to-here">Link to<br />
here</span></a></span>おしまい</h2>
<p><span class="ascii">fumieval</span>氏のコードをほとんど引用するだけになったので自分でリリースするか迷ったんですけど、リリースしてくれというのも丸投げがひどいので自分でリリースしました。 まぁこういう結果が生まれるのも<span class="ascii">OSS</span>コミュニティの醍醐味ということで。 <span class="ascii">fumieval</span>氏、いつもアドバイスをくれてありがとう！</p>
<p><span class="ascii">(</span>もちろん他の<span class="ascii">Haskell-jp</span>の皆さんも！<span class="ascii">)</span></p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/hiw-ghc8.8.html" lang="ja">HIW 2019で発表された、GHC 8.8で導入された機能</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/strip-ansi-escape.html" style="margin-left: auto;" lang="ja">strip-ansi-escapeというパッケージをリリースしました</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>strip-ansi-escapeというパッケージをリリースしました</title>
    <link href="https://haskell.jp/blog/posts/2019/strip-ansi-escape.html" />
    <id>https://haskell.jp/blog/posts/2019/strip-ansi-escape.html</id>
    <published>2019-07-08T00:00:00Z</published>
    <updated>2019-07-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>現職で<span class="ascii">Haskell</span>を仕事で書き始めるようになってからというもの、度々小さなパッケージをリリースするようになりました。<br />
敢えてパッケージにするほどのものでもなさそうなぐらい小さなものが多いですが、もし再利用したくなったらな、という気持ちで書いております。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#なに作ったか" title="なに作ったか">なに作ったか</a></li>
<li><a href="#なぜ作ったか" title="なぜ作ったか">なぜ作ったか</a></li>
<li><a href="#最近のmmlh" title="最近のmmlh">最近の<span class="ascii">mmlh</span></a></li>
</ul>
</div>
</div>
<h1 id="なに作ったか"><span class="link-to-here-outer"><a href="#なに作ったか" title="なに作ったか"><span class="link-to-here">Link to<br />
here</span></a></span>なに作ったか</h1>
<p><a href="http://hackage.haskell.org/package/strip-ansi-escape"><span class="ascii">strip-ansi-escape</span></a>というパッケージです。<br />
今回もメインの処理は<span class="ascii">100</span>行にも満たないような小さなもので、また用途もニッチです。<br />
具体的には、名前のとおり<a href="https://en.wikipedia.org/wiki/ANSI_escape_code"><span class="ascii">ANSI</span>エスケープコード</a>を文字列から取り除く、ただそれだけです。<br />
使い方も極めてシンプル<span class="ascii">:</span></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1">ghci<span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">Data.String.AnsiEscapeCodes.Strip.Text</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="co">-- 現状Text型向けにしか作っていないため、OverloadedStringsを有効にした方が使いやすい</span></a>
<a class="sourceLine" id="cb1-4" title="4">ghci<span class="op">&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XOverloadedStrings</span></a>
<a class="sourceLine" id="cb1-5" title="5">ghci<span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">Data.Text</span></a>
<a class="sourceLine" id="cb1-6" title="6"></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="co">-- 出力すると下線付きで &quot;hello&quot; と表示されるANSIエスケープコード付きの文字列</span></a>
<a class="sourceLine" id="cb1-8" title="8">ghci<span class="op">&gt;</span> <span class="st">&quot;\x001B[4mhello\x001B[0m&quot;</span></a>
<a class="sourceLine" id="cb1-9" title="9"><span class="st">&quot;\ESC[4mhello\ESC[0m&quot;</span></a>
<a class="sourceLine" id="cb1-10" title="10"></a>
<a class="sourceLine" id="cb1-11" title="11">ghci<span class="op">&gt;</span> stripAnsiEscapeCodes <span class="st">&quot;\x001B[4mhello\x001B[0m&quot;</span></a>
<a class="sourceLine" id="cb1-12" title="12"><span class="st">&quot;hello&quot;</span></a></code></pre></div>
<h1 id="なぜ作ったか"><span class="link-to-here-outer"><a href="#なぜ作ったか" title="なぜ作ったか"><span class="link-to-here">Link to<br />
here</span></a></span>なぜ作ったか</h1>
<p>通常我々が<span class="ascii">ANSI</span>エスケープコードを扱うときは、<strong>ユーザーのために</strong>端末に文字列を分かりやすく表示したいときで、それをプログラムで再利用することは想定していません。<br />
そのため<span class="ascii">ANSI</span>エスケープコードを出力できるアプリケーションは、大抵の場合出力しないよう設定できる<small>（あるいは、出力先が<span class="ascii">tty</span>でないことを検出して出力しない）</small>ようになっています。<br />
なので、プログラムが<span class="ascii">ANSI</span>エスケープコードの混ざった文字列を扱わざるを得ない、という事態は、何かがおかしい事態だと言えるでしょう。</p>
<p>一体どういう事態なのかというと、それは私がずっと開発中の、対話的<span class="ascii">Haskell</span>入門コンテンツ — <a href="https://github.com/haskell-jp/makeMistakesToLearnHaskell">「失敗しながら学ぶ<span class="ascii">Haskell</span>入門」</a> — で出遭った事態でした。<br />
「失敗しながら学ぶ<span class="ascii">Haskell</span>入門」（以下、英語名を略して「<span class="ascii">mmlh</span>」と呼びます）では、ユーザーが書いた<span class="ascii">Haskell</span>のソースコードを受け取って、<span class="ascii">GHC</span>にコンパイルさせることで、型エラーなどのエラーメッセージを取得しています。<br />
当初から<span class="ascii">mmlh</span>はそれを簡単にパースしてユーザーへのヒントを出すのに使ったり、ユーザーにそのまま表示したりするのに使うため、<code>-fdiagnostics-color=always</code>というオプションを<span class="ascii">GHC</span>に渡していました。<br />
これは、エラーメッセージに色を着けるようになった<span class="ascii">GHC 8.2</span>から導入されたオプションで、「エラーメッセージに必ず<small>（<span class="ascii">ANSI</span>エスケープコードを使って）</small>色を着ける」というものです。<br />
<span class="ascii">GHC</span>が出すエラーメッセージを「簡単にパース」しつつ「ユーザーにそのまま表示」する、という<span class="ascii">2</span>つの要件を満たすためには、このオプションを利用して、強制的にエラーメッセージに色を着ける必要がありました。</p>
<p>さらに最近、<span class="ascii">GHC</span>が出したエラーメッセージをファイルに保存して、<a href="https://github.com/haskell-jp/makeMistakesToLearnHaskell/issues/101"><span class="ascii">GitHub</span>で閲覧できるようにする</a><small>（正確には、閲覧して各行にコメントできるようにする）</small>、という機能も追加した結果、<span class="ascii">ANSI</span>エスケープコードを取り除かざるを得なくなってしまったのです。<br />
というのも、<code>-fdiagnostics-color=always</code>を有効にしている限り、<span class="ascii">GHC</span>は必ず<span class="ascii">ANSI</span>エスケープコードをエラーメッセージに混ぜるので、ファイルに保存して<span class="ascii">GitHub</span>上で表示する際、下記のように余計な文字として混ざってしまい、エラーメッセージが読みづらくなってしまうためです。</p>
<pre><code>�[;1m16.hs:19:18: �[;1m�[31merror:�[0m�[0m�[;1m�[0m�[0m�[;1m
    • No instance for (Num ([Char], String))
        arising from a use of ‘countWords’
    • In the expression: countWords (concat wordsList)
      In an equation for ‘countMap’:
          countMap = countWords (concat wordsList)
      In the expression:
        do paths &lt;- getArgs
           wordsList &lt;- for paths scrapeWords
           let countMap = countWords (concat wordsList)
           for_ (toList countMap) catCount�[0m�[0m
�[;1m�[34m   |�[0m�[0m
�[;1m�[34m19 |�[0m�[0m   let countMap = �[;1m�[31mcountWords (concat wordsList)�[0m�[0m
�[;1m�[34m   |�[0m�[0m�[;1m�[31m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^�[0m�[0m
�[0m�[0m�[0m</code></pre>
<p><code>-fdiagnostics-color=always</code>を有効にしなければこんな問題は起こらないのですが、そうすると今度はユーザーにエラーメッセージを表示させる際、色が着かなくなってしまいます。<br />
せっかく<span class="ascii">GHC 8.2</span>以降を使っているのに色つきのエラーメッセージが見られないのは残念ですよね。<br />
<span class="ascii">GHC</span>を<span class="ascii">2</span>回実行することで、ユーザーに表示する用のエラーメッセージとファイルに保存する用のエラーメッセージを分けることもできますが、それでは効率が悪いでしょうし。</p>
<p>そんなわけで、<span class="ascii">GHC</span>が出力するエラーメッセージを<strong>ユーザーに端末上で表示する用途と、<span class="ascii">ANSI</span>エスケープコードを解釈しない箇所で表示する用途</strong>、両方に使用したくなったため、今回敢えて<span class="ascii">ANSI</span>エスケープコードを取り除くライブラリーを作りました。<br />
もし他に同じような事態に出遭った方がいらっしゃいましたら、試してみてください🙏</p>
<h1 id="最近のmmlh"><span class="link-to-here-outer"><a href="#最近のmmlh" title="最近のmmlh"><span class="link-to-here">Link to<br />
here</span></a></span>最近の<span class="ascii">mmlh</span></h1>
<p>ついでにここ数ヶ月弊社でやっている、<span class="ascii">mmlh</span>を使った社内勉強会のお話も書こうかと思いましたが、やっぱり社内でのことなんで、<a href="https://eng-blog.iij.ad.jp/">会社のブログ</a>に書くことにします。<br />
<del>多分今週中には上げますので乞うご期待！</del><br />
⬇️大分遅くなってしまいましたが公開しました！</p>
<p><a href="https://eng-blog.iij.ad.jp/archives/3467"><span class="ascii">Haskell</span>社内勉強会と<span class="ascii">Haskell</span>学習ツールの紹介 <span class="ascii">| IIJ Engineers Blog</span></a></p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/fallible.html" lang="ja">fallibleというパッケージをリリースしました</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/asterius.html" style="margin-left: auto;" lang="ja">AsteriusでHaskellの関数をJSから呼べるようにしてみた（けど失敗）（拡大版）</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>

</feed>
