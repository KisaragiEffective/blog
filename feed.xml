<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Haskell-jp Blog</title>
    <link href="https://haskell.jp/blog/feed.xml" rel="self" />
    <link href="https://haskell.jp/blog" />
    <id>https://haskell.jp/blog/feed.xml</id>
    <author>
        <name>Haskell-jp</name>
        <email></email>
    </author>
    <updated>2021-06-14T00:00:00Z</updated>
    <entry>
    <title>Haskell Day 2021を開催します</title>
    <link href="https://haskell.jp/blog/posts/2021/haskell-day-2021.html" />
    <id>https://haskell.jp/blog/posts/2021/haskell-day-2021.html</id>
    <published>2021-06-14T00:00:00Z</published>
    <updated>2021-06-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <p><a href="https://haskell.jp/haskell-day-2021/"><span class="ascii">Haskell Day 2021</span></a>を開催します！</p>
<p><a href="https://haskell.jp/haskell-day-2021/"><img src="../../img/2021/haskell-day-2021/ogp.png" alt="Haskell Day 2021" /></a></p>
<p>こんにちは<span class="ascii">kakkun61</span>こと岡本和樹です。</p>
<p>この記事では<a href="https://haskell.jp/haskell-day-2021/"><span class="ascii">Haskell Day 2021</span></a>の紹介と開催の経緯などを記載します。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#経緯" title="経緯">経緯</a></li>
<li><a href="#発表者募集" title="発表者募集">発表者募集</a></li>
<li><a href="#参加登録" title="参加登録">参加登録</a></li>
</ul>
</div>
</div>
<h1 id="経緯"><span class="link-to-here-outer"><a href="#経緯" title="経緯"><span class="link-to-here">Link to<br />
here</span></a></span>経緯</h1>
<p><span class="ascii">Haskell Day</span>は日本語で開催される<span class="ascii">Haskell</span>に関するイベントとしては最多の参加者を誇るイベントです。これまで<span class="ascii">2012</span>・<span class="ascii">2016</span>・<span class="ascii">2018</span>・<span class="ascii">2019</span>と開催してきました。新型コロナウイルスの影響により、残念ながら<span class="ascii">2020</span>は開催しませんでしたが、<span class="ascii">2021</span>は<em>オンライン</em>イベントとして開催します。</p>
<p>このようなオンラインイベントの開催は未経験だったため、さまざまなイベント形式を検討した結果、今回は事前録画動画の予約公開という形式を採用しました。生放送ももちろん検討しましたが、ノウハウ不足の中で一発勝負という生放送はリスクが大きいという判断をしました。録画公開における臨場感の不足をおぎなうことを期待し、<span class="ascii">YouTube</span>の<a href="https://creatoracademy.youtube.com/page/course/hype-with-premieres">プレミア公開</a>を使用しリアルタイムチャットによる発表者と視聴者・視聴者同士の交流をできるように予定しています。</p>
<h1 id="発表者募集"><span class="link-to-here-outer"><a href="#発表者募集" title="発表者募集"><span class="link-to-here">Link to<br />
here</span></a></span>発表者募集</h1>
<p>現在<a href="https://haskell.jp/haskell-day-2021/#call-for-papers">発表者募集</a>中です！</p>
<p>今回はオンライン開催ということで、お手数ですが発表者にもオンサイトのイベントと異なった準備をお願いすることになります。運営としてできるかぎりのサポートをしますので安心して応募いただければと思います。</p>
<h1 id="参加登録"><span class="link-to-here-outer"><a href="#参加登録" title="参加登録"><span class="link-to-here">Link to<br />
here</span></a></span>参加登録</h1>
<p><a href="https://haskell-jp.connpass.com/event/215363/"><span class="ascii">Connpass</span></a>にて参加登録の受け付けもしていますので視聴者の方も登録をお願いします。</p>
<p>その他のくわしい情報は<a href="https://haskell.jp/haskell-day-2021/"><span class="ascii">Haskell Day 2021</span>イベントページ</a>をご覧ください。</p>
<p>みなさまのご応募をお待ちしています。またお体にお気をつけください。</p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/grc.html" style="margin-left: auto;" lang="ja">「相互を尊重したコミュニケーションのためのガイドライン」制定のお知らせ</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>「相互を尊重したコミュニケーションのためのガイドライン」制定のお知らせ</title>
    <link href="https://haskell.jp/blog/posts/grc.html" />
    <id>https://haskell.jp/blog/posts/grc.html</id>
    <published>2021-05-30T00:00:00Z</published>
    <updated>2021-05-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p><a href="about_admins.html">先日の<span class="ascii">Haskell-jp Admins</span></a>と同様に事務的な連絡で恐縮ですが、当ブログや<a href="https://haskell.jp/signin-slack.html"><span class="ascii">Haskell-jp</span>の<span class="ascii">Slack Workspace</span></a>、<a href="https://github.com/haskell-jp"><span class="ascii">GitHub</span>の<span class="ascii">Organization</span></a>などにおけるコミュニケーションに適用される、<a href="https://github.com/haskell-jp/community/blob/master/GRC.md">「相互を尊重したコミュニケーションのためのガイドライン」</a>を制定致しました。</p>
<p><a href="https://github.com/haskell-jp/community/blob/master/GRC.md"><span class="ascii">Haskell-jp</span> 相互を尊重したコミュニケーションのためのガイドライン</a></p>
<p>こちらは<a href="https://haskell.foundation/guidelines-for-respectful-communication/"><span class="ascii">Haskell Foundation</span>における<span class="ascii">Guidelines for Respectful Communication (GRC)</span></a>を日本語に翻訳し、運用主体などを<span class="ascii">Haskell-jp</span>における実態に合わせて書き換えたものです。いわゆる「行動規範<small>（<span class="ascii">Code Of Conduct</span>。しばしば「<span class="ascii">COC</span>」と略されます）</small>」と同じ役割を果たすものですが、行動規範と異なり、禁止事項よりも推奨事項を数多く挙げているのが特徴です。<a href="https://github.com/haskell-jp/community/pull/29">この<span class="ascii">GRC</span>を翻訳する前に、<span class="ascii">COC</span>を提案した際の議論</a>において<span class="ascii">GRC</span>のこうした特徴が好まれ、採用に至りました。</p>
<p>この<span class="ascii">GRC</span>は、今後<a href="https://haskell.jp/signin-slack.html"><span class="ascii">Haskell-jp</span>の<span class="ascii">Slack Workspace</span></a>や<a href="https://github.com/haskell-jp/"><span class="ascii">Haskell-jp</span>の<span class="ascii">GitHub</span>における<span class="ascii">Organization</span>が管理するリポジトリー</a>、それから<span class="ascii">Haskell-jp</span>として開催するイベントなど、様々な場面で適用されます。参加されるみなさんはご理解の上、快適なコミュニティー活動をお楽しみください。</p>
<p>加えて、もちろん今秋開催予定の<a href="https://haskell.jp/haskell-day-2021/"><span class="ascii">Haskell Day 2021</span></a>においても、こちらの<span class="ascii">GRC</span>を採用します。参加者、発表者、運営者の方々はご理解とご協力をよろしくお願いします。</p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2021/haskell-day-2021.html" lang="ja">Haskell Day 2021を開催します</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/about_admins.html" style="margin-left: auto;" lang="ja">日本Haskellユーザーグループ管理委員会（Haskell-jp Admins）設立のお知らせ</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>日本Haskellユーザーグループ管理委員会（Haskell-jp Admins）設立のお知らせ</title>
    <link href="https://haskell.jp/blog/posts/about_admins.html" />
    <id>https://haskell.jp/blog/posts/about_admins.html</id>
    <published>2021-03-29T00:00:00Z</published>
    <updated>2021-03-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>去る<span class="ascii">2021</span>年<span class="ascii">2</span>月<span class="ascii">9</span>日、任意団体であり明確な会員資格を持たない、<a href="https://haskell.jp/blog/posts/about_us.html">日本<span class="ascii">Haskell</span>ユーザーグループ（<span class="ascii">Haskell-jp</span>）</a>における共有財産やコミュニケーションの場の管理・運営を担う法人として、一般社団法人日本<span class="ascii">Haskell</span>ユーザーグループ管理委員会（通称 <span class="ascii">Haskell-jp Admins</span>。<a href="https://www.houjin-bangou.nta.go.jp/henkorireki-johoto.html?selHouzinNo=5020005014971">法人番号 <span class="ascii">5020005014971</span></a>）を設立しました。法人格を持つことを活かして、<span class="ascii">Haskell-jp Admins</span>は次の事業に取り組みます。</p>
<ul>
<li>プログラミング言語<span class="ascii">Haskell</span>に関するイベントの企画・開催・運営
<ul>
<li>イベントの会場を借りたり、ノベルティーを作成したりする際の名義として使用する予定です</li>
</ul></li>
<li><span class="ascii">haskell.jp</span> ドメインの維持・管理</li>
<li><a href="https://haskell.jp/signin-slack.html"><span class="ascii">Haskell-jp</span>の<span class="ascii">Slack Workspace</span></a>を始めとする、交流や情報共有を行う場の提供・管理・運営</li>
<li>そのほか、上記に関連して必要なこと</li>
</ul>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#背景" title="背景">背景</a></li>
<li><a href="#今後の活動と連絡先" title="今後の活動と連絡先">今後の活動と連絡先</a></li>
<li><a href="#現在の理事社員" title="現在の理事社員">現在の理事・社員</a></li>
<li><a href="#所在地" title="所在地">所在地</a></li>
<li><a href="#定款" title="定款">定款</a></li>
</ul>
</div>
</div>
<h1 id="背景"><span class="link-to-here-outer"><a href="#背景" title="背景"><span class="link-to-here">Link to<br />
here</span></a></span>背景</h1>
<p>そもそもの設立の動機は、山下さん（<a href="https://twitter.com/nobsun"><span class="ascii">@nobsun</span></a>）の好意によって個人名義で保有していた<span class="ascii">haskell.jp</span> ドメインを共同で管理出来るようにするためでした。ドメインを団体として保有するには、法人格と、法人名義の銀行口座が必要なのです。これ以外にも、<span class="ascii">Haskell-jp</span>として共有する価値のあるアカウントを管理する際の名義として、随時「日本<span class="ascii">Haskell</span>ユーザーグループ管理委員会」を使用します。</p>
<h1 id="今後の活動と連絡先"><span class="link-to-here-outer"><a href="#今後の活動と連絡先" title="今後の活動と連絡先"><span class="link-to-here">Link to<br />
here</span></a></span>今後の活動と連絡先</h1>
<p><span class="ascii">Haskell-jp Admins</span>が出来たからといって、<span class="ascii">Haskell-jp</span>のあり方が大きく変わることはありません。今後も<span class="ascii">Slack</span>で質問したり議論したり<a href="https://haskell.jp/blog/">ブログ</a>記事を書いたりしましょう！<a href="https://haskell.jp/"><span class="ascii">haskell.jp</span></a>というドメインを活かし、「公式面して」自由に活動する方をいつでも待っています！</p>
<ul>
<li>公の場で提案・相談したい場合は<span class="ascii">:</span>
<ul>
<li>前述の<a href="https://haskell.jp/signin-slack.html"><span class="ascii">Haskell-jp</span>の<span class="ascii">Slack Workspace</span></a>の<span class="ascii">#random</span>チャンネルなどで投稿いただくか、</li>
<li><a href="https://github.com/haskell-jp/community/issues"><span class="ascii">haskell-jp/community</span>に<span class="ascii">issue</span></a>として登録したり、</li>
<li><a href="https://twitter.com/haskell_jp"><span class="ascii">Haskell-jp</span>の<span class="ascii">Twitter</span>アカウント <span class="ascii">@haskell_jp</span></a>にメンションをください。</li>
</ul></li>
<li>プライベートに提案・相談したい場合は<span class="ascii">:</span>
<ul>
<li><span class="ascii">haskell-jp-admins@googlegroups.com</span> にメールを送ってください</li>
</ul></li>
</ul>
<p>我々<span class="ascii">Haskell-jp Admins</span>は、そうした活動をバックアップするために種々の問題に取り組んでいきます。</p>
<h1 id="現在の理事社員"><span class="link-to-here-outer"><a href="#現在の理事社員" title="現在の理事社員"><span class="link-to-here">Link to<br />
here</span></a></span>現在の理事・社員</h1>
<ul>
<li>代表理事<span class="ascii">:</span> 山本悠滋（<a href="https://twitter.com/igrep"><span class="ascii">@igrep</span></a>）</li>
<li>社員<span class="ascii">:</span>
<ul>
<li>中嶋大嗣（<a href="https://twitter.com/nakaji_dayo/"><span class="ascii">@nakaji_dayo</span></a><span class="ascii">)</span></li>
<li>山下伸夫（<a href="https://twitter.com/nobsun"><span class="ascii">@nobsun</span></a>）</li>
<li>岡本和樹（<a href="https://twitter.com/kakkun61"><span class="ascii">@kakkun61</span></a>）</li>
<li>木下郁章（<a href="https://twitter.com/fumieval"><span class="ascii">@fumieval</span></a>）</li>
<li>廣瀬達也（<a href="https://twitter.com/lotz84_"><span class="ascii">@lotz84_</span></a>）</li>
</ul></li>
</ul>
<h1 id="所在地"><span class="link-to-here-outer"><a href="#所在地" title="所在地"><span class="link-to-here">Link to<br />
here</span></a></span>所在地</h1>
<p>〒<span class="ascii">220-0004</span> 神奈川県横浜市西区北幸 <span class="ascii">1-11-1</span> 水信ビル<span class="ascii">7</span>階</p>
<h1 id="定款"><span class="link-to-here-outer"><a href="#定款" title="定款"><span class="link-to-here">Link to<br />
here</span></a></span>定款</h1>
<p>こちらに一部個人情報を削除した上で掲載しています。</p>
<p><a href="https://github.com/haskell-jp/community/blob/master/admins/article.md">一般社団法人 日本<span class="ascii">Haskell</span>ユーザーグループ管理委員会 定款</a></p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/grc.html" lang="ja">「相互を尊重したコミュニケーションのためのガイドライン」制定のお知らせ</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2020/break-monad-law-with-writer.html" style="margin-left: auto;" lang="ja">Writer Monadで気軽にMonad則を破る</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>Writer Monadで気軽にMonad則を破る</title>
    <link href="https://haskell.jp/blog/posts/2020/break-monad-law-with-writer.html" />
    <id>https://haskell.jp/blog/posts/2020/break-monad-law-with-writer.html</id>
    <published>2020-12-25T00:00:00Z</published>
    <updated>2020-12-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>🎅この記事は、<a href="https://qiita.com/advent-calendar/2020/haskell"><span class="ascii">Haskell Advent Calendar 2020</span></a> <span class="ascii">25</span>日目の記事です。<br />
🎄<span class="ascii">Happy Christmas!!</span>🎄</p>
<p>今回は先日<small>（といっても元の質問の投稿からもう何ヶ月も経ってしまいましたが…）</small><span class="ascii">StackOverflow</span>に上がったこちら👇の質問に対する回答の、続きっぽい話を書こうと思います。長いし、質問の回答からスコープが大きく外れてしまうので記事にしました。</p>
<p><a href="https://ja.stackoverflow.com/questions/70079/%E3%83%A2%E3%83%8A%E3%83%89%E5%89%87%E3%82%92%E5%B4%A9%E3%81%97%E3%81%A6%E3%81%97%E3%81%BE%E3%81%86%E4%BE%8B%E3%81%8C%E7%9F%A5%E3%82%8A%E3%81%9F%E3%81%84"><span class="ascii">haskell -</span> モナド則を崩してしまう例が知りたい <span class="ascii">-</span> スタック・オーバーフロー</a></p>
<p><code>Monad</code>と<code>Monoid</code>にある重要な繋がりを説明した後、それを応用した<code>Writer</code> <code>Monad</code>がどう<code>Monoid</code>を使って<code>Monad</code>則を満たしているのか証明します。そして、<code>Writer</code>のそうした性質を用いて簡単に<code>Monad</code>則を破る例を紹介することで、読者のみなさんが<code>Monad</code>則のみならず<code>do</code>記法や<code>Monad</code>そのものの性質について、よりはっきりとした理解が得られることを目指します。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#サンプルコードについて" title="サンプルコードについて">サンプルコードについて</a></li>
<li><a href="#monadとmonoidの切っても切り離せない関係" title="monadとmonoidの切っても切り離せない関係"><code>Monad</code>と<code>Monoid</code>の切っても切り離せない関係</a>
<ul>
<li><a href="#monoidの例" title="monoidの例"><code>Monoid</code>の例</a></li>
</ul></li>
<li><a href="#monoidとwriterの切っても切り離せない関係" title="monoidとwriterの切っても切り離せない関係"><code>Monoid</code>と<code>Writer</code>の切っても切り離せない関係</a>
<ul>
<li><a href="#doと" title="doと"><code>do</code>と<code>&lt;&gt;</code></a></li>
<li><a href="#writer-monadの結合則とmonoidの結合則" title="writer-monadの結合則とmonoidの結合則"><code>Writer</code> <code>Monad</code>の結合則と<code>Monoid</code>の結合則</a></li>
</ul></li>
<li><a href="#関係を壊してみる" title="関係を壊してみる">関係を壊してみる</a>
<ul>
<li><a href="#とmonoidの結合則" title="とmonoidの結合則"><code>&lt;&gt;</code>と<code>Monoid</code>の結合則</a></li>
<li><a href="#とmonadの結合則" title="とmonadの結合則"><code>&gt;&gt;=</code>と<code>Monad</code>の結合則</a></li>
<li><a href="#do記法とmonadの結合則" title="do記法とmonadの結合則"><code>do</code>記法と<code>Monad</code>の結合則</a></li>
</ul></li>
<li><a href="#まとめ" title="まとめ">まとめ</a></li>
</ul>
</div>
</div>
<h1 id="サンプルコードについて"><span class="link-to-here-outer"><a href="#サンプルコードについて" title="サンプルコードについて"><span class="link-to-here">Link to<br />
here</span></a></span>サンプルコードについて</h1>
<p>本記事のサンプルコードは、<span class="ascii">Haskell</span>の構文に準拠していないものを除いて、すべて<a href="https://github.com/igrep/readme-test"><span class="ascii">readme-test</span></a>というツールの<a href="https://github.com/igrep/readme-test/tree/f6ce7a6f5ce5f5f8031cd5dfedc8c6e47c13b1f3"><span class="ascii">2020</span>年<span class="ascii">12</span>月<span class="ascii">13</span>日時点の開発版</a>でテストしました。こちらのツールはまだ開発中で、今後も仕様が大きく変わる可能性がありますが、この記事のサンプルコードをテストするのに必要な機能は十分にそろっています。この<span class="ascii">readme-test</span>自体についてはいつか改めて共有します。</p>
<p>また、テストの際に用いた環境は以下の通りです<span class="ascii">:</span></p>
<ul>
<li><span class="ascii">Windows 10 Pro 20H2</span></li>
<li><span class="ascii">GHC 8.10.1</span></li>
<li><a href="https://www.stackage.org/nightly-2020-08-15"><span class="ascii">Stackage nightly-2020-08-15</span></a></li>
</ul>
<h1 id="monadとmonoidの切っても切り離せない関係"><span class="link-to-here-outer"><a href="#monadとmonoidの切っても切り離せない関係" title="monadとmonoidの切っても切り離せない関係"><span class="link-to-here">Link to<br />
here</span></a></span><code>Monad</code>と<code>Monoid</code>の切っても切り離せない関係</h1>
<p>「<a href="http://www.aoky.net/articles/james_iry/brief-incomplete-and-mostly-wrong.htm">モナドは単なる自己関手の圏におけるモノイド対象だよ。何か問題でも？</a>」というフレーズ（原文「<a href="http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html"><span class="ascii">A monad is a monoid in the category of endofunctors, what</span>’<span class="ascii">s the problem?</span></a>」が示すとおり、モナドとモノイド、<span class="ascii">Haskell</span>の識別子で言うところの<code>Monad</code>と<code>Monoid</code>には密接な関係があります。ぶっちゃけ、このフレーズの正確な意味を私は理解していないのですが、少なくとも<code>Monad</code>と<code>Monoid</code>には重要な共通点があることは知っています。それは、どちらも<strong>単位元と結合則</strong>がある、ということです！</p>
<p>具体的に<code>Monad</code>と<code>Monoid</code>の単位元・結合則を見てみましょう<span class="ascii">:</span></p>
<!-- ReadmeTest: Ignore -->
<p><code>Monoid</code>の単位元<span class="ascii">:</span> 単位元である<code>mempty</code>は、どんな値<code>x</code>に<code>&lt;&gt;</code>で足しても結果が変わらない！</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1">x <span class="op">&lt;&gt;</span> <span class="fu">mempty</span> <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="fu">mempty</span> <span class="op">&lt;&gt;</span> x <span class="ot">=</span> x</a></code></pre></div>
<p><code>Monad</code>の単位元<span class="ascii">:</span> <code>return</code>は<code>&gt;&gt;=</code>の前に使っても後ろに使っても、<code>m</code>や<code>k a</code>の結果を変えない！</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="fu">return</span> a <span class="op">&gt;&gt;=</span> (\a <span class="ot">-&gt;</span> k a) <span class="ot">=</span> k a</a>
<a class="sourceLine" id="cb2-2" title="2">m <span class="op">&gt;&gt;=</span> (\a <span class="ot">-&gt;</span> <span class="fu">return</span> a) <span class="ot">=</span> m</a></code></pre></div>
<p><code>Monoid</code>の結合則<span class="ascii">:</span> <code>x &lt;&gt; y &lt;&gt; z</code>の結果は、<code>y &lt;&gt; z</code>を先に計算しようと<code>x &lt;&gt; y</code>を先に計算しようと変わらない！</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1">x <span class="op">&lt;&gt;</span> (y <span class="op">&lt;&gt;</span> z) <span class="ot">=</span> (x <span class="op">&lt;&gt;</span> y) <span class="op">&lt;&gt;</span> z</a></code></pre></div>
<p><code>Monad</code>の結合則<span class="ascii">:</span> <code>m &gt;&gt;= \x -&gt; k x &gt;&gt;= h</code> の結果は、<code>\x -&gt; k x &gt;&gt;= h</code>を先に計算しようと、<code>m &gt;&gt;= (\x -&gt; k x)</code>を先に計算しようと変わらない！</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1">m <span class="op">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> k x <span class="op">&gt;&gt;=</span> h) <span class="ot">=</span> (m <span class="op">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> k x)) <span class="op">&gt;&gt;=</span> h</a></code></pre></div>
<p>※<code>Monad</code>の単位元・結合則の式についてはわかりやすさのために<a href="http://hackage.haskell.org/package/base-4.14.0.0/docs/Control-Monad.html#t:Monad">引用元</a>から少し形を変えています。</p>
<p><span class="ascii">Haskell</span>における<code>Monad</code>・<code>Monoid</code>とは、値がそれぞれの単位元・結合則をを満たす型です<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>。それ以上でも、それ以下でもありません。</p>
<p>それぞれの単位元・結合則を表す式は、一見して異なるものに見えるかも知れませんが、表す性質自体はよく似ています。なので、式を読んでもよく分からないという方は、上記に書いた日本語の説明をざっと眺めて覚えておいてください。特に、結合則における<strong>「～を先に計算しようと、～を先に計算しようと変わらない！」</strong>の部分がこの後とても重要になります。</p>
<div id="monoid-examples">

</div>
<h2 id="monoidの例"><span class="link-to-here-outer"><a href="#monoidの例" title="monoidの例"><span class="link-to-here">Link to<br />
here</span></a></span><code>Monoid</code>の例</h2>
<p>ここまで読んで、<code>Monad</code>はなんか聞いたことがあるけど<code>Monoid</code>は初めて聞くよ、という方向けに補足すると、<code>Monoid</code>とは例えば次のような型の値（と、それに対する処理）です。</p>
<p><code>Sum</code>型<span class="ascii">:</span> 数値<small>（<span class="ascii">Num</span>型クラスのインスタンス）</small>に対する、足し算を表す<code>Monoid</code>のインスタンス</p>
<!-- ReadmeTest: AppendAsIs -->
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="co">-- これから紹介する処理に必要なモジュールのimport</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="kw">import</span> <span class="dt">Data.Monoid</span></a></code></pre></div>
<!-- ReadmeTest: CompareAfterPrompt ByExpression -->
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="co">-- Sum aに対する &lt;&gt; は + と同等なので、</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="op">&gt;</span> getSum (<span class="dt">Sum</span> <span class="dv">1</span> <span class="op">&lt;&gt;</span> <span class="dt">Sum</span> <span class="dv">2</span> <span class="op">&lt;&gt;</span> <span class="fu">mempty</span>)</a>
<a class="sourceLine" id="cb6-3" title="3"><span class="co">-- は、</span></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="co">-- と同じ。</span></a></code></pre></div>
<p><code>mempty</code>が各<code>Monoid</code>のインスタンスにおける単位元を返す、という点に注意してください。上記のとおり足し算の場合は<code>0</code>です。</p>
<p><code>Product</code>型<span class="ascii">:</span> 数値<small>（<span class="ascii">Num</span>型クラスのインスタンス）</small>に対する、かけ算を表す<code>Monoid</code>のインスタンス</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="co">-- Product aに対する &lt;&gt; は * と同等なので、</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="op">&gt;</span> getProduct (<span class="dt">Product</span> <span class="dv">1</span> <span class="op">&lt;&gt;</span> <span class="dt">Product</span> <span class="dv">2</span> <span class="op">&lt;&gt;</span> <span class="fu">mempty</span>)</a>
<a class="sourceLine" id="cb7-3" title="3"><span class="co">-- は、</span></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="dv">1</span> <span class="op">*</span> <span class="dv">2</span> <span class="op">*</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="co">-- と同じ。</span></a></code></pre></div>
<p>リスト型<span class="ascii">:</span> リスト型の値に対する、結合 <code>(++)</code>を表す<code>Monoid</code>のインスタンス</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="co">-- [a] に対する &lt;&gt; は ++ と同等なので、</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="op">&gt;</span> [<span class="dv">1</span>, <span class="dv">2</span>] <span class="op">&lt;&gt;</span> [<span class="dv">3</span>] <span class="op">&lt;&gt;</span> <span class="fu">mempty</span></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="co">-- は、</span></a>
<a class="sourceLine" id="cb8-4" title="4">[<span class="dv">1</span>, <span class="dv">2</span>] <span class="op">++</span> [<span class="dv">3</span>] <span class="op">++</span> []</a>
<a class="sourceLine" id="cb8-5" title="5"><span class="co">-- と同じ</span></a></code></pre></div>
<p><code>All</code>型<span class="ascii">:</span> <code>Bool</code>型の値に対する論理積<code>&amp;&amp;</code>を表す<code>Monoid</code>のインスタンス</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="op">&gt;</span> getAll (<span class="dt">All</span> <span class="dt">True</span> <span class="op">&lt;&gt;</span> <span class="dt">All</span> <span class="dt">False</span>)</a>
<a class="sourceLine" id="cb9-2" title="2"><span class="co">-- は、</span></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="dt">True</span> <span class="op">&amp;&amp;</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb9-4" title="4"><span class="co">-- と同じ</span></a></code></pre></div>
<!-- ReadmeTest: ValidateAsExpression -->
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="co">-- これが何を返すかは、想像してみてください！</span></a>
<a class="sourceLine" id="cb10-2" title="2">getAll <span class="fu">mempty</span></a></code></pre></div>
<p><code>Any</code>型<span class="ascii">:</span> <code>Bool</code>型の値に対する論理和<code>||</code>を表す<code>Monoid</code>のインスタンス</p>
<!-- ReadmeTest: CompareAfterPrompt ByExpression -->
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="op">&gt;</span> getAny (<span class="dt">Any</span> <span class="dt">True</span> <span class="op">&lt;&gt;</span> <span class="dt">Any</span> <span class="dt">False</span>)</a>
<a class="sourceLine" id="cb11-2" title="2"><span class="co">-- は、</span></a>
<a class="sourceLine" id="cb11-3" title="3"><span class="dt">True</span> <span class="op">||</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb11-4" title="4"><span class="co">-- と同じ</span></a></code></pre></div>
<!-- ReadmeTest: ValidateAsExpression -->
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="co">-- これも何を返すかは、想像してみてください！</span></a>
<a class="sourceLine" id="cb12-2" title="2">getAny <span class="fu">mempty</span></a></code></pre></div>
<p>このように、<code>Monoid</code>は他のプログラミング言語でもおなじみの、多くの二項演算を表しています。これらのインスタンスはすべて、先ほど紹介した「単位元」や「結合則」のルールを守っているので、気になった方はぜひチェックしてみてください<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>。</p>
<h1 id="monoidとwriterの切っても切り離せない関係"><span class="link-to-here-outer"><a href="#monoidとwriterの切っても切り離せない関係" title="monoidとwriterの切っても切り離せない関係"><span class="link-to-here">Link to<br />
here</span></a></span><code>Monoid</code>と<code>Writer</code>の切っても切り離せない関係</h1>
<p>実はそんな<code>Monad</code>と<code>Monoid</code>の固い絆を象徴するような<code>Monad</code>が、この世にはあります。そう、<code>Writer</code>です！<code>Writer</code>は<code>Monoid</code>の単位元・結合則をそのまま活かすことによって<code>Monad</code>の単位元・結合則を満たした<code>Monad</code>であり、<code>Writer</code>がどうやって<code>Monad</code>則を満たしているのか知れば、<code>Monad</code>則がどうやって成立するものなのかが、すっきりクリアになることでしょう。</p>
<p>手始めに<code>Writer</code>の定義と、<code>Writer</code>が<code>Monad</code>の各メソッドをどのように実装しているか見てみましょう。<a href="https://www.sampou.org/haskell/a-a-monads/html/writermonad.html">「モナドのすべて」における<code>Writer</code>の紹介ページ</a>から、少しリファクタリングしつつ引用します<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>。</p>
<!-- ReadmeTest: AppendAsIs -->
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="co">-- Writer型の定義</span></a>
<a class="sourceLine" id="cb13-2" title="2"><span class="kw">newtype</span> <span class="dt">Writer</span> w a <span class="ot">=</span> <span class="dt">Writer</span> {<span class="ot"> runWriter ::</span> (a, w) }</a></code></pre></div>
<p>タプルに対して<code>newtype</code>していることから分かるとおり、<code>Writer</code>の実態はただのタプルです。ただのタプルがどうやって<code>Monad</code>になるのでしょう？その答えがこちら👇<span class="ascii">:</span></p>
<!--
```haskell
instance Functor (Writer w) where
  fmap f (Writer (x, w)) = Writer (f x, w)

instance Monoid w => Applicative (Writer w) where
  pure a = Writer (a, mempty)
  Writer (f, w1) <*> Writer (x, w2) = Writer (f x, w1 <> w2)
```
-->
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="co">-- WriterのMonad型クラスの実装</span></a>
<a class="sourceLine" id="cb14-2" title="2"><span class="co">-- 実際のところFunctor, Applicativeのインスタンス定義も必要だけどここでは省略</span></a>
<a class="sourceLine" id="cb14-3" title="3"><span class="kw">instance</span> <span class="dt">Monoid</span> w <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">Writer</span> w) <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-4" title="4">  <span class="fu">return</span> a <span class="ot">=</span> <span class="dt">Writer</span> (a, <span class="fu">mempty</span>)</a>
<a class="sourceLine" id="cb14-5" title="5">  <span class="dt">Writer</span> (a, w1) <span class="op">&gt;&gt;=</span> f <span class="ot">=</span></a>
<a class="sourceLine" id="cb14-6" title="6">    <span class="kw">let</span> <span class="dt">Writer</span> (b, w2) <span class="ot">=</span> f a</a>
<a class="sourceLine" id="cb14-7" title="7">     <span class="kw">in</span> <span class="dt">Writer</span> (b, w1 <span class="op">&lt;&gt;</span> w2)</a></code></pre></div>
<p><code>return</code>の定義は比較的シンプルですね。<code>mempty</code>を受け取った値<code>a</code>と一緒にタプルに入れて返すだけです。<code>Monad</code>の単位元である<code>return</code>では、<code>Monoid</code>の単位元である<code>mempty</code>を使うのです。</p>
<p>一方、<code>&gt;&gt;=</code>はどう読めばいいでしょう？<code>let ... in ...</code>の結果にあたる<code>Writer (b, w1 &lt;&gt; w2)</code>に注目してください。</p>
<p>まず、<code>b</code>は<code>&gt;&gt;=</code>の右辺である<code>f</code>が返した結果です。<code>Writer</code>の<code>&gt;&gt;=</code>が返す、<code>Writer</code>がラップしたタプルの一つ目の要素は、ここで<code>f</code>が返した値の型と一致していなければなりません。<code>Writer</code>において<code>&gt;&gt;=</code>の型は<code>Writer w a -&gt; (a -&gt; Writer w b) -&gt; Writer w b</code>であり、右辺にあたる<code>f</code>は<code>(a -&gt; Writer w b)</code>という型なので、<code>&gt;&gt;=</code>全体の戻り値<code>Writer w b</code>と<code>f</code>の戻り値が一致している必要があることがわかりますよね？</p>
<p>さらに重要なのが<code>w1 &lt;&gt; w2</code>です。ここであの<code>Monoid</code>の演算子<code>&lt;&gt;</code>が出てきました！<code>Writer</code>は<code>&gt;&gt;=</code>の中で<code>&lt;&gt;</code>を使う<code>Monad</code>なんですね！一体何と何を<code>&lt;&gt;</code>しているのでしょう？まず、<code>&lt;&gt;</code>の左辺である<code>w1</code>は、左辺にあたる<code>Writer</code>がタプルに保持していた<code>Monoid</code>型クラスのインスタンスの値です。そして右辺の<code>w2</code>は、<code>&gt;&gt;=</code>の右辺に渡した関数<code>f</code>が<code>b</code>と一緒に返した<code>w2</code>です。</p>
<p>以上のことをまとめると、<code>Writer</code>の<code>&gt;&gt;=</code>は、</p>
<ol type="1">
<li>左辺の<code>(a, w1)</code>における<code>a</code>を<code>f</code>に渡して、</li>
<li><code>f</code>が返した<code>(b, w2)</code>における<code>b</code>を、</li>
<li><code>w1</code>と<code>w2</code>と一緒に<code>&lt;&gt;</code>でくっつけつつ返す、</li>
</ol>
<p>という処理を行っています。<code>Writer</code>は、「<code>b</code>を返すついでに<code>w1</code>と<code>w2</code>を<code>&lt;&gt;</code>でくっつける」と覚えてください。</p>
<p><code>Writer</code>は、</p>
<ul>
<li><code>Monad</code>の単位元<code>return</code>で<code>Monoid</code>の単位元<code>mempty</code>を使って、</li>
<li><code>Monad</code>の結合則を満たす<code>&gt;&gt;=</code>で、これまた<code>Monoid</code>の結合則を満たす<code>&lt;&gt;</code>を使っているのです。</li>
</ul>
<p>やっぱり<code>Writer</code>は<code>Monoid</code>あっての<code>Monad</code>と言えますね。</p>
<h2 id="doと"><span class="link-to-here-outer"><a href="#doと" title="doと"><span class="link-to-here">Link to<br />
here</span></a></span><code>do</code>と<code>&lt;&gt;</code></h2>
<p>さて、この「<code>b</code>を返すついでに<code>w1</code>と<code>w2</code>を<code>&lt;&gt;</code>でくっつける」という<code>Writer</code>の振る舞いが象徴するように、大抵の<code>Monad</code>のインスタンスにおける<code>&gt;&gt;=</code>は、<strong>何かしら値を返すついでに、何らかの処理を行う</strong>よう実装されています。この「ついでに行われる処理」は<code>Monad</code>のインスタンスを<code>do</code>記法の中で扱うと、ますます静かに身を隠すようになります。</p>
<p>こちらも<code>Writer</code>を例に説明しましょう。まず、例示用に<code>Writer</code>を作るアクションを適当に定義します。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="ot">addLogging ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Writer</span> [<span class="dt">String</span>] <span class="dt">Int</span></a>
<a class="sourceLine" id="cb15-2" title="2">addLogging x y <span class="ot">=</span></a>
<a class="sourceLine" id="cb15-3" title="3">  <span class="dt">Writer</span> (x <span class="op">+</span> y, [<span class="st">&quot;Adding &quot;</span> <span class="op">++</span> <span class="fu">show</span> x <span class="op">++</span> <span class="st">&quot; to &quot;</span> <span class="op">++</span> <span class="fu">show</span> y <span class="op">++</span> <span class="st">&quot;.&quot;</span>])</a>
<a class="sourceLine" id="cb15-4" title="4"></a>
<a class="sourceLine" id="cb15-5" title="5"><span class="ot">multLogging ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Writer</span> [<span class="dt">String</span>] <span class="dt">Int</span></a>
<a class="sourceLine" id="cb15-6" title="6">multLogging x y <span class="ot">=</span></a>
<a class="sourceLine" id="cb15-7" title="7">  <span class="dt">Writer</span> (x <span class="op">*</span> y, [<span class="st">&quot;Multiplying &quot;</span> <span class="op">++</span> <span class="fu">show</span> x <span class="op">++</span> <span class="st">&quot; with &quot;</span> <span class="op">++</span> <span class="fu">show</span> y <span class="op">++</span> <span class="st">&quot;.&quot;</span>])</a></code></pre></div>
<p><code>addLogging</code>と<code>multLogging</code>はそれぞれ、引数として受け取った整数を足し算したりかけ算したりしつつ、「足したよ」「かけたよ」という内容の文字列を一緒に返します。<code>Writer [String] Int</code>における<code>[String]</code>にログとして書き込んでいるようなイメージで捉えてください。</p>
<p>これらを<code>do</code>の中で使ってみると、より<code>addLogging</code>や<code>multLogging</code>が「足し算やかけ算をするついでに、ログとして書き込んでいる」っぽいイメージが伝わるでしょう<span class="ascii">:</span></p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="ot">testDo ::</span> <span class="dt">Writer</span> [<span class="dt">String</span>] <span class="dt">Int</span></a>
<a class="sourceLine" id="cb16-2" title="2">testDo <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-3" title="3">  result1 <span class="ot">&lt;-</span> addLogging <span class="dv">3</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb16-4" title="4">  result2 <span class="ot">&lt;-</span> multLogging <span class="dv">5</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb16-5" title="5">  addLogging result1 result2</a></code></pre></div>
<p><small>⚠️申し訳なくも<code>do</code>記法自体の解説、つまり<code>&gt;&gt;=</code>がどのように<code>do</code>記法に対応するかはここには書きません。お近くの<span class="ascii">Haskell</span>入門書をご覧ください。</small></p>
<p>👆では、<code>3 + 4</code>した結果<code>result1</code>と、<code>5 * 2</code>した結果<code>result2</code>を足す処理を行っています。それに加えて、「足したよ」「かけたよ」というログを表す文字列のリスト<code>[String]</code>も一緒に返しています。<code>do</code>記法が<code>&gt;&gt;=</code>に変換されるのに従い、<code>Writer</code>の<code>&gt;&gt;=</code>が内部で<code>&lt;&gt;</code>を使い、<code>addLogging 3 4</code>・<code>multLogging 5 2</code>・<code>addLogging result1 result2</code>が返した文字列のリスト<code>[String]</code>を結合することによって、あたかも<code>addLogging</code>や<code>multLogging</code>が「値を返しつつ、ログとして書き込む」かのような処理を実現できるのが<code>Writer</code>における<code>do</code>記法の特徴です。</p>
<!-- ReadmeTest: CompareAfterPrompt ByExpression -->
<p>能書きはここまでにして、実際にどのような結果になるか見てみましょう<span class="ascii">:</span></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="op">&gt;</span> runWriter testDo</a>
<a class="sourceLine" id="cb17-2" title="2">(<span class="dv">17</span>,[<span class="st">&quot;Adding 3 to 4.&quot;</span>,<span class="st">&quot;Multiplying 5 with 2.&quot;</span>,<span class="st">&quot;Adding 7 to 10.&quot;</span>])</a></code></pre></div>
<p>はい、<code>3 + 4</code>と<code>5 * 2</code>の結果を足し算した結果<code>17</code>と、<code>addLogging 3 4</code>・<code>multLogging 5 2</code>・<code>addLogging result1 result2</code>が一緒に返していた文字列のリスト<code>[String]</code>が、書いた順番どおりに結合されて返ってきました。<code>Writer</code>は<code>do</code>記法の中に書いた<code>Writer</code>の値<code>(a, w)</code>のうち、<code>Monoid</code>のインスタンスである<code>w</code>を<code>&lt;&gt;</code>で都度結合させているということが伝わったでしょうか？</p>
<h2 id="writer-monadの結合則とmonoidの結合則"><span class="link-to-here-outer"><a href="#writer-monadの結合則とmonoidの結合則" title="writer-monadの結合則とmonoidの結合則"><span class="link-to-here">Link to<br />
here</span></a></span><code>Writer</code> <code>Monad</code>の結合則と<code>Monoid</code>の結合則</h2>
<p>ここまでで、<code>Writer</code> <code>Monad</code>がどのように<code>&lt;&gt;</code>を使っているのか、それによって<code>&gt;&gt;=</code>や<code>do</code>記法がどのように振る舞っているのか、具体例を示して説明いたしました。ここからは、<code>Writer</code>が<code>Monoid</code>の<code>&lt;&gt;</code>の結合則をどう利用することで、<code>Monad</code>としての<code>&gt;&gt;=</code>の結合則を満たしているのかを示しましょう。長いので「めんどい！」という方は<a href="#associative-law-qed">こちらをクリックしてスキップ</a>してください。</p>
<p>そのために、<code>Monad</code>の結合則における<code>&gt;&gt;=</code>を、<code>Writer</code>の<code>&gt;&gt;=</code>として展開してみます。</p>
<!-- ReadmeTest: Ignore -->
<p><span class="ascii">(0)</span> <code>Monad</code>の結合則<span class="ascii">:</span></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1">m <span class="op">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> k x <span class="op">&gt;&gt;=</span> h) <span class="ot">=</span> (m <span class="op">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> k x)) <span class="op">&gt;&gt;=</span> h</a></code></pre></div>
<p><span class="ascii">(1)</span> <code>m</code>は<code>&gt;&gt;=</code>の左辺なので<code>Writer (a, w1)</code>に置き換える<span class="ascii">:</span></p>
<p><small>※ここからは、比較しやすくするために等式<code>=</code>の左辺と右辺を別々の行に書きます。</small></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" title="1"><span class="kw">let</span> <span class="dt">Writer</span> (a, w1) <span class="ot">=</span> m <span class="kw">in</span> <span class="dt">Writer</span> (a, w1) <span class="op">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> k x <span class="op">&gt;&gt;=</span> h)</a>
<a class="sourceLine" id="cb19-2" title="2">  <span class="ot">=</span></a>
<a class="sourceLine" id="cb19-3" title="3"><span class="kw">let</span> <span class="dt">Writer</span> (a, w1) <span class="ot">=</span> m <span class="kw">in</span> <span class="dt">Writer</span> (a, w1) <span class="op">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> k x) <span class="op">&gt;&gt;=</span> h</a></code></pre></div>
<p><span class="ascii">(2)</span> 一つ目の<code>&gt;&gt;=</code>を<code>Writer</code>における<code>&gt;&gt;=</code>の定義で置き換える<span class="ascii">:</span></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">let</span> <span class="dt">Writer</span> (a, w1) <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb20-2" title="2">    <span class="dt">Writer</span> (b, w2) <span class="ot">=</span> (\x <span class="ot">-&gt;</span> k x <span class="op">&gt;&gt;=</span> h) a</a>
<a class="sourceLine" id="cb20-3" title="3"> <span class="kw">in</span> <span class="dt">Writer</span> (b, w1 <span class="op">&lt;&gt;</span> w2)</a>
<a class="sourceLine" id="cb20-4" title="4">  <span class="ot">=</span></a>
<a class="sourceLine" id="cb20-5" title="5"><span class="kw">let</span> <span class="dt">Writer</span> (a, w1) <span class="ot">=</span> m <span class="kw">in</span> <span class="dt">Writer</span> (a, w1) <span class="op">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> k x) <span class="op">&gt;&gt;=</span> h</a></code></pre></div>
<p><span class="ascii">(3)</span> 等式<code>=</code>の右辺における一つ目の<code>&gt;&gt;=</code>も同様に変換する<span class="ascii">:</span></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" title="1"><span class="kw">let</span> <span class="dt">Writer</span> (a, w1) <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb21-2" title="2">    <span class="dt">Writer</span> (b, w2) <span class="ot">=</span> (\x <span class="ot">-&gt;</span> k x <span class="op">&gt;&gt;=</span> h) a</a>
<a class="sourceLine" id="cb21-3" title="3"> <span class="kw">in</span> <span class="dt">Writer</span> (b, w1 <span class="op">&lt;&gt;</span> w2)</a>
<a class="sourceLine" id="cb21-4" title="4">  <span class="ot">=</span></a>
<a class="sourceLine" id="cb21-5" title="5"><span class="kw">let</span> <span class="dt">Writer</span> (a, w1) <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb21-6" title="6">    <span class="dt">Writer</span> (b, w2) <span class="ot">=</span> (\x <span class="ot">-&gt;</span> k x) a</a>
<a class="sourceLine" id="cb21-7" title="7"> <span class="kw">in</span> <span class="dt">Writer</span> (b, w1 <span class="op">&lt;&gt;</span> w2) <span class="op">&gt;&gt;=</span> h</a></code></pre></div>
<p><span class="ascii">(4)</span> 無名関数である<code>(\x -&gt; k x &gt;&gt;= h)</code>と<code>(\x -&gt; k x)</code>に、<code>a</code>を適用する<span class="ascii">:</span></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">let</span> <span class="dt">Writer</span> (a, w1) <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb22-2" title="2">    <span class="dt">Writer</span> (b, w2) <span class="ot">=</span> k a <span class="op">&gt;&gt;=</span> h</a>
<a class="sourceLine" id="cb22-3" title="3"> <span class="kw">in</span> <span class="dt">Writer</span> (b, w1 <span class="op">&lt;&gt;</span> w2)</a>
<a class="sourceLine" id="cb22-4" title="4">  <span class="ot">=</span></a>
<a class="sourceLine" id="cb22-5" title="5"><span class="kw">let</span> <span class="dt">Writer</span> (a, w1) <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb22-6" title="6">    <span class="dt">Writer</span> (b, w2) <span class="ot">=</span> k a</a>
<a class="sourceLine" id="cb22-7" title="7"> <span class="kw">in</span> <span class="dt">Writer</span> (b, w1 <span class="op">&lt;&gt;</span> w2) <span class="op">&gt;&gt;=</span> h</a></code></pre></div>
<p><span class="ascii">(5)</span> 等式<code>=</code>の左辺における二つ目の<code>&gt;&gt;=</code>を<code>Writer</code>における<code>&gt;&gt;=</code>の定義で置き換える<span class="ascii">:</span></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" title="1"><span class="kw">let</span> <span class="dt">Writer</span> (a, w1) <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb23-2" title="2">    <span class="dt">Writer</span> (b, w2) <span class="ot">=</span></a>
<a class="sourceLine" id="cb23-3" title="3">      <span class="kw">let</span> <span class="dt">Writer</span> (c, w3) <span class="ot">=</span> k a</a>
<a class="sourceLine" id="cb23-4" title="4">          <span class="dt">Writer</span> (d, w4) <span class="ot">=</span> h c</a>
<a class="sourceLine" id="cb23-5" title="5">       <span class="kw">in</span> <span class="dt">Writer</span> (d, w3 <span class="op">&lt;&gt;</span> w4)</a>
<a class="sourceLine" id="cb23-6" title="6"> <span class="kw">in</span> <span class="dt">Writer</span> (b, w1 <span class="op">&lt;&gt;</span> w2)</a>
<a class="sourceLine" id="cb23-7" title="7">  <span class="ot">=</span></a>
<a class="sourceLine" id="cb23-8" title="8"><span class="kw">let</span> <span class="dt">Writer</span> (a, w1) <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb23-9" title="9">    <span class="dt">Writer</span> (b, w2) <span class="ot">=</span> k a</a>
<a class="sourceLine" id="cb23-10" title="10"> <span class="kw">in</span> <span class="dt">Writer</span> (b, w1 <span class="op">&lt;&gt;</span> w2)) <span class="op">&gt;&gt;=</span> h</a></code></pre></div>
<p><span class="ascii">(6)</span> 等式<code>=</code>の右辺における二つ目の<code>&gt;&gt;=</code>も同様に変換する<span class="ascii">:</span></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" title="1"><span class="kw">let</span> <span class="dt">Writer</span> (a, w1) <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb24-2" title="2">    <span class="dt">Writer</span> (b, w2) <span class="ot">=</span></a>
<a class="sourceLine" id="cb24-3" title="3">      <span class="kw">let</span> <span class="dt">Writer</span> (c, w3) <span class="ot">=</span> k a</a>
<a class="sourceLine" id="cb24-4" title="4">          <span class="dt">Writer</span> (d, w4) <span class="ot">=</span> h c</a>
<a class="sourceLine" id="cb24-5" title="5">       <span class="kw">in</span> <span class="dt">Writer</span> (d, w3 <span class="op">&lt;&gt;</span> w4)</a>
<a class="sourceLine" id="cb24-6" title="6"> <span class="kw">in</span> <span class="dt">Writer</span> (b, w1 <span class="op">&lt;&gt;</span> w2)</a>
<a class="sourceLine" id="cb24-7" title="7">  <span class="ot">=</span></a>
<a class="sourceLine" id="cb24-8" title="8"><span class="kw">let</span> <span class="dt">Writer</span> (a, w1) <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb24-9" title="9">    <span class="dt">Writer</span> (b, w2) <span class="ot">=</span> k a</a>
<a class="sourceLine" id="cb24-10" title="10"> <span class="kw">in</span> <span class="kw">let</span> <span class="dt">Writer</span> (c, w3) <span class="ot">=</span> <span class="dt">Writer</span> (b, w1 <span class="op">&lt;&gt;</span> w2)</a>
<a class="sourceLine" id="cb24-11" title="11">        <span class="dt">Writer</span> (d, w4) <span class="ot">=</span> h c</a>
<a class="sourceLine" id="cb24-12" title="12">     <span class="kw">in</span> <span class="dt">Writer</span> (d, w3 <span class="op">&lt;&gt;</span> w4)</a></code></pre></div>
<p><span class="ascii">(7)</span> <code>Writer</code>は、<code>Writer</code>と<code>(a, w)</code>を切り替えるだけで実質何もしていないので削除する<span class="ascii">:</span></p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" title="1"><span class="kw">let</span> (a, w1) <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb25-2" title="2">    (b, w2) <span class="ot">=</span></a>
<a class="sourceLine" id="cb25-3" title="3">      <span class="kw">let</span> (c, w3) <span class="ot">=</span> k a</a>
<a class="sourceLine" id="cb25-4" title="4">          (d, w4) <span class="ot">=</span> h c</a>
<a class="sourceLine" id="cb25-5" title="5">       <span class="kw">in</span> (d, w3 <span class="op">&lt;&gt;</span> w4)</a>
<a class="sourceLine" id="cb25-6" title="6"> <span class="kw">in</span> (b, w1 <span class="op">&lt;&gt;</span> w2)</a>
<a class="sourceLine" id="cb25-7" title="7">  <span class="ot">=</span></a>
<a class="sourceLine" id="cb25-8" title="8"><span class="kw">let</span> (a, w1) <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb25-9" title="9">    (b, w2) <span class="ot">=</span> k a</a>
<a class="sourceLine" id="cb25-10" title="10"> <span class="kw">in</span> <span class="kw">let</span> (c, w3) <span class="ot">=</span> (b, w1 <span class="op">&lt;&gt;</span> w2)</a>
<a class="sourceLine" id="cb25-11" title="11">        (d, w4) <span class="ot">=</span> h c</a>
<a class="sourceLine" id="cb25-12" title="12">     <span class="kw">in</span> (d, w3 <span class="op">&lt;&gt;</span> w4)</a></code></pre></div>
<p><span class="ascii">(7.5) (7)</span>の等式をよく見ると、<code>=</code>の左辺においては<code>(b, w2)</code>と<code>(d, w3 &lt;&gt; w4)</code>が、<code>=</code>の右辺においては<code>(c, w3)</code>と<code>(b, w1 &lt;&gt; w2)</code>が等しい。</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" title="1"><span class="kw">let</span> (a, w1) <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb26-2" title="2">    (b, w2) <span class="ot">=</span> <span class="co">--           ここの(b, w2)は、</span></a>
<a class="sourceLine" id="cb26-3" title="3">      <span class="kw">let</span> (c, w3) <span class="ot">=</span> k a</a>
<a class="sourceLine" id="cb26-4" title="4">          (d, w4) <span class="ot">=</span> h c</a>
<a class="sourceLine" id="cb26-5" title="5">       <span class="kw">in</span> (d, w3 <span class="op">&lt;&gt;</span> w4) <span class="co">-- ここの(d, w3 &lt;&gt; w4)を代入したもの！</span></a>
<a class="sourceLine" id="cb26-6" title="6"> <span class="kw">in</span> (b, w1 <span class="op">&lt;&gt;</span> w2)</a>
<a class="sourceLine" id="cb26-7" title="7">  <span class="ot">=</span></a>
<a class="sourceLine" id="cb26-8" title="8"><span class="kw">let</span> (a, w1) <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb26-9" title="9">    (b, w2) <span class="ot">=</span> k a</a>
<a class="sourceLine" id="cb26-10" title="10"> <span class="kw">in</span> <span class="kw">let</span> (c, w3) <span class="ot">=</span> (b, w1 <span class="op">&lt;&gt;</span> w2) <span class="co">-- ここで代入している！</span></a>
<a class="sourceLine" id="cb26-11" title="11">        (d, w4) <span class="ot">=</span> h c</a>
<a class="sourceLine" id="cb26-12" title="12">     <span class="kw">in</span> (d, w3 <span class="op">&lt;&gt;</span> w4)</a></code></pre></div>
<p><span class="ascii">(8) (7.5)</span>から、<code>=</code>の左辺では<code>b = d</code>で<code>w2 = w3 &lt;&gt; w4</code>、<code>=</code>の右辺では<code>c = d</code>で<code>w3 = w1 &lt;&gt; w2</code>であることがわかる。なのでそれぞれ置き換える<span class="ascii">:</span></p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" title="1"><span class="kw">let</span> (a, w1) <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb27-2" title="2">    (c, w3) <span class="ot">=</span> k a</a>
<a class="sourceLine" id="cb27-3" title="3">    (d, w4) <span class="ot">=</span> h c</a>
<a class="sourceLine" id="cb27-4" title="4"> <span class="kw">in</span> (d, w1 <span class="op">&lt;&gt;</span> (w3 <span class="op">&lt;&gt;</span> w4))</a>
<a class="sourceLine" id="cb27-5" title="5">  <span class="ot">=</span></a>
<a class="sourceLine" id="cb27-6" title="6"><span class="kw">let</span> (a, w1) <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb27-7" title="7">    (b, w2) <span class="ot">=</span> k a</a>
<a class="sourceLine" id="cb27-8" title="8">    (d, w4) <span class="ot">=</span> h b</a>
<a class="sourceLine" id="cb27-9" title="9"> <span class="kw">in</span> (d, (w1 <span class="op">&lt;&gt;</span> w2) <span class="op">&lt;&gt;</span> w4)</a></code></pre></div>
<div id="associative-law-qed">

</div>
<p><span class="ascii">(9)</span> <code>a</code>～<code>d</code>・<code>w1</code>～<code>w4</code>の変数名を、登場した順番に振り直す<span class="ascii">:</span></p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" title="1"><span class="kw">let</span> (a, w1) <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb28-2" title="2">    (b, w2) <span class="ot">=</span> k a</a>
<a class="sourceLine" id="cb28-3" title="3">    (c, w3) <span class="ot">=</span> h b</a>
<a class="sourceLine" id="cb28-4" title="4"> <span class="kw">in</span> (c, w1 <span class="op">&lt;&gt;</span> (w2 <span class="op">&lt;&gt;</span> w3))</a>
<a class="sourceLine" id="cb28-5" title="5">  <span class="ot">=</span></a>
<a class="sourceLine" id="cb28-6" title="6"><span class="kw">let</span> (a, w1) <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb28-7" title="7">    (b, w2) <span class="ot">=</span> k a</a>
<a class="sourceLine" id="cb28-8" title="8">    (c, w3) <span class="ot">=</span> h b</a>
<a class="sourceLine" id="cb28-9" title="9"> <span class="kw">in</span> (c, (w1 <span class="op">&lt;&gt;</span> w2) <span class="op">&lt;&gt;</span> w3)</a></code></pre></div>
<p>等式<code>=</code>の左辺と右辺がそっくりな式になりましたね！</p>
<p>ここで、<code>Monoid</code>の結合則を思い出してみましょう<span class="ascii">:</span></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" title="1">x <span class="op">&lt;&gt;</span> (y <span class="op">&lt;&gt;</span> z) <span class="ot">=</span> (x <span class="op">&lt;&gt;</span> y) <span class="op">&lt;&gt;</span> z</a></code></pre></div>
<p>そう、<code>x &lt;&gt; y &lt;&gt; z</code>などと書いて<span class="ascii">3</span>つの<code>Monoid</code>型クラスのインスタンスの値を<code>&lt;&gt;</code>でくっつけるときは、カッコで囲って<code>(y &lt;&gt; z)</code>を先に計算しようと、<code>(x &lt;&gt; y)</code>を先に計算しようと、結果が変わらない、というものでした！</p>
<p>それを踏まえて、<span class="ascii">(9)</span>の等式<code>=</code>の両辺をよく見比べてみてください。異なっているのは<code>w1 &lt;&gt; (w2 &lt;&gt; w3)</code>と<code>(w1 &lt;&gt; w2) &lt;&gt; w3)</code>の箇所だけですね！つまり、<code>Writer</code> <code>Monad</code>における<code>&gt;&gt;=</code>の結合則は、<code>w1 &lt;&gt; (w2 &lt;&gt; w3)</code>と<code>(w1 &lt;&gt; w2) &lt;&gt; w3)</code>が等しいから、すなわち<code>Monoid</code>における<code>&lt;&gt;</code>の結合則が成り立つからこそ成立するのです。これがまさしく「<code>Monoid</code>と<code>Writer</code>の切っても切り離せない関係」なのです！</p>
<h1 id="関係を壊してみる"><span class="link-to-here-outer"><a href="#関係を壊してみる" title="関係を壊してみる"><span class="link-to-here">Link to<br />
here</span></a></span>関係を壊してみる</h1>
<p>それではいよいよ、「<code>Monoid</code>と<code>Writer</code>の切っても切り離せない関係」を利用して、<code>Monad</code>則を破ってみましょう💣</p>
<h2 id="とmonoidの結合則"><span class="link-to-here-outer"><a href="#とmonoidの結合則" title="とmonoidの結合則"><span class="link-to-here">Link to<br />
here</span></a></span><code>&lt;&gt;</code>と<code>Monoid</code>の結合則</h2>
<p>前述のとおり、<code>Writer</code>における<code>&gt;&gt;=</code>が結合則を満たすのは、<code>Writer</code>がラップしている<code>Monoid</code>な値の<code>&lt;&gt;</code>が結合則を満たしてこそ、なのでした。これは言い換えれば、その、ラップしている<code>Monoid</code>な値の<code>&lt;&gt;</code>が結合則を破れば、自然に<code>Writer</code>の<code>&gt;&gt;=</code>も結合則を破るはずです。この方法は、結合則を満たさない<code>&gt;&gt;=</code>っぽい処理をゼロから探すより遥かに簡単です。<code>&gt;&gt;=</code>のような<code>m a -&gt; (a -&gt; m b) -&gt; m b</code>というややこしい型の関数よりも、<code>&lt;&gt;</code>のような<code>a -&gt; a -&gt; a</code>という型の関数の方がずっと身近ですしね！</p>
<p><code>Monoid</code>の<code>&lt;&gt;</code>のような<code>a -&gt; a -&gt; a</code>という型の関数で、結合則を満たさない処理 — といえば、引き算<code>-</code>や割り算<code>/</code>を思い浮かべる方が多いのではないでしょうか。と、いうわけで<a href="#monoid-examples"><code>Monoid</code>の例</a>で紹介した<code>Sum</code>や<code>Product</code>のように、数値に対する引き算を表す<code>newtype</code>、<code>Difference</code>を定義してみましょう<span class="ascii">:</span></p>
<!-- ReadmeTest: AppendAsIs -->
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" title="1"><span class="kw">newtype</span> <span class="dt">Difference</span> a <span class="ot">=</span> <span class="dt">Difference</span> {<span class="ot"> getDifference ::</span> a }</a></code></pre></div>
<p>それから、<code>Difference</code>を<small>（実際には間違いですが）</small><code>Monoid</code>のインスタンスにします。最近の<span class="ascii">GHC</span>では、<code>Monoid</code>のインスタンスを定義する前に<code>Semigroup</code>のインスタンスにする必要があるのでご注意ください。説明しやすさのために敢えてこれまで触れてきませんでしたが、これまで何度も使った<code>&lt;&gt;</code>は実際のところ<code>Monoid</code>の関数ではなく<code>Semigroup</code>の関数なんですね。<code>Monoid</code>は「<code>&lt;&gt;</code>で（結合則を備えた）二項演算ができるだけでなく、<code>mempty</code>という単位元もある」という性質の型クラスなので、「単に『<code>&lt;&gt;</code>で（結合則を備えた）二項演算ができる』だけの型クラスも欲しい！」というニーズから、<code>Monoid</code>の<code>&lt;&gt;</code>は<code>Semigroup</code>の関数となり、<code>Monoid</code>は<code>Semigroup</code>のサブクラスという関係に変わったのでした。</p>
<p>何はともあれ、<code>Difference</code>を<code>Semigroup</code>のインスタンスにしましょう<span class="ascii">:</span></p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" title="1"><span class="kw">instance</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">Difference</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb31-2" title="2">  <span class="dt">Difference</span> a <span class="op">&lt;&gt;</span> <span class="dt">Difference</span> b <span class="ot">=</span> <span class="dt">Difference</span> (a <span class="op">-</span> b)</a></code></pre></div>
<p>はい、単に両辺を<code>-</code>で引き算するだけですね。</p>
<p>今度こそ<code>Difference</code>を<code>Monoid</code>のインスタンスにします。本記事では<code>mempty</code>を直接使うことはないので何でもいいはずですが、とりあえず<code>Sum</code>と同様に<code>0</code>ということにしておきます<span class="ascii">:</span></p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" title="1"><span class="kw">instance</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Difference</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-2" title="2">  <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">Difference</span> <span class="dv">0</span></a></code></pre></div>
<p>😈これで<code>&lt;&gt;</code>が結合則を満たさないおかしな<code>Monoid</code>のインスタンス、<code>Difference</code>ができました！早速試して結合則を破っていることを確認してみましょう<span class="ascii">:</span></p>
<!-- ReadmeTest: CompareAfterPrompt ByExpression -->
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" title="1"><span class="co">-- こちらは 1 - (2 - 3) と同じ</span></a>
<a class="sourceLine" id="cb33-2" title="2"><span class="op">&gt;</span> getDifference <span class="op">$</span> <span class="dt">Difference</span> <span class="dv">1</span> <span class="op">&lt;&gt;</span> (<span class="dt">Difference</span> <span class="dv">2</span> <span class="op">&lt;&gt;</span> <span class="dt">Difference</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb33-3" title="3"><span class="dv">2</span></a>
<a class="sourceLine" id="cb33-4" title="4"></a>
<a class="sourceLine" id="cb33-5" title="5"><span class="co">-- こちらは (1 - 2) - 3 と同じなので...</span></a>
<a class="sourceLine" id="cb33-6" title="6"><span class="op">&gt;</span> getDifference <span class="op">$</span> (<span class="dt">Difference</span> <span class="dv">1</span> <span class="op">&lt;&gt;</span> <span class="dt">Difference</span> <span class="dv">2</span>) <span class="op">&lt;&gt;</span> <span class="dt">Difference</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb33-7" title="7"><span class="op">-</span><span class="dv">4</span> <span class="co">-- &lt;- 当然 1 - (2 - 3) とは異なる結果に！</span></a></code></pre></div>
<p>バッチリ破れてますね！このように<code>&lt;&gt;</code>における結合則は、引き算などおなじみの演算で、簡単に破ることができます💪</p>
<h2 id="とmonadの結合則"><span class="link-to-here-outer"><a href="#とmonadの結合則" title="とmonadの結合則"><span class="link-to-here">Link to<br />
here</span></a></span><code>&gt;&gt;=</code>と<code>Monad</code>の結合則</h2>
<p><code>&lt;&gt;</code>における結合則を破ることができたと言うことは、<code>Writer</code>の<code>&gt;&gt;=</code>による結合則も、もはや破れたも同然です。先ほど定義した<code>Difference</code>型を使えば、<code>&gt;&gt;=</code>は途端に結合則を満たさなくなるでしょう。</p>
<p>例を示す前に、<code>Writer</code>を使う際しばしば用いられる、ユーティリティー関数を定義しておきます。実践で<code>Writer</code>を使いたくなったときにも大変便利なので、是非覚えておいてください<span class="ascii">:</span></p>
<!-- ReadmeTest: AppendAsIs -->
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" title="1"><span class="ot">tell ::</span> <span class="dt">Monoid</span> w <span class="ot">=&gt;</span> w <span class="ot">-&gt;</span> <span class="dt">Writer</span> w ()</a>
<a class="sourceLine" id="cb34-2" title="2">tell w <span class="ot">=</span> <span class="dt">Writer</span> ((), w)</a></code></pre></div>
<p>この<code>tell</code>関数は、受け取った<code>Monoid</code>な値をそのまま「ログとして書き込む」関数です。結果として返す値はただのユニット<code>()</code>なので、気にする必要がありません。<code>tell</code>のみを使って<code>Writer</code>を組み立てれば、「ログとして書き込む」値のみに集中することができます。これから紹介する例でもやはり関心があるのは「ログとして書き込む」値だけなので、ここで<code>tell</code>を定義しました。</p>
<p>それでは<code>tell</code>を使って、<code>Writer</code>の<code>&gt;&gt;=</code>における結合則も破ってみましょう<span class="ascii">:</span></p>
<!-- ReadmeTest: CompareAfterPrompt ByExpression -->
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" title="1"><span class="co">-- こちらは Difference 1 &lt;&gt; (Difference 2 &lt;&gt; Difference 3) と同じ</span></a>
<a class="sourceLine" id="cb35-2" title="2"><span class="op">&gt;</span> getDifference <span class="op">.</span> <span class="fu">snd</span> <span class="op">.</span> runWriter <span class="op">$</span> tell (<span class="dt">Difference</span> <span class="dv">1</span>) <span class="op">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> tell (<span class="dt">Difference</span> <span class="dv">2</span>) <span class="op">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> tell (<span class="dt">Difference</span> <span class="dv">3</span>)))</a>
<a class="sourceLine" id="cb35-3" title="3"><span class="dv">2</span></a>
<a class="sourceLine" id="cb35-4" title="4"></a>
<a class="sourceLine" id="cb35-5" title="5"><span class="co">-- こちらは (Difference 1 &lt;&gt; Difference 2) &lt;&gt; Difference 3 と同じなので...</span></a>
<a class="sourceLine" id="cb35-6" title="6"><span class="op">&gt;</span> getDifference <span class="op">.</span> <span class="fu">snd</span> <span class="op">.</span> runWriter <span class="op">$</span> (tell (<span class="dt">Difference</span> <span class="dv">1</span>) <span class="op">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> tell (<span class="dt">Difference</span> <span class="dv">2</span>))) <span class="op">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> tell (<span class="dt">Difference</span> <span class="dv">3</span>))</a>
<a class="sourceLine" id="cb35-7" title="7"><span class="op">-</span><span class="dv">4</span> <span class="co">-- &lt;- 当然 1 - (2 - 3) とは異なる結果に！</span></a></code></pre></div>
<p>予想どおり一つ目の<code>Writer</code>と二つ目の<code>Writer</code>とで異なる結果となりました。<code>1 - (2 - 3)</code>と<code>(1 - 2) - 3</code>を<code>Writer</code>を使って遠回しに言い換えているだけなので、当然と言えば当然です。</p>
<p>しかし<code>tell (Difference 1) &gt;&gt;= (\_ -&gt; tell (Difference 2) &gt;&gt;= \_ -&gt; tell (Difference 3))</code>などの<code>Writer</code>型の式が<code>Monad</code>の結合則<code>m &gt;&gt;= (\x -&gt; k x &gt;&gt;= h) = (m &gt;&gt;= (\x -&gt; k x)) &gt;&gt;= h</code>にどう対応するのか、ちょっと分かりづらいですかね？<small>（式も長いし）</small>一つずつ注釈を加えます<span class="ascii">:</span></p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" title="1"><span class="co">-- こちらは m &gt;&gt;= (\x -&gt; k x &gt;&gt;= h) = (m &gt;&gt;= (\x -&gt; k x)) &gt;&gt;= h の前半、</span></a>
<a class="sourceLine" id="cb36-2" title="2"><span class="co">--   m &gt;&gt;= (\x -&gt; k x &gt;&gt;= h) に相当する</span></a>
<a class="sourceLine" id="cb36-3" title="3"><span class="op">&gt;</span>  tell (<span class="dt">Difference</span> <span class="dv">1</span>) <span class="op">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> tell (<span class="dt">Difference</span> <span class="dv">2</span>) <span class="op">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> tell (<span class="dt">Difference</span> <span class="dv">3</span>)))</a>
<a class="sourceLine" id="cb36-4" title="4"><span class="co">-- ^^^^^^^^^^^^^^^^^^^       ^    ^^^^^^^^^^^^^^^^^^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></a>
<a class="sourceLine" id="cb36-5" title="5"><span class="co">--          m                x             k                             h</span></a>
<a class="sourceLine" id="cb36-6" title="6"><span class="co">--</span></a>
<a class="sourceLine" id="cb36-7" title="7"></a>
<a class="sourceLine" id="cb36-8" title="8"><span class="co">-- こちらは m &gt;&gt;= (\x -&gt; k x &gt;&gt;= h) = (m &gt;&gt;= (\x -&gt; k x)) &gt;&gt;= h の後半、</span></a>
<a class="sourceLine" id="cb36-9" title="9"><span class="co">--   (m &gt;&gt;= (\x -&gt; k x)) &gt;&gt;= h に相当する</span></a>
<a class="sourceLine" id="cb36-10" title="10"><span class="op">&gt;</span>  (tell (<span class="dt">Difference</span> <span class="dv">1</span>) <span class="op">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> tell (<span class="dt">Difference</span> <span class="dv">2</span>))) <span class="op">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> tell (<span class="dt">Difference</span> <span class="dv">3</span>))</a>
<a class="sourceLine" id="cb36-11" title="11"><span class="co">--  ^^^^^^^^^^^^^^^^^^^       ^    ^^^^^^^^^^^^^^^^^^^       ^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></a>
<a class="sourceLine" id="cb36-12" title="12"><span class="co">--           m                x             k                             h</span></a></code></pre></div>
<p>ラムダ式の引数<code>x</code>は実際には使われていない点に注意してください。これでも<code>const</code>を使って<code>\x -&gt; const (tell (Difference 2)) x</code>と書き換えれば、<code>const (tell (Difference 2))</code>が<code>k</code>に厳密に対応するので、上記の二組の式は<code>&gt;&gt;=</code>の結合則を破るペアだと言えます。</p>
<h2 id="do記法とmonadの結合則"><span class="link-to-here-outer"><a href="#do記法とmonadの結合則" title="do記法とmonadの結合則"><span class="link-to-here">Link to<br />
here</span></a></span><code>do</code>記法と<code>Monad</code>の結合則</h2>
<p>前の節では、<code>Monoid</code>の結合則を守っていない値をラップしている<code>Writer</code>を作ることで、<code>&gt;&gt;=</code>の結合則を破る例を簡単に作り出せることを紹介しました。ここでは本記事の最後として、<code>&gt;&gt;=</code>の結合則を破った結果、<code>do</code>記法がいかに直感に反する挙動となるか紹介して、<code>&gt;&gt;=</code>の結合則を守ることが私たちにどのようなメリットをもたらすのか解説します。</p>
<p>例として、先ほど<code>&gt;&gt;=</code>の結合則を破るのに使った<code>1 - 2 - 3</code>を再利用しましょう。<code>Difference</code>をラップした<code>Writer</code>で<code>1 - 2 - 3</code>を計算させると、次のような式になります<span class="ascii">:</span></p>
<!-- ReadmeTest: ValidateAsExpression -->
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" title="1">tell (<span class="dt">Difference</span> <span class="dv">1</span>) <span class="op">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> tell (<span class="dt">Difference</span> <span class="dv">2</span>)) <span class="op">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> tell (<span class="dt">Difference</span> <span class="dv">3</span>))</a></code></pre></div>
<p>これを<code>do</code>記法に変換すると、次のようになります<span class="ascii">:</span></p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" title="1"><span class="kw">do</span></a>
<a class="sourceLine" id="cb38-2" title="2">  tell (<span class="dt">Difference</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb38-3" title="3">  tell (<span class="dt">Difference</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb38-4" title="4">  tell (<span class="dt">Difference</span> <span class="dv">3</span>)</a></code></pre></div>
<p><code>do</code>記法における各行の間に<code>&gt;&gt;=</code>が隠れたことで、すっきりしましたね！</p>
<p>この状態から、<code>do</code>記法を使って<code>1 - (2 - 3)</code>と<code>(1 - 2) - 3</code>を表す<code>Writer</code>の式にするには、次のように書き換えます<span class="ascii">:</span></p>
<!-- ReadmeTest: AppendAsIs -->
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" title="1"><span class="co">-- こちらが 1 - (2 - 3) を表す</span></a>
<a class="sourceLine" id="cb39-2" title="2">do_1minus&#39;2minus3&#39; <span class="ot">=</span></a>
<a class="sourceLine" id="cb39-3" title="3">  <span class="kw">do</span></a>
<a class="sourceLine" id="cb39-4" title="4">    tell (<span class="dt">Difference</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb39-5" title="5">    <span class="kw">do</span></a>
<a class="sourceLine" id="cb39-6" title="6">      tell (<span class="dt">Difference</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb39-7" title="7">      tell (<span class="dt">Difference</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb39-8" title="8"></a>
<a class="sourceLine" id="cb39-9" title="9"><span class="co">-- こちらが (1 - 2) - 3 を表す</span></a>
<a class="sourceLine" id="cb39-10" title="10">do_&#39;1minus2&#39;minus3 <span class="ot">=</span></a>
<a class="sourceLine" id="cb39-11" title="11">  <span class="kw">do</span></a>
<a class="sourceLine" id="cb39-12" title="12">    <span class="kw">do</span></a>
<a class="sourceLine" id="cb39-13" title="13">      tell (<span class="dt">Difference</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb39-14" title="14">      tell (<span class="dt">Difference</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb39-15" title="15">    tell (<span class="dt">Difference</span> <span class="dv">3</span>)</a></code></pre></div>
<p>コメントに書いたとおり、<code>do_1minus'2minus3'</code>が<code>1 - (2 - 3)</code>、<code>do_'1minus2'minus3</code>が<code>(1 - 2) - 3</code>と同等な<code>Writer</code>です。<span class="ascii">Haskell</span>はシングルクォートを変数の名前に含めることができるので、シングルクォートでカッコを表すことにしました<small>（まさかこんなところで役に立つとはね！）</small>。</p>
<p>上記の二つの式では、カッコ<code>()</code>で囲う代わりにもう一つの<code>do</code>記法に収めることで、<code>do</code>記法における各行を実行する順番をいじっています。</p>
<p>本当にこれで<code>1 - (2 - 3)</code>や<code>(1 - 2) - 3</code>と同等な式になっているのでしょうか？試しに<code>runWriter</code>して結果を確かめてみましょう<span class="ascii">:</span></p>
<!-- ReadmeTest: CompareAfterPrompt ByExpression -->
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" title="1"><span class="co">-- こちらが 1 - (2 - 3) を表す</span></a>
<a class="sourceLine" id="cb40-2" title="2"><span class="op">&gt;</span> getDifference <span class="op">.</span> <span class="fu">snd</span> <span class="op">$</span> runWriter do_1minus&#39;2minus3&#39;</a>
<a class="sourceLine" id="cb40-3" title="3"><span class="dv">2</span></a>
<a class="sourceLine" id="cb40-4" title="4"></a>
<a class="sourceLine" id="cb40-5" title="5"><span class="co">-- こちらが (1 - 2) - 3 を表す</span></a>
<a class="sourceLine" id="cb40-6" title="6"><span class="op">&gt;</span> getDifference <span class="op">.</span> <span class="fu">snd</span> <span class="op">$</span> runWriter do_&#39;1minus2&#39;minus3</a>
<a class="sourceLine" id="cb40-7" title="7"><span class="op">-</span><span class="dv">4</span></a></code></pre></div>
<p>バッチリ👌想定どおり、<code>do_1minus'2minus3'</code>が<code>1 - (2 - 3) = 2</code>を計算し、<code>do_'1minus2'minus3</code>が<code>(1 - 2) - 3 = -4</code>を計算していますね！</p>
<p>さてこれまでで、<code>Writer</code> <code>Monad</code>は<code>Monoid</code>の結合則を利用することで<code>&gt;&gt;=</code>の結合則を満たしていることを示し、ラップしている<code>Monoid</code>な値が結合則を満たしていなければ、必然的に<code>Writer</code>も結合則を破ってしまうことを、<code>&gt;&gt;=</code>や<code>do</code>記法を使って具体的に示しました。それでは今挙げた、<code>do</code>記法で結合則を破った例は、一体何を示唆しているのでしょうか？普通に<span class="ascii">Haskell</span>でコードを書いていて、前述のような書き換え、すなわち、</p>
<!-- ReadmeTest: ValidateAsExpression -->
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" title="1"><span class="kw">do</span></a>
<a class="sourceLine" id="cb41-2" title="2">  tell (<span class="dt">Difference</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb41-3" title="3">  <span class="kw">do</span></a>
<a class="sourceLine" id="cb41-4" title="4">    tell (<span class="dt">Difference</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb41-5" title="5">    tell (<span class="dt">Difference</span> <span class="dv">3</span>)</a></code></pre></div>
<p>から、</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" title="1"><span class="kw">do</span></a>
<a class="sourceLine" id="cb42-2" title="2">  <span class="kw">do</span></a>
<a class="sourceLine" id="cb42-3" title="3">    tell (<span class="dt">Difference</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb42-4" title="4">    tell (<span class="dt">Difference</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb42-5" title="5">  tell (<span class="dt">Difference</span> <span class="dv">3</span>)</a></code></pre></div>
<p>への書き換え<small>（あるいはその逆）</small>は、一見するとそんな機会ないように思えます。しかしこれが、<code>do</code>記法をカッコ代わりに使うという変な方法ではなく、次のように変数に代入することで切り出していた場合、いかがでしょうか？</p>
<!-- ReadmeTest: AppendAsIs -->
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" title="1">someSingleAction <span class="ot">=</span> tell (<span class="dt">Difference</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb43-2" title="2"></a>
<a class="sourceLine" id="cb43-3" title="3">someSequence <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb43-4" title="4">  tell (<span class="dt">Difference</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb43-5" title="5">  tell (<span class="dt">Difference</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb43-6" title="6"></a>
<a class="sourceLine" id="cb43-7" title="7">someCompositeAction <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb43-8" title="8">  someSingleAction</a>
<a class="sourceLine" id="cb43-9" title="9">  someSequence</a></code></pre></div>
<p>上記👆のような三つの<code>Writer</code>の値を、下記👇の三つの値にリファクタリングする場合です。</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" title="1">refactoredSequence <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb44-2" title="2">  tell (<span class="dt">Difference</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb44-3" title="3">  tell (<span class="dt">Difference</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb44-4" title="4"></a>
<a class="sourceLine" id="cb44-5" title="5">splitOutSingleAction <span class="ot">=</span> tell (<span class="dt">Difference</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb44-6" title="6"></a>
<a class="sourceLine" id="cb44-7" title="7">refactoredCompositeAction <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb44-8" title="8">  refactoredSequence</a>
<a class="sourceLine" id="cb44-9" title="9">  splitOutSingleAction</a></code></pre></div>
<p>あるいは、たった<span class="ascii">3</span>行しかありませんし、一つの値に統合する方がいいかも知れません<span class="ascii">:</span></p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" title="1">flattenedAction <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb45-2" title="2">  tell (<span class="dt">Difference</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb45-3" title="3">  tell (<span class="dt">Difference</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb45-4" title="4">  tell (<span class="dt">Difference</span> <span class="dv">3</span>)</a></code></pre></div>
<p>これらの書き換えは、いずれも<code>do</code>記法が内部で使っている<code>&gt;&gt;=</code>の結合則を前提とすれば、可能であってしかるべきです。<code>do</code>記法は、適当に<code>Monad</code>のインスタンスの値（「アクション」などとも呼ばれます）を上から下まで列挙すれば、自動で<code>&gt;&gt;=</code>を使ってつなげてくれる、というものです。なので、適当に並べたアクションがどういう形に結合されるのか気にする必要があるのでは、安心して使えません。一方、上記の<span class="ascii">3</span>組の式は、<code>Writer Difference</code>、すなわち引き算を表す「偽<code>Monoid</code>」をラップしているが故に、<code>&gt;&gt;=</code>の結合則を満たしておりません。結果、<code>do</code>記法に変えたときに並べたアクションをどこで切り出すかで、結果が変わってしまいます。これでは安心して列挙できません！</p>
<!-- ReadmeTest: CompareAfterPrompt ByExpression -->
<!--
```haskell
> getDifference . snd $ runWriter someCompositeAction
2
> getDifference . snd $ runWriter refactoredCompositeAction
-4
> getDifference . snd $ runWriter flattenedAction
2
```
-->
<h1 id="まとめ"><span class="link-to-here-outer"><a href="#まとめ" title="まとめ"><span class="link-to-here">Link to<br />
here</span></a></span>まとめ</h1>
<p>以上です。これまでで、<code>Monad</code>則のうち結合則がなぜ重要なのか、結合則を実際に破ってみることを通じて説明しました。<code>Monad</code>と同様に結合則を持った<code>Monoid</code>は、<code>Monad</code>以上にインスタンスを見つけるのが簡単で、なおかつ、例えば引き算のように「二項演算だけど結合則を満たしていない」処理を見つけるのが簡単です。本記事では<code>Monoid</code>のそうした性質と、<code>Monoid</code>の性質でもって<code>Monad</code>則を満たしている<code>Writer</code> <code>Monad</code>に注目することで、簡単に<code>Monad</code>則を破る例を提示することができました。それから、<code>Monad</code>の結合則を実際に破った例を使って、<code>Monad</code>の結合則が<code>do</code>記法を自然に書けるようにするために必要であることを示しました。これらの実例から主張したいことを一般化すると、次のとおりです<span class="ascii">:</span></p>
<ul>
<li><code>do</code>記法の各行の間で、値を返すついでに何かを行うのが<code>Monad</code>のインスタンス</li>
<li><code>do</code>記法の各行の間で、値を返すついでに行っている処理が結合則を満たす型が、<code>Monad</code>則を満たすと言える</li>
<li><code>Monad</code>則を守らない型を<code>do</code>記法で使うと、<code>do</code>記法の結合を気にして書かなければならなくなる</li>
</ul>
<p>それでは、<span class="ascii">2021</span>年も🎁<span class="ascii">Happy Haskell Hacking with Monad</span>🎁<span class="ascii">!</span></p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>一応、<code>Monad</code>についてはそのスーパークラスである<code>Applicative</code>の則、<code>Functor</code>の則がありますが、<code>Monad</code>則を満たしていればそれらは自動的に満たせるので、ここでは省略します。<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>残念ながら実際のところ、<code>Float</code>型・<code>Double</code>型などの浮動小数点数に対する<code>Sum</code>や<code>Product</code>は結合則を満たさない場合があります。これは他の多くのプログラミング言語にもある、浮動小数点数の悩ましい問題です。詳しくは「情報落ち」で検索してみてください。<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>ここでの定義は、実際に使われている<a href="http://hackage.haskell.org/package/transformers"><span class="ascii">transformers</span>パッケージ</a>の<code>Writer</code>の定義とは大きく異なっているのでご注意ください。実際の<code>Writer</code>はパフォーマンス上の都合や<span class="ascii">Monad Transformer</span>との兼ね合いで、幾分工夫された定義となっています。<a href="#fnref3" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/about_admins.html" lang="ja">日本Haskellユーザーグループ管理委員会（Haskell-jp Admins）設立のお知らせ</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2020/antenna-with-gh-actions.html" style="margin-left: auto;" lang="ja">Haskell AntennaのCI/CDをGitHub Actionsに移行する</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>Haskell AntennaのCI/CDをGitHub Actionsに移行する</title>
    <link href="https://haskell.jp/blog/posts/2020/antenna-with-gh-actions.html" />
    <id>https://haskell.jp/blog/posts/2020/antenna-with-gh-actions.html</id>
    <published>2020-12-12T00:00:00Z</published>
    <updated>2020-12-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p><span class="ascii">Haskell-jp</span>のコンテンツの一つとして<a href="https://haskell.jp/antenna/"><span class="ascii">Haskell Antenna</span></a>という<span class="ascii">Web</span>ページの開発・運用をしております。</p>
<p><img src="../../img/2020/antenna-with-gh-actions/antenna-page.jpg" style="width: 100%;"></p>
<p>バイナリのビルドや<span class="ascii">Docker</span>イメージのビルドに<span class="ascii">TravisCI</span>を、バイナリを実行してページの更新をするのに<span class="ascii">DroneCI</span>を使っていました。 しかし、長らく放置していてちゃんと動作しているか怪しかったので、メンテナンスをするついでに昨今はやり（要出典）の<a href="https://github.com/haskell-jp/antenna/pull/26"><span class="ascii">GitHub Actions</span>にこれらを移行することにしました</a>。</p>
<p><img src="../../img/2020/antenna-with-gh-actions/pr.jpg" style="width: 100%;"></p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#stackプロジェクトのビルド" title="stackプロジェクトのビルド"><span class="ascii">Stack</span>プロジェクトのビルド</a></li>
<li><a href="#dockerイメージのビルドとプッシュ" title="dockerイメージのビルドとプッシュ"><span class="ascii">Docker</span>イメージのビルドとプッシュ</a></li>
<li><a href="#antennaプログラムの実行" title="antennaプログラムの実行"><span class="ascii">antenna</span>プログラムの実行</a></li>
</ul>
</div>
</div>
<h3 id="stackプロジェクトのビルド"><span class="link-to-here-outer"><a href="#stackプロジェクトのビルド" title="stackプロジェクトのビルド"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Stack</span>プロジェクトのビルド</h3>
<p>まずはバイナリのビルドを行うように設定します。 <span class="ascii">Haskell Antenna</span>のプログラムは<span class="ascii">Haskell Stack</span>を利用しているので、<code>stack build</code>が実行できれば良いです。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb1-1" title="1"><span class="fu">name:</span><span class="at"> Build Application</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="fu">on:</span></a>
<a class="sourceLine" id="cb1-3" title="3">  <span class="fu">pull_request:</span><span class="at"> </span><span class="ch">null</span></a>
<a class="sourceLine" id="cb1-4" title="4">  <span class="fu">push:</span></a>
<a class="sourceLine" id="cb1-5" title="5">    <span class="fu">branches:</span></a>
<a class="sourceLine" id="cb1-6" title="6">    <span class="kw">-</span> master</a>
<a class="sourceLine" id="cb1-7" title="7"><span class="fu">jobs:</span></a>
<a class="sourceLine" id="cb1-8" title="8">  <span class="fu">build:</span></a>
<a class="sourceLine" id="cb1-9" title="9">    <span class="fu">name:</span><span class="at"> ${{ matrix.os }}</span></a>
<a class="sourceLine" id="cb1-10" title="10">    <span class="fu">runs-on:</span><span class="at"> ubuntu-18.04</span></a>
<a class="sourceLine" id="cb1-11" title="11">    <span class="fu">strategy:</span></a>
<a class="sourceLine" id="cb1-12" title="12">      <span class="fu">fail-fast:</span><span class="at"> </span><span class="ch">false</span></a>
<a class="sourceLine" id="cb1-13" title="13">      <span class="fu">matrix:</span></a>
<a class="sourceLine" id="cb1-14" title="14">        <span class="fu">ghc:</span><span class="at"> </span><span class="kw">[</span><span class="st">&quot;8.8.4&quot;</span><span class="kw">]</span></a>
<a class="sourceLine" id="cb1-15" title="15">    <span class="fu">steps:</span></a>
<a class="sourceLine" id="cb1-16" title="16">    <span class="kw">-</span> <span class="fu">uses:</span><span class="at"> actions/checkout@v2</span></a>
<a class="sourceLine" id="cb1-17" title="17">    <span class="kw">-</span> <span class="fu">name:</span><span class="at"> Cache .stack</span></a>
<a class="sourceLine" id="cb1-18" title="18">      <span class="fu">id:</span><span class="at"> cache-stack</span></a>
<a class="sourceLine" id="cb1-19" title="19">      <span class="fu">uses:</span><span class="at"> actions/cache@v2</span></a>
<a class="sourceLine" id="cb1-20" title="20">      <span class="fu">with:</span></a>
<a class="sourceLine" id="cb1-21" title="21">        <span class="fu">path:</span><span class="at"> ~/.stack</span></a>
<a class="sourceLine" id="cb1-22" title="22">        <span class="fu">key:</span><span class="at"> </span><span class="st">&quot;\</span></a>
<a class="sourceLine" id="cb1-23" title="23"><span class="st">          ${{ runner.os }}-stack\</span></a>
<a class="sourceLine" id="cb1-24" title="24"><span class="st">          -${{ hashFiles(&#39;**/stack.yaml.lock&#39;) }}\</span></a>
<a class="sourceLine" id="cb1-25" title="25"><span class="st">          -${{ hashFiles(&#39;**/package.yaml&#39;) }}\</span></a>
<a class="sourceLine" id="cb1-26" title="26"><span class="st">        &quot;</span></a>
<a class="sourceLine" id="cb1-27" title="27"><span class="fu">        restore-keys:</span> <span class="st">|</span></a>
<a class="sourceLine" id="cb1-28" title="28">          ${{ runner.os }}-stack-</a>
<a class="sourceLine" id="cb1-29" title="29">    <span class="kw">-</span> <span class="fu">uses:</span><span class="at"> haskell/actions/setup@main</span></a>
<a class="sourceLine" id="cb1-30" title="30">      <span class="fu">name:</span><span class="at"> Setup Haskell</span></a>
<a class="sourceLine" id="cb1-31" title="31">      <span class="fu">with:</span></a>
<a class="sourceLine" id="cb1-32" title="32">        <span class="fu">ghc-version:</span><span class="at"> ${{ matrix.ghc }}</span></a>
<a class="sourceLine" id="cb1-33" title="33">        <span class="fu">enable-stack:</span><span class="at"> </span><span class="ch">true</span></a>
<a class="sourceLine" id="cb1-34" title="34">        <span class="fu">stack-version:</span><span class="at"> </span><span class="st">&#39;latest&#39;</span></a>
<a class="sourceLine" id="cb1-35" title="35">    <span class="kw">-</span> <span class="fu">name:</span><span class="at"> Install dependencies</span></a>
<a class="sourceLine" id="cb1-36" title="36">      <span class="fu">run:</span><span class="at"> stack --system-ghc test --only-dependencies</span></a>
<a class="sourceLine" id="cb1-37" title="37">    <span class="kw">-</span> <span class="fu">name:</span><span class="at"> Build and Test</span></a>
<a class="sourceLine" id="cb1-38" title="38">      <span class="fu">run:</span><span class="at"> stack --system-ghc test --copy-bins --local-bin-path=./bin</span></a></code></pre></div>
<p>これは、<span class="ascii">PR</span>が作られたときや<span class="ascii">master</span>がプッシュされたときに実行されることを想定しています。</p>
<p><span class="ascii">GitHub Actions</span>で<span class="ascii">Haskell</span>や<span class="ascii">Haskell Stack</span>を使うには、<del>公式が提供している<a href="https://github.com/actions/setup-haskell"><span class="ascii">actions/setup-haskell</span></a></del> <a href="https://github.com/haskell/actions/tree/main/setup"><span class="ascii">haskell/actions/setup</span></a> を利用します。 元々は<span class="ascii">actions/haskell-setup</span>がありましたが、どうやら<a href="https://github.com/actions/setup-haskell/pull/56">メンテナンスする人がいなくなったっぽく</a>アーカイブされてしまいました。 この記事を書いている時点では移行したばかりでちゃんとタグが切られていないため、<span class="ascii">main</span>ブランチを指定しています。 ちなみに、<span class="ascii">Stack</span>プロジェクトの<span class="ascii">GHC</span>バージョンを<span class="ascii">haskell/actions/setup</span>でインストールして、<code>stack --system-ghc</code>をすることでキャッシュサイズを減らすことができます。</p>
<p>これまた余談ですが、<span class="ascii">actions/setup-haskell</span>の方を使っていて次のようなエラーが出る場合は<span class="ascii">actions/setup-haskell</span>のバージョンが古いです（<a href="https://github.com/actions/setup-haskell/issues/44">最新では修正済みです</a>）。<span class="ascii">haskell/actions/setup</span>の方を使いましょう。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" title="1"><span class="ex">Installing</span> ghc version 8.8.4</a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="ex">Error</span>: Unable to process command <span class="st">&#39;::add-path::/opt/ghc/8.8.4/bin&#39;</span> successfully.</a>
<a class="sourceLine" id="cb2-3" title="3">  <span class="ex">Error</span>: The <span class="kw">`</span><span class="ex">add-path</span><span class="kw">`</span> command is disabled. Please upgrade to using Environment Files or opt into unsecure command execution by setting the <span class="kw">`</span><span class="ex">ACTIONS_ALLOW_UNSECURE_COMMANDS</span><span class="kw">`</span> environment variable to <span class="kw">`</span><span class="fu">true</span><span class="kw">`</span>. For more information see: https://github.blog/changelog/2020-10-01-github-actions-deprecating-set-env-and-add-path-commands/</a></code></pre></div>
<h3 id="dockerイメージのビルドとプッシュ"><span class="link-to-here-outer"><a href="#dockerイメージのビルドとプッシュ" title="dockerイメージのビルドとプッシュ"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Docker</span>イメージのビルドとプッシュ</h3>
<p><a href="https://hub.docker.com/r/haskelljp/antenna/"><span class="ascii">antenna</span>プログラムは<span class="ascii">Docker</span>イメージにして<span class="ascii">Docker Hub</span>に置いてあります</a>（これも<span class="ascii">GitHub Container Registry</span>に移行したいですね）。 なので、<span class="ascii">master</span>の更新に合わせて<span class="ascii">Docker</span>イメージをビルドしてプッシュするジョブを設定します。 <span class="ascii">Docker</span>イメージのビルドとプッシュには<a href="https://github.com/docker/build-push-action"><span class="ascii">docker/build-push-action</span></a>を使います。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb3-1" title="1"><span class="co"># さっきと同じ設定ファイルです</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="fu">name:</span><span class="at"> Build Application</span></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="fu">on:</span></a>
<a class="sourceLine" id="cb3-4" title="4">  <span class="fu">pull_request:</span><span class="at"> </span><span class="ch">null</span></a>
<a class="sourceLine" id="cb3-5" title="5">  <span class="fu">push:</span></a>
<a class="sourceLine" id="cb3-6" title="6">    <span class="fu">branches:</span></a>
<a class="sourceLine" id="cb3-7" title="7">    <span class="kw">-</span> master</a>
<a class="sourceLine" id="cb3-8" title="8"><span class="fu">jobs:</span></a>
<a class="sourceLine" id="cb3-9" title="9">  <span class="fu">build:</span></a>
<a class="sourceLine" id="cb3-10" title="10">    <span class="fu">name:</span><span class="at"> ${{ matrix.os }}</span></a>
<a class="sourceLine" id="cb3-11" title="11">    <span class="fu">runs-on:</span><span class="at"> ubuntu-18.04</span></a>
<a class="sourceLine" id="cb3-12" title="12">    <span class="fu">strategy:</span></a>
<a class="sourceLine" id="cb3-13" title="13">      <span class="fu">fail-fast:</span><span class="at"> </span><span class="ch">false</span></a>
<a class="sourceLine" id="cb3-14" title="14">      <span class="fu">matrix:</span></a>
<a class="sourceLine" id="cb3-15" title="15">        <span class="fu">ghc:</span><span class="at"> </span><span class="kw">[</span><span class="st">&quot;8.8.4&quot;</span><span class="kw">]</span></a>
<a class="sourceLine" id="cb3-16" title="16">    <span class="fu">steps:</span></a>
<a class="sourceLine" id="cb3-17" title="17">    ... <span class="co"># 割愛</span></a>
<a class="sourceLine" id="cb3-18" title="18">    <span class="kw">-</span> <span class="fu">name:</span><span class="at"> Build and Test</span></a>
<a class="sourceLine" id="cb3-19" title="19">      <span class="fu">run:</span><span class="at"> stack --system-ghc test --copy-bins --local-bin-path=./bin</span></a>
<a class="sourceLine" id="cb3-20" title="20">    <span class="co"># Build and Push Docker Image</span></a>
<a class="sourceLine" id="cb3-21" title="21">    <span class="kw">-</span> <span class="fu">name:</span><span class="at"> Setup QEMU</span></a>
<a class="sourceLine" id="cb3-22" title="22">      <span class="fu">uses:</span><span class="at"> docker/setup-qemu-action@master</span></a>
<a class="sourceLine" id="cb3-23" title="23">      <span class="fu">with:</span></a>
<a class="sourceLine" id="cb3-24" title="24">        <span class="fu">platforms:</span><span class="at"> all</span></a>
<a class="sourceLine" id="cb3-25" title="25">    <span class="kw">-</span> <span class="fu">name:</span><span class="at"> Setup Docker Buildx</span></a>
<a class="sourceLine" id="cb3-26" title="26">      <span class="fu">id:</span><span class="at"> buildx</span></a>
<a class="sourceLine" id="cb3-27" title="27">      <span class="fu">uses:</span><span class="at"> docker/setup-buildx-action@master</span></a>
<a class="sourceLine" id="cb3-28" title="28">      <span class="fu">with:</span></a>
<a class="sourceLine" id="cb3-29" title="29">        <span class="fu">version:</span><span class="at"> latest</span></a>
<a class="sourceLine" id="cb3-30" title="30">    <span class="kw">-</span> <span class="fu">name:</span><span class="at"> Login to DockerHub</span></a>
<a class="sourceLine" id="cb3-31" title="31">      <span class="fu">uses:</span><span class="at"> docker/login-action@v1</span></a>
<a class="sourceLine" id="cb3-32" title="32">      <span class="fu">with:</span></a>
<a class="sourceLine" id="cb3-33" title="33">        <span class="fu">username:</span><span class="at"> ${{ secrets.DOCKER_USERNAME }}</span></a>
<a class="sourceLine" id="cb3-34" title="34">        <span class="fu">password:</span><span class="at"> ${{ secrets.DOCKERHUB_TOKEN }}</span></a>
<a class="sourceLine" id="cb3-35" title="35">    <span class="kw">-</span> <span class="fu">name:</span><span class="at"> Build and push</span></a>
<a class="sourceLine" id="cb3-36" title="36">      <span class="fu">uses:</span><span class="at"> docker/build-push-action@v2</span></a>
<a class="sourceLine" id="cb3-37" title="37">      <span class="fu">with:</span></a>
<a class="sourceLine" id="cb3-38" title="38">        <span class="fu">context:</span><span class="at"> .</span></a>
<a class="sourceLine" id="cb3-39" title="39">        <span class="fu">builder:</span><span class="at"> ${{ steps.buildx.outputs.name }}</span></a>
<a class="sourceLine" id="cb3-40" title="40">        <span class="fu">tags:</span><span class="at"> haskelljp/antenna:latest</span></a>
<a class="sourceLine" id="cb3-41" title="41">        <span class="fu">push:</span><span class="at"> ${{ github.event_name != &#39;pull_request&#39; }}</span></a>
<a class="sourceLine" id="cb3-42" title="42">        <span class="fu">build-args:</span><span class="at"> local_bin_path=./bin</span></a></code></pre></div>
<p><span class="ascii">master</span>ブランチへのプッシュのときにだけ<span class="ascii">Docker</span>イメージのプッシュをして欲しいので、<code>push:</code> に <code>github.event_name != 'pull_request'</code> を設定しています。 また、<span class="ascii">Haskell Stack</span>でビルドされたバイナリファイルは<code>--local-bin-path=./bin</code>オプションで<code>./bin</code>に置いてあります。 これを<span class="ascii">Dockerfile</span>でコピーするようにしている（下記参照）ので、<code>docker build</code>の引数に<code>local_bin_path=./bin</code>というのを与える必要がありました。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode dockerfile"><code class="sourceCode dockerfile"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">FROM</span> matsubara0507/ubuntu-for-haskell:git</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="kw">ARG</span> local_bin_path</a>
<a class="sourceLine" id="cb4-3" title="3"><span class="kw">RUN</span> mkdir -p /root/.local/bin &amp;&amp; mkdir -p /work</a>
<a class="sourceLine" id="cb4-4" title="4"><span class="kw">ENV</span> PATH /root/.local/bin:$PATH</a>
<a class="sourceLine" id="cb4-5" title="5"><span class="kw">WORKDIR</span> /work</a>
<a class="sourceLine" id="cb4-6" title="6"><span class="kw">COPY</span> ${local_bin_path} /root/.local/bin</a></code></pre></div>
<p>このように前の<span class="ascii">step</span>までの結果を利用するには <code>context: .</code> を指定する必要があります（デフォルトでは<a href="https://github.com/docker/build-push-action/tree/v2#git-context"><span class="ascii">git-context</span></a>というのを使うからです）。</p>
<h3 id="antennaプログラムの実行"><span class="link-to-here-outer"><a href="#antennaプログラムの実行" title="antennaプログラムの実行"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">antenna</span>プログラムの実行</h3>
<p>最後に、<span class="ascii">master</span>の更新があったときに<span class="ascii">antenna</span>プログラムを実行して<span class="ascii">Haskell Antenna</span>ページを更新するような設定をします。 日毎のスケジュール実行も設定したいので、新しいワークフローを切りました。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb5-1" title="1"><span class="fu">name:</span><span class="at"> Update Antenna page</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="fu">on:</span></a>
<a class="sourceLine" id="cb5-3" title="3">  <span class="fu">schedule:</span></a>
<a class="sourceLine" id="cb5-4" title="4">  <span class="kw">-</span> <span class="fu">cron:</span><span class="at"> </span><span class="st">&#39;0 8 * * *&#39;</span></a>
<a class="sourceLine" id="cb5-5" title="5">  <span class="fu">push:</span></a>
<a class="sourceLine" id="cb5-6" title="6">    <span class="fu">branches:</span></a>
<a class="sourceLine" id="cb5-7" title="7">    <span class="kw">-</span> master</a>
<a class="sourceLine" id="cb5-8" title="8">    <span class="fu">paths-ignore:</span></a>
<a class="sourceLine" id="cb5-9" title="9">    <span class="kw">-</span> <span class="st">&#39;README.md&#39;</span></a>
<a class="sourceLine" id="cb5-10" title="10">    <span class="kw">-</span> <span class="st">&#39;CHANGELOG.md&#39;</span></a>
<a class="sourceLine" id="cb5-11" title="11">    <span class="kw">-</span> <span class="st">&#39;LICENSE&#39;</span></a>
<a class="sourceLine" id="cb5-12" title="12">    <span class="kw">-</span> <span class="st">&#39;.gitignore&#39;</span></a>
<a class="sourceLine" id="cb5-13" title="13"><span class="fu">jobs:</span></a>
<a class="sourceLine" id="cb5-14" title="14">  <span class="fu">update:</span></a>
<a class="sourceLine" id="cb5-15" title="15">    <span class="fu">name:</span><span class="at"> ${{ matrix.os }}</span></a>
<a class="sourceLine" id="cb5-16" title="16">    <span class="fu">runs-on:</span><span class="at"> ubuntu-18.04</span></a>
<a class="sourceLine" id="cb5-17" title="17">    <span class="fu">strategy:</span></a>
<a class="sourceLine" id="cb5-18" title="18">      <span class="fu">fail-fast:</span><span class="at"> </span><span class="ch">false</span></a>
<a class="sourceLine" id="cb5-19" title="19">      <span class="fu">matrix:</span></a>
<a class="sourceLine" id="cb5-20" title="20">        <span class="fu">ghc:</span><span class="at"> </span><span class="kw">[</span><span class="st">&quot;8.8.4&quot;</span><span class="kw">]</span></a>
<a class="sourceLine" id="cb5-21" title="21">    <span class="fu">steps:</span></a>
<a class="sourceLine" id="cb5-22" title="22">    ... <span class="co"># Install dependenciesまでは一緒なので割愛</span></a>
<a class="sourceLine" id="cb5-23" title="23">    <span class="kw">-</span> <span class="fu">name:</span><span class="at"> Build</span></a>
<a class="sourceLine" id="cb5-24" title="24">      <span class="fu">run:</span><span class="at"> stack --system-ghc build</span></a>
<a class="sourceLine" id="cb5-25" title="25"></a>
<a class="sourceLine" id="cb5-26" title="26">    <span class="kw">-</span> <span class="fu">uses:</span><span class="at"> actions/checkout@v2</span></a>
<a class="sourceLine" id="cb5-27" title="27">      <span class="fu">with:</span></a>
<a class="sourceLine" id="cb5-28" title="28">        <span class="fu">ref:</span><span class="at"> </span><span class="st">&#39;gh-pages&#39;</span></a>
<a class="sourceLine" id="cb5-29" title="29">        <span class="fu">path:</span><span class="at"> </span><span class="st">&#39;temp&#39;</span></a>
<a class="sourceLine" id="cb5-30" title="30">    <span class="kw">-</span> <span class="fu">name:</span><span class="at"> Exec Application</span></a>
<a class="sourceLine" id="cb5-31" title="31"><span class="fu">      run:</span> <span class="st">|</span></a>
<a class="sourceLine" id="cb5-32" title="32">        cp sites.yaml temp/sites.yaml</a>
<a class="sourceLine" id="cb5-33" title="33">        cp -r image/* temp/image</a>
<a class="sourceLine" id="cb5-34" title="34">        cd temp &amp;&amp; stack exec -- antenna sites.yaml</a>
<a class="sourceLine" id="cb5-35" title="35">    <span class="kw">-</span> <span class="fu">name:</span><span class="at"> Push changes</span></a>
<a class="sourceLine" id="cb5-36" title="36">      <span class="fu">env:</span></a>
<a class="sourceLine" id="cb5-37" title="37">        <span class="fu">COMMIT_MESSAGE:</span><span class="at"> Update haskell antenna. See https://haskell.jp/antenna/ for new entries!</span></a>
<a class="sourceLine" id="cb5-38" title="38"><span class="fu">      run:</span> <span class="st">|</span></a>
<a class="sourceLine" id="cb5-39" title="39">        git config --local user.email &quot;bot@example.com&quot;</a>
<a class="sourceLine" id="cb5-40" title="40">        git config --local user.name &quot;Bot&quot;</a>
<a class="sourceLine" id="cb5-41" title="41">        git status</a>
<a class="sourceLine" id="cb5-42" title="42">        git add -A</a>
<a class="sourceLine" id="cb5-43" title="43">        git diff --staged --quiet || git commit -m &quot;$COMMIT_MESSAGE&quot;</a>
<a class="sourceLine" id="cb5-44" title="44">        git push origin gh-pages</a>
<a class="sourceLine" id="cb5-45" title="45">      <span class="fu">working-directory:</span><span class="at"> ./temp</span></a></code></pre></div>
<p>バイナリをビルドするところまでは一緒です。 <span class="ascii">Haskell Antenna</span>は同じリポジトリの<span class="ascii">gh-pages</span>ブランチに置いて、<span class="ascii">GitHub Pages</span>を使って公開しています。 なので、同じリポジトリの<span class="ascii">gh-pages</span>ブランチを<span class="ascii">git clone</span>しなおしてサブディレクトリに置き、そこで<span class="ascii">antenna</span>プログラムを実行して、更新があった場合にのみプッシュしています。 同じリポジトリであれば、特に設定することなくプッシュできるのが<span class="ascii">GitHub Actions</span>のメリットですね。</p>
<h2 id="おまけzennを追加しました"><span class="link-to-here-outer"><a href="#おまけzennを追加しました" title="おまけzennを追加しました"><span class="link-to-here">Link to<br />
here</span></a></span>おまけ：<span class="ascii">Zenn</span>を追加しました！</h2>
<p>ついでに最近のアップデートによって、<a href="https://github.com/haskell-jp/antenna/pull/25"><span class="ascii">Zenn</span>を<span class="ascii">Haskell Antenna</span>に載せるサイトへ追加しました</a>（<span class="ascii">igrep</span>氏がしてくれました、ありがとうございます）。 アイコンの利用規約などがわからなかったのですが、<span class="ascii">GitHub</span>の<span class="ascii">PR</span>上で直接聞いてみたところ、問題ないという回答をいただきました。 突然だったのにありがとうございます。</p>
<p><img src="../../img/2020/antenna-with-gh-actions/antenna-page-with-zenn.jpg" style="width: 100%;"></p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2020/break-monad-law-with-writer.html" lang="ja">Writer Monadで気軽にMonad則を破る</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2020/how-to-use-type-newtype-data.html" style="margin-left: auto;" lang="ja">data / newtype / type の使い方</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>data / newtype / type の使い方</title>
    <link href="https://haskell.jp/blog/posts/2020/how-to-use-type-newtype-data.html" />
    <id>https://haskell.jp/blog/posts/2020/how-to-use-type-newtype-data.html</id>
    <published>2020-06-14T00:00:00Z</published>
    <updated>2020-06-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p><span class="ascii">Haskell</span> プログラミングにおいて，データ型は非常に重要な役割を持つ．データ型は，扱うデータをプログラミング上で安全かつ容易に加工するために用いられ，またデータに対してどのような操作ができるのかを規定する．</p>
<p><span class="ascii">Haskell</span> には，データ型を新たに定義する方法が<span class="ascii">3</span>つある．</p>
<ul>
<li><span class="ascii">1</span>つ目は <code>type</code> キーワードによって定義する方法で，これにより定義されたデータ型は型シノニムと呼ばれる．</li>
<li><span class="ascii">2</span>つ目は <code>data</code> キーワードによって定義する方法で，これにより定義されたデータ型は代数的データ型と呼ばれる．</li>
<li><span class="ascii">3</span>つ目は <code>newtype</code> キーワードによってある型を元に新たな型を作る方法だ．</li>
</ul>
<p>今回は，それぞれどういう使い方をするのか，どういう違いがあるのかについて見ていきたいと思う．</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#型シノニム" title="型シノニム">型シノニム</a></li>
<li><a href="#代数的データ型" title="代数的データ型">代数的データ型</a></li>
<li><a href="#ある型を元に新たな型を作る-datatype-renaming" title="ある型を元に新たな型を作る-datatype-renaming">ある型を元に新たな型を作る <span class="ascii">(Datatype Renaming)</span></a></li>
<li><a href="#まとめ" title="まとめ">まとめ</a></li>
</ul>
</div>
</div>
<h2 id="型シノニム"><span class="link-to-here-outer"><a href="#型シノニム" title="型シノニム"><span class="link-to-here">Link to<br />
here</span></a></span>型シノニム</h2>
<p>例えば，あなたは <span class="ascii">Web</span> サイトを運営していて，一部年齢制限が必要なため，人の年齢が <span class="ascii">20</span> 歳以上かを判定する関数を書かなければいけないとする．年齢は整数だが，入力は必須でないため入力してない人もいる．その場合は，<span class="ascii">20</span> 歳以上でないと判定する．この関数は，</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="ot">isAdult ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb1-2" title="2">isAdult m <span class="ot">=</span> <span class="kw">case</span> m <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-3" title="3">  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb1-4" title="4">  <span class="dt">Just</span> x  <span class="ot">-&gt;</span> x <span class="op">&gt;=</span> <span class="dv">20</span></a></code></pre></div>
<p>と書ける．ただ，この定義はどこか味気ない．<code>isAdult</code> が受け取るデータは，年齢を表していて，整数か未詳かの状態を持つので，<code>Maybe Int</code> はデータを正確に捉えられている．しかし，<code>Maybe Int</code> に適合するデータは他に無数にあるため，<code>isAdult</code> が受け取るデータが年齢を表すのか知能指数を表すのか，はたまた今までお酒を飲んだことのある回数なのかは推測しないと分からない．年齢を表すデータ型を新たに定義して，それを受け取るようにすればもっとプログラムがクールになるだろう．</p>
<p><span class="ascii">Haskell</span> で新しくデータ型を定義する最も簡単な方法は，<code>type</code> キーワードを使って型シノニム <span class="ascii">(type synonym)</span> を定義する方法だ．シノニムとは，別名という意味で，型シノニムは文字通り，ある型の別名を表す．今回は次のように使える<span class="ascii">:</span></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">type</span> <span class="dt">Age</span> <span class="ot">=</span> <span class="dt">Maybe</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="ot">isAdult ::</span> <span class="dt">Age</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-4" title="4">isAdult age <span class="ot">=</span> <span class="kw">case</span> age <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-5" title="5">  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb2-6" title="6">  <span class="dt">Just</span> x  <span class="ot">-&gt;</span> x <span class="op">&gt;=</span> <span class="dv">20</span></a></code></pre></div>
<p>これで関数 <code>isAdult</code> は，先ほどと比べてとても明確になった．<code>Age</code> は <code>Maybe Int</code> を元に作られた型シノニムで，つまり <code>Age</code> は <code>Maybe Int</code> の別名になっている．単なる別名なので，<code>isAdult</code> は <code>Maybe Int -&gt; Bool</code> 型の関数だと思って使うこともできる．<span class="ascii">GHCi</span> で試してみよう<span class="ascii">:</span></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="op">&gt;&gt;&gt;</span> (<span class="ot">isAdult ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>) (<span class="dt">Just</span> <span class="dv">22</span><span class="ot"> ::</span> <span class="dt">Age</span>)</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="dt">True</span></a></code></pre></div>
<p><code>Maybe Int</code> を <code>Age</code> だと思うこともできるしその逆もできる．型シノニムと元となった型は自在に取り替え可能だ．型シノニムはとても手軽なので，<span class="ascii">Haskell</span> の標準ライブラリでも使われている．例えば，次のようなデータ型が型シノニムで定義されている<span class="ascii">:</span></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">type</span> <span class="dt">String</span> <span class="ot">=</span> [<span class="dt">Char</span>]</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="kw">type</span> <span class="dt">FilePath</span> <span class="ot">=</span> <span class="dt">String</span></a></code></pre></div>
<p>文字列は文字のリストと見做せる．そこから文字列によるデータ型 <code>String</code> は，単に文字のリスト型の型シノニムで定義されている．文字列に対してリストの関数を自由に適用できるのは，このためだ．ファイルのパスによるデータ型 <code>FilePath</code> は <code>String</code> の型シノニムで定義されている．なので，文字列の関数を自由に適用できる．</p>
<p><span class="ascii">Haskell</span> の型シノニムは，これだけに止まらずもっと強力な機能も持っている．例えば，型シノニムは型コンストラクタ，すなわち型を受け取って新たな型を作るコンストラクタに対しても作れる<span class="ascii">:</span></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">type</span> <span class="dt">Option</span> <span class="ot">=</span> <span class="dt">Maybe</span></a></code></pre></div>
<p>この型シノニムを使うと，<code>Maybe Int</code> と書く代わりに <code>Option Int</code> と書くことも可能だ．部分適用された型コンストラクタに対する型シノニムも書ける<span class="ascii">:</span></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">type</span> <span class="dt">Failable</span> <span class="ot">=</span> <span class="dt">Either</span> <span class="dt">String</span></a></code></pre></div>
<p>この型シノニムを使うと，<code>Either String ()</code> と書く代わりに <code>Failable ()</code> と書くことができる．</p>
<p>さらに型シノニムは，パラメータを持つことができる<span class="ascii">:</span></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">type</span> <span class="dt">List</span> a <span class="ot">=</span> [a]</a></code></pre></div>
<p>この型シノニムを使うと，<code>[Int]</code> は <code>List Int</code> と書ける．ただし，型シノニムはあくまで別名なので，全てのパラメータを適用した状態でしか書けないことに注意する必要がある．例えば，次のプログラムはコンパイルエラーになる<span class="ascii">:</span></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">type</span> <span class="dt">Apply</span> f a <span class="ot">=</span> f a</a>
<a class="sourceLine" id="cb8-2" title="2"><span class="kw">type</span> <span class="dt">ApplyMaybe</span> <span class="ot">=</span> <span class="dt">Apply</span> <span class="dt">Maybe</span></a></code></pre></div>
<p><code>Apply</code> は<span class="ascii">2</span>つのパラメータをとるが，<code>ApplyMaybe</code> は <code>Apply</code> に<span class="ascii">1</span>つのパラメータしか渡していない．この場合，<code>Apply Maybe</code> という型がどういう型の別名になるか <span class="ascii">Haskell</span> は分からないため，この型を拒否する．このプログラムを修正するには，</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">type</span> <span class="dt">Apply</span> f a <span class="ot">=</span> f a</a>
<a class="sourceLine" id="cb9-2" title="2"><span class="kw">type</span> <span class="dt">ApplyMaybe</span> a <span class="ot">=</span> <span class="dt">Apply</span> <span class="dt">Maybe</span> a</a></code></pre></div>
<p>というように，<code>Apply</code> に全ての引数を渡してやる必要がある．こうすることで，<span class="ascii">Haskell</span> は <code>Apply</code> の定義から <code>Apply Maybe a</code> が <code>Maybe a</code> の別名であると認識できるようになる <a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>．</p>
<p>型シノニムは，他にも幾つか用途上で制限がある．<span class="ascii">1</span>つ目は再帰的な型シノニムが作れないという制限だ．例えば，</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">type</span> <span class="dt">InfiniteList</span> a <span class="ot">=</span> (a, <span class="dt">InfiniteList</span> a)</a></code></pre></div>
<p>という定義は <span class="ascii">Haskell</span> では却下される．相互再帰的な定義も許容されていない<span class="ascii">:</span></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">type</span> <span class="dt">Rec1</span> <span class="ot">=</span> [<span class="dt">Rec2</span>]</a>
<a class="sourceLine" id="cb11-2" title="2"><span class="kw">type</span> <span class="dt">Rec2</span> <span class="ot">=</span> [<span class="dt">Rec1</span>]</a></code></pre></div>
<p><code>Rec1</code> の型を具体的に求めようとすると，<code>[Rec2]</code> の型になる．<code>Rec2</code> はやっぱり型シノニムで，<code>[Rec1]</code> の別名なので，この型はさらに <code>[[Rec1]]</code> という型になる．このようにして具体的な型を求めようとしても永遠に型シノニムがどこかしらに入り込むことになってしまい，型シノニムが現れない型を求めることはできない．<span class="ascii">Haskell</span> ではそのようなことがないように，そのような定義を排除している <a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>．</p>
<p>もう<span class="ascii">1</span>つの制約は，型シノニムを型クラスのインスタンスとして使えないというものだ．例えば，次のようなことはできない<span class="ascii">:</span></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">type</span> <span class="dt">I</span> <span class="ot">=</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb12-2" title="2"></a>
<a class="sourceLine" id="cb12-3" title="3"><span class="kw">class</span> <span class="dt">C</span> a</a>
<a class="sourceLine" id="cb12-4" title="4"><span class="kw">instance</span> <span class="dt">C</span> <span class="dt">I</span></a></code></pre></div>
<p>代わりに，</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">class</span> <span class="dt">C</span> a</a>
<a class="sourceLine" id="cb13-2" title="2"><span class="kw">instance</span> <span class="dt">C</span> <span class="dt">Int</span></a></code></pre></div>
<p>というように型シノニムを使わず書く必要がある．これは型シノニムを使って書けない唯一の例外だ．ただ，この制限は本質的なものではなく，<span class="ascii">Haskell</span> 標準で型シノニムに対する混乱を避けるための制限になっている．もし，型シノニムに対してインスタンスを書けるようにしても，型シノニムは単なる別名なので，それは元となった型に対してインスタンスを定義してることと同じになる．このため，</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="ot">f ::</span> <span class="dt">C</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb14-2" title="2">f x <span class="ot">=</span> x</a></code></pre></div>
<p>という関数は，<code>type Age = Int</code> による型シノニム <code>Age</code> に対して <code>C</code> のインスタンスが定義されていた場合，<code>a</code> が <code>Age</code> の場合も <code>Int</code> の場合も許容される．これは，プログラマが意図していない動作かもしれない．つまり，年齢のデータだけにインスタンスを定義したつもりが，整数データ全般に対していつのまにかインスタンスを定義してしまったことになるからだ <a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>．</p>
<p>これらの制限はあるものの，型シノニムはデータ型を定義する上でとても強力で，しかも簡単に使用できる機能だ．</p>
<h2 id="代数的データ型"><span class="link-to-here-outer"><a href="#代数的データ型" title="代数的データ型"><span class="link-to-here">Link to<br />
here</span></a></span>代数的データ型</h2>
<p>さて，型シノニムでデータ型を定義する場合には幾つかの制限があった．では，この制限を超えたデータ型を定義する方法はないのだろうか？ そのような場合には代数的データ型 <span class="ascii">(algebraic datatype)</span> を使うことができる．</p>
<p>代数的データ型は，複数の型の値を統合して<span class="ascii">1</span>つの型の値として扱うデータ型の積と，複数の型の表現範囲を合わせて<span class="ascii">1</span>つの型として扱うデータ型の和を組み合わせることで構成されている．そして，このデータ型の定義は，型シノニムと異なり完全に新しい型を作り出す．実際の例を見てみよう．</p>
<p>あなたは積木パズルのパーツそれぞれの面積を計算する関数を，書かなければいけない．積木パズルのパーツはそれぞれ，長方形，真円，三角形から構成されている．まずはこのパーツを <span class="ascii">Haskell</span> のデータ型に落とし込む必要がある．それぞれのパーツにおいて，</p>
<ul>
<li>四角形の面積は縦横の長さ</li>
<li>真円は半径</li>
<li>三角形は三辺の長さ</li>
</ul>
<p>によって特徴付けられている．では，これを代数的データ型に落とし込んでみよう<span class="ascii">:</span></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">data</span> <span class="dt">PuzzleElement</span></a>
<a class="sourceLine" id="cb15-2" title="2">  <span class="ot">=</span> <span class="dt">Rect</span></a>
<a class="sourceLine" id="cb15-3" title="3">      <span class="dt">Double</span></a>
<a class="sourceLine" id="cb15-4" title="4">      <span class="co">-- ^ 縦の長さ</span></a>
<a class="sourceLine" id="cb15-5" title="5">      <span class="dt">Double</span></a>
<a class="sourceLine" id="cb15-6" title="6">      <span class="co">-- ^ 横の長さ</span></a>
<a class="sourceLine" id="cb15-7" title="7">  <span class="op">|</span> <span class="dt">Circle</span></a>
<a class="sourceLine" id="cb15-8" title="8">      <span class="dt">Double</span></a>
<a class="sourceLine" id="cb15-9" title="9">      <span class="co">-- ^ 半径</span></a>
<a class="sourceLine" id="cb15-10" title="10">  <span class="op">|</span> <span class="dt">Triangle</span></a>
<a class="sourceLine" id="cb15-11" title="11">    <span class="co">-- ^ 三つの辺の長さを与える</span></a>
<a class="sourceLine" id="cb15-12" title="12">      <span class="dt">Double</span> <span class="dt">Double</span> <span class="dt">Double</span> </a></code></pre></div>
<p>この定義は，<code>PuzzleElement</code> という新しい型を作り，<span class="ascii">3</span>つの値コンストラクタを作る．それぞれ</p>
<ul>
<li><code>Rect :: Double -&gt; Double -&gt; PuzzleElement</code></li>
<li><code>Circle :: Double -&gt; PuzzleElement</code></li>
<li><code>Triangle :: Double -&gt; Double -&gt; Double -&gt; PuzzleElement</code></li>
</ul>
<p>という型を持つ．<code>Rect</code> は <code>Double</code> 型の値を<span class="ascii">2</span>つ受け取り，その<span class="ascii">2</span>つの値を <code>PuzzleElement</code> 型の<span class="ascii">1</span>つの値として統合する．つまり，<code>Double</code> 型<span class="ascii">2</span>つの積を作る．<code>Circle</code> や <code>Triangle</code> も同様だ．そして，<code>PuzzleElement</code> 型は<span class="ascii">3</span>種類の積の値のいずれかを表し，すなわちこれら<span class="ascii">3</span>種類の積の和を表す．このように，積和によって新しいデータ型を定義できるのが <code>data</code> 宣言であり，それによって定義されるのが代数的データ型になる．</p>
<p>代数的データ型の値から統合した値を取り出したい時は，<code>case</code> 文を使ったパターンマッチを行う<span class="ascii">:</span></p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="ot">areaMeasure ::</span> <span class="dt">PuzzleElement</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb16-2" title="2">areaMeasure x <span class="ot">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb16-3" title="3">  <span class="dt">Rect</span> w h <span class="ot">-&gt;</span> w <span class="op">*</span> h</a>
<a class="sourceLine" id="cb16-4" title="4">  <span class="dt">Circle</span> r <span class="ot">-&gt;</span> r <span class="op">*</span> r <span class="op">*</span> <span class="fu">pi</span></a>
<a class="sourceLine" id="cb16-5" title="5">  <span class="dt">Triangle</span> s1 s2 s3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb16-6" title="6">    <span class="kw">let</span> s <span class="ot">=</span> (s1 <span class="op">+</span> s2 <span class="op">+</span> s3) <span class="op">/</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb16-7" title="7">    <span class="kw">in</span> <span class="fu">sqrt</span> <span class="op">$</span> s <span class="op">*</span> (s <span class="op">-</span> s1) <span class="op">*</span> (s <span class="op">-</span> s2) <span class="op">*</span> (s <span class="op">-</span> s3)</a></code></pre></div>
<p><code>areaMeasure</code> によってパズルのピースの面積を求めることができるようになった．</p>
<p>前に紹介した型シノニムは，ある型に対してその別名を与えるだけだった．それに比べ，代数的データ型では新しいデータ型を作り，その型の値を作る値コンストラクタを定義する．そして，型シノニムと大きく異なる点は，型システム上からは新たに定義された型しか分からず，実際にそのデータ型がどういう型から構成されるか分からない点にある．<code>PuzzleElement</code> 型の値は，もしかしたら <code>Double</code> 型の<span class="ascii">2</span>つの値から <code>Rect</code> コンストラクタを介して作られているかもしれないし，<code>Double</code> 型<span class="ascii">1</span>つの値から <code>Circle</code> コンストラクタを通して作られているかもしれない．これは実行時にその関数でパターンマッチをしてみて初めて分かることだ．型シノニムでは，型システムからそれがどういう型を元にしていたか分かるが，代数的データ型で観測できるのは新たに作られたデータ型があることだけだ．この違いは，代数的データ型と型シノニムの制約の違いに表れてくる．代数的データ型では，型シノニムの時に挙げたような制約はない．</p>
<p>例えば，代数的データ型は型シノニムと同様，パラメータをとることができ，さらに部分適用も可能だ <a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a><span class="ascii">:</span></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">data</span> <span class="dt">Apply</span> f a <span class="ot">=</span> <span class="dt">Apply</span> (f a)</a>
<a class="sourceLine" id="cb17-2" title="2"><span class="kw">type</span> <span class="dt">ApplyMaybe</span> <span class="ot">=</span> <span class="dt">Apply</span> <span class="dt">Maybe</span></a></code></pre></div>
<p>これは <span class="ascii">Haskell</span> の正しいプログラムになる．<code>Apply</code> は，<span class="ascii">2</span>つのパラメータをとる型コンストラクタになっていて，データ型 <code>Apply f a</code> の値を作る方法として，<code>f a</code> 型の値から値コンストラクタ <code>Apply :: f a -&gt; Apply f a</code> を通す方法がある．<code>ApplyMaybe</code> は <code>Apply Maybe</code> の型シノニムになっていて，これを使えば <code>Apply Maybe Int</code> と書く代わりに <code>ApplyMaybe Int</code> と書けるようになる．<code>ApplyMaybe</code> の定義は，<code>Apply</code> に対して<span class="ascii">1</span>つのパラメータしか渡していない．にも関わらず正しいというのが，型シノニムと異なる点になる．</p>
<p>再帰的なデータ型を代数的データ型で定義することも可能だ<span class="ascii">:</span></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">data</span> <span class="dt">List</span> a</a>
<a class="sourceLine" id="cb18-2" title="2">  <span class="ot">=</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</a>
<a class="sourceLine" id="cb18-3" title="3">  <span class="op">|</span> <span class="dt">Nil</span></a></code></pre></div>
<p>データ型 <code>List a</code> は <code>a</code> 型の要素を持つ単連結リストを表す．値コンストラクタが <code>List a</code> 型の値を受け取ることがポイントだ．型シノニムでは，その型の定義に自身を含めることはできなかった．これは実際の具体的な型を求めようとした時，その計算が永遠に終わらなくなってしまうからだった．代数的データ型 <code>List a</code> ではその型は単に新しい型として作られ，実際にその型の値がどういう型の値によって構成されているか知る必要はない．<code>List a</code> はそれ自体が具体的な型であり <a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a> ，それ以上計算する必要はないからだ．代数的データ型において，定義された型とその型の値を作る方法は分離されている．そのため，データ型の計算においてその型の値を作る方法は考慮されない．よって，自身が定義中で用いられても，型シノニムのようにデータ型の計算が永遠に終わることがないということはないため，その操作が許容されている．</p>
<p>もちろん，新しい型が定義されるため，型クラスのインスタンスを混乱なく定義できる．代数的データ型を作成した時，基本的なインスタンスを定義することは <span class="ascii">Haskell</span> プログラミングにおいてよくあることだ．<span class="ascii">Haskell</span> では，言語機能としてそれを支援する機能がある．それは，<code>deriving</code> 構文というもので，<code>Eq</code> <span class="ascii">/</span> <code>Ord</code> などの標準的な型クラスを，データ型の定義から自動で導出してくれる．例えば，<code>List a</code> に対して使ってみると，以下のようになる<span class="ascii">:</span></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" title="1"><span class="kw">data</span> <span class="dt">List</span> a</a>
<a class="sourceLine" id="cb19-2" title="2">  <span class="ot">=</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</a>
<a class="sourceLine" id="cb19-3" title="3">  <span class="op">|</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb19-4" title="4">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>このように代数的データ型は，型シノニムでは定義できなかったデータ型を定義することができる．そして，代数的データ型は全く新しい型を作ることもできる<span class="ascii">:</span></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">data</span> <span class="dt">Nat</span></a>
<a class="sourceLine" id="cb20-2" title="2">  <span class="ot">=</span> <span class="dt">Succ</span> <span class="dt">Nat</span></a>
<a class="sourceLine" id="cb20-3" title="3">  <span class="op">|</span> <span class="dt">Zero</span></a></code></pre></div>
<p>このデータ型 <code>Nat</code> は，他の型には依存しない全く新しい型だ．このように，代数的データ型は型シノニムと異なり全く新しい構造を作り出すことができる．</p>
<p>ただ，その代わり既存の関数を流用できなくなってしまう場合がある．例えば，</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" title="1"><span class="kw">data</span> <span class="dt">Tuple</span> a b <span class="ot">=</span> <span class="dt">Tuple</span> a b</a></code></pre></div>
<p>は，<code>(a, b)</code> と構造が同じであり，<code>(a, b)</code> に対する関数 <code>fst :: (a, b) -&gt; a</code> を適用できてもいいはずだ．ところが，データ型 <code>Tuple a b</code> とその値コンストラクタは型システム上は切り離されているため，自身の値が <code>(a, b)</code> の値と同じ方法でしか構成できないことを知らない．<code>Tuple a b</code> と <code>(a, b)</code> において型上で言及できることは，それらが異なる型であるということだけだ．なので，<code>fst</code> に <code>Tuple a b</code> 型の値を渡すことはできない．これは，もし型シノニムを使って，</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">type</span> <span class="dt">Tuple</span> a b <span class="ot">=</span> (a, b)</a></code></pre></div>
<p>と定義した場合は解決する問題だ <a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a>．</p>
<p>このように両者にはトレードオフがあり，利用目的に合った使い分けをするのがいいだろう．</p>
<p>さて，<code>data</code> 宣言の構文は他に<span class="ascii">2</span>つ，便利な機能がある．</p>
<p><span class="ascii">1</span>つは正格性フラグと呼ばれる機能で，値コンストラクタにおいて引数を正格に評価することを強制できる．例えば，</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" title="1"><span class="kw">data</span> <span class="dt">StrictTuple</span> a b <span class="ot">=</span> <span class="dt">StrictTuple</span> <span class="op">!</span>a <span class="op">!</span>b</a></code></pre></div>
<p>というように，正格性フラグ <code>!</code> を使った定義を行うと，値コンストラクタ <code>StrictTuple :: a -&gt; b -&gt; StrictTuple</code> はその引数を正格に評価してから格納するようになる．通常，</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" title="1"><span class="kw">data</span> <span class="dt">Tuple</span> a b <span class="ot">=</span> <span class="dt">Tuple</span> a b</a></code></pre></div>
<p>のように正格性フラグを使わない定義では，</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">case</span> <span class="dt">Tuple</span> <span class="fu">undefined</span> <span class="fu">undefined</span> <span class="kw">of</span> <span class="dt">Tuple</span> _ _ <span class="ot">-&gt;</span> ()</a>
<a class="sourceLine" id="cb25-2" title="2">()</a></code></pre></div>
<p>のように値コンストラクタは受け取った引数の評価を行わず，素直にそのままの形で遅延させて格納するため，エラーを出す式を渡してもその式の評価を行わない限りエラーにはならない．これは通常の関数の動作と同じになる．ところが，正格性フラグを使用した <code>StrictTuple</code> の場合，</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">case</span> <span class="dt">StrictTuple</span> <span class="fu">undefined</span> <span class="fu">undefined</span> <span class="kw">of</span> <span class="dt">StrictTuple</span> _ _ <span class="ot">-&gt;</span> ()</a>
<a class="sourceLine" id="cb26-2" title="2"><span class="op">***</span> <span class="dt">Exception</span><span class="op">:</span> Prelude.undefined</a></code></pre></div>
<p>のように引数の評価を行うため，エラーを出す式を受け取った場合値コンストラクタの適用においてその式を評価しエラーを出す．データ型を作成する際，その元となる式の評価を強制させることはパフォーマンスに大きく寄与する．そのため，そのようなことを支援するために正格性フラグは設けられている．</p>
<p>また，代数的データ型の値コンストラクタはフィールド名を持つことができる<span class="ascii">:</span></p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" title="1"><span class="kw">data</span> <span class="dt">Tuple</span> a b <span class="ot">=</span> <span class="dt">Tuple</span></a>
<a class="sourceLine" id="cb27-2" title="2">  {<span class="ot"> firstVal  ::</span> a</a>
<a class="sourceLine" id="cb27-3" title="3">  ,<span class="ot"> secondVal ::</span> b</a>
<a class="sourceLine" id="cb27-4" title="4">  }</a></code></pre></div>
<p>この場合，型コンストラクタ <code>Tuple</code>，値コンストラクタ <code>Tuple :: a -&gt; b -&gt; Tuple a b</code> の他に，関数 <code>firstVal :: Tuple a b -&gt; a</code>， <code>secondVal :: Tuple a b -&gt; b</code> が作られる．また，値コンストラクタの呼び出しにおいて特別なレコード構文 <code>Tuple { firstVal = 0, secondVal = 1 }</code> を使用でき，またレコード更新構文 <code>(Tuple 2 1) { firstVal = 0 }</code> を使用できる．これらは両者 <code>Tuple 0 1</code> と同様の値が作成される．</p>
<h2 id="ある型を元に新たな型を作る-datatype-renaming"><span class="link-to-here-outer"><a href="#ある型を元に新たな型を作る-datatype-renaming" title="ある型を元に新たな型を作る-datatype-renaming"><span class="link-to-here">Link to<br />
here</span></a></span>ある型を元に新たな型を作る <span class="ascii">(Datatype Renaming)</span></h2>
<p>さて，これまで見てきたように，型シノニムは型の別名を定義し，代数的データ型は型の積和により新たなデータ型を定義するものだった．<span class="ascii">Haskell</span> にはもう<span class="ascii">1</span>つデータ型を定義する方法がある．それが <code>newtype</code> 宣言だ．この宣言によって作られるデータ型は，型システム上は代数的データ型と同じように扱われ，実行時は型シノニムと同様の動作をする．</p>
<p><code>newtype</code> 宣言の構文は，<code>data</code> 宣言と同じような形をしている<span class="ascii">:</span></p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" title="1"><span class="kw">newtype</span> <span class="dt">Identity</span> a <span class="ot">=</span> <span class="dt">Identity</span> a</a></code></pre></div>
<p>フィールド名をつけることもできる<span class="ascii">:</span></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" title="1"><span class="kw">newtype</span> <span class="dt">Identity</span> a <span class="ot">=</span> <span class="dt">Identity</span></a>
<a class="sourceLine" id="cb29-2" title="2">  {<span class="ot"> unIdentity ::</span> a</a>
<a class="sourceLine" id="cb29-3" title="3">  }</a></code></pre></div>
<p>この場合 <code>data</code> 宣言と同様に，型コンストラクタ <code>Identity</code>，値コンストラクタ <code>Identity</code> が作られることになる．ただし，<code>data</code> 宣言と異なり <code>newtype</code> は積和の機能を使用することはできない．単にある<span class="ascii">1</span>つの型を受け取る値コンストラクタしか定義できない．なので，</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" title="1"><span class="kw">newtype</span> <span class="dt">Unit</span> <span class="ot">=</span> <span class="dt">Unit</span></a>
<a class="sourceLine" id="cb30-2" title="2"><span class="kw">newtype</span> <span class="dt">Tuple</span> a b <span class="ot">=</span> <span class="dt">Tuple</span> a b</a>
<a class="sourceLine" id="cb30-3" title="3"><span class="kw">newtype</span> <span class="dt">Enum</span> <span class="ot">=</span> <span class="dt">A</span> <span class="op">|</span> <span class="dt">B</span> <span class="op">|</span> <span class="dt">C</span></a></code></pre></div>
<p>はいずれも受け入れられない．この <code>newtype</code> の制約はいまいちよく分からない．では，このような制約によりどのような違いが出るのだろうか？ <code>newtype</code> と <code>data</code> は型システム上は違いはない．しかし，パターンマッチの動作など，実行時の動作に少し差異が設けられている．例えば，通常</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" title="1"><span class="kw">data</span> <span class="dt">DataIdentity</span> a <span class="ot">=</span> <span class="dt">DataIdentity</span> a</a></code></pre></div>
<p>において，</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">case</span><span class="ot"> undefined ::</span> <span class="dt">DataIdentity</span> () <span class="kw">of</span> <span class="dt">DataIdentity</span> _ <span class="ot">-&gt;</span> ()</a>
<a class="sourceLine" id="cb32-2" title="2"><span class="op">***</span> <span class="dt">Exception</span><span class="op">:</span> Prelude.undefined</a></code></pre></div>
<p>のようにエラーを出す式をパターンマッチで分解しようとするとエラーが出力される．ところが，<code>newtype</code> によって作られた値コンストラクタの場合，</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">case</span><span class="ot"> undefined ::</span> <span class="dt">Identity</span> () <span class="kw">of</span> <span class="dt">Identity</span> _ <span class="ot">-&gt;</span> ()</a>
<a class="sourceLine" id="cb33-2" title="2">()</a></code></pre></div>
<p>のようにパターンマッチ時にエラーが出されることはない．<span class="ascii">Haskell</span> では <code>newtype</code> で作られた値コンストラクタが実行動作に影響することはないと規定されている．よって，上のパターンマッチは，以下と同様の動きをすることになっている<span class="ascii">:</span></p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">case</span><span class="ot"> undefined ::</span> <span class="dt">Identity</span> () <span class="kw">of</span> _ <span class="ot">-&gt;</span> ()</a>
<a class="sourceLine" id="cb34-2" title="2">()</a></code></pre></div>
<p>このように値コンストラクタを指定しないパターンマッチの場合，<code>data</code> 宣言で作られたものもエラーを出さない<span class="ascii">:</span></p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">case</span><span class="ot"> undefined ::</span> <span class="dt">DataIdentity</span> () <span class="kw">of</span> _ <span class="ot">-&gt;</span> ()</a>
<a class="sourceLine" id="cb35-2" title="2">()</a></code></pre></div>
<p>よって，<code>data</code> と <code>newtype</code> で作られた値コンストラクタの動作が異なるのは，パターンマッチにおいて値コンストラクタを指定した場合だけということになる．</p>
<p>では，<code>newtype</code> はなぜ値コンストラクタを無視するよう規定されているのだろう？ これは，<code>newtype</code> によるデータ型が実行時の動作として型シノニムと同様の動作をすることを目的としてしているからだ．値コンストラクタが無視されるのは，</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" title="1"><span class="kw">newtype</span> <span class="dt">Identity</span> a <span class="ot">=</span> <span class="dt">Identity</span> a</a></code></pre></div>
<p>という宣言は，</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" title="1"><span class="kw">type</span> <span class="dt">IdentitySynonym</span> a <span class="ot">=</span> a</a></code></pre></div>
<p>という宣言と同様の意味を持って欲しいことを <span class="ascii">Haskell</span> の設計者が意図しているからだ．よって，</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">case</span><span class="ot"> undefined ::</span> <span class="dt">Identity</span> () <span class="kw">of</span> <span class="dt">Identity</span> _ <span class="ot">-&gt;</span> ()</a>
<a class="sourceLine" id="cb38-2" title="2">()</a></code></pre></div>
<p>の動作は，</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">case</span><span class="ot"> undefined ::</span> <span class="dt">IdentitySynonym</span> () <span class="kw">of</span> _ <span class="ot">-&gt;</span> ()</a>
<a class="sourceLine" id="cb39-2" title="2">()</a></code></pre></div>
<p>のように，代数的データ型ではなく型シノニムに合わせてあるため，<code>data</code> 宣言主体に見ると一見不思議な動作をしていたというわけだ．</p>
<p>さて，ではなぜわざわざ型シノニムとは別に <code>newtype</code> 宣言を導入したのだろうか？ 型シノニムには幾つか制約があったのを思い出して欲しい．そして，それらの制約は代数的データ型では解決されたのだった．それは <code>type</code> 宣言が単に型の別名を導入するのに対し，<code>data</code> 宣言が完全に新たな型を作るからだった．<code>newtype</code> はその点に着目し，実行時には単なる別名として動作するが型システム上は完全に別の新たな型を導入することで，<code>type</code> 宣言同様ある型の別名を作りたいものの型シノニムの制約は回避したい需要を満たすようにしたものだ．</p>
<p>例えば，大文字小文字を区別しない文字列データを考えてみよう．この場合，<code>"aBc" == "Abc"</code> であって欲しいが，これは型シノニムで</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" title="1"><span class="kw">type</span> <span class="dt">CaseInsensString</span> <span class="ot">=</span> <span class="dt">String</span></a></code></pre></div>
<p>と定義するだけでは，</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" title="1"><span class="op">&gt;&gt;&gt;</span> (<span class="st">&quot;aBc&quot;</span><span class="ot"> ::</span> <span class="dt">CaseInsensString</span>) <span class="op">==</span> (<span class="st">&quot;Abc&quot;</span><span class="ot"> ::</span> <span class="dt">CaseInsensString</span>)</a>
<a class="sourceLine" id="cb41-2" title="2"><span class="dt">False</span></a></code></pre></div>
<p>のままだ．そこで，<code>newtype</code> を使って，</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" title="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Char</span> <span class="kw">as</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb42-2" title="2"></a>
<a class="sourceLine" id="cb42-3" title="3"><span class="kw">newtype</span> <span class="dt">CaseInsensString</span> <span class="ot">=</span> <span class="dt">CaseInsens</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb42-4" title="4"></a>
<a class="sourceLine" id="cb42-5" title="5"><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">CaseInsensString</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb42-6" title="6">  <span class="dt">CaseInsens</span> s1 <span class="op">==</span> <span class="dt">CaseInsens</span> s2 <span class="ot">=</span> go s1 s2</a>
<a class="sourceLine" id="cb42-7" title="7">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb42-8" title="8">      go []       []       <span class="ot">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb42-9" title="9">      go []       (_<span class="op">:</span>_)    <span class="ot">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb42-10" title="10">      go (_<span class="op">:</span>_)    []       <span class="ot">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb42-11" title="11">      go (c1<span class="op">:</span>cs1) (c2<span class="op">:</span>cs2) <span class="ot">=</span> <span class="dt">Char</span><span class="op">.</span><span class="fu">toLower</span> c1 <span class="op">==</span> <span class="dt">Char</span><span class="op">.</span><span class="fu">toLower</span> c2 <span class="op">&amp;&amp;</span> go cs1 cs2</a></code></pre></div>
<p>とすれば，</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="dt">CaseInsens</span> <span class="st">&quot;aBc&quot;</span> <span class="op">==</span> <span class="dt">CaseInsens</span> <span class="st">&quot;Abc&quot;</span></a>
<a class="sourceLine" id="cb43-2" title="2"><span class="dt">True</span></a></code></pre></div>
<p>とできる．型シノニムは単なる <code>String</code> の別名なので，<code>String</code> と異なるインスタンスを新しく定義することはできない．それに対して，<code>newtype</code> によるデータ型は代数的データ型と同様に自由に定義することができる．そして，値コンストラクタ <code>CaseInsens</code> は単なる飾りであり，実行時には完全に無視されるため，<code>CaseInsensString</code> は動作としては <code>String</code> の別名としてみることができる．</p>
<p><code>newtype</code> は型シノニムでの制約であった，</p>
<ul>
<li>再帰的なデータ型が定義できない</li>
<li>型コンストラクタに対する部分適用ができない</li>
</ul>
<p>といった問題も解決する．このように <code>newtype</code> は型シノニムの問題を改善したデータ型を定義するが，<code>data</code> 宣言と同様型シノニムでは起きなかった問題も一緒に顕在化させてしまう．</p>
<p>上の例で，<code>CaseInsens</code> は飾りだと言ったが，実際にはこの値コンストラクタは必要不可欠であり，重要な役割を持っている．例えば，</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="dt">CaseInsens</span> <span class="st">&quot;aBc&quot;</span> <span class="op">==</span> <span class="dt">CaseInsens</span> <span class="st">&quot;Abc&quot;</span></a>
<a class="sourceLine" id="cb44-2" title="2"><span class="dt">True</span></a></code></pre></div>
<p>の例は，片方だけ</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="st">&quot;aBc&quot;</span> <span class="op">==</span> <span class="dt">CaseInsens</span> <span class="st">&quot;Abc&quot;</span></a></code></pre></div>
<p>としてしまうと，コンパイルエラーになってしまう．なぜなら，<code>(==)</code> は<span class="ascii">2</span>つの引数が同じ型の値である必要があり，<code>"aBc"</code> の型である <code>String</code> と <code>CaseInsens "Abc</code> の型である <code>CaseInsensString</code> は全く異なる型であるからだ．つまり，値コンストラクタ <code>CaseInsens</code> は，実行時には何の影響も与えないが，型システム上は全く異なる型の値であることを示すマーカーとなる．そして，型シノニムではデータ型は単なる別名であったが，<code>newtype</code> は <code>data</code> と同様全く新たな型として導入する道を選んだため，元の型として受け入れてもらうことが出来なくなってしまったのだ．</p>
<p>といっても，これは一長一短である．<code>data</code> と同様 <code>newtype</code> で作られた型は，型シノニムのように既存の関数を使い回すことができない．その反面，データの意味に沿わないプログラムを型によって弾くことができるという点は長所になる場合もある．例えば，<code>"aBc" == CaseInsens "Abc"</code> の例は，一体どのような結果を返すべきか一見して分からない．両者は単なる文字列と，大文字小文字を区別しない文字列という異なるデータを表しており，その比較は定義されないとするのが自然だろう．このような場合に，型シノニムでは定義されないことを表す方法はなかったが，<code>newtype</code> は元の型と異なる型を持つので，そのような仕組みを作ることができる．</p>
<p>さて，<code>newtype</code> において値コンストラクタは実行時に何の影響も及ぼさないことと，何故そうなっているかについて分かってもらえただろうか？ この影響は，パターンマッチ以外にも表れる．例えば，<code>newtype</code> の値コンストラクタに正格性フラグの機能はない．</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" title="1"><span class="kw">newtype</span> <span class="dt">StrictNewtype</span> <span class="ot">=</span> <span class="dt">StrictNewtype</span> <span class="op">!</span><span class="dt">Int</span></a></code></pre></div>
<p>というプログラムは，<span class="ascii">Haskell</span> では受け入れられない．なぜなら，これを受け入れた場合，値コンストラクタがあるかどうかによって実行時の動作が変わってしまうからだ．ただ，その他の <code>data</code> 宣言の機能は使用できる．<code>deriving</code> も使用できる．<code>newtype</code> で作られたデータ型は，元のデータ型のインスタンスを継承することはできない．全く新たな型を作ったため，更地の状態から始まる．ただし，<code>deriving</code> を使うことでインスタンスを用意に導出することは可能だ．ただ，標準クラスのインスタンスしか自動で導出できないため，自身で定義した型クラスなどのインスタンスは一から書く必要がある．そのことには，注意する必要があるだろう <a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a>．</p>
<p>最後に少し応用的な <code>newtype</code> の使い方を紹介しよう．<code>newtype</code> は上のように目的に合わせて型を既存の型から作る他，型シノニムの制約によって定義できない型上の計算を実現するのにも使用できる．例えば，</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb47-1" title="1"><span class="kw">newtype</span> <span class="dt">Fix</span> f <span class="ot">=</span> <span class="dt">Fix</span> (f (<span class="dt">Fix</span> f))</a></code></pre></div>
<p>という変わったデータ型を使うと，型上の不動点演算をエミュレートできる．また，<code>newtype</code> を使うことで幽霊型による曖昧な型を避けることもできる．例えば，</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb48-1" title="1"><span class="kw">type</span> <span class="dt">WithAnn</span> ann a <span class="ot">=</span> a</a>
<a class="sourceLine" id="cb48-2" title="2"></a>
<a class="sourceLine" id="cb48-3" title="3"><span class="ot">readShow ::</span> (<span class="dt">Read</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">WithAnn</span> a <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb48-4" title="4">readShow s <span class="ot">=</span> <span class="fu">show</span> <span class="op">$</span> <span class="fu">read</span> s</a></code></pre></div>
<p>を考える．この関数 <code>readShow</code> は，<code>WithAnn</code> で引数に <code>a</code> を使っているにもかかわらず <code>a</code> が曖昧な型になるため弾かれる．なぜなら，型シノニム <code>WithAnn a String</code> は <code>String</code> と書いてるのと同じであり，<code>readShow</code> は</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb49-1" title="1"><span class="ot">readShow ::</span> (<span class="dt">Read</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a></code></pre></div>
<p>という型を持つのと同様になってしまうからだ．このため，制約だけに <code>a</code> が現れることになってしまい，曖昧な型になってしまう．この例のような，型シノニムが具体化されてしまうことで曖昧な型が生じる問題は，<code>newtype</code> を使用することで回避できる<span class="ascii">:</span></p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb50-1" title="1"><span class="kw">newtype</span> <span class="dt">WithAnn</span> ann a <span class="ot">=</span> <span class="dt">WithAnn</span> a</a>
<a class="sourceLine" id="cb50-2" title="2"></a>
<a class="sourceLine" id="cb50-3" title="3"><span class="ot">readShow ::</span> (<span class="dt">Read</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">WithAnn</span> a <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb50-4" title="4">readShow (<span class="dt">WithAnn</span> s) <span class="ot">=</span> <span class="fu">show</span> <span class="op">$</span> <span class="fu">read</span> s</a></code></pre></div>
<p><span class="ascii">Haskell</span> は型システム上は <code>WithAnn a String</code> が実行時に単なる <code>String</code> の別名として扱われることを知らず，これを<span class="ascii">1</span>つの具体化された型として認識する．このため，実際には <code>a</code> が引数の値に何ら関与しない場合も，型 <code>a</code> を伴う型として残る．よって，この場合は <code>a</code> は曖昧な型にならず，<code>WithAnn a String</code> の <code>a</code> の部分にあてがわれる型から特定することができる．このように，型シノニムで早期に元となった型に具体化されることで生じる問題は，<code>newtype</code> を使うことで実際に値を作る箇所とパターンマッチの箇所での型計算に遅延させることができ，回避できる場合がある．</p>
<h2 id="まとめ"><span class="link-to-here-outer"><a href="#まとめ" title="まとめ"><span class="link-to-here">Link to<br />
here</span></a></span>まとめ</h2>
<p><span class="ascii">Haskell</span> の<span class="ascii">3</span>つのデータ型定義方法について紹介した．</p>
<p>型シノニムは，ある型に対してその別名を与えることで，データ型を定義するものだった．簡易で元の型に対する関数をそのまま流用でき，使いやすい反面，部分適用ができない，再帰的データ型が定義できない，型クラスのインスタンスにできないと言う制約があった．</p>
<p>代数的データ型は複数の型の積和によって全く新しいデータ型を定義するものだった．型シノニムであった制約を回避でき，新たな構造を導入できるが，関数の流用が困難な場合があり型シノニムとの使い分けが必要だった．</p>
<p><code>newtype</code> によるデータ型は，型システム上は代数的データ型と，実行時の動作は型シノニムと同様といった，それぞれの中間をとったようなものだった．型シノニムのような関数の流用ができない場合はあるものの，その代わり型シノニムの制約を回避でき，型システム上は全く異なる振る舞いを行うことも可能だった．</p>
<p>これらは，それぞれが一長一短を持ち，目的にあった使い分けをする必要がある．この記事が，そのような場合の助けになればいいと思う．では，今回はこれで．</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>型シノニムに対して部分適用を許容する一般的な方法は，型上にもラムダ抽象にあたる表現を導入することである．ただ，この場合型上の演算が停止しない場合があり，型システムが決定不能になる．このため，<span class="ascii">Haskell</span> では型シノニムに対しての部分適用は許容していない．<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>等価再帰データ型 <span class="ascii">(equirecursive types)</span> と呼ばれる特別な型を型システムに導入することで，このような型を許容する理論は存在するが，この理論はとても複雑で型検査のアルゴリズムも難しくなりがちである．<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>ただ，このような混乱が起こるかもしれないことを許容し，利便性のため型シノニムをインスタンス定義で使いたい場合，<code>TypeSynonymInstances</code> という <span class="ascii">GHC</span> 拡張を有効にすることで許容されるようになる．<a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p>型上の計算によって，実際の型が特定される型シノニムとは異なり，代数的データ型の型コンストラクタはそれ自体がもう計算できないものになる．それは部分適用されても同様であり，部分適用を許容することで型シノニムと同様の問題は起こらない．これが，代数的データ型で部分適用が許容されている理由になる．<a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p>実際にはパラメータ <code>a</code> の部分に具体的な型を当てはめないといけないが，当てはめればそれは完全に具体的な型になる．<a href="#fnref5" class="footnote-back">↩</a></p></li>
<li id="fn6"><p>なお，代数的データ型でも型シノニムと同様の利点を手に入れるための研究は，<span class="ascii">Haskell</span> では盛んに行われている．例えば，<code>Generic</code> <span class="ascii">/</span> <code>Data</code> 型クラス，<code>lens</code> パッケージなどを使うことで，構造が同じだが異なるデータ型で関数が流用できない問題を回避できる場合がある．<a href="#fnref6" class="footnote-back">↩</a></p></li>
<li id="fn7"><p><span class="ascii">GHC</span> 拡張では，<code>deriving</code> 構文の拡張として強力な機能がいくつか搭載されている．特に <code>newtype</code> によるデータ型の場合は，<code>GeneralizedNewtypeDeriving</code> や <code>DerivingVia</code> 拡張を使えば，インスタンスの自動導出の範囲を大幅に拡大できる．<a href="#fnref7" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2020/antenna-with-gh-actions.html" lang="ja">Haskell AntennaのCI/CDをGitHub Actionsに移行する</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2020/strict-gotchas.html" style="margin-left: auto;" lang="ja">Strict拡張を使用する際の注意点</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>Strict拡張を使用する際の注意点</title>
    <link href="https://haskell.jp/blog/posts/2020/strict-gotchas.html" />
    <id>https://haskell.jp/blog/posts/2020/strict-gotchas.html</id>
    <published>2020-06-11T00:00:00Z</published>
    <updated>2020-06-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p><span class="ascii">Haskell</span>は他の多くのプログラミング言語と異なった特徴を備えており、しばしばそれらが議論を呼ぶことがあります。その中でも特によく俎上に上がるのが、遅延評価です。遅延評価は、適切に扱えば不要な計算を行わず、計算資源を節約してくれるステキな仕組みですが、一歩使い方を間違うと「サンク」という「これから実行する<small>（かも知れない）</small>計算」を表すオブジェクトが無駄に作られてしまい、却ってメモリー消費量が増えてしまう、などといった問題を抱えています。この現象は「スペースリーク」と呼ばれ、かつて<a href="https://qiita.com/advent-calendar/2015/haskell-space-leaks">専門の<span class="ascii">Advent Calendar</span></a>が作られたことがあるほど、<span class="ascii">Haskeller</span>達の関心を集めてきました。</p>
<p>そんな<span class="ascii">Haskeller</span>達の悩みの種を軽減しようと、<span class="ascii">GHC 8.0</span>以降、<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#strict-by-default-pattern-bindings"><code>Strict</code></a>と<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#strict-data"><code>StrictData</code></a>という言語拡張が搭載されました。これらの拡張は、大雑把に言うと、</p>
<ul>
<li><code>StrictData</code><span class="ascii">:</span> 値コンストラクターにおいて、引数の値が弱頭正規形（<span class="ascii">Weak Head Normal Form</span>。以降慣習に従い「<span class="ascii">WHNF</span>」と呼びます）まで評価されるようになる</li>
<li><code>Strict</code><span class="ascii">:</span> <code>StrictData</code>の効果に加え、あらゆる関数の引数やローカル変数の定義において、パターンマッチで代入した変数の値が<span class="ascii">WHNF</span>まで評価されるようになる</li>
</ul>
<p>というものです。</p>
<p>このうち、<code>StrictData</code>は比較的リスクが少なく大変有用<small>（もはや標準であって欲しいぐらい）</small>という声をよく聞きますが<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>、<code>Strict</code>については様々な問題点があることが知られています。今回はその各種問題点をまとめて共有することで、思い切って<code>Strict</code>を有効にするときに参考になる情報を提供したいと思います！</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#前提知識とその参考資料" title="前提知識とその参考資料">前提知識とその参考資料</a></li>
<li><a href="#サンプルコードの試し方" title="サンプルコードの試し方">サンプルコードの試し方</a></li>
<li><a href="#case-1-where句だろうとなんだろうと評価" title="case-1-where句だろうとなんだろうと評価"><span class="ascii">Case 1:</span> <code>where</code>句だろうとなんだろうと評価</a></li>
<li><a href="#case-2-ポイントフリースタイルかどうかで変わる" title="case-2-ポイントフリースタイルかどうかで変わる"><span class="ascii">Case 2:</span> ポイントフリースタイルかどうかで変わる！</a></li>
<li><a href="#case-3-内側のパターンはやっぱりダメ" title="case-3-内側のパターンはやっぱりダメ"><span class="ascii">Case 3:</span> 内側のパターンはやっぱりダメ</a></li>
<li><a href="#case-4-foldrに渡す関数" title="case-4-foldrに渡す関数"><span class="ascii">Case 4:</span> <code>foldr</code>に渡す関数</a></li>
<li><a href="#case-5-undefinedを受け取るメソッド" title="case-5-undefinedを受け取るメソッド"><span class="ascii">Case 5:</span> <code>undefined</code>を受け取るメソッド</a></li>
<li><a href="#おわりに-やっぱりstrictは使う使わない" title="おわりに-やっぱりstrictは使う使わない">おわりに<span class="ascii">:</span> やっぱり<code>Strict</code>は使う？使わない？</a></li>
</ul>
</div>
</div>
<h1 id="前提知識とその参考資料"><span class="link-to-here-outer"><a href="#前提知識とその参考資料" title="前提知識とその参考資料"><span class="link-to-here">Link to<br />
here</span></a></span>前提知識とその参考資料</h1>
<p>以下の知識について、ざっくり理解しているものとして進めます。参考になりそうな日本語のページも付記したので、ご覧ください。</p>
<ul>
<li><span class="ascii">Haskell</span>の遅延評価について
<ul>
<li><a href="https://itchyny.hatenablog.com/entry/20130209/1360417348">実装して理解する遅延評価の仕組み 〜 <span class="ascii">thunk</span>を絵に描いて理解しよう・<span class="ascii">JavaScript</span>で<span class="ascii">Haskell</span>を実装！？ <span class="ascii">-</span> プログラムモグモグ</a>が詳しくて分かりやすいでしょう</li>
</ul></li>
<li><span class="ascii">Haskell</span>の正格評価、および<code>BangPatterns</code>について
<ul>
<li><a href="https://haskell.e-bigmoon.com/posts/2018/06-25-all-about-strictness">正格性のすべて <span class="ascii">(</span>翻訳<span class="ascii">)</span></a></li>
</ul></li>
<li><code>Strict</code>と<code>StrictData</code>について
<ul>
<li><a href="https://kazu-yamamoto.hatenablog.jp/entry/20151117/1447726679"><span class="ascii">Strict Haskell -</span> あどけない話</a></li>
</ul></li>
<li>その他、<a href="https://qiita.com/advent-calendar/2015/haskell-space-leaks"><span class="ascii">Haskell</span>スペースリーク <span class="ascii">Advent Calendar 2015 - Qiita</span></a>の記事にも有用なものがたくさんあります。</li>
</ul>
<h1 id="サンプルコードの試し方"><span class="link-to-here-outer"><a href="#サンプルコードの試し方" title="サンプルコードの試し方"><span class="link-to-here">Link to<br />
here</span></a></span>サンプルコードの試し方</h1>
<p>これから紹介するコードは、すべて<a href="https://github.com/haskell-jp/blog/tree/master/examples/2020/strict-gotchas">このブログのリポジトリーの、<code>examples</code>ディレクトリー</a>に置いておきました。下記のコマンドを実行すれば実際に試すことができます<small>（一部実行する際のコマンドが異なりますので、適宜例示します）</small>。</p>
<pre><code>git clone https://github.com/haskell-jp/blog.git
cd blog/examples/2020/strict-gotchas
stack exec runghc -- &lt;これから紹介するコードのファイル&gt;.hs</code></pre>
<p>実際に試すときは<code>--ghc-arg=-XStrict</code>というオプションを<code>runghc</code>に付けた場合と付けなかった場合両方で実行して、違いを確かめてみてください。</p>
<p>なお、使用した<span class="ascii">GHC</span>のバージョンは<span class="ascii">8.10.1</span>で、<span class="ascii">OS</span>は<span class="ascii">Windows 10 ver. 1909</span>です。</p>
<h1 id="case-1-where句だろうとなんだろうと評価"><span class="link-to-here-outer"><a href="#case-1-where句だろうとなんだろうと評価" title="case-1-where句だろうとなんだろうと評価"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Case 1:</span> <code>where</code>句だろうとなんだろうと評価</h1>
<p>サンプル<span class="ascii">:</span> <a href="https://github.com/haskell-jp/blog/blob/master/examples/2020/strict-gotchas/where.hs"><span class="ascii">where.hs</span></a></p>
<p>最初のケースは、遅延評価で当たり前に享受できていたメリットが、<code>Strict</code>を有効にしている状態では得られなくなってしまう、というものです。<a href="https://qiita.com/pxfnc/items/a26bda6d11402daba675"><span class="ascii">pxfnc</span>さんの<span class="ascii">Strict</span>拡張でハマったお話</a>という記事でも紹介されてはいますが、まとめ記事なのでここでも改めて取り上げます。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1">main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> div10 <span class="dv">0</span></a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="ot">div10 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-4" title="4">div10 n</a>
<a class="sourceLine" id="cb2-5" title="5">  <span class="op">|</span> n <span class="op">==</span> <span class="dv">0</span>    <span class="ot">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb2-6" title="6">  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> result</a>
<a class="sourceLine" id="cb2-7" title="7"> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-8" title="8">  result <span class="ot">=</span> <span class="dv">10</span> <span class="ot">`div`</span> n</a></code></pre></div>
<p>ご覧のとおり、本当にほとんど<span class="ascii">pxfnc</span>さんの記事のサンプルそのままで恐縮ですが、このプログラム、👇のように<code>Strict</code>拡張を有効にして実行するとエラーが起こります。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" title="1"><span class="op">&gt;</span> <span class="ex">stack</span> exec -- runghc --ghc-arg=-XStrict where.hs</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="ex">where.hs</span>: divide by zero</a></code></pre></div>
<p>一方、<code>Strict</code>拡張を有効にしなかった場合、エラーは起こりません。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" title="1"><span class="op">&gt;</span> <span class="ex">stack</span> exec -- runghc where.hs</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="ex">0</span></a></code></pre></div>
<p>なぜこんなことが起こるのでしょう？</p>
<p>これは、<code>Strict</code>拡張がパターンマッチで代入したあらゆる変数の値を<span class="ascii">WHNF</span>まで評価するようになった結果、<code>where</code>句で代入した変数まで必ず<span class="ascii">WHNF</span>まで評価してしまうために発生したエラーです。すなわち、<code>where</code>における、</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1">  result <span class="ot">=</span> <span class="dv">10</span> <span class="ot">`div`</span> n</a></code></pre></div>
<p>までもが、</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1">  <span class="op">!</span>result <span class="ot">=</span> <span class="dv">10</span> <span class="ot">`div`</span> n</a></code></pre></div>
<p>と<span class="ascii">Bang</span>パターンを付けた代入であるかのように解釈されたのです<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>。</p>
<p>こうなると、<code>result</code>を使用しないケース、すなわち<code>n == 0</code>の場合であっても<code>result</code>に <small>（<span class="ascii">WHNF</span>まで評価した）</small>値を代入するのに必要な計算は実行され、結果<code>10 `div` 0</code>が計算されようとして<code>divide by zero</code>が発生するのです。</p>
<p>⚠️<code>where</code>句は関数定義の後ろの方に書くという性格上、見落としがちかも知れません。注意しましょう。</p>
<h1 id="case-2-ポイントフリースタイルかどうかで変わる"><span class="link-to-here-outer"><a href="#case-2-ポイントフリースタイルかどうかで変わる" title="case-2-ポイントフリースタイルかどうかで変わる"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Case 2:</span> ポイントフリースタイルかどうかで変わる！</h1>
<p>サンプル<span class="ascii">:</span> <a href="https://github.com/haskell-jp/blog/blob/master/examples/2020/strict-gotchas/const.hs"><span class="ascii">const.hs</span></a></p>
<p>続いて、<span class="ascii">Haskell</span>に慣れた方なら誰もが一度は試したくなる、ポイントフリースタイルに関する落とし穴です。まずは次の二つの関数をご覧ください。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="ot">dontReferArgs ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb7-2" title="2">dontReferArgs <span class="ot">=</span> <span class="fu">const</span></a>
<a class="sourceLine" id="cb7-3" title="3"></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="ot">referArgs ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb7-5" title="5">referArgs x _ <span class="ot">=</span> x</a></code></pre></div>
<p>この関数、どちらもやっていることは<code>const</code>と変わりません。<code>dontReferArgs</code>は<code>const</code>をそのまま使うことでポイントフリースタイルにしていますが、<code>referArgs</code>は自前で引数に言及することで<code>const</code>と同等の定義となっています。ポイントフリースタイルに変えると言うことは原則として元の関数の挙動を変えないワケですから、<code>dontReferArgs</code>と<code>referArgs</code>の意味は変わらないはず、ですよね<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>？</p>
<p>ところがこれらの関数を<code>Strict</code>拡張を有効にした上で定義すると、なんと挙動が異なってしまいます！</p>
<p>使用例<span class="ascii">:</span></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb8-2" title="2">main <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-3" title="3">  <span class="fu">print</span> <span class="op">$</span> dontReferArgs <span class="st">&quot;dontReferArgs&quot;</span> (<span class="fu">undefined</span><span class="ot"> ::</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb8-4" title="4">  <span class="fu">print</span> <span class="op">$</span> referArgs <span class="st">&quot;referArgs&quot;</span> (<span class="fu">undefined</span><span class="ot"> ::</span> <span class="dt">Int</span>)</a></code></pre></div>
<p>実行結果（<span class="ascii">Strict</span>拡張を有効にしなかった場合）<span class="ascii">:</span></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb9-1" title="1"><span class="op">&gt;</span> <span class="ex">stack</span> exec runghc const.hs</a>
<a class="sourceLine" id="cb9-2" title="2"><span class="st">&quot;dontReferArgs&quot;</span></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="st">&quot;referArgs&quot;</span></a></code></pre></div>
<p>実行結果（<span class="ascii">Strict</span>拡張を有効にした場合）<span class="ascii">:</span></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb10-1" title="1"><span class="op">&gt;</span> <span class="ex">stack</span> exec -- runghc --ghc-arg=-XStrict const.hs</a>
<a class="sourceLine" id="cb10-2" title="2"><span class="st">&quot;dontReferArgs&quot;</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="ex">const.hs</span>: Prelude.undefined</a>
<a class="sourceLine" id="cb10-4" title="4"><span class="ex">CallStack</span> (from HasCallStack)<span class="bu">:</span></a>
<a class="sourceLine" id="cb10-5" title="5">  <span class="ex">error</span>, called at libraries\base\GHC\Err.hs:79:14 in base:GHC.Err</a>
<a class="sourceLine" id="cb10-6" title="6">  <span class="ex">undefined</span>, called at const.hs:10:34 in main:Main</a></code></pre></div>
<p>はい、<code>where</code>句のケースと同様、<code>Strict</code>拡張を有効にした場合、例外が発生してしまいました❗️<code>Strict</code>拡張を有効にした結果、意図せず例外を発生させる値<small>（今回の場合<code>undefined</code>）</small>が評価されてしまったのです。</p>
<p>例外を発生させた関数はそう、ポイントフリースタイルでない、<code>referArgs</code>関数の方です！なぜ<code>referArgs</code>でのみ例外が発生してしまったのかというと、<code>referArgs</code>が<code>Strict</code>拡張を有効にしたモジュールで、引数に言及<small>（パターンマッチ）</small>しているからです。<code>Strict</code>拡張を有効にした結果「あらゆる関数やローカル変数の定義において、パターンマッチで代入した変数の値」が評価されるとおり、<code>referArgs</code>の引数<code>x</code>・<code>_</code>も必ず評価されるようになり、このような例外が発生したのです。たとえ使用しない変数<code>_</code>でも関係ありません！</p>
<p>そのため、原因の本質は引数に言及<small>（パターンマッチ）</small>しているか否かであり、<code>Prelude</code>の<code>const</code>を使用しているか否かではありません。こちら👇のように引数に言及した上で<code>const</code>を使っても、結果は同じなのです。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="ot">referArgsByConst ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb11-2" title="2">referArgsByConst x y <span class="ot">=</span> <span class="fu">const</span> x y</a></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="fu">print</span> <span class="op">$</span> referArgsByConst <span class="st">&quot;referArgsByConst&quot;</span> (<span class="fu">undefined</span><span class="ot"> ::</span> <span class="dt">Int</span>)</a></code></pre></div>
<p>一方、<code>dontReferArgs</code>については、引数に言及せず、<code>Prelude</code>にある<code>const</code>をそのまま使っています。<code>Strict</code>拡張はあくまでも「パターンマッチした変数」のみを<span class="ascii">WHNF</span>まで評価するものであり、あらゆる関数が正格に呼び出されるわけではありません。なので通常の<code>Prelude</code>における<code>const</code>と同様、<code>dontReferArgs</code>も第<span class="ascii">2</span>引数は評価しないため、<code>undefined</code>を渡しても例外は起こらなかったのです。</p>
<p>このことは、「<strong><code>Strict</code>拡張を有効にしているモジュールの中でも、<code>Strict</code>を有効にしていないモジュール<small>（この場合は<code>Prelude</code>）</small>から<code>import</code>した関数は、引数を正格に評価しない</strong>」という忘れてはならないポイントも示しています。例えば<code>const</code>よりももっと頻繁に使われるであろう、言及する引数を一つ削除する演算子の代表、関数合成<code>.</code>を使ったケースを考えてみてください。</p>
<p>ポイントフリースタイルに慣れた方なら、関数適用<code>$</code>を次👇のように使って定義した<code>f</code>を見ると、</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1">f xs <span class="ot">=</span> <span class="fu">map</span> (<span class="op">+</span> <span class="dv">3</span>) <span class="op">$</span> <span class="fu">filter</span> (<span class="op">&gt;</span> <span class="dv">2</span>) xs</a>
<a class="sourceLine" id="cb13-2" title="2"></a>
<a class="sourceLine" id="cb13-3" title="3"><span class="co">-- あるいは、`$`を使わないでこのように書いた場合も:</span></a>
<a class="sourceLine" id="cb13-4" title="4">f xs <span class="ot">=</span> <span class="fu">map</span> (<span class="op">+</span> <span class="dv">3</span>) (<span class="fu">filter</span> (<span class="op">&gt;</span> <span class="dv">2</span>) xs)</a></code></pre></div>
<p>こちら👇のように書き換えたくなってうずうずするでしょう。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1">f <span class="ot">=</span> <span class="fu">map</span> (<span class="op">+</span> <span class="dv">3</span>) <span class="op">.</span> <span class="fu">filter</span> (<span class="op">&gt;</span> <span class="dv">2</span>)</a></code></pre></div>
<p>しかし、<code>Strict</code>を有効にしたモジュールでこのような書き換えを行うと、<code>f</code>の挙動が変わってしまいます。引数<code>.</code>を使って書き換える前は、引数<code>xs</code>に言及していたところ<code>.</code>を使って引数<code>xs</code>に言及しなくなったからです。<code>filter</code>も<code>map</code>も<code>Strict</code>拡張を有効にしたモジュールで定義されているわけではないので、引数を正格に評価しないんですね。結果、こうした書き換えによって、<strong><code>Strict</code>拡張を有効にしていても意図せず遅延評価してしまう</strong>、というリスクがあるので、リファクタリングの際はくれぐれも気をつけてください<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>。ざっくりまとめると、<code>Strict</code>拡張を有効にしているモジュールでは、「引数や変数を宣言することすなわち<span class="ascii">WHNF</span>まで評価すること」、あるいは「引数や変数を宣言しなければ、評価されない」と意識しましょう。</p>
<p>ちなみに、<code>referArgs</code>における<code>_</code>のように「<code>Strict</code>拡張を有効にした場合さえ、使用していない引数が評価されてしまうのは困る！」という場合は、引数名の前にチルダ<code>~</code>を付けてください。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="ot">referArgs ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb15-2" title="2">referArgs x <span class="op">~</span>_ <span class="ot">=</span> x</a></code></pre></div>
<h1 id="case-3-内側のパターンはやっぱりダメ"><span class="link-to-here-outer"><a href="#case-3-内側のパターンはやっぱりダメ" title="case-3-内側のパターンはやっぱりダメ"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Case 3:</span> 内側のパターンはやっぱりダメ</h1>
<p>サンプル<span class="ascii">:</span> 今回は<span class="ascii">GHCi</span>ですべて紹介するのでサンプルはありません。</p>
<p>続いては、<code>Strict</code>拡張のドキュメントでも触れられている、入れ子になったパターンマッチにおける問題を紹介します。一言で言うと、<code>let (a, b) = ...</code>のような、データ構造<small>（この場合タプルですね）</small>の「内側」に対するパターンマッチは、<code>Strict</code>拡張を有効にしていても正格に評価しないよ、という話です。</p>
<p>例えば、下記のコードを<code>Strict</code>拡張付きで実行しても、パターンマッチしている<code>a</code>・<code>b</code>ともに代入した時点では正格評価されず、<code>error "a"</code>・<code>error "b"</code>による例外はいずれも発生しません。次のコードを<span class="ascii">GHCi</span>で試してみてください。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="op">&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XStrict</span></a>
<a class="sourceLine" id="cb16-2" title="2"><span class="op">&gt;</span> (a, b) <span class="ot">=</span> (<span class="fu">error</span> <span class="st">&quot;a&quot;</span>, <span class="fu">error</span> <span class="st">&quot;b&quot;</span>)</a>
<a class="sourceLine" id="cb16-3" title="3"><span class="co">-- 何も起きない</span></a></code></pre></div>
<p>先ほどの節における「<code>Strict</code>拡張を有効にしているモジュールでは、『引数や変数を宣言することすなわち<span class="ascii">WHNF</span>まで評価すること」』、あるいは『引数や変数を宣言しなければ、評価されない』と意識しましょう」という主張を真に受けてしまうと、意図せず遅延評価させてしまい、ハマりそうです😰。⚠️繰り返しますが「<strong>内側のパターンにおける変数は正格評価されない</strong>」ということも意識してください。</p>
<p>一方、<code>StrictData</code>や正格性フラグを用いるなどして、各要素を正格評価するよう定義した値コンストラクターでは、ちゃんと評価して例外を発生させます。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="op">&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XStrict</span></a>
<a class="sourceLine" id="cb17-2" title="2"><span class="op">&gt;</span> <span class="kw">data</span> <span class="dt">MyTuple</span> a b <span class="ot">=</span> <span class="dt">MyTuple</span> a b <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb17-3" title="3"><span class="op">&gt;</span> <span class="kw">let</span> <span class="dt">MyTuple</span> a b <span class="ot">=</span> <span class="dt">MyTuple</span> (<span class="fu">error</span> <span class="st">&quot;a&quot;</span>) (<span class="fu">error</span> <span class="st">&quot;b&quot;</span>)</a>
<a class="sourceLine" id="cb17-4" title="4"><span class="op">***</span> <span class="dt">Exception</span><span class="op">:</span> b</a>
<a class="sourceLine" id="cb17-5" title="5"><span class="dt">CallStack</span> (from <span class="dt">HasCallStack</span>)<span class="op">:</span></a>
<a class="sourceLine" id="cb17-6" title="6">  <span class="fu">error</span>, called at <span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">10</span><span class="op">:</span><span class="dv">40</span> <span class="kw">in</span> interactive<span class="op">:</span><span class="dt">Ghci7</span></a></code></pre></div>
<p><code>Strict</code>拡張を有効にすると<code>StrictData</code>も自動的に有効になるので、👆における<code>MyTuple</code>値コンストラクターは各要素を正格評価するようになったわけです。なので<code>Strict</code>拡張を有効にしたモジュールにおいて、なおかつそこで定義した型で完結している限りは平和でしょう。</p>
<p>ただし、<span class="ascii">GHCi</span>で試す場合に特に注意していただきたいのですが、<span class="ascii">GHCi</span>で<strong><code>let</code>をつけないでパターンマッチした場合は正格評価されない</strong>、という点に注意してください。<code>let</code>をつけないとトップレベルでの定義と見なされるからです。<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#strict-by-default-pattern-bindings"><span class="ascii">Strict</span>拡張のドキュメント</a>にも、「<span class="ascii">Top level bindings are unaffected by</span> <code>Strict</code>」とありますとおり、トップレベルでの定義は例外扱いされているのです。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1"><span class="op">&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XStrict</span></a>
<a class="sourceLine" id="cb18-2" title="2"><span class="op">&gt;</span> <span class="kw">data</span> <span class="dt">MyTuple</span> a b <span class="ot">=</span> <span class="dt">MyTuple</span> a b <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb18-3" title="3"><span class="op">&gt;</span> <span class="dt">MyTuple</span> a b <span class="ot">=</span> <span class="dt">MyTuple</span> (<span class="fu">error</span> <span class="st">&quot;a&quot;</span>) (<span class="fu">error</span> <span class="st">&quot;b&quot;</span>)</a>
<a class="sourceLine" id="cb18-4" title="4"><span class="co">-- 何も起きない</span></a></code></pre></div>
<h1 id="case-4-foldrに渡す関数"><span class="link-to-here-outer"><a href="#case-4-foldrに渡す関数" title="case-4-foldrに渡す関数"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Case 4:</span> <code>foldr</code>に渡す関数</h1>
<p>サンプル<span class="ascii">:</span> <a href="https://github.com/haskell-jp/blog/blob/master/examples/2020/strict-gotchas/stackoverflow-foldr.hs"><span class="ascii">stackoverflow-foldr.hs</span></a></p>
<p>ここの話はちょっと難しいので、先に守るべきルールを述べておきます。</p>
<p>「遅延評価する関数を受け取る前提の高階関数に、（<code>Strict</code>拡張などで）引数を正格に評価するよう定義された関数を渡すのは止めましょう。」</p>
<p>なんだかこう書くと半ばトートロジーのようにも聞こえますが、より具体的には、例えば<code>foldr</code>に引数を正格に評価するよう定義された関数を渡すのは止めましょう、という話です。<code>Strict</code>拡張を有効にした状態では、ラムダ式にも注意しないといけないもポイントです。</p>
<p>※あらかじめおことわり<span class="ascii">:</span> この節のお話は、あくまでもリストに対する<code>foldr</code>の場合のお話です。他の<code>Foldable</code>な型では必ずしも当てはまらないのでご注意ください。</p>
<p>論より証拠で、サンプルコードの中身（抜粋）とその実行結果を見てみましょう。</p>
<pre class="main"><code>-- ...
evaluate . length $ foldr (:) [] [1 .. size]
putStrLn &quot;DONE: foldr 1&quot;

evaluate . length $ foldr (\x z -&gt; x : z) [] [1 .. size]
putStrLn &quot;DONE: foldr 2&quot;</code></pre>
<p>今回のサンプルコードを実行する際は、<span class="ascii">GHC</span>のランタイムオプションを設定して、スタック領域のサイズを減らしてください。そうでなければ、処理するリストがあまり大きくないので<code>Strict</code>拡張を有効にしても問題の現象は再現されないでしょう<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a>。<a href="https://stackoverflow.com/questions/29339643/how-can-i-pass-rts-options-to-runghc">こちらの<span class="ascii">Stackoverflow</span>の質問</a>曰く、<code>runghc</code>で実行する際にランタイムオプションを設定する場合は、<code>GHCRTS</code>環境変数を使用するしかないそうです。</p>
<p>実行結果（<span class="ascii">Strict</span>拡張を有効にしなかった場合）<span class="ascii">:</span></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb20-1" title="1"><span class="op">&gt;</span> <span class="va">GHCRTS=</span>-K100k <span class="ex">stack</span> exec runghc -- ./stackoverflow-foldr.hs</a>
<a class="sourceLine" id="cb20-2" title="2"><span class="ex">DONE</span>: foldr 1</a>
<a class="sourceLine" id="cb20-3" title="3"><span class="ex">DONE</span>: foldr 2</a></code></pre></div>
<p>実行結果（<span class="ascii">Strict</span>拡張を有効にした場合）<span class="ascii">:</span></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb21-1" title="1"><span class="op">&gt;</span> <span class="va">GHCRTS=</span>-K100k <span class="ex">stack</span> exec runghc -- --ghc-arg=-XStrict ./stackoverflow-foldr.hs</a>
<a class="sourceLine" id="cb21-2" title="2"><span class="ex">DONE</span>: foldr 1</a>
<a class="sourceLine" id="cb21-3" title="3"><span class="ex">stackoverflow-foldr.hs</span>: stack overflow</a></code></pre></div>
<p>サンプルコードは整数のリストに対して特に何も変換せず<code>foldr</code>する<small>（そして、<code>length</code>関数でリスト全体を評価してから捨てる）</small>だけのことを<span class="ascii">2</span>回繰り返したコードです。最初の<code>foldr</code>は<code>Strict</code>拡張があろうとなかろうと無事実行できたにもかかわらず、<code>Strict</code>拡張を有効にした二つめの<code>foldr</code>は、<code>stack overflow</code>というエラーを起こしてしまいました💥！</p>
<p>なぜこんなエラーが発生したのかを知るために、<code>foldr</code>の定義を見直しましょう。こちら👇は<a href="http://hackage.haskell.org/package/base-4.14.0.0/docs/src/GHC.Base.html#foldr"><span class="ascii">GHC 8.10.1</span>における、リストに対する<code>foldr</code>の定義</a>です<small>（コメントは省略しています）</small>。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" title="1"><span class="fu">foldr</span><span class="ot">            ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb22-2" title="2"><span class="fu">foldr</span> k z <span class="ot">=</span> go</a>
<a class="sourceLine" id="cb22-3" title="3">          <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-4" title="4">            go []     <span class="ot">=</span> z</a>
<a class="sourceLine" id="cb22-5" title="5">            go (y<span class="op">:</span>ys) <span class="ot">=</span> y <span class="ot">`k`</span> go ys</a></code></pre></div>
<p><code>go</code>という補助関数を再帰的に呼び出すことで、第一引数として渡した関数<code>k</code>を用いてリストの要素<span class="ascii">(</span><code>y</code><span class="ascii">)</span>を一つずつ変換しています。呼び出す度にリストの残りの要素をチェックして、最終的に空のリストを受け取ったときは<code>foldr</code>の第二引数<code>z</code>を返していますね。</p>
<p>このとき<code>k</code>が第二引数を遅延評価する関数であった場合、 — サンプルコードで言えば<code>(:)</code>の場合 — 受け取った<code>go ys</code>という式は直ちには評価されません。サンプルコードの<code>(:)</code>に置き換えると、<code>(:)</code>の第二引数、つまりリストの残りの要素を取り出す度に<code>go ys</code>を一回計算して、一個ずつ要素を作り出すイメージです。</p>
<p>一方、<code>k</code>が第二引数を正格評価する関数であった場合、 — サンプルコードで言うところの、<code>Strict</code>拡張を有効にした<code>(\x z -&gt; x : z)</code>の場合 — <code>k</code>は受け取った<code>go ys</code>をすぐに評価しようとします。このとき、<span class="ascii">GHC</span>は<code>k</code>や<code>go</code>に渡されている引数をスタック領域に積みます<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a>。そうして<code>go</code>と、<code>go</code>に呼ばれた<code>k</code>が次々と引数をスタック領域に積んだ結果、スタックサイズの上限に達し、スタックオーバーフローが発生してしまうのです。</p>
<p>これは他の多くのプログラミング言語で<small>（末尾再帰じゃない、普通の）</small>再帰呼び出しを行った場合とよく似た振る舞いです。間違って無限再帰呼び出しをしてしまってスタック領域があふれる、なんて経験は多くのプログラマーがお持ちでしょう。つまり単純に、<code>Strict</code>拡張を有効にした場合の<code>foldr (\x z -&gt; x : z) []</code>は、再帰呼び出しをしすぎてしまう関数となるのです。</p>
<p>なお、今回は<code>length</code>関数を使ってリスト全体を使用するコードにしましたが、遅延リストらしく<code>foldr</code>の結果を一部しか使わない、という場合、<code>foldr</code>に渡した関数がリストを都度正格評価してしまうので、無駄な評価が占める割合はもっと増えることになります。やはり<code>foldr</code>は遅延評価を前提とした高階関数と言えるでしょう。</p>
<p>以上のとおり、<span class="ascii">Haskell</span>には<code>foldr</code>のような、遅延評価を前提とした関数が<code>Strict</code>拡張より遥か昔から存在しています。それらを<code>Strict</code>拡張を有効にした状態で使うと、思わぬ衝突が起きてしまうので、くれぐれも気をつけましょう。</p>
<p>こういう「使ってはいけない関数」を引いてしまわないための方法についても一点補足します。<span class="ascii">HLint</span>を細かく設定したり、カスタム<code>Prelude</code>を設定したりしてみるのは、一つの作戦です。なんとプロジェクト全体で、<code>foldr</code>を禁止することができます<small>（一部のモジュールでは例外的に許可する、なんてこともできます）</small>。詳しくは<a href="https://haskell.e-bigmoon.com/posts/2018/01-29-awesome-hlint.html">「素晴らしき <span class="ascii">HLint</span> を使いこなす」</a>や<a href="https://haskell.e-bigmoon.com/posts/2018/05-23-extended-prelude.html">「<span class="ascii">Prelude</span> を カスタム<span class="ascii">Prelude</span> で置き換える」</a>をご覧ください。</p>
<h1 id="case-5-undefinedを受け取るメソッド"><span class="link-to-here-outer"><a href="#case-5-undefinedを受け取るメソッド" title="case-5-undefinedを受け取るメソッド"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Case 5:</span> <code>undefined</code>を受け取るメソッド</h1>
<p>サンプル<span class="ascii">:</span> <a href="https://github.com/haskell-jp/blog/blob/master/examples/2020/strict-gotchas/storable.hs"><span class="ascii">storable.hs</span></a></p>
<p>最後はちょっとレアケースではありますが、こちら👇の<span class="ascii">Issue</span>で発覚した問題を解説しましょう。</p>
<p><a href="https://gitlab.haskell.org/ghc/ghc/issues/16810"><span class="ascii">#16810: Use explicit lazy binding around undefined in inlinable functions · Issues · Glasgow Haskell Compiler / GHC · GitLab</span></a></p>
<p>問題を簡単に再現するために、次のサンプルコードを用意しました。</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" title="1"><span class="co">-- importなどは当然省略！</span></a>
<a class="sourceLine" id="cb23-2" title="2"><span class="kw">data</span> <span class="dt">Test</span> <span class="ot">=</span> <span class="dt">Test</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb23-3" title="3"></a>
<a class="sourceLine" id="cb23-4" title="4"><span class="kw">instance</span> <span class="dt">Storable</span> <span class="dt">Test</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-5" title="5">  sizeOf _ <span class="ot">=</span> sizeOf (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>) <span class="op">*</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb23-6" title="6">  alignment _ <span class="ot">=</span> <span class="dv">8</span></a>
<a class="sourceLine" id="cb23-7" title="7">  peek <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;This should not be called in this program&quot;</span></a>
<a class="sourceLine" id="cb23-8" title="8">  poke <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;This should not be called in this program&quot;</span></a>
<a class="sourceLine" id="cb23-9" title="9"></a>
<a class="sourceLine" id="cb23-10" title="10">main <span class="ot">=</span> alloca <span class="op">$</span> \(<span class="ot">_ ::</span> <span class="dt">Ptr</span> <span class="dt">Test</span>) <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> <span class="st">&quot;This won&#39;t be printed when Strict is enabled&quot;</span></a></code></pre></div>
<p>はい、適当な型を定義して<a href="https://downloads.haskell.org/~ghc/8.10.1/docs/html/libraries/base-4.14.0.0/Foreign-Storable.html#t:Storable"><code>Storable</code></a>のインスタンスにして、それに対して<a href="https://downloads.haskell.org/~ghc/8.10.1/docs/html/libraries/base-4.14.0.0/Foreign-Marshal-Alloc.html#v:alloca"><code>alloca</code></a>を呼ぶだけのコードです。インスタンス定義をはじめかなり手抜きな感じになっちゃってますが、まぁ今回の問題を再現するのにはこれで十分なので、ご了承ください🙏。</p>
<p>このコード、残念ながら<code>Strict</code>拡張を有効にした状態で実行すると、<code>undefined</code>による例外が発生してしまいます💥。</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb24-1" title="1"><span class="op">&gt;</span> <span class="ex">stack</span> exec -- runghc --ghc-arg=-XStrict storable.hs</a>
<a class="sourceLine" id="cb24-2" title="2"><span class="ex">storable.hs</span>: Prelude.undefined</a>
<a class="sourceLine" id="cb24-3" title="3"><span class="ex">CallStack</span> (from HasCallStack)<span class="bu">:</span></a>
<a class="sourceLine" id="cb24-4" title="4">  <span class="ex">error</span>, called at libraries\base\GHC\Err.hs:79:14 in base:GHC.Err</a>
<a class="sourceLine" id="cb24-5" title="5">  <span class="ex">undefined</span>, called at libraries\base\Foreign\Marshal\Alloc.hs:117:31 in base:Foreign.Marshal.Alloc</a></code></pre></div>
<p>こちらは<code>Strict</code>を有効にしなかった場合。やはり例外は起きてませんね😌。</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb25-1" title="1"><span class="op">&gt;</span> <span class="ex">stack</span> exec -- runghc storable.hs</a>
<a class="sourceLine" id="cb25-2" title="2"><span class="ex">This</span> won<span class="st">&#39;t be printed when Strict is enabled</span></a></code></pre></div>
<p>さてこの、<code>Strict</code>拡張を有効にした場合に発生した、<code>undefined</code>による例外はどこからやってきたのでしょう？上記のコードにはいくつか<code>error</code>関数を使用している箇所がありますが、発生した例外はあくまでも<code>undefined</code>です。見た限り上記のコードそのものから発生した例外ではなさそうですね…🤔。</p>
<p>その答えはなんと、<code>main</code>関数で呼んでいる<a href="https://downloads.haskell.org/~ghc/8.10.1/docs/html/libraries/base-4.14.0.0/src/Foreign-Marshal-Alloc.html#alloca"><code>alloca</code>の定義</a>にありました！</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" title="1"><span class="ot">alloca ::</span> <span class="kw">forall</span> a b <span class="op">.</span> <span class="dt">Storable</span> a <span class="ot">=&gt;</span> (<span class="dt">Ptr</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> <span class="dt">IO</span> b</a>
<a class="sourceLine" id="cb26-2" title="2">alloca  <span class="ot">=</span></a>
<a class="sourceLine" id="cb26-3" title="3">  allocaBytesAligned (sizeOf (<span class="fu">undefined</span><span class="ot"> ::</span> a)) (alignment (<span class="fu">undefined</span><span class="ot"> ::</span> a))</a></code></pre></div>
<p>確かに、<code>sizeOf</code>メソッドや<code>alignment</code>メソッドに<code>undefined</code>を渡しています。これらはいずれも<code>Storable</code>型クラスのメソッドなので、上記の<code>Test</code>型でももちろん実装しています。そう、実はこの<code>sizeOf</code>メソッドと<code>alignment</code>メソッドの実装で、下👇のように引数<code>_</code>を宣言しているのが問題なのです！</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" title="1"><span class="kw">instance</span> <span class="dt">Storable</span> <span class="dt">Test</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-2" title="2">  sizeOf _ <span class="ot">=</span> sizeOf (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>) <span class="op">*</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb27-3" title="3">  alignment _ <span class="ot">=</span> <span class="dv">8</span></a>
<a class="sourceLine" id="cb27-4" title="4">  <span class="co">-- ...</span></a></code></pre></div>
<p><a href="#case-2-ポイントフリースタイルかどうかで変わる">「<span class="ascii">Case 2:</span> ポイントフリースタイルかどうかで変わる！」の節</a>で、「<code>Strict</code>拡張を有効にしているモジュールでは、『引数や変数を宣言することすなわち<span class="ascii">WHNF</span>まで評価すること」』、あるいは『引数や変数を宣言しなければ、評価されない』」と述べたことを再び思い出してください。こちらの<code>sizeOf</code>・<code>alignment</code>の定義でも同様に、引数<code>_</code>を宣言しているため、引数を必ず<span class="ascii">WHNF</span>まで評価することになっています。結果、<code>alloca</code>関数がそれぞれを呼ぶ際<code>undefined</code>を渡しているため、<code>undefined</code>を評価してしまい、<code>undefined</code>による例外が発生してしまうのです💥。</p>
<p>なぜこのように、<code>alloca</code>関数では<code>sizeOf</code>や<code>alignment</code>に<code>undefined</code>をわざわざ渡しているのでしょう？それは、これらのメソッドがそもそも<code>undefined</code>を渡して使うことを前提に設計されているからです。<code>sizeOf</code>・<code>alignment</code>はともに<code>Storable a =&gt; a -&gt; Int</code>という型の関数なので、第一引数に<code>Storable</code>のインスタンスである型<code>a</code>の値を受け取るのですが、このとき<strong>渡される<code>a</code>型の値は、使わない</strong>こととなっています。<a href="https://downloads.haskell.org/~ghc/8.10.1/docs/html/libraries/base-4.14.0.0/Foreign-Storable.html#v:sizeOf">それぞれのメソッドの説明</a>にも「<span class="ascii">The value of the argument is not used.</span>」と書かれていますね。これは、<code>sizeOf</code>も<code>alignment</code>も、型毎に一意な値として定まる<small>（引数の値によって<code>sizeOf</code>や<code>alignment</code>の結果が変わることがない）</small>ので、第一引数の<code>a</code>は、単に「この型の<code>sizeOf</code>を呼んでくださいね」という<strong>型の</strong>情報を渡すためのものでしかないからです。だから値には関心がないので<code>undefined</code>を渡しているわけです。そもそも、<code>alloca</code>関数のように引数として<code>Storable a =&gt; a</code>型の値をとらない関数では、<code>a</code>型の値を用意することができませんし。</p>
<p>現代では通常、このように「値に関心がなく、何の型であるかという情報だけを受け取りたい」という場合は、<a href="https://downloads.haskell.org/~ghc/8.10.1/docs/html/libraries/base-4.14.0.0/Data-Proxy.html#t:Proxy"><code>Proxy</code></a>型を使うのが一般的です。<code>Storable</code>は恐らく<code>Proxy</code>が発明される前に生まれたため、<code>undefined</code>を渡すことになってしまっているのでしょう。なので、<code>Storable</code>型クラスのインスタンスを自前で定義したりしない限り、こうしたケースに出遭うことはまれだと思います。ただ、それでも<code>Proxy</code>を<code>import</code>するのを面倒くさがって<code>undefined</code>を代わりに渡す、なんてケースはありえるので、<code>Proxy</code>を使って定義した型クラスでも同じ問題にハマることはあるかも知れません…。</p>
<p>⚠️結論として、<code>Storable</code>型クラスや、<code>Proxy</code>を受け取るメソッドを持つ型クラスのインスタンスを、<code>Strict</code>拡張を有効にした状態で定義する場合は、<code>Proxy</code>にあたる引数を評価しないよう、<code>~_</code>などを使って定義しましょう。</p>
<h1 id="おわりに-やっぱりstrictは使う使わない"><span class="link-to-here-outer"><a href="#おわりに-やっぱりstrictは使う使わない" title="おわりに-やっぱりstrictは使う使わない"><span class="link-to-here">Link to<br />
here</span></a></span>おわりに<span class="ascii">:</span> やっぱり<code>Strict</code>は使う？使わない？</h1>
<p>さて、ここまで<code>Strict</code>拡張を有効にすることによって犯しうる、数々のミスを紹介してきました。ここまで書いた個人的な印象としては、「敢えて有効にする必要はないんじゃないか」といったところです<small>（まぁ、悪いところばかり調べた結果のため、とてもフェアな視点での判断とは言えないのですが…）</small>。<code>foldr</code>の例でも触れたとおり、<span class="ascii">Haskell</span>には遅延評価を前提とした、遅延評価を存分に活かした機能が溢れています。当然それらは<code>Strict</code>拡張ができるよりはるか昔からあり、<code>Strict</code>拡張のことなど一切考えないで作られたものです。動的型付け言語に後から静的型検査を導入するのが大変なように、相対する機能を後付けすると衝突が起こるのは仕方のないことですが、こと<code>Strict</code>拡張については想像以上に大きな衝突のようです😞。</p>
<p>それでも使いたいという方に、今回の記事が助けになれば幸いです💪それでは<code>Strict</code>な方も<code>NoStrict</code>な方も<span class="ascii">Happy Haskell Hacking!!</span></p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>例えば<span class="ascii">fumieval</span>さんによる<a href="http://fumieval.hatenablog.com/entry/2015/12/10/200630">この記事</a>より<span class="ascii">:</span> 「もっとも、日常ではここまで気にしなければいけない場面は少ないので、ほとんどの場合は気にせず感嘆符をつけて大丈夫だろう。<span class="ascii">GHC 8.0</span>からは、全フィールドをデフォルトで正格にする<code>StrictData</code>という拡張が入るため、こちらを使おう」<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p><code>BangPatterns</code>言語拡張を有効にした上で上記のように書き換えてみると、<code>Strict</code>拡張の有無に関わらずエラーが発生します。試してみましょう。<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>実際のところ今回紹介するケース以外にも、ポイントフリースタイルにするかしないかで実行効率などが変わる場合があります。例えば、<a href="https://treszkai.github.io/2019/07/13/haskell-eval"><span class="ascii">Evaluation of function calls in Haskell</span></a>をご覧ください。<a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p>もっとも、この例では引数はリストでしょうから、<span class="ascii">WHNF</span>までのみ正格評価するメリットは少なそうですが。<a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p>大きなリストにすると、今度はエラーが発生するまでに時間がかかってしまうので…。ちなみに、このようにスタック領域を小さくすることでスペースリークを検出する手法は、<a href="https://github.com/ndmitchell/spaceleak"><span class="ascii">ndmitchell/spaceleak: Notes on space leaks</span></a>でも紹介されています。<a href="#fnref5" class="footnote-back">↩</a></p></li>
<li id="fn6"><p><span class="ascii">GHC</span>がどのように評価し、スタック領域を消費するかは<a href="https://takenobu-hs.github.io/downloads/haskell_ghc_illustrated.pdf"><span class="ascii">GHC illustrated</span></a>や、その参考文献をご覧ください。<a href="#fnref6" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2020/how-to-use-type-newtype-data.html" lang="ja">data / newtype / type の使い方</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2020/haskell-casually-at-work.html" style="margin-left: auto;" lang="ja">Haskellを業務で使う、カジュアルに</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>Haskellを業務で使う、カジュアルに</title>
    <link href="https://haskell.jp/blog/posts/2020/haskell-casually-at-work.html" />
    <id>https://haskell.jp/blog/posts/2020/haskell-casually-at-work.html</id>
    <published>2020-04-26T00:00:00Z</published>
    <updated>2020-04-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#はじめに" title="はじめに">はじめに</a></li>
<li><a href="#作業の支援加速にhaskellを使う" title="作業の支援加速にhaskellを使う">🔧「作業」の支援・加速に、<span class="ascii">Haskell</span>を使う</a>
<ul>
<li><a href="#テストデータ生成" title="テストデータ生成">テストデータ生成</a></li>
<li><a href="#パーサー" title="パーサー">パーサー</a></li>
<li><a href="#階層データ処理" title="階層データ処理">階層データ処理</a></li>
<li><a href="#高機能電卓" title="高機能電卓">高機能電卓</a></li>
<li><a href="#その他" title="その他">その他</a></li>
</ul></li>
<li><a href="#思考の支援加速にhaskellを使う" title="思考の支援加速にhaskellを使う">💡「思考」の支援・加速に、<span class="ascii">Haskell</span>を使う</a>
<ul>
<li><a href="#仕様理解" title="仕様理解">仕様理解</a></li>
<li><a href="#モデル確認" title="モデル確認">モデル確認</a></li>
<li><a href="#モデル探索" title="モデル探索">モデル探索</a></li>
<li><a href="#その他-1" title="その他-1">その他</a></li>
</ul></li>
<li><a href="#おわりに" title="おわりに">おわりに</a></li>
</ul>
</div>
</div>
<h1 id="はじめに"><span class="link-to-here-outer"><a href="#はじめに" title="はじめに"><span class="link-to-here">Link to<br />
here</span></a></span>はじめに</h1>
<p>この記事では、<span class="ascii">Haskell</span>を業務でカジュアルに使う観点やヒントについて、簡単に紹介します。</p>
<p><span class="ascii">Haskell</span>を業務で使える局面は、以下のようにいくつか考えられます。</p>
<ol type="1">
<li>「プロダクト」の開発用言語として、<span class="ascii">Haskell</span>を使う</li>
<li>「作業」の支援・加速用に、<span class="ascii">Haskell</span>を使う</li>
<li>「思考」の支援・加速用に、<span class="ascii">Haskell</span>を使う</li>
</ol>
<p>つまり、プロダクトの開発用言語として<span class="ascii">Haskell</span>を用いない業務形態においても、上記<span class="ascii">2</span>や<span class="ascii">3</span>のケースとして、<span class="ascii">Haskell</span>を使用できます。すなわち、<span class="ascii">Haskell</span>は幅広い局面でカジュアルに、つまり気軽に手軽に使用できます。</p>
<p>本記事では、特に、上記の<span class="ascii">2</span>と<span class="ascii">3</span>について、いくつかの観点やヒントや例を紹介します。</p>
<p>なお、上記は、<span class="ascii">Haskell</span>を用いる場合には限りません。<span class="ascii">Python, Perl, Ruby, Rust, Scala, OCaml, Clojure, Go, Elixir,</span> … といった、様々なプログラミング言語に置き換えて本記事を解釈してもらって構いません。</p>
<hr />
<h1 id="作業の支援加速にhaskellを使う"><span class="link-to-here-outer"><a href="#作業の支援加速にhaskellを使う" title="作業の支援加速にhaskellを使う"><span class="link-to-here">Link to<br />
here</span></a></span>🔧「作業」の支援・加速に、<span class="ascii">Haskell</span>を使う</h1>
<p><span class="ascii">Haskell</span>（を含むプログラミング言語）は、開発などの日常業務において、「作業」の支援・加速用に使うことが出来ます。</p>
<p>つまり、電卓や<span class="ascii">Excel</span>などのように、<span class="ascii">Haskell</span>を日常ツールの一つとして使えます。</p>
<p>特に、直近の業務作業を加速するために、書き捨てのツールを高品質で素早く欲しい場合や、ちょっとした対話ツールを欲しい場合などにも、<span class="ascii">Haskell</span>を便利に活用できます。</p>
<p>例えば具体的には、以下の場合に<span class="ascii">Haskell</span>を便利に使えます。</p>
<ul>
<li>テストデータ生成</li>
<li>パーサー</li>
<li>階層データ処理</li>
<li>高機能電卓</li>
</ul>
<p>以下、それぞれについて簡単に紹介します。</p>
<h2 id="テストデータ生成"><span class="link-to-here-outer"><a href="#テストデータ生成" title="テストデータ生成"><span class="link-to-here">Link to<br />
here</span></a></span>テストデータ生成</h2>
<p>例えば、解析事案が発生し、至急<span class="ascii">10</span>分程度でテストデータを複数用意したい、というような場合に、<span class="ascii">Haskell</span>でデータを生成させることは有効です。</p>
<p><span class="ascii">Haskell</span>は、関数合成や部分適用や高階関数や多相関数などの言語的な特徴により、小さな関数を組み合わせて、より大きな関数として作り上げることが容易です。</p>
<p>対話環境（<span class="ascii">REPL</span>）である<span class="ascii">GHCi</span>を用いて、それら小さな関数を素早く高品質に確認した上で、徐々に大きな関数として組み合わせることにより、高品質な結果を素早く得ることがでできます。</p>
<p>特にバイナリデータや複雑なデータを、一刻も早く高品質に生成することが重要な局面で、<span class="ascii">Haskell</span>は威力を発揮します。</p>
<h2 id="パーサー"><span class="link-to-here-outer"><a href="#パーサー" title="パーサー"><span class="link-to-here">Link to<br />
here</span></a></span>パーサー</h2>
<p>日常業務において、各種ログなどのデータを解析したい局面は頻繁に有ります。 単純なデータであれば、<span class="ascii">grep</span>コマンドや<span class="ascii">Perl</span>などの正規表現を用いて手早く仕事を済ませることも出来ます。</p>
<p>しかし、データの構造が複雑であったり再帰的な構造である場合には、正規表現をデバッグするよりも、<span class="ascii">Haskell</span>で思い切ってパーサーを書いてしまう方が手早く済ませられることがあります。</p>
<p><span class="ascii">Haskell</span>では、関数の組み立てが容易であることや<span class="ascii">do</span>記法といった言語的な特徴を活かし、簡潔にパーサーを記述することができます。 言語的な特徴を活かした便利なパーサーコンビネータ関連のライブラリ（<a href="https://hackage.haskell.org/package/parsec"><code>Parsec</code></a>や<a href="https://hackage.haskell.org/package/megaparsec"><code>Megaparsec</code></a>や<a href="https://hackage.haskell.org/package/replace-attoparsec"><code>replace-attoparsec</code></a>など）が豊富に存在します。</p>
<p>一度パーサーの骨格を用意してしまえば、流用は容易であるため、強力な日常ツールとして<span class="ascii">Haskell</span>を便利に使用できます。</p>
<h2 id="階層データ処理"><span class="link-to-here-outer"><a href="#階層データ処理" title="階層データ処理"><span class="link-to-here">Link to<br />
here</span></a></span>階層データ処理</h2>
<p>例えばモジュールの構造に対応したデータのように、データが再帰的・階層的に表現されている場合は多くあります。</p>
<p><span class="ascii">Haskell</span>は、代数的データ型を用いて再帰的なデータ構造を簡潔に表現できます。また、簡潔なパターンマッチの記法と再帰的な関数により、これらの処理を容易に記述できる傾向にあります。</p>
<p>もちろん、この再帰的なデータ構造も、コンパイル時の静的な型チェックの対象となるため、多くの不用意なミスを事前に抽出できます。</p>
<p>素早く、非常に高品質にデータ処理を行うことが重要な局面で、<span class="ascii">Haskell</span>は有効に機能します。</p>
<h2 id="高機能電卓"><span class="link-to-here-outer"><a href="#高機能電卓" title="高機能電卓"><span class="link-to-here">Link to<br />
here</span></a></span>高機能電卓</h2>
<p>日常業務において、なんらかの変換テーブルや、計算式、定数値などの値を、散発的に直ちに得たい局面があります。 その都度、電卓で計算したり、<span class="ascii">Excel</span>などの計算フォームを用意することで、手軽に業務を済ませられる場合もあります。</p>
<p>しかし、繰り返し必要となる計算式や、ある程度複雑な計算であれば、これらの計算式などを、<span class="ascii">Haskell</span>の関数群として定義しておき、対話環境<span class="ascii">GHCi</span>から用いることで、使い勝手良く素早く値を得ることができます。</p>
<p>数値や対話操作などを補助する便利なライブラリ<span class="ascii">(</span><a href="https://hackage.haskell.org/package/base/docs/Numeric.html"><code>Numeric</code></a>や<a href="https://hackage.haskell.org/package/base/docs/Data-Bits.html"><code>Data.Bits</code></a>や<a href="http://hackage.haskell.org/package/ghci-hexcalc/docs/Data-GHex.html"><code>Data.GHex</code></a><span class="ascii">)</span>や言語拡張<span class="ascii">(</span><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#binary-integer-literals"><code>BinaryLiterals</code></a>や<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#numeric-underscores"><code>NumericUnderscores</code></a><span class="ascii">)</span>などが豊富に存在します。</p>
<p><span class="ascii">Haskell</span>における関数の組み立てが容易な特徴は、対話環境における対話的な操作との相性が良いため、試行錯誤的な計算作業にも有用です。</p>
<h2 id="その他"><span class="link-to-here-outer"><a href="#その他" title="その他"><span class="link-to-here">Link to<br />
here</span></a></span>その他</h2>
<p>他にも、定型的なファイル処理や<span class="ascii">CLI</span>コマンドや<span class="ascii">DSL</span>の構築などを、<span class="ascii">Haskell</span>を用いて便利に実現出来ます。 手元に各種雛形を蓄積していると、作業の素早さと正確さが求められる場合に、有益でしょう。</p>
<p>もちろん、これらは<span class="ascii">Haskell</span>に限らず、多くのプログラミング言語にも言えます。</p>
<p><span class="ascii">Haskell</span>は、型システムに守られながら、関数を容易に組み立てられる特徴を持ちます。また、代数的データ型とパターンマッチの特徴により、直感的・シンプルで高品質なデータ表現・処理が可能です。さらに、<span class="ascii">GHCi</span>を用いる対話操作により、日常作業を高品質かつ手早く行えます。</p>
<p><span class="ascii">Haskell</span>は、（型システムの高度な機能などを使わない）基本的な機能のみにおいても、日常業務において有効に活用できるツールの一つです。</p>
<hr />
<h1 id="思考の支援加速にhaskellを使う"><span class="link-to-here-outer"><a href="#思考の支援加速にhaskellを使う" title="思考の支援加速にhaskellを使う"><span class="link-to-here">Link to<br />
here</span></a></span>💡「思考」の支援・加速に、<span class="ascii">Haskell</span>を使う</h1>
<p><span class="ascii">Haskell</span>（を含むプログラミング言語）は、開発などの日常業務において、「思考」の支援・加速用にも使うことが出来ます。</p>
<p>つまり、紙と鉛筆などのように、<span class="ascii">Haskell</span>を思考ツールの一つとして使えます。</p>
<p>特に、試行錯誤的な思考フェーズや、探索フェーズにおいて、思考を整理・加速する場合などに、<span class="ascii">Haskell</span>は便利です。</p>
<p>例えば具体的には、以下の場合に<span class="ascii">Haskell</span>を便利に使えます。</p>
<ul>
<li>仕様理解</li>
<li>モデル確認</li>
<li>モデル探索</li>
</ul>
<p>以下、それぞれについて簡単に紹介します。</p>
<h2 id="仕様理解"><span class="link-to-here-outer"><a href="#仕様理解" title="仕様理解"><span class="link-to-here">Link to<br />
here</span></a></span>仕様理解</h2>
<p>ハードウェアやソフトウェア開発過程などでは、例えば、自然言語と図表や式の組み合わせで表現された仕様書を理解する事が必要な局面が多くあります。</p>
<p>設計の上流工程で思考を広く深く及ばせておくことにより、仕様に対する思わぬ考え漏れや勘違いを防ぐことは、開発全体の質や開発速度を上げる観点で非常に有効です。</p>
<p><span class="ascii">Haskell</span>は、代数的データ型やパターンマッチを簡潔に記述できる言語的な特徴を持つため、仕様を簡潔に表現することに向いています。さらに、対話環境<span class="ascii">GHCi</span>を用いて、自分の考えを試行錯誤的に確認できます。</p>
<p>自然言語等の仕様を、プログラミング言語を用いて表現・写経する過程は、単純ですが、対象への理解を深める上で、意外に大きな投資対効果があります。<span class="ascii">Haskell</span>は、このような場合に強力なツールとなります。</p>
<h2 id="モデル確認"><span class="link-to-here-outer"><a href="#モデル確認" title="モデル確認"><span class="link-to-here">Link to<br />
here</span></a></span>モデル確認</h2>
<p>設計の初期段階において、自分の考えミスを抽出するために、設計の中核部分を簡単なモデルで表現して確認することは、開発全体の質や開発速度を上げる観点で非常に有効です。</p>
<p>前節の仕様理解の場合と同様に、設計の中核モデルを簡潔に記述する目的で、<span class="ascii">Haskell</span>を用いることが出来る場合があります。</p>
<p><span class="ascii">Haskell</span>の代数的データ型とパターンマッチは、モデルの簡潔表現にもフィットする場合が多く、自分の考えを手早く確認することに有効に使用できます。</p>
<p>さらに、<span class="ascii">Haskell</span>で記述したモデルを、<a href="https://hackage.haskell.org/package/QuickCheck"><code>QuickCheck</code></a>ライブラリなどによるランダムテストパターンを用いて簡易検査することにより、値の範囲や特性に対する考え不足を、容赦なく効率的に抽出できます。</p>
<h2 id="モデル探索"><span class="link-to-here-outer"><a href="#モデル探索" title="モデル探索"><span class="link-to-here">Link to<br />
here</span></a></span>モデル探索</h2>
<p>設計の初期段階において、モデルのパラメータなどについての設計空間を、試行錯誤しながら探索したい局面があります。</p>
<p>前節のモデル理解の場合と同様に、設計空間を探索する目的で、<span class="ascii">Haskell</span>を用いることが出来る場合があります。</p>
<p><span class="ascii">Haskell</span>の代数的データ型とパターンマッチを用いてモデルを簡潔に記述できれば、系の大きさなどの多くのパラメータを振りながら、最適な設計値を探索することに活用できます。</p>
<h2 id="その他-1"><span class="link-to-here-outer"><a href="#その他-1" title="その他-1"><span class="link-to-here">Link to<br />
here</span></a></span>その他</h2>
<p>思考フェーズでは、記述したプログラムの実行速度よりも、思考内容をコードで表現する速さや、試行錯誤的にコードの内容を確認・変更する速さの方が重要なことが有ります。</p>
<p>各々の人の思考特性によりますが、<span class="ascii">Haskell</span>の代数的データ型とパターンマッチなどの言語的な特徴は、実行可能仕様書・実行可能思考表現として、思考を整理することに向いています。</p>
<p>以下のように、<span class="ascii">Haskell</span>を用いて、簡潔に、素早く、手軽に、思考作業を支援・加速できます。</p>
<ul>
<li>モデルなどの思考を、代数的データ型で直感的・簡潔に記述する</li>
<li>処理をパターンマッチを用いて簡潔に記述する</li>
<li>対話環境<span class="ascii">GHCi</span>で、挙動と思考を手早く試行錯誤的に確認する</li>
</ul>
<p>便利ですね。</p>
<hr />
<h1 id="おわりに"><span class="link-to-here-outer"><a href="#おわりに" title="おわりに"><span class="link-to-here">Link to<br />
here</span></a></span>おわりに</h1>
<p>この記事では、<span class="ascii">Haskell</span>を業務でカジュアルに使う観点やヒントについて紹介しました。 「作業」や「思考」が必要な、よりたくさんの局面で<span class="ascii">Haskell</span>を使用できます。</p>
<p>関数合成、部分適用、高階関数、多相関数などの言語的な特徴は、関数をボトムアップや対話的に、素早くかつ高品質に組み上げるのに便利です。代数的データ型などの言語的な特徴は、ある種の思考パターン（選択、非一様、入れ子など）をストレートに表現するのに便利です。対話環境<span class="ascii">GHCi</span>は、試行錯誤的に作業や思考を進めるのに便利です。</p>
<p><span class="ascii">Haskell</span>に限らず、自分の思考特性にあったプログラミング言語を、業務を加速する日常的なツールとして備えておくことは有用です。</p>
<p>しかし、そもそもプログラミング言語の可能性・適用範囲は非常に広いものです。その適用範囲を、「業務」に狭めてしまう必要もありません。</p>
<p>プログラミング言語は、業務のみに限らず、日々の「思考」の支援・加速に広く使用できるものです。</p>
<p>以上、 <span class="ascii">Enjoy programming</span>！</p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2020/strict-gotchas.html" lang="ja">Strict拡張を使用する際の注意点</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2020/io-monad-and-sideeffect.html" style="margin-left: auto;" lang="ja">IO モナドと副作用</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>IO モナドと副作用</title>
    <link href="https://haskell.jp/blog/posts/2020/io-monad-and-sideeffect.html" />
    <id>https://haskell.jp/blog/posts/2020/io-monad-and-sideeffect.html</id>
    <published>2020-04-05T00:00:00Z</published>
    <updated>2020-04-05T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p><span class="ascii">Haskell</span> は他のプログラミング言語には見られない特徴を多く持っている。その中の<span class="ascii">1</span>つが純粋性だ。<span class="ascii">Haskell</span> は純粋関数型プログラミング言語であることを、売りの<span class="ascii">1</span>つにしている。しかし、純粋性は多くの場合表現力の縮小を招く。ところが <span class="ascii">Haskell</span> は、<span class="ascii">IO</span>モナドの導入により、通常のプログラミング言語と変わらぬ表現力を持てるようになっている。これは、とても驚くべきことだ。しかし、同時にこれは <span class="ascii">Haskell</span> 入門者にとって、大きな混乱を招いているようだ。</p>
<p>今回は、そもそも純粋性とはなんなのか、なぜ他の言語は純粋性を担保できないのか、そして <span class="ascii">Haskell</span> はどうやって <span class="ascii">IO</span> モナドにより純粋性を担保しつつ他の言語と変わらない表現力を持てるようにしているのかについて、触れていきたいと思う。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#純粋性とは何か" title="純粋性とは何か">純粋性とは何か</a></li>
<li><a href="#動作を扱う関数" title="動作を扱う関数">動作を扱う関数</a></li>
<li><a href="#io-モナド" title="io-モナド"><span class="ascii">IO</span> モナド</a></li>
<li><a href="#動作を第一級で取り扱う" title="動作を第一級で取り扱う">動作を第一級で取り扱う</a></li>
<li><a href="#まとめ" title="まとめ">まとめ</a></li>
<li><a href="#おまけ-ioモナドの実装" title="おまけ-ioモナドの実装">おまけ<span class="ascii">: IO</span>モナドの実装</a></li>
</ul>
</div>
</div>
<h2 id="純粋性とは何か"><span class="link-to-here-outer"><a href="#純粋性とは何か" title="純粋性とは何か"><span class="link-to-here">Link to<br />
here</span></a></span>純粋性とは何か</h2>
<p><span class="ascii">Haskell</span> は純粋関数型プログラミング言語 <span class="ascii">(purely functional programming language)</span> を売りにしている。関数型 <span class="ascii">(functional)</span> の部分は他に任せるとして、ここでは<strong>純粋 <span class="ascii">(purely)</span></strong> の部分に着目しよう。純粋とはなんだろうか？ どういう条件を満たせば、プログラミング言語は純粋と言えるんだろうか？ <a href="https://www.haskell.org/"><span class="ascii">Haskell</span> の公式サイト</a> ではこう述べられている<span class="ascii">:</span></p>
<blockquote>
<p><span class="ascii">Every function in Haskell is a function in the mathematical sense (i.e.,</span> “<span class="ascii">pure</span>”<span class="ascii">).</span></p>
<p><span class="ascii">Haskell</span> の全ての関数は、数学の意味での関数 <span class="ascii">(</span>つまり「純粋」<span class="ascii">)</span> です。</p>
<p>– <a href="https://www.haskell.org/"><span class="ascii">haskell.org</span></a> <span class="ascii">Features: Purely functional</span> より</p>
</blockquote>
<p>ふむ、どうやら全ての関数が、数学的な意味での関数であれば、そのプログラミング言語は純粋と言えるようだ。ところで、数学的な意味での関数とはなんだろうか？ 関数が純粋とはどういうことを指すんだろうか？ これは噛み砕くと、</p>
<ol type="1">
<li><p>関数はどんな時も、同じ引数を与えられたら同じ結果を返す</p>
<p>つまり、関数は毎回まっさらな状態で始まり、前にどんなことがあったのか、今巷でどういうことが起きてるのかを全く考慮に入れず、ただ受け取った引数から得られる情報だけを使って結果を計算する。</p></li>
<li><p>関数は、副作用を持たない</p>
<p>つまり、関数は計算の結果を返す以外の役割を持たない。例えば、関数を<span class="ascii">1</span>回呼び出すのと、関数を<span class="ascii">1</span>回呼び出してその結果を捨てまたもう<span class="ascii">1</span>回呼び出すので結果が変わることはない。</p></li>
</ol>
<p>という<span class="ascii">2</span>つの性質にまとめられる <a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>。具体的には、関数 <code>f</code> が、</p>
<ul>
<li><span class="ascii">1</span>回目の <code>f 1</code> では <code>2</code> を返し、<span class="ascii">2</span>回目の <code>f 1</code> では <code>3</code> を返す</li>
</ul>
<p>という動作をするなら、これは <span class="ascii">1</span> の条件にも <span class="ascii">2</span> の条件にも違反することになる。では、関数 <code>printString</code> が</p>
<ul>
<li>受け取った文字列をターミナルに出力し、<code>()</code> を結果として返す</li>
</ul>
<p>ことを考えよう。関数 <code>printString</code> は常に <code>()</code> を返すので <span class="ascii">1</span> の条件にはマッチする。しかし、この関数は、与えられた文字列をターミナルに出力するので、<span class="ascii">1</span>回呼び出すか<span class="ascii">2</span>回呼び出すかは重要な違いになる。よって、<span class="ascii">2</span> 番目の条件を満たさないため、純粋ではない。逆に、関数 <code>getNowYear</code> が、</p>
<ul>
<li>完全に副作用を持たず、何回呼び出しても他には何の影響もないが、今の年数を返す関数で、年が変わるごとに結果が変わる</li>
</ul>
<p>となると <span class="ascii">1</span> の条件に違反するため、やはり純粋ではない。関数が純粋になるためには、何の面白味もないかもしれないが、<span class="ascii">1</span> と <span class="ascii">2</span> の条件を守らないといけない。決して夕日が沈むと突然結果を出さなくなったり、関数を呼ぶ度に近所の犬が吠えたり静かになったりしてはいけない。</p>
<p>さて、このような定義なら、多くのプログラミング言語の関数が純粋性を持たないのは納得できるだろう。同じ引数でも呼ぶタイミングによって結果が変わる関数、関数を呼ぶと全く予期しなかったスイッチが作動し、別の関数の結果が突然変わるようなプログラムを思いつく人は少なくないはずだ。ただ、その人たちは同時にこうも思うだろう。</p>
<blockquote>
<p>そのような関数はプログラミングでは必要不可欠だ。<span class="ascii">Haskell</span> はその必要不可欠な関数を、純粋性のためだけに書けないようにしてるのだろうか？</p>
</blockquote>
<p>その疑問は至極妥当で、当然のものだ。そして安心して欲しい。その質問に対する答えは <span class="ascii">NO</span> だ。<span class="ascii">Haskell</span> は純粋性を保ちながら、そのような必要不可欠な関数を表現する方法を持っている。</p>
<h2 id="動作を扱う関数"><span class="link-to-here-outer"><a href="#動作を扱う関数" title="動作を扱う関数"><span class="link-to-here">Link to<br />
here</span></a></span>動作を扱う関数</h2>
<p><span class="ascii">Haskell</span> には、ターミナルに出力する動作を扱う関数や、ターミナルへの入力を受け取る動作を扱う関数が存在する。これは、どうも先ほどまでの純粋性の定義とは相容れないように見える。<span class="ascii">Haskell</span> の純粋関数型プログラミング言語という性質は、そのような関数を除いては純粋という意味なんだろうか？ それなら他のプログラミング言語でも事情は変わらない。ところが、<span class="ascii">Haskell</span> はそのような関数まで純粋なのだ。そのカラクリについて、見ていこう。</p>
<p><span class="ascii">Haskell</span> でターミナルに文字列を <span class="ascii">(</span>改行付きで<span class="ascii">)</span> 出力する動作を扱う関数として、<code>putStrLn</code> という関数がある。これを題材として扱っていこう。この関数はどういう型を持っているのだろう？ もし、</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="fu">putStrLn</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> ()</a></code></pre></div>
<p>という型になっていたら、この場合は文字列を受け取り <code>()</code> 型の値を返す関数になる。<code>()</code> 型は次のように定義される <a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a><span class="ascii">:</span></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">data</span> () <span class="ot">=</span> ()</a></code></pre></div>
<p>つまり、<code>()</code> というたった一つの値を持つ型になる。なので、<code>putStrLn</code> が <code>putStrLn :: String -&gt; ()</code> という型を持っていた場合は、常に <code>()</code> という値を返す関数となり、純粋性の <span class="ascii">1</span> 番目の条件を満たす。しかし、<code>putStrLn</code> は呼び出し回数に応じて文字列をターミナルに出力していくので、副作用を持ち、<span class="ascii">2</span> 番目の条件には到底当てはまらない。では、<span class="ascii">2</span> 番目の条件に当てはまるようにするにはどうすればいいだろう？ そのような選択肢は到底ないように見える。</p>
<p>実際には、<span class="ascii">Haskell</span> の <code>putStrLn</code> は</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="fu">putStrLn</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a></code></pre></div>
<p>という型を持つ。つまり、返る値は <code>IO ()</code> という不思議な型を持つ。こうすると純粋に文字列をターミナルに出力できるんだろうか？ 答えは <span class="ascii">NO</span> だ。<span class="ascii">Haskell</span> の <code>putStrLn</code> 関数は、</p>
<ul>
<li>受け取った文字列をターミナルに出力する</li>
</ul>
<p>関数ではない。<span class="ascii">Haskell</span> は、到底純粋性を持たないような操作をする関数を、そもそも関数の見方を変えて提供することで純粋性を保っている。この関数 <code>putStrLn</code> は</p>
<ul>
<li>受け取った文字列から、「ターミナルにその文字列を出力する動作」を返す</li>
</ul>
<p>関数だ。そして、「ターミナルにその文字列を出力する動作」は <code>IO ()</code> という型を持つ。動作 <span class="ascii">(action)</span> とは、文字通り「何をするか」 <a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a> を表す。<code>IO a</code> は、</p>
<ul>
<li>動作、つまり「何をするか」を表す値を持つ</li>
<li>その動作をした結果、得られる値の型が <code>a</code> であることを表す</li>
</ul>
<p>型だ。抽象的すぎてあまりピンとこないかもしれない。もし、その動作が結果を返す以外に何もしないなら、それは純粋な操作であるから、次のように書ける<span class="ascii">:</span></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">data</span> <span class="dt">PureAction</span> a <span class="ot">=</span> <span class="dt">PureAction</span> (() <span class="ot">-&gt;</span> a)</a></code></pre></div>
<p>つまり、引数が何もない純粋関数だ。例えば、整数を<span class="ascii">2</span>つ受け取って、その和を計算する動作を返す関数は次のように書けるだろう<span class="ascii">:</span></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="ot">addAction ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">PureAction</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-2" title="2">addAction x y <span class="ot">=</span> <span class="dt">PureAction</span> (\_ <span class="ot">-&gt;</span> x <span class="op">+</span> y)</a></code></pre></div>
<p><code>putStrLn</code> も <code>addAction</code> と同じように、値そのものではなくその値を計算する<strong>動作</strong>それ自体を返す。ただ、<code>putStrLn</code> が返す <code>IO</code> の動作は、<code>PureAction</code> の動作よりもっと一般的なものだ。つまり、純粋な動作ではないかもしれないということだ。もしかしたらそれは、今の時刻で結果を変えるかもしれないし、結果は常に変わらなくても何回呼び出すかでターミナルに表示する文字を変えるかもしれない。つまり、完全に純粋な関数では表せないかもしれない。でも、動作自体は不変的だ。<code>putStrLn "str"</code> は</p>
<ul>
<li>ターミナルに <code>"str"</code> を出力する動作</li>
</ul>
<p>を表す。これが、<span class="ascii">10</span>時にはこういう動作を返してきたのが、<span class="ascii">12</span>時には</p>
<ul>
<li>ターミナルに <code>"str"</code> を出力し、お昼の鐘を鳴らす動作</li>
</ul>
<p>を返すようになるということはないし、この動作を返す以外に</p>
<ul>
<li>勝手にターミナルに文字列を出力する</li>
</ul>
<p>ということもない。例えば、<span class="ascii">GHCi</span> で以下のようなプログラムの出力を見てみよう<span class="ascii">:</span></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">let</span> _ <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="st">&quot;str&quot;</span> <span class="kw">in</span> ()</a>
<a class="sourceLine" id="cb6-2" title="2">()</a></code></pre></div>
<p>これは</p>
<ol type="1">
<li><code>putStrLn "str"</code> を計算し、</li>
<li>結果を捨て</li>
<li><code>()</code> を返す</li>
</ol>
<p>というプログラムだ。このプログラムを評価しても、<code>()</code> だけしか目にしないはずで、何回実行しても同じ結果が得られるはずだ。つまり、<code>putStrLn</code> は余計なことを何もしていないと言えるだろう。そう説明すると、ちょっと <span class="ascii">Haskell</span> をかじった人は</p>
<blockquote>
<p>この説明は間違っている。この式は <code>putStrLn "str"</code> を全く評価していないので、実際に <code>putStrLn "str"</code> が余計なことを何もしていないかは分からない</p>
</blockquote>
<p>と言うだろう。その通りだ。この説明は間違っている。それを確認してみよう<span class="ascii">:</span></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">let</span> _ <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;something happened!&quot;</span> <span class="kw">in</span> ()</a>
<a class="sourceLine" id="cb7-2" title="2">()</a></code></pre></div>
<p>もし、さっきの <code>putStrLn "str"</code> がちゃんと計算されていたなら、今回は <code>something happened!</code> というエラーが見れるはずだ。ところが、全く何の問題もなく式の実行は終わり、<code>()</code> が出力されてしまった。<span class="ascii">Haskell</span> は遅延評価により、最終結果に本当に必要な部分しか計算してくれないので、<code>putStrLn "str"</code> の部分は計算されず無視されてしまっていただけのようだ。では、ちゃんと修正してみよう。修正は、<code>seq</code> という魔法の関数を使うことで可能だ。<code>seq :: a -&gt; b -&gt; b</code> は一番最初に渡された引数を <span class="ascii">(</span>必要かどうかに関わらず、強制的に<span class="ascii">)</span> 計算し、その後<span class="ascii">2</span>番目の引数を返す関数だ。この関数を使うと、次のように修正が可能だ<span class="ascii">:</span></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="fu">putStrLn</span> <span class="st">&quot;str&quot;</span> <span class="ot">`seq`</span> ()</a>
<a class="sourceLine" id="cb8-2" title="2">()</a>
<a class="sourceLine" id="cb8-3" title="3"><span class="op">&gt;&gt;&gt;</span> <span class="fu">error</span> <span class="st">&quot;something happened!&quot;</span> <span class="ot">`seq`</span> ()</a>
<a class="sourceLine" id="cb8-4" title="4"><span class="op">***</span> <span class="dt">Exception</span><span class="op">:</span> something happened<span class="op">!</span></a></code></pre></div>
<p>今度は大丈夫だろう。<code>putStrLn "str"</code> の部分をエラーに変えると、ちゃんとエラーが出力されている。<code>putStrLn "str"</code> は計算されているようだ。そう、<code>putStrLn "str"</code> が実行されて実際に行われるのは、その定義通り</p>
<ul>
<li>「ターミナルに <code>"str"</code> を出力する動作」を返す</li>
</ul>
<p>ということだけで、他には何もしない。常に同じ動作を返すし、副作用を起こしたりもしない。これは純粋関数の定義に当てはまっている。<code>putStrLn</code> は純粋な関数なのだ。そして、その動作には、動作の結果の型によって型が決まっていて、それが <code>IO</code> 型ということになる。</p>
<blockquote>
<p>では、実際に <code>putStrLn</code> はどういう定義になるんだろう？ その定義は純粋な枠組みで定義できるんだろうか？</p>
</blockquote>
<p>と疑問を持つ人はいるかもしれない。その疑問はとても良いところをついている。そう、<code>putStrLn</code> は、<span class="ascii">Haskell</span> では定義できない。もしくは、定義するならば「文字列をターミナルに出力する動作」を表す値の作成方法を、何らかの仕組みで提供する必要がある。もし、</p>
<ul>
<li>「文字列 <code>s</code> をターミナルに出力する動作」を <code>PutStrLn s :: IO ()</code> と書ける</li>
</ul>
<p>なら、その時は、<code>putStrLn</code> を次のように定義できる<span class="ascii">:</span></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="fu">putStrLn</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb9-2" title="2"><span class="fu">putStrLn</span> s <span class="ot">=</span> <span class="dt">PutStrLn</span> s</a></code></pre></div>
<p>ただ、今度は <code>PutStrLn</code> を <span class="ascii">Haskell</span> で定義するにはどうすればいいのだろう？ という話になり、この話は延々と続くことになるだろう。現実世界の純粋なエミュレータを <span class="ascii">Haskell</span> 内部で実装すれば収束するかもしれない。しかし、私たちは、現実世界をコストなく扱いたいわけであり、純粋かどうかは重要なことではない。そして、別に <code>putStrLn</code> を <span class="ascii">Haskell</span> 内で純粋に定義したいのではなく、「文字列 <code>s</code> をターミナルに出力する動作」を扱いたいだけなのだ。なので、<span class="ascii">Haskell</span> は純粋な部分だけは目に見える範囲で提供し、非純粋な部分は隠蔽し、純粋に扱うことだけをできるようにしている。</p>
<p>では、実際にこの動作を実行したい時はどうすればいいんだろう？ <code>putStrLn "str"</code> が純粋に、「<code>"str"</code> をターミナルに出力する動作」を返してきて、それを純粋に扱うことしかできないとなると、実際にターミナルに出力することはできないのではないだろうか？ それもその通りだ。では、<span class="ascii">Haskell</span> ではその問題をどう解決するか。実は <span class="ascii">Haskell</span> の <code>main</code> プログラムは、<code>IO</code> 型の値で定義するようになっている。つまり、</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb10-2" title="2">main <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="st">&quot;str&quot;</span></a></code></pre></div>
<p>というように、<code>main</code> を何らかの <code>IO</code> 動作で定義する。そして、実際にこのプログラムからコンパイルされた実行ファイルは、定義された動作をそのまま行うようになっている。こうすることで、<span class="ascii">Haskell</span> は純粋性を保ちながら、非純粋な動作を扱えるようになっている。</p>
<h2 id="io-モナド"><span class="link-to-here-outer"><a href="#io-モナド" title="io-モナド"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">IO</span> モナド</h2>
<p><span class="ascii">Haskell</span> の <code>putStrLn</code> が純粋な理由は分かってもらえただろうか？ さて中には、</p>
<blockquote>
<p>主張は分かったが、純粋に扱うだけに制限するということは、普通のプログラミング言語より非純粋な動作を上手く扱えないんじゃないか</p>
</blockquote>
<p>と疑問に思う人もいるだろう。これも当然の疑問だ。普通のプログラミング言語は、表現力豊かで、様々な制御構文を持ち、それぞれの構文が純粋性に拘らないため、とてもユニークな非純粋なプログラムを書くことができる。ただ、安心して欲しい。<span class="ascii">Haskell</span> も、それに負けない表現力で、非純粋な動作を作成することができる。さて、<span class="ascii">Haskell</span> は、普通のプログラミング言語の機構の基盤は</p>
<ul>
<li><span class="ascii">2</span>つの動作を上手く結合できること</li>
</ul>
<p>ではないかと考えた。そして、このうまく結合する機構を、<code>IO</code> 動作の上で実現する方法を考えた。結果、<span class="ascii">Haskell</span> では<span class="ascii">2</span>つの特殊な操作が組み込まれている<span class="ascii">:</span></p>
<ul>
<li>純粋な計算を、<code>IO</code> 動作に変換する<span class="ascii">:</span> <code>pure :: a -&gt; IO a</code></li>
<li><span class="ascii">2</span>つの <code>IO</code> 動作を繋げる<span class="ascii">:</span> <code>(&gt;&gt;=) :: IO a -&gt; (a -&gt; IO b) -&gt; IO b</code></li>
</ul>
<p><code>(&gt;&gt;=)</code> については少し説明が必要だろう。<span class="ascii">2</span>つの <code>IO</code> 動作を繋げるというのは、<code>(&gt;&gt;=) :: IO a -&gt; IO b -&gt; IO b</code> となった方が自然そうである。しかし、普通のプログラミング言語は、</p>
<ul>
<li>前の動作の結果により、次に行う動作を変える <span class="ascii">(</span><code>if</code> 文や <code>while</code> 文など<span class="ascii">)</span></li>
</ul>
<p>ということが可能だ。そして、前の動作の結果は変数束縛などにより自由に参照できる。<span class="ascii">Haskell</span> は、<code>IO</code> 動作を純粋性により実際に実行することはできない。その代わり、上の動作の制御機構を、繋げる操作に組み入れることで代用しようとしたのだ。つまり、</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="ot">(&gt;&gt;=) ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> <span class="dt">IO</span> b</a></code></pre></div>
<p>の操作は、</p>
<ol type="1">
<li>最初に受け取った <code>IO</code> 動作を実行し、</li>
<li>その結果から、次に行う <code>IO</code> 動作を<strong>純粋に</strong>生成し、</li>
<li>生成された動作を行う</li>
</ol>
<p>という動作全体を表す <code>IO</code> 動作を生成する。この結果から次に行う <code>IO</code> 動作を生成する部分をうまく定義すれば、<code>(&gt;&gt;=)</code> によって様々な制御構文を模倣できるのではないかと考えたのだ。この仕組みはとても上手くいった。<span class="ascii">Haskell</span> では、非純粋な動作を<code>if</code> 文や <code>while</code> 文で任意に実行することを、次のような純粋に動作を切り替える関数で代用する<span class="ascii">:</span></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="ot">ifIO ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb12-2" title="2">ifIO b act1 act2 <span class="ot">=</span> <span class="kw">case</span> b <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-3" title="3">  <span class="dt">True</span>  <span class="ot">-&gt;</span> act1</a>
<a class="sourceLine" id="cb12-4" title="4">  <span class="dt">False</span> <span class="ot">-&gt;</span> act2</a>
<a class="sourceLine" id="cb12-5" title="5"></a>
<a class="sourceLine" id="cb12-6" title="6"><span class="ot">whileIO ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb12-7" title="7">whileIO isEnd x0 act <span class="ot">=</span> go x0 <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-8" title="8">  go x <span class="ot">=</span> ifIO (isEnd x)</a>
<a class="sourceLine" id="cb12-9" title="9">    (<span class="fu">pure</span> ())</a>
<a class="sourceLine" id="cb12-10" title="10">    (</a>
<a class="sourceLine" id="cb12-11" title="11">        act x <span class="op">&gt;&gt;=</span> \nx <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb12-12" title="12">        go nx</a>
<a class="sourceLine" id="cb12-13" title="13">    )</a></code></pre></div>
<p>これらの関数を使えば、</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb13-2" title="2">main <span class="ot">=</span></a>
<a class="sourceLine" id="cb13-3" title="3">  <span class="fu">getLine</span> <span class="op">&gt;&gt;=</span> \loopCmd <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb13-4" title="4">  ifIO (loopCmd <span class="op">/=</span> <span class="st">&quot;loop&quot;</span>)</a>
<a class="sourceLine" id="cb13-5" title="5">    (<span class="fu">putStrLn</span> <span class="st">&quot;No loop&quot;</span>)</a>
<a class="sourceLine" id="cb13-6" title="6">    (whileIO (\(b, _) <span class="ot">-&gt;</span> b) (<span class="dt">False</span>, <span class="dv">0</span>) (\(_, i) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb13-7" title="7">        <span class="fu">putStrLn</span> (<span class="st">&quot;loop &quot;</span> <span class="op">++</span> <span class="fu">show</span> i) <span class="op">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb13-8" title="8">        <span class="fu">getLine</span> <span class="op">&gt;&gt;=</span> \loopEndCmd <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb13-9" title="9">        ifIO (loopEndCmd <span class="op">==</span> <span class="st">&quot;end&quot;</span>)</a>
<a class="sourceLine" id="cb13-10" title="10">          (<span class="fu">pure</span> (<span class="dt">True</span>, i))</a>
<a class="sourceLine" id="cb13-11" title="11">          (<span class="fu">pure</span> (<span class="dt">False</span>, i <span class="op">+</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb13-12" title="12">    ))</a></code></pre></div>
<p>のようなプログラムが書ける。このプログラムは、</p>
<ol type="1">
<li>最初にターミナルへの入力を待ち、<code>loop</code> と打たれれば、ループに入る。それ以外の場合は <code>"No loop"</code> と出力し、プログラムを終了する。</li>
<li>今のループの回数を出力し、ターミナルへの入力を待つ。</li>
<li>ターミナルに <code>end</code> と打たれれば、プログラムを終了する。それ以外の場合、ループカウントを<span class="ascii">1</span>増加させて、<span class="ascii">2</span> に戻る。</li>
</ol>
<p>ということを行う。このように、純粋な範囲内で繋げる操作を工夫することで、普通のプログラミング言語の機構を <code>IO</code> 動作内に組み込めるようになっている。ただ、このプログラムは大変見にくい。なので、<span class="ascii">Haskell</span> はさらに、この繋げる操作を元に、次のような <span class="ascii">DSL</span> を提供している<span class="ascii">:</span></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb14-2" title="2">main <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb14-3" title="3">  loopCmd <span class="ot">&lt;-</span> <span class="fu">getLine</span></a>
<a class="sourceLine" id="cb14-4" title="4">  ifIO (loopCmd <span class="op">/=</span> <span class="st">&quot;loop&quot;</span>)</a>
<a class="sourceLine" id="cb14-5" title="5">    (<span class="fu">putStrLn</span> <span class="st">&quot;No loop&quot;</span>)</a>
<a class="sourceLine" id="cb14-6" title="6">    (whileIO (\(b, _) <span class="ot">-&gt;</span> b) (<span class="dt">False</span>, <span class="dv">0</span>) (\(_, i) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb14-7" title="7">        <span class="fu">putStrLn</span> (<span class="st">&quot;loop &quot;</span> <span class="op">++</span> <span class="fu">show</span> i)</a>
<a class="sourceLine" id="cb14-8" title="8">        loopEndCmd <span class="ot">&lt;-</span> <span class="fu">getLine</span></a>
<a class="sourceLine" id="cb14-9" title="9">        ifIO (loopEndCmd <span class="op">==</span> <span class="st">&quot;end&quot;</span>)</a>
<a class="sourceLine" id="cb14-10" title="10">          (<span class="fu">pure</span> (<span class="dt">True</span>, i))</a>
<a class="sourceLine" id="cb14-11" title="11">          (<span class="fu">pure</span> (<span class="dt">False</span>, i <span class="op">+</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb14-12" title="12">    ))</a></code></pre></div>
<p>少しは見やすくなっただろうか？ この操作は、そこまで特別な操作をしてるわけではない。インデントを解析して、</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb15-2" title="2">main <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb15-3" title="3">  x1 <span class="ot">&lt;-</span> e1</a>
<a class="sourceLine" id="cb15-4" title="4">  x2 <span class="ot">&lt;-</span> e2</a>
<a class="sourceLine" id="cb15-5" title="5">  e3</a></code></pre></div>
<p>というのを、</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb16-2" title="2">main <span class="ot">=</span></a>
<a class="sourceLine" id="cb16-3" title="3">  e1 <span class="op">&gt;&gt;=</span> \x1 <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-4" title="4">  x2 <span class="ot">&lt;-</span> e2</a>
<a class="sourceLine" id="cb16-5" title="5">  e3</a></code></pre></div>
<p>に変形して、さらに</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb17-2" title="2">main <span class="ot">=</span></a>
<a class="sourceLine" id="cb17-3" title="3">  e1 <span class="op">&gt;&gt;=</span> \x1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb17-4" title="4">  e2 <span class="op">&gt;&gt;=</span> \x2 <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb17-5" title="5">  e3</a></code></pre></div>
<p>と変形して、</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb18-2" title="2">main <span class="ot">=</span></a>
<a class="sourceLine" id="cb18-3" title="3">  e1 <span class="op">&gt;&gt;=</span> \x1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb18-4" title="4">  e2 <span class="op">&gt;&gt;=</span> \x2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb18-5" title="5">  e3</a></code></pre></div>
<p>と変形する、というように最初から<span class="ascii">1</span>行<span class="ascii">1</span>行変形して、<code>do</code> がなくなるまで変形を行うだけだ。つまり一行一行の動作を <code>(&gt;&gt;=)</code> で繋げていくのだ。なお、一番最後以外は <code>x &lt;- e</code> という形になっているのが基本で、もしそのような形になっていない <code>e</code> は、<code>_ &lt;- e</code> と変換される <a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a> 。なので、</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb19-2" title="2">main <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb19-3" title="3">  <span class="fu">putStrLn</span> <span class="st">&quot;str1&quot;</span></a>
<a class="sourceLine" id="cb19-4" title="4">  <span class="fu">putStrLn</span> <span class="st">&quot;str2&quot;</span></a></code></pre></div>
<p>は、</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb20-2" title="2">main <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb20-3" title="3">  _ <span class="ot">&lt;-</span> <span class="fu">putStrLn</span> <span class="st">&quot;str1&quot;</span></a>
<a class="sourceLine" id="cb20-4" title="4">  <span class="fu">putStrLn</span> <span class="st">&quot;str2&quot;</span></a></code></pre></div>
<p>と変換された後、先ほどの変換によって、</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb21-2" title="2">main <span class="ot">=</span></a>
<a class="sourceLine" id="cb21-3" title="3">  <span class="fu">putStrLn</span> <span class="st">&quot;str1&quot;</span> <span class="op">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb21-4" title="4">  <span class="fu">putStrLn</span> <span class="st">&quot;str2&quot;</span></a></code></pre></div>
<p>となる。このようにして、<span class="ascii">Haskell</span> は他のプログラミング言語の非純粋な動作を、純粋な枠組みでも同じように扱えるようになっている <a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a> 。<span class="ascii">Haskell</span> は、この仕組みをモナディック<code>IO</code>と名付け、<code>IO</code> 型を <code>IO</code> モナドと呼んでいる。モナドとは何か、どういう便利な側面があるのかについては、他の記事に譲る。</p>
<h2 id="動作を第一級で取り扱う"><span class="link-to-here-outer"><a href="#動作を第一級で取り扱う" title="動作を第一級で取り扱う"><span class="link-to-here">Link to<br />
here</span></a></span>動作を第一級で取り扱う</h2>
<p>どうやら、<span class="ascii">Haskell</span> の <code>IO</code> 動作の仕組みが、純粋な枠組みでも他のプログラミング言語とそう劣るものではないということが分かってもらえただろうか？ ところで、先ほどの <code>ifIO</code> や <code>whileIO</code> は、<code>IO</code> 動作を何事もなく引数にとって返したりしていた。<code>ifIO</code> の定義をもう一度よく見てみよう<span class="ascii">:</span></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" title="1"><span class="ot">ifIO ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb22-2" title="2">ifIO b act1 act2 <span class="ot">=</span> <span class="kw">case</span> b <span class="kw">of</span></a>
<a class="sourceLine" id="cb22-3" title="3">  <span class="dt">True</span>  <span class="ot">-&gt;</span> act1</a>
<a class="sourceLine" id="cb22-4" title="4">  <span class="dt">False</span> <span class="ot">-&gt;</span> act2</a></code></pre></div>
<p>このプログラムは、条件を表す引数と、<code>IO</code> 動作を<span class="ascii">2</span>個受け取り、条件によって<span class="ascii">2</span>つの動作のうちのどちらかを返していた。これは考えてみれば、とても不思議で強力なことだと思わないだろうか？ 普通のプログラミング言語の <code>if</code> 文は、条件から書かれたプログラムのどちらかを実行する。一方、<code>ifIO</code> は実行を制御しているわけではない。単に、普通の関数と同じように、<span class="ascii">2</span>つの動作を受け取って、そのうちの片方を関数の返り値として返すだけだ。<code>ifIO</code> を呼び出したプログラマは、返ってきた動作をゴミ箱に捨ててもいいし、<code>(&gt;&gt;=)</code> で繋げて「<span class="ascii">2</span>回続けて同じ動作をする」<span class="ascii">1</span>つの動作にしてもいい。もちろんその動作も <code>main</code> に組み入れるかはプログラマ次第だ。なんなら、<code>main</code> 以外にライブラリの一部としてグローバルに定義してもいい。ライブラリを使うユーザは、やっぱりそれを使うも使わないも自由だ。<code>main</code> に組み入れない限り、その動作は単なるデータであり、実行もされない。</p>
<p><code>IO</code> 動作がデータであることは、プログラムをより豊かにする。さっきの <code>ifIO</code> は、条件によって片方の動作を返していた。<code>IO</code>動作はもっと多彩に制御できる。例えば、条件によって動作の順番を変えたかったら次のように書けばいい<span class="ascii">:</span></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" title="1"><span class="ot">chooseOrderIO ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb23-2" title="2">chooseOrderIO b act1 act2 <span class="ot">=</span> <span class="kw">case</span> b <span class="kw">of</span></a>
<a class="sourceLine" id="cb23-3" title="3">  <span class="dt">True</span>  <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb23-4" title="4">    act1</a>
<a class="sourceLine" id="cb23-5" title="5">    act2</a>
<a class="sourceLine" id="cb23-6" title="6">  <span class="dt">False</span> <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb23-7" title="7">    act2</a>
<a class="sourceLine" id="cb23-8" title="8">    act1</a></code></pre></div>
<p><code>chooseOrderIO</code> は条件によって、受け取った動作を実行する順番を変え、その順序で結合した動作を返す。順番が同じで結果だけ選ぶといったこともできる<span class="ascii">:</span></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" title="1"><span class="ot">ifResultIO ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb24-2" title="2">ifResultIO b act1 act2 <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb24-3" title="3">  x1 <span class="ot">&lt;-</span> act1</a>
<a class="sourceLine" id="cb24-4" title="4">  x2 <span class="ot">&lt;-</span> act2</a>
<a class="sourceLine" id="cb24-5" title="5">  <span class="kw">case</span> b <span class="kw">of</span></a>
<a class="sourceLine" id="cb24-6" title="6">    <span class="dt">True</span>  <span class="ot">-&gt;</span> x1</a>
<a class="sourceLine" id="cb24-7" title="7">    <span class="dt">False</span> <span class="ot">-&gt;</span> x2</a></code></pre></div>
<p><code>ifIO</code> は条件によって動作そのものを選んでいたが、<code>ifResultIO</code> はどの条件でも <code>act1</code> と <code>act2</code> の順に動作をすること自体は変えない。代わりに、その動作の結果をどっちにするかだけを変える。このように、<span class="ascii">Haskell</span> は <code>IO</code> 動作を、多彩に、しかも純粋にコーディネートすることができる。これは、他の多くのプログラミング言語にはなく、しかも強力な機能だ。そう、<span class="ascii">Haskell</span> の <code>IO</code> 動作は、それが単なるデータであるがゆえに、通常のプログラミングの範囲で自由に加工できるのだ。</p>
<p>これを、動作が第一級であるという。第一級とは、つまり他のデータと全く同じように扱えるということだ。</p>
<h2 id="まとめ"><span class="link-to-here-outer"><a href="#まとめ" title="まとめ"><span class="link-to-here">Link to<br />
here</span></a></span>まとめ</h2>
<p>この記事では、</p>
<ol type="1">
<li>純粋とは何か</li>
<li><span class="ascii">Haskell</span> は、どうして純粋なのか</li>
<li><span class="ascii">Haskell</span> は、純粋な中で、他の言語の機構をどうやって実現しているのか</li>
<li><span class="ascii">Haskell</span> が、その中で獲得した強力な機能とは何か</li>
</ol>
<p>について紹介した。どうだろう？ <span class="ascii">Haskell</span> の <span class="ascii">IO</span> モナドについて、少しでも理解の補助になっただろうか？</p>
<p><span class="ascii">Haskell</span> の <span class="ascii">IO</span> モナドとは、動作そのものを値に持つ型だった。そして、その値は、特別な繋げる操作により他の言語と同じように加工でき、しかも通常のプログラミングの範囲で加工が可能になっている。しかも、加工自体は純粋にでき、動作の生成も純粋にできる。これが、<span class="ascii">Haskell</span> が純粋であると言われる所以だった。</p>
<p>この <span class="ascii">Haskell</span> の根幹をなす機能が、どういう点で魅力的なのか分かってもらえたら、この記事を書いた甲斐があるというものだ。もし、あなたもこの機能の魅力に取り憑かれたらなら、ぜひ <code>IO</code> 動作をふんだんに加工してプログラミングをしていって欲しい。では、楽しい <span class="ascii">Haskell</span> ライフを。</p>
<h2 id="おまけ-ioモナドの実装"><span class="link-to-here-outer"><a href="#おまけ-ioモナドの実装" title="おまけ-ioモナドの実装"><span class="link-to-here">Link to<br />
here</span></a></span>おまけ<span class="ascii">: IO</span>モナドの実装</h2>
<p>ところで、もしかしたら、読者の中には、</p>
<blockquote>
<p><span class="ascii">Haskell</span> の <span class="ascii">IO</span> モナドは、現実世界を状態にする <span class="ascii">State</span> モナドだ</p>
</blockquote>
<p>という主張を、見たことがある人がいるかもしれない。最後におまけとしてこの話に触れておこうと思う。気になる人は、この後も呼んでみると、<code>IO</code> モナドの理解の助けになるかもしれない <span class="ascii">(</span>または、むしろ混乱するかもしれない。もし、混乱したなら、とりあえずこの話は忘れることをお勧めする。ここに書いてある話を理解しなくても、<code>IO</code> モナドの利用に関して全く支障はない。そういう話もあるぐらいの事柄だ。なので、安心してまずは <span class="ascii">Haskell</span> プログラミングを楽しんでほしい。いつか楽しみ飽きたら戻ってきてもいいかもしれない<span class="ascii">)</span>。</p>
<p>まず、この話は、</p>
<ul>
<li>非純粋な世界の話だということ</li>
<li>単なる <span class="ascii">State</span> モナドではないということ</li>
</ul>
<p>を押さえておいて欲しい。さて、<span class="ascii">Haskell</span> の代表的な処理系 <span class="ascii">GHC</span> は、標準の範囲では純粋関数型プログラミングを提供するが、全体としては非純粋な計算も許容している。そして、その計算を <code>IO</code> モナドの内部に使っている。<span class="ascii">GHC</span> では <code>IO</code> モナドは、通常の言語内の一部として定義されている<span class="ascii">:</span></p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" title="1"><span class="kw">newtype</span> <span class="dt">IO</span> a <span class="ot">=</span> <span class="dt">IO</span> (<span class="dt">State</span><span class="op">#</span> <span class="dt">RealWorld</span> <span class="ot">-&gt;</span> (<span class="op">#</span> <span class="dt">State</span><span class="op">#</span> <span class="dt">RealWorld</span>, a <span class="op">#</span>))</a></code></pre></div>
<p>この型は、詳細は省くが、本質的には、</p>
<ul>
<li><code>State# RealWorld</code> 型の値を受け取り、<code>State# RealWorld</code> 型の値と <code>a</code> 型の値のタプルを返す関数</li>
</ul>
<p>の <code>newtype</code> になっている。<code>State</code> モナドについて知ってる人は、これは <code>State (State# RealWorld) a</code> と同じだと思うだろう。しかし、<code>IO a</code> の値は、他に <span class="ascii">Haskell</span> の型では表現できない契約を持つ。それは、</p>
<ul>
<li><code>State# RealWorld</code> の型の値は、必ず<span class="ascii">1</span>回だけ使用される</li>
</ul>
<p>という契約だ。なので、</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" title="1"><span class="dt">IO</span> <span class="op">$</span> \s<span class="op">#</span> <span class="ot">-&gt;</span> (<span class="op">#</span> s<span class="op">#</span>, \() <span class="ot">-&gt;</span> s<span class="op">#</span> <span class="op">#</span>)</a></code></pre></div>
<p>は <a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a> <code>s#</code> を<span class="ascii">2</span>箇所で使ってるため <code>IO (() -&gt; State# RealWorld)</code> の値になれないし、</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" title="1"><span class="dt">IO</span> <span class="op">$</span> \s<span class="op">#</span> <span class="ot">-&gt;</span> (<span class="op">#</span> s<span class="op">#</span>, <span class="dt">IO</span> <span class="op">$</span> \_ <span class="ot">-&gt;</span> (<span class="op">#</span> s<span class="op">#</span>, () <span class="op">#</span>) <span class="op">#</span>)</a></code></pre></div>
<p>は一番外側の <code>IO</code> は <code>s#</code> を <span class="ascii">2</span> 箇所で使っているため契約違反で、内側の <code>IO</code> は受け取った引数を一度も使っていないのでやはり契約違反ということになる。この定義を使って、例えば <span class="ascii">Haskell</span> で可変参照を扱う <code>IORef</code> のフレームワークは、次のように定義されている <a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a> <span class="ascii">:</span></p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" title="1"><span class="kw">data</span> <span class="dt">IORef</span> a <span class="ot">=</span> <span class="dt">IORef</span> (<span class="dt">MutVar</span><span class="op">#</span> <span class="dt">RealWorld</span> a)</a>
<a class="sourceLine" id="cb28-2" title="2"></a>
<a class="sourceLine" id="cb28-3" title="3"><span class="ot">newIORef ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">IORef</span> a)</a>
<a class="sourceLine" id="cb28-4" title="4">newIORef <span class="fu">init</span> <span class="ot">=</span> <span class="dt">IO</span> <span class="op">$</span> \s1<span class="op">#</span> <span class="ot">-&gt;</span> <span class="kw">case</span> newMutVar<span class="op">#</span> <span class="fu">init</span> s1<span class="op">#</span> <span class="kw">of</span></a>
<a class="sourceLine" id="cb28-5" title="5">  (<span class="op">#</span> s2<span class="op">#</span>, var <span class="op">#</span>) <span class="ot">-&gt;</span> (s2<span class="op">#</span>, <span class="dt">IORef</span> var)</a>
<a class="sourceLine" id="cb28-6" title="6"></a>
<a class="sourceLine" id="cb28-7" title="7"><span class="ot">readIORef ::</span> <span class="dt">IORef</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb28-8" title="8">readIORef (<span class="dt">IORef</span> var) <span class="ot">=</span> <span class="dt">IO</span> <span class="op">$</span> \s1<span class="op">#</span> <span class="ot">-&gt;</span> readMutVar<span class="op">#</span> var<span class="op">#</span> s1<span class="op">#</span></a>
<a class="sourceLine" id="cb28-9" title="9"></a>
<a class="sourceLine" id="cb28-10" title="10"><span class="ot">writeIORef ::</span> <span class="dt">IORef</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb28-11" title="11">writeIORef (<span class="dt">IORef</span> var<span class="op">#</span>) val <span class="ot">=</span> <span class="dt">IO</span> <span class="op">$</span> \s1<span class="op">#</span> <span class="ot">-&gt;</span> <span class="kw">case</span> writeMutVar<span class="op">#</span> var<span class="op">#</span> val s1<span class="op">#</span> <span class="kw">of</span></a>
<a class="sourceLine" id="cb28-12" title="12">  s2<span class="op">#</span> <span class="ot">-&gt;</span> (<span class="op">#</span> s2<span class="op">#</span>, () <span class="op">#</span>)</a></code></pre></div>
<p>この定義は、ちゃんと <code>IO</code> 型の制約を守っている。なおここで出てくる、<code>#</code> が付く関数やデータ型は、<span class="ascii">GHC</span> の中で特別扱いされ、プリミティブな関数やデータ型になっている。それぞれ、以下の型の関数として扱える<span class="ascii">:</span></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" title="1">newMutVar<span class="op">#</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">State</span><span class="op">#</span> s <span class="ot">-&gt;</span> (<span class="op">#</span> <span class="dt">State</span><span class="op">#</span> s, <span class="dt">MutVar</span><span class="op">#</span> s a <span class="op">#</span>)</a>
<a class="sourceLine" id="cb29-2" title="2"></a>
<a class="sourceLine" id="cb29-3" title="3">readMutVar<span class="op">#</span><span class="ot"> ::</span> <span class="dt">MutVar</span><span class="op">#</span> s a <span class="ot">-&gt;</span> <span class="dt">State</span><span class="op">#</span> s <span class="ot">-&gt;</span> (<span class="op">#</span> <span class="dt">State</span><span class="op">#</span> s, a <span class="op">#</span>)</a>
<a class="sourceLine" id="cb29-4" title="4"></a>
<a class="sourceLine" id="cb29-5" title="5">writeMutVar<span class="op">#</span><span class="ot"> ::</span> <span class="dt">MutVar</span><span class="op">#</span> s a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">State</span><span class="op">#</span> s <span class="ot">-&gt;</span> <span class="dt">State</span><span class="op">#</span> s</a></code></pre></div>
<p>注意して欲しいのは、これらの関数は純粋ではないということだ。これは、<span class="ascii">GHCi</span> 上で次のように確認できる<span class="ascii">:</span></p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XMagicHash</span> <span class="op">-</span><span class="dt">XUnboxedTuples</span></a>
<a class="sourceLine" id="cb30-2" title="2"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span><span class="kw">module</span> <span class="dt">GHC.Prim</span> <span class="dt">GHC.Types</span></a>
<a class="sourceLine" id="cb30-3" title="3"><span class="op">&gt;&gt;&gt;</span> <span class="op">:</span>{</a>
<a class="sourceLine" id="cb30-4" title="4"><span class="dt">IO</span> <span class="op">$</span> \r0<span class="op">#</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb30-5" title="5">  <span class="kw">let</span> (<span class="op">#</span> r1<span class="op">#</span>, var<span class="op">#</span> <span class="op">#</span>) <span class="ot">=</span> newMutVar<span class="op">#</span> <span class="dt">False</span> r0<span class="op">#</span> <span class="kw">in</span></a>
<a class="sourceLine" id="cb30-6" title="6">  <span class="kw">let</span> (<span class="op">#</span> r2<span class="op">#</span>, b1 <span class="op">#</span>) <span class="ot">=</span> readMutVar<span class="op">#</span> var<span class="op">#</span> r1<span class="op">#</span></a>
<a class="sourceLine" id="cb30-7" title="7">      r3<span class="op">#</span> <span class="ot">=</span> writeMutVar<span class="op">#</span> var<span class="op">#</span> <span class="dt">True</span> r2<span class="op">#</span></a>
<a class="sourceLine" id="cb30-8" title="8">  <span class="kw">in</span></a>
<a class="sourceLine" id="cb30-9" title="9">  <span class="kw">let</span> (<span class="op">#</span> _, b2 <span class="op">#</span>) <span class="ot">=</span> readMutVar<span class="op">#</span> var<span class="op">#</span> r1<span class="op">#</span> <span class="kw">in</span></a>
<a class="sourceLine" id="cb30-10" title="10">  (<span class="op">#</span> r3<span class="op">#</span>, b1 <span class="op">==</span> b2 <span class="op">#</span>)</a>
<a class="sourceLine" id="cb30-11" title="11"><span class="op">:</span>}</a>
<a class="sourceLine" id="cb30-12" title="12"><span class="dt">False</span></a></code></pre></div>
<p><code>b1</code> と <code>b2</code> は両方とも <code>readMutVar# var# r1#</code> から得た値になる。ところが、これらを比較してみると <code>False</code> になる <a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a> 。もし、<code>readMutVar#</code> が純粋なら、<code>b1</code> と <code>b2</code> の結果は同じになるため、上の評価結果は <code>True</code> になるはずだ。しかし、残念ながら <code>readMutVar#</code> は純粋ではないので、<code>b1</code> と <code>b2</code> は異なる値になってしまう。なお、この式は、<code>IO</code> 型で定義しているが、実際には</p>
<ul>
<li><span class="ascii">2</span> 回目の <code>readMutVar#</code> の呼び出しで <code>r1#</code> を <span class="ascii">2</span> 回使用しているし、</li>
<li>返ってきた <code>State# RealWorld</code> の値を捨てている</li>
</ul>
<p>ので契約違反であることに注意だ。<span class="ascii">GHCi</span> 上で、うまく評価結果を確認するために、<code>IO</code> を使っている。</p>
<p>さて、純粋性を守れないなら、<span class="ascii">GHC</span> は一体全体何のためにこのような定義をしているんだろう？ 関数が純粋でなくてもいいなら、単に</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" title="1"><span class="kw">newtype</span> <span class="dt">IO</span> a <span class="ot">=</span> <span class="dt">IO</span> (() <span class="ot">-&gt;</span> a)</a></code></pre></div>
<p>と定義しても問題ないのではないだろうか？ この方が自然に動作を表しているように思える。ところが、このような定義は、ある問題を招くのだ。<span class="ascii">Haskell</span> は純粋関数型プログラミング言語という売りの他に、遅延評価という他の言語にはあまり見られない評価機構を採用している。もちろん、<span class="ascii">GHC</span> も遅延評価が基本だ。正確には、<span class="ascii">Haskell</span> の評価順序は、</p>
<blockquote>
<p><span class="ascii">The order of evaluation of expressions in Haskell is constrained only by data dependencies; an implementation has a great deal of freedom in choosing this order.</span></p>
<p><span class="ascii">Haskell</span> の式の評価順序は、データ依存によってのみ縛られます。これは、実装がこの順序の選択において、大きな自由度を持つことを意味します。</p>
<p>– <a href="https://www.haskell.org/onlinereport/haskell2010/haskellch7.html#x14-1420007"><span class="ascii">Haskell Language Report - Chapter 7 Basic Input/Output</span></a></p>
</blockquote>
<p>とあるように、データ依存関係によってのみ制御できる。ところが、<code>IO</code>動作は違う。例えば、</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb32-2" title="2">main <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb32-3" title="3">  <span class="fu">putStrLn</span> <span class="st">&quot;str1&quot;</span></a>
<a class="sourceLine" id="cb32-4" title="4">  <span class="fu">putStrLn</span> <span class="st">&quot;str2&quot;</span></a></code></pre></div>
<p>という式において、<code>putStrLn "str1"</code> と <code>putStrLn "str2"</code> の動作の間には、何らのデータ依存関係も存在しない。しかしながら、<code>main</code> は</p>
<ul>
<li><code>"str1"</code> をターミナルに出力した後、<code>"str2"</code> をターミナルに出力する</li>
</ul>
<p>という動作を表して欲しいはずだ。つまり、<code>IO</code>動作はデータ依存関係によってのみ順序が決まるわけではなく、その繋げ方によって順序が決まって欲しいのだ。ところが、単純に</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" title="1"><span class="kw">newtype</span> <span class="dt">IO</span> a <span class="ot">=</span> <span class="dt">IO</span> (() <span class="ot">-&gt;</span> a)</a></code></pre></div>
<p>という定義を採用してしまうと、<code>IO</code>の中身は繋げ方の順序を情報として持たないため、動作の実行順序を制御するのに、別途工夫が必要になる。そこで、元の定義の登場だ<span class="ascii">:</span></p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" title="1"><span class="kw">newtype</span> <span class="dt">IO</span> a <span class="ot">=</span> <span class="dt">IO</span> (<span class="dt">State</span><span class="op">#</span> <span class="dt">RealWorld</span> <span class="ot">-&gt;</span> (<span class="op">#</span> <span class="dt">State</span><span class="op">#</span> <span class="dt">RealWorld</span>, a <span class="op">#</span>))</a></code></pre></div>
<p>この <code>State# RealWorld</code> は、実際には <code>()</code> 型と同じく単一の値を持つほぼ何の意味も持たない型になる。しかし、この型の値を計算度に付与することで、データ依存を作ることができる。具体的には、この <code>IO</code> に対して次のように <code>pure</code> <span class="ascii">/</span> <code>(&gt;&gt;=)</code> を定義するのだ<span class="ascii">:</span></p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" title="1"><span class="fu">pure</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb35-2" title="2"><span class="fu">pure</span> x <span class="ot">=</span> <span class="dt">IO</span> <span class="op">$</span> \r<span class="op">#</span> <span class="ot">-&gt;</span> (<span class="op">#</span> r<span class="op">#</span>, x <span class="op">#</span>)</a>
<a class="sourceLine" id="cb35-3" title="3"></a>
<a class="sourceLine" id="cb35-4" title="4"><span class="ot">(&gt;&gt;=) ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> <span class="dt">IO</span> b</a>
<a class="sourceLine" id="cb35-5" title="5"><span class="dt">IO</span> f <span class="op">&gt;&gt;=</span> g <span class="ot">=</span> <span class="dt">IO</span> <span class="op">$</span> \r0<span class="op">#</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb35-6" title="6">  <span class="kw">let</span> (<span class="op">#</span> r1<span class="op">#</span>, x <span class="op">#</span>) <span class="ot">=</span> f r0<span class="op">#</span></a>
<a class="sourceLine" id="cb35-7" title="7">      <span class="dt">IO</span> g&#39; <span class="ot">=</span> g x</a>
<a class="sourceLine" id="cb35-8" title="8">  <span class="kw">in</span> g&#39; r1<span class="op">#</span></a></code></pre></div>
<p>特に、<code>(&gt;&gt;=)</code> の定義が重要になる。<code>(&gt;&gt;=)</code> が返してくる <code>IO</code> の中身は、</p>
<ol type="1">
<li>受け取った <code>State# RealWorld</code> をまず最初の <code>IO</code> 動作に渡す</li>
<li>その結果を <code>g</code> に渡して、次の <code>IO</code> 動作を生成する</li>
<li>生成した <code>IO</code> 動作に、最初の <code>IO</code> 動作が返してきた <code>State# RealWorld</code> を渡す</li>
</ol>
<p>ということを行っている。これにより、</p>
<ol type="1">
<li>受け取った <code>State# RealWorld</code></li>
<li><code>f</code> の結果の <code>State# RealWorld</code></li>
<li><code>g'</code> の結果の <code>State# RealWorld</code></li>
</ol>
<p>という順で <code>State# RealWorld</code> のデータ依存関係が出来上がる。つまり、通常の <span class="ascii">Haskell</span> の評価の枠組みで、評価順序を保証できるようになるのだ。実際に、<code>IORef</code> を例に考えてみよう。</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb36-2" title="2">main <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb36-3" title="3">  x <span class="ot">&lt;-</span> newIORef <span class="dt">False</span></a>
<a class="sourceLine" id="cb36-4" title="4">  b1 <span class="ot">&lt;-</span> readIORef x</a>
<a class="sourceLine" id="cb36-5" title="5">  writeIORef <span class="dt">True</span> x</a>
<a class="sourceLine" id="cb36-6" title="6">  b2 <span class="ot">&lt;-</span> readIORef x</a>
<a class="sourceLine" id="cb36-7" title="7">  <span class="fu">pure</span> <span class="op">$</span> b1 <span class="op">==</span> b2</a></code></pre></div>
<p>というプログラムにおいて、最終的な <code>pure $ b1 == b2</code> からのデータ依存関係に、一見 <code>writeIORef True x</code> は関与していないように見える。ところが、内部を見てみると、上のプログラムは、</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb37-2" title="2">main <span class="ot">=</span> <span class="dt">IO</span> <span class="op">$</span> \r0<span class="op">#</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb37-3" title="3">  <span class="kw">let</span> (<span class="op">#</span> r1<span class="op">#</span>, x<span class="op">#</span> <span class="op">#</span>) <span class="ot">=</span> newMutVar<span class="op">#</span> <span class="dt">False</span> r0<span class="op">#</span></a>
<a class="sourceLine" id="cb37-4" title="4">      (<span class="op">#</span> r2<span class="op">#</span>, b1 <span class="op">#</span>) <span class="ot">=</span> readMutVar<span class="op">#</span> x<span class="op">#</span> r1<span class="op">#</span></a>
<a class="sourceLine" id="cb37-5" title="5">      r3<span class="op">#</span> <span class="ot">=</span> writeMutVar<span class="op">#</span> <span class="dt">True</span> x<span class="op">#</span> r2<span class="op">#</span></a>
<a class="sourceLine" id="cb37-6" title="6">      (<span class="op">#</span> r4<span class="op">#</span>, b2 <span class="op">#</span>) <span class="ot">=</span> readMutVar<span class="op">#</span> x<span class="op">#</span> r3<span class="op">#</span></a>
<a class="sourceLine" id="cb37-7" title="7">  <span class="kw">in</span> (<span class="op">#</span> r4<span class="op">#</span>, b1 <span class="op">==</span> b2 <span class="op">#</span>)</a></code></pre></div>
<p>と同じ意味を持ち、全て隠れた <code>State# RealWorld</code> によってデータ依存で紐づいている。もちろん、<code>let</code> 内の定義の順番を変えても何の問題もない。重要なのは <code>r0#</code> から <code>r1#</code> の結果が得られ、<code>r1#</code> から <code>r2#</code> の結果が得られ、というようなデータ依存だけだ。これにより、<span class="ascii">GHC</span> は <span class="ascii">Haskell</span> の評価順序に特別な規則を設けない <a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a> <a href="#fn10" class="footnote-ref" id="fnref10"><sup>10</sup></a> で、<code>IO</code> を実装しているのだ。</p>
<p>なお、こうなると <code>IO</code> の</p>
<ul>
<li><code>State# RealWorld</code> の型の値は、必ず<span class="ascii">1</span>回だけ使用される</li>
</ul>
<p>という契約も意義が見えてくる。もし、この契約が破られると、途中でデータ依存が分岐したり、または途中で途絶えたりすることになる。そうなると、動作がどういう挙動をするかは、<span class="ascii">Haskell</span> 内では規定されなくなってしまう。実際に、最適化によってどう動作するかが変わってきてしまう例も作れる。<code>IO</code> の契約とは、データ依存が必ず一本の線で繋がり、<span class="ascii">Haskell</span> の評価の枠できちんと順番が規定されるということを保証しているのだ。</p>
<p>これが、<span class="ascii">GHC</span> がこのような定義を <code>IO</code> で採用している理由になる。もちろん、アナロジーとして現実世界全体を表す架空の状態を <code>State# RealWorld</code> と見立て、<code>IO</code>動作の実行により新たな現実世界全体の状態が手に入るという見方は可能だ。名前の由来もそこから来ている。ただ、基本的には、<span class="ascii">GHC</span> において、特別な仕組みを入れずに <code>IO</code> を実装するためのやり方であるということを押さえておいて欲しい。</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>定義は、 <a href="https://www.schoolofhaskell.com/school/starting-with-haskell/basics-of-haskell/3-pure-functions-laziness-io"><span class="ascii">School of Haskell</span> のチュートリアル</a> から拝借している。<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>この定義は、<a href="https://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1220006.1.5"><span class="ascii">Haskell Language Report 6.1.5 The Unit Datatype</span></a> で述べられているが、実際には <span class="ascii">Haskell</span> の構文規則に違反している特別な構文が使われている。なので、実際に <span class="ascii">Haskell</span> でこのように定義できるわけではなく、擬似的に書くとこうなるという意味になる。<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>動作は、計算 <span class="ascii">(computation)</span> とも呼ばれる。また、日本の <span class="ascii">Haskell</span> コミュニティでは、英語そのままで「アクション」とも呼ばれている。<a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p>厳密には、<code>(&gt;&gt;)</code> という別の関数を使って定義されるんだが、意味的にはそのような変換と思ってもらって構わない。正式な変換方法は、<a href="https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14"><span class="ascii">Haskell Language Report 3.14 Do Expressions</span></a> を参照するといいだろう。<a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p>多くの言語では、<code>main</code> プログラム以外の、例えばライブラリが勝手にスレッドを<span class="ascii">1</span>つ立てるなどの挙動をサポートしている。そのような挙動は、<span class="ascii">Haskell</span> では残念ながらできない。なぜなら、<span class="ascii">Haskell</span> では <code>main</code> に動作を組み入れない限りその動作は実行されないからだ。この点では、他の言語より表現力は劣っているということもできる。しかし、そのような機能は、多くの場合明示的に模倣できる。<a href="#fnref5" class="footnote-back">↩</a></p></li>
<li id="fn6"><p><code>(# x, y #)</code> は <code>(# a, b #)</code> 型の値を表す特別な構文だ。ここでは詳細は述べないので、<code>x</code> と <code>y</code> のタプルの特別な表記方法だと思ってもらって構わない。<a href="#fnref6" class="footnote-back">↩</a></p></li>
<li id="fn7"><p>実際には <code>ST</code> モナドとの兼ね合いで、直接こう定義はされていないが、分かりやすさのため簡略化している。<a href="#fnref7" class="footnote-back">↩</a></p></li>
<li id="fn8"><p>実際には、最適化次第で結果が変わることもある。<a href="#fnref8" class="footnote-back">↩</a></p></li>
<li id="fn9"><p>さらに、<code>State# RealWorld</code> は <span class="ascii">unlifted</span> なデータ型になっており、サンクを持たない。このため、強制的に正格評価になるようになっており、<code>IO</code>動作が遅延され、最後に一気に評価されるということを防いでいる。これも、通常の <span class="ascii">GHC</span> の枠組みの中で提供されているのは、とても興味深い。<a href="#fnref9" class="footnote-back">↩</a></p></li>
<li id="fn10"><p>厳密には、残念ながら全てを特別扱いせずに済ませられているわけではない。<span class="ascii">GHC</span> では、<code>State# RealWorld</code> に関して一部の最適化で特別な処理を施している。<a href="#fnref10" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2020/haskell-casually-at-work.html" lang="ja">Haskellを業務で使う、カジュアルに</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2020/property-io.html" style="margin-left: auto;" lang="ja">HspecでQuickCheckするときもshouldBeなどが使えます</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>HspecでQuickCheckするときもshouldBeなどが使えます</title>
    <link href="https://haskell.jp/blog/posts/2020/property-io.html" />
    <id>https://haskell.jp/blog/posts/2020/property-io.html</id>
    <published>2020-02-27T00:00:00Z</published>
    <updated>2020-02-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>タイトルがほとんどすべてなんですが詳細を解説します。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#shouldbeなどはpropertyの中でも使えるので使ってください" title="shouldbeなどはpropertyの中でも使えるので使ってください">📣<code>shouldBe</code>などは<code>property</code>の中でも使えるので使ってください！</a></li>
<li><a href="#なぜ使える" title="なぜ使える">😕なぜ使える？</a></li>
</ul>
</div>
</div>
<h1 id="shouldbeなどはpropertyの中でも使えるので使ってください"><span class="link-to-here-outer"><a href="#shouldbeなどはpropertyの中でも使えるので使ってください" title="shouldbeなどはpropertyの中でも使えるので使ってください"><span class="link-to-here">Link to<br />
here</span></a></span>📣<code>shouldBe</code>などは<code>property</code>の中でも使えるので使ってください！</h1>
<p>みなさんは<span class="ascii">Hspec</span>で<span class="ascii">QuickCheck</span>を使った<span class="ascii">property test</span>を書く際、どのように書いているでしょうか？<br />
例えば<a href="https://hspec.github.io/quickcheck.html"><span class="ascii">Hspec</span>のマニュアル</a>のように、<span class="ascii">Hspec</span>に<span class="ascii">property test</span>を組み込む例として、次のような例を挙げています。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1">describe <span class="st">&quot;read&quot;</span> <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-2" title="2">  it <span class="st">&quot;is inverse to show&quot;</span> <span class="op">$</span> property <span class="op">$</span></a>
<a class="sourceLine" id="cb1-3" title="3">    \x <span class="ot">-&gt;</span> (<span class="fu">read</span> <span class="op">.</span> <span class="fu">show</span>) x <span class="op">==</span> (<span class="ot">x ::</span> <span class="dt">Int</span>)</a></code></pre></div>
<p>※<a href="https://github.com/hspec/hspec/blob/9f3f4c38952f526701a67b6e26336a3a5aec0e89/doc/quickcheck.md">こちらのコミット</a>の時点での話です。</p>
<p><code>property</code>関数に渡した関数<small>（以下、「<code>porperty</code>ブロック」と呼びます）</small>の中では<span class="ascii">Hspec</span>でおなじみの<code>shouldBe</code>などの<span class="ascii">expectation</span>用関数を使わず、<code>==</code>で結果を判定してますよね。<br />
このサンプルに倣って、<span class="ascii">Hspec</span>で書いたテストに<span class="ascii">property test</span>を書くときは、<code>==</code>を使ってる方が多いんじゃないでしょうか？</p>
<p>ところが、この記事のタイトルに書いたとおり、実際のところ<code>property</code>ブロックの中でも<code>shouldBe</code>は利用できます。<br />
つまりは、こちら👇のようにも書ける、ということです！</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1">describe <span class="st">&quot;read&quot;</span> <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-2" title="2">  it <span class="st">&quot;is inverse to show&quot;</span> <span class="op">$</span> property <span class="op">$</span></a>
<a class="sourceLine" id="cb2-3" title="3">    \x <span class="ot">-&gt;</span> (<span class="fu">read</span> <span class="op">.</span> <span class="fu">show</span>) x <span class="ot">`shouldBe`</span> (<span class="ot">x ::</span> <span class="dt">Int</span>)</a></code></pre></div>
<p>このように<code>property</code>ブロックの中でも<code>shouldBe</code>や<code>shouldSatisfy</code>といった、<span class="ascii">Hspec</span>固有の<span class="ascii">expectation</span>関数を使うことの利点は、単に構文を他のテストと一貫させることができる、だけではありません。<br />
<strong>テストが失敗したときのエラーが分かりやすくなる</strong>、という遥かに重大なメリットがあるのです。</p>
<p>試しにわざとテストを失敗させてみましょう。<br />
先ほどの例<span class="ascii">:</span></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1">describe <span class="st">&quot;read&quot;</span> <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-2" title="2">  it <span class="st">&quot;is inverse to show&quot;</span> <span class="op">$</span> property <span class="op">$</span></a>
<a class="sourceLine" id="cb3-3" title="3">    \x <span class="ot">-&gt;</span> (<span class="fu">read</span> <span class="op">.</span> <span class="fu">show</span>) x <span class="op">==</span> (<span class="ot">x ::</span> <span class="dt">Int</span>)</a></code></pre></div>
<p>における<code>(x :: Int)</code>という式を<code>(x + 1 :: Int)</code>に変えれば、必ず失敗するはずです。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1">describe <span class="st">&quot;read&quot;</span> <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-2" title="2">  it <span class="st">&quot;is inverse to show&quot;</span> <span class="op">$</span> property <span class="op">$</span></a>
<a class="sourceLine" id="cb4-3" title="3">    \x <span class="ot">-&gt;</span> (<span class="fu">read</span> <span class="op">.</span> <span class="fu">show</span>) x <span class="op">==</span> (x <span class="op">+</span> <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>)</a></code></pre></div>
<p>※お手元で試す場合は<a href="https://github.com/hspec/hspec/blob/9f3f4c38952f526701a67b6e26336a3a5aec0e89/doc/_includes/QuickCheck.hs">こちら</a>から元のコードを持ってきて、<code>stack build hspec</code>なりを実行した上で修正・実行するのが簡単でしょう。</p>
<p>結果、下記のようなエラーメッセージとなるでしょう。</p>
<pre><code>...
  1) read, when used with ints, is inverse to show
       Falsifiable (after 1 test):
         0</code></pre>
<p>このエラーでは「テストが失敗したこと」と「どんな入力を<span class="ascii">QuickCheck</span>が生成したか」までしか教えてくれず、わかりづらいですよね。</p>
<p>一方、<code>shouldBe</code>を使用して以下のように書き換えると…</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1">describe <span class="st">&quot;read&quot;</span> <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-2" title="2">  it <span class="st">&quot;is inverse to show&quot;</span> <span class="op">$</span> property <span class="op">$</span></a>
<a class="sourceLine" id="cb6-3" title="3">    \x <span class="ot">-&gt;</span> (<span class="fu">read</span> <span class="op">.</span> <span class="fu">show</span>) x <span class="ot">`shouldBe`</span> (x <span class="op">+</span> <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>)</a></code></pre></div>
<p>エラーメッセージはこう👇なります。</p>
<pre><code>  1) read, when used with ints, is inverse to show
       Falsifiable (after 1 test):
         0
       expected: 1
        but got: 0</code></pre>
<p>「テストが失敗したこと」と「どんな入力を<span class="ascii">QuickCheck</span>が生成したか」に加えて、<code>shouldBe</code>に与えた両辺の式がどのような値を返したか、まで教えてくれました！<br />
今回の例は極めて単純なのであまり役に立たないかも知れませんが、あなたが書いた関数をテストするときはやっぱり「期待される結果」と「実際の結果」両方がわかる方がデバッグしやすいですよね！</p>
<p>と、いうわけで今後は<code>property</code>関数<small>（あるいはその省略版の<code>prop</code>関数）</small>に渡した関数の中でも<code>shouldBe</code>などを必ず使ってください！<br />
<small>（せっかくなんで、今回紹介したドキュメントを<a href="https://github.com/hspec/hspec/pull/429">修正するための<span class="ascii">Pull request</span></a>を送っておきました。これがマージされればこの記事の情報の大半は時代遅れになります）</small></p>
<h1 id="なぜ使える"><span class="link-to-here-outer"><a href="#なぜ使える" title="なぜ使える"><span class="link-to-here">Link to<br />
here</span></a></span>😕なぜ使える？</h1>
<p>しかしここで、一つ疑問が残ります。<br />
<span class="ascii">QuickCheck</span>や<span class="ascii">Hspec</span>のドキュメントをつぶさに読んだことがある方はお気づきでしょう。<br />
<span class="ascii">QuickCheck</span>の<a href="http://hackage.haskell.org/package/QuickCheck-2.13.2/docs/Test-QuickCheck.html#t:Testable"><code>property</code>関数は、<code>Testable</code>という型クラスのメソッド</a>であるため、<code>Testable</code>のインスタンスでなければ使えないはずです。<br />
<span class="ascii">Hspec</span>の<code>shouldBe</code>などが返す値は型シノニムのたらい回しをたどればわかるとおり、結局のところ<code>IO ()</code>型の値です。<br />
ところが<code>Testable</code>のインスタンス一覧を見る限り、<code>IO a</code>は<code>Testable</code>のインスタンスではありません。<br />
先ほどの例のように</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1">property <span class="op">$</span> \x <span class="ot">-&gt;</span> (<span class="fu">read</span> <span class="op">.</span> <span class="fu">show</span>) x <span class="ot">`shouldBe`</span> (x <span class="op">+</span> <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>)</a></code></pre></div>
<p>と書いた場合における、関数型<code>(a -&gt; prop)</code>のインスタンスは、<code>(Arbitrary a, Show a, Testable prop) =&gt; Testable (a -&gt; prop)</code>という定義のとおり、関数の戻り値の型が<code>Testable</code>のインスタンスでないと、型チェックを通らないはずです。<br />
<code>Testable</code>のインスタンスでない、<code>IO ()</code>を返しているにも関わらず型エラーが起きなかったのは、一体なぜでしょうか？</p>
<p>その秘密を探るべく、<span class="ascii">GHCi</span>を立ち上げましょう。<br />
先ほどの例のソースコードを<code>ghci</code>コマンドに読ませれば、まとめて<span class="ascii">Hspec</span>のモジュールも<code>import</code>できるので簡単です。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb9-1" title="1"><span class="op">&gt;</span> <span class="ex">stack</span> exec ghci .\QuickCheck.hs</a></code></pre></div>
<p><span class="ascii">GHCi</span>が起動したら、<code>:i Testable</code>と入力して、<code>Testable</code>型クラスのインスタンス一覧を出力しましょう。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="op">&gt;</span> <span class="op">:</span>i <span class="dt">Testable</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="kw">class</span> <span class="dt">Testable</span> prop <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="ot">  property ::</span> prop <span class="ot">-&gt;</span> <span class="dt">Property</span></a>
<a class="sourceLine" id="cb10-4" title="4">  <span class="ot">{-# MINIMAL property #-}</span></a>
<a class="sourceLine" id="cb10-5" title="5">        <span class="co">-- Defined in ‘Test.QuickCheck.Property’</span></a>
<a class="sourceLine" id="cb10-6" title="6"><span class="kw">instance</span> [safe] <span class="dt">Testable</span> <span class="dt">Property</span></a>
<a class="sourceLine" id="cb10-7" title="7">  <span class="co">-- Defined in ‘Test.QuickCheck.Property’</span></a>
<a class="sourceLine" id="cb10-8" title="8"><span class="kw">instance</span> [safe] <span class="dt">Testable</span> prop <span class="ot">=&gt;</span> <span class="dt">Testable</span> (<span class="dt">Gen</span> prop)</a>
<a class="sourceLine" id="cb10-9" title="9">  <span class="co">-- Defined in ‘Test.QuickCheck.Property’</span></a>
<a class="sourceLine" id="cb10-10" title="10"><span class="kw">instance</span> [safe] <span class="dt">Testable</span> <span class="dt">Discard</span></a>
<a class="sourceLine" id="cb10-11" title="11">  <span class="co">-- Defined in ‘Test.QuickCheck.Property’</span></a>
<a class="sourceLine" id="cb10-12" title="12"><span class="kw">instance</span> [safe] <span class="dt">Testable</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb10-13" title="13">  <span class="co">-- Defined in ‘Test.QuickCheck.Property’</span></a>
<a class="sourceLine" id="cb10-14" title="14"><span class="kw">instance</span> [safe] (<span class="dt">Arbitrary</span> a, <span class="dt">Show</span> a, <span class="dt">Testable</span> prop) <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb10-15" title="15">                <span class="dt">Testable</span> (a <span class="ot">-&gt;</span> prop)</a>
<a class="sourceLine" id="cb10-16" title="16">  <span class="co">-- Defined in ‘Test.QuickCheck.Property’</span></a>
<a class="sourceLine" id="cb10-17" title="17"><span class="kw">instance</span> [safe] <span class="dt">Testable</span> ()</a>
<a class="sourceLine" id="cb10-18" title="18">  <span class="co">-- Defined in ‘Test.QuickCheck.Property’</span></a>
<a class="sourceLine" id="cb10-19" title="19"><span class="kw">instance</span> [safe] <span class="dt">Testable</span> <span class="dt">Test.HUnit.Lang.Assertion</span></a>
<a class="sourceLine" id="cb10-20" title="20">  <span class="co">-- Defined in ‘Test.QuickCheck.IO’</span></a></code></pre></div>
<p>ありました！💡 最後の方にある<code>instance [safe] Testable Test.HUnit.Lang.Assertion</code>という行に注目してください。<br />
<a href="http://hackage.haskell.org/package/HUnit-1.6.0.0/docs/Test-HUnit-Lang.html#t:Assertion"><code>Test.HUnit.Lang.Assertion</code></a>は、<code>IO ()</code>の型シノニムであり、<span class="ascii">Hspec</span>でも間接的に型シノニムとして参照されています<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>。<br />
要するに<code>instance [safe] Testable Test.HUnit.Lang.Assertion</code>という行は<code>instance [safe] Testable (IO ())</code>と読み替えることができます<small>（<code>[safe]</code>という表記が指しているものについてはここでは省略します！すみません！）</small>。</p>
<p>紹介したとおり<code>Testable</code>のドキュメントには<code>Testable Assertion</code>なんて記載はありませんし、じゃあ一体どこで定義したのか、というとそう、続く行に<code>-- Defined in ‘Test.QuickCheck.IO’</code>と書かれているとおり、<a href="https://hackage.haskell.org/package/quickcheck-io-0.2.0/docs/Test-QuickCheck-IO.html"><code>Test.QuickCheck.IO</code></a>というモジュールで定義されています！</p>
<p><code>Test.QuickCheck.IO</code>は、名前のとおり<span class="ascii">QuickCheck</span>の<code>Testable</code>について、<code>IO</code>の<span class="ascii">orphan instance</span>を定義するためのモジュールです。<br />
これを<a href="https://github.com/hspec/hspec/blob/226510631f24b674827e99d17d10f9f92440c5a9/hspec-core/src/Test/Hspec/Core/QuickCheckUtil.hs#L18"><code>import</code>している</a>が故に、<span class="ascii">Hspec</span>では<code>property</code>ブロックの中で<code>shouldBe</code>などが利用できるんですね！</p>
<p>結論<span class="ascii">:</span></p>
<ul>
<li><span class="ascii">orphan instance</span>わかりづらい😥</li>
<li><span class="ascii">GHCi</span>の<code>:i</code>は<span class="ascii">orphan instance</span>であろうとインスタンスを定義した箇所を見つけてくれるから便利！</li>
</ul>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>この節の冒頭で「型シノニムのたらい回し」と呼んだものを追いかけてみましょう。<br />
おなじみ<a href="http://hackage.haskell.org/package/hspec-expectations-0.8.2/docs/Test-Hspec-Expectations.html#v:shouldBe"><code>shouldBe</code></a>は<a href="http://hackage.haskell.org/package/hspec-expectations-0.8.2/docs/Test-Hspec-Expectations.html#t:Expectation"><code>Expectation</code></a>という型の値を返します。<br />
そして<code>Expectation</code>は<code>Assertion</code>の型シノニムであり、クリックすると<a href="http://hackage.haskell.org/package/HUnit-1.6.0.0/docs/Test-HUnit-Lang.html#t:Assertion"><code>Test.HUnit.Lang.Assertion</code></a>であることがわかります。<br />
そして<code>Assertion</code>はそう、<code>type Assertion = IO ()</code>とあるとおり<code>IO ()</code>なのです。やっと知ってる型にたどり着きました😌。<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2020/io-monad-and-sideeffect.html" lang="ja">IO モナドと副作用</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2020/revenge-of-hourly-antenna.html" style="margin-left: auto;" lang="ja">リベンジ・オブ・毎時更新 Haskell Antenna</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>

</feed>
