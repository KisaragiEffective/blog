<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Haskell-jp Blog</title>
    <link href="https://haskell.jp/blog/feed.xml" rel="self" />
    <link href="https://haskell.jp/blog" />
    <id>https://haskell.jp/blog/feed.xml</id>
    <author>
        <name>Haskell-jp</name>
        <email></email>
    </author>
    <updated>2019-09-28T00:00:00Z</updated>
    <entry>
    <title>HIW 2019で発表された、Gibbonコンパイラーについて</title>
    <link href="https://haskell.jp/blog/posts/2019/hiw-gibbon.html" />
    <id>https://haskell.jp/blog/posts/2019/hiw-gibbon.html</id>
    <published>2019-09-28T00:00:00Z</published>
    <updated>2019-09-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p><a href="/posts/2019/hiw-ghc-future.html">前回</a>から引き続き、<a href="https://icfp19.sigplan.org/home/hiw-2019#About"><span class="ascii">Haskell Implementors</span>’ <span class="ascii">Workshop 2019</span></a>への参加レポートとして、私の印象に残った発表を紹介します。<br />
今回は、<a href="http://iu-parfunc.github.io/gibbon/"><span class="ascii">Gibbon</span></a>という、<span class="ascii">GHC</span>以外の<span class="ascii">Haskell</span><small>（の、サブセット）</small>の処理系についての発表です。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#the-gibbon-compiler-accelerating-a-small-subset-of-haskell" title="the-gibbon-compiler-accelerating-a-small-subset-of-haskell"><span class="ascii">The Gibbon Compiler: Accelerating a small subset of Haskell</span></a></li>
</ul>
</div>
</div>
<h1 id="the-gibbon-compiler-accelerating-a-small-subset-of-haskell"><span class="link-to-here-outer"><a href="#the-gibbon-compiler-accelerating-a-small-subset-of-haskell" title="the-gibbon-compiler-accelerating-a-small-subset-of-haskell"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">The Gibbon Compiler: Accelerating a small subset of Haskell</span></h1>
<p>発表者<span class="ascii">: Ryan R. Newton</span> <em><span class="ascii">Indiana University</span></em><span class="ascii">, Michael Vollmer</span> <em><span class="ascii">Indiana University, USA</span></em><span class="ascii">, Chaitanya Koparkar</span> <em><span class="ascii">Indiana University</span></em></p>
<p><span class="ascii">Gibbon</span>は最適化の手法を研究するために作られたコンパイラーです。<br />
具体的には、我々<small>（特に<span class="ascii">Haskeller</span>）</small>がよく使う、木構造全体に対する処理の最適化です。</p>
<p>こうした木構造のデータは、通常ポインターを使ってメモリー内にバラバラに格納されますが、<span class="ascii">Gibbon</span>による最適化を行うと、実際にプログラムがどのような順番で木を処理しているのか解析して、（元のデータ構造を配列に変換した上で）その順番に並べられた配列として処理するコードに変換する、という大胆な変換を行います。 図にするとこんなイメージでしょうか？</p>
<figure>
<img src="/img/2019/hiw-gibbon/tree-and-array1.svg" alt="変換前の木構造。各ノードがそれぞれ（レベル順で）A, B, … , Gという値を持っている" /><figcaption>変換前の木構造。各ノードがそれぞれ（レベル順で）<span class="ascii">A, B,</span> … <span class="ascii">, G</span>という値を持っている</figcaption>
</figure>
<p>👆のような木構造があったとして、</p>
<figure>
<img src="/img/2019/hiw-gibbon/tree-and-array2.svg" alt="行きがけ順（A, B, D, E, C, F, Gの順）でアクセスする" /><figcaption>行きがけ順（<span class="ascii">A, B, D, E, C, F, G</span>の順）でアクセスする</figcaption>
</figure>
<p>👆における、赤い線の順番<small>（行きがけ順）</small>にアクセスする関数があったとします。<br />
適当に<span class="ascii">Haskell</span>の再帰関数として書くと、👇こういうコードです。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">data</span> <span class="dt">Tree</span> <span class="ot">=</span> <span class="dt">Node</span> <span class="dt">Char</span> (<span class="dt">Maybe</span> <span class="dt">Tree</span>) (<span class="dt">Maybe</span> <span class="dt">Tree</span>) <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="ot">tree ::</span> <span class="dt">Tree</span></a>
<a class="sourceLine" id="cb1-4" title="4">tree <span class="ot">=</span></a>
<a class="sourceLine" id="cb1-5" title="5">  <span class="dt">Node</span> <span class="ch">&#39;A&#39;</span></a>
<a class="sourceLine" id="cb1-6" title="6">    ( <span class="dt">Just</span></a>
<a class="sourceLine" id="cb1-7" title="7">      ( <span class="dt">Node</span> <span class="ch">&#39;B&#39;</span></a>
<a class="sourceLine" id="cb1-8" title="8">        (<span class="dt">Just</span> (<span class="dt">Node</span> <span class="ch">&#39;D&#39;</span> <span class="dt">Nothing</span> <span class="dt">Nothing</span>))</a>
<a class="sourceLine" id="cb1-9" title="9">        (<span class="dt">Just</span> (<span class="dt">Node</span> <span class="ch">&#39;E&#39;</span> <span class="dt">Nothing</span> <span class="dt">Nothing</span>))</a>
<a class="sourceLine" id="cb1-10" title="10">      )</a>
<a class="sourceLine" id="cb1-11" title="11">    )</a>
<a class="sourceLine" id="cb1-12" title="12">    ( <span class="dt">Just</span></a>
<a class="sourceLine" id="cb1-13" title="13">      ( <span class="dt">Node</span> <span class="ch">&#39;C&#39;</span></a>
<a class="sourceLine" id="cb1-14" title="14">        (<span class="dt">Just</span> (<span class="dt">Node</span> <span class="ch">&#39;F&#39;</span> <span class="dt">Nothing</span> <span class="dt">Nothing</span>))</a>
<a class="sourceLine" id="cb1-15" title="15">        (<span class="dt">Just</span> (<span class="dt">Node</span> <span class="ch">&#39;G&#39;</span> <span class="dt">Nothing</span> <span class="dt">Nothing</span>))</a>
<a class="sourceLine" id="cb1-16" title="16">      )</a>
<a class="sourceLine" id="cb1-17" title="17">    )</a>
<a class="sourceLine" id="cb1-18" title="18"></a>
<a class="sourceLine" id="cb1-19" title="19"><span class="ot">preOrder ::</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()) <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-20" title="20">preOrder access (<span class="dt">Node</span> char mLeft mRight) <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-21" title="21">  access char</a>
<a class="sourceLine" id="cb1-22" title="22"></a>
<a class="sourceLine" id="cb1-23" title="23">  <span class="kw">case</span> mLeft <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-24" title="24">    <span class="dt">Just</span> left <span class="ot">-&gt;</span> preOrder access left</a>
<a class="sourceLine" id="cb1-25" title="25">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">return</span> ()</a>
<a class="sourceLine" id="cb1-26" title="26"></a>
<a class="sourceLine" id="cb1-27" title="27">  <span class="kw">case</span> mRight <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-28" title="28">    <span class="dt">Just</span> right <span class="ot">-&gt;</span> preOrder access right</a>
<a class="sourceLine" id="cb1-29" title="29">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">return</span> ()</a></code></pre></div>
<p><span class="ascii">Gibbon</span>はこの関数と、それが処理する木構造を解析して、</p>
<figure>
<img src="/img/2019/hiw-gibbon/tree-and-array3.svg" alt="変換された配列。A, B, D, E, C, F, Gの順に要素が並んだただの配列" /><figcaption>変換された配列。<span class="ascii">A, B, D, E, C, F, G</span>の順に要素が並んだただの配列</figcaption>
</figure>
<p>👆のような、ただの配列（とそれに対する関数）にまとめて変換してしまう、というのです！</p>
<p>現代のコンピューターは、このような配列の要素にまとめてアクセス処理する方が、ポインターをたどって各要素を処理するより、たいてい遙かに速いです。<br />
<span class="ascii">Gibbon</span>はこの特性を活かすべく、我々<span class="ascii">Haskeller</span>が好んで使うような、ポインターだらけの木構造を可能な限り配列に変換することで、要素をまとめて処理する（<span class="ascii">traverse</span>する）演算の最適化を図るコンパイラーです。</p>
<p>ちなみに、元の木に対するノードの追加に相当する処理は、新しいノードに対するポインターを書き込む処理に変換するそうです。<br />
なので何度も追加を繰り返すと、あまり恩恵が受けられなくなってしまいそうです。</p>
<p>なかなか興味深いアイディアですが、個人的に聞きそびれた疑問が<span class="ascii">2</span>つあります。<br />
一つは、そもそも木構造を定義するような状況というのは、いろいろな順番でアクセスしたいし、新しい要素の追加も繰り返し行いたいケースではないでしょうか？<br />
例えば<a href="http://hackage.haskell.org/package/unordered-containers"><span class="ascii">unordered-containers</span></a>にある<code>HashMap</code>型は探索木を使った頻繁に使われるデータ構造ですが、<code>HashMap</code>を使う場合に行う処理の多くは、ランダムアクセスや要素の追加・削除でしょう。</p>
<p>なので、<span class="ascii">Gibbon</span>が最適化したい「木構造」というのは、どちらかというと探索木のような木ではなく、構文木のような、要素をまとめて処理することを前提とした木のことなのかもしれません。<br />
確かに人間が書く言語の構文木程度であれば、すべてメモリー上で処理できる程度のサイズに収まる<small>（という想定でなければコンパイラー作りがものすごく難しくなる）</small>でしょうし、構文木の処理を高速化できれば、遅い遅いと言われる<span class="ascii">GHC</span>のコンパイル速度も高められるはずです。それはそれでありがたい。</p>
<p>もう一つは、これまた例えば<code>HashMap</code>型のような木をベースにした連想配列も、配列ベースのハッシュテーブルに変換することができるのでしょうか？<br />
もしそうだとすると、ランダムアクセスに対する計算量のオーダーも<span class="ascii">O(log n)</span>から<span class="ascii">O(1)</span>に変わるわけですし、要素をまとめて処理する以外の演算についても劇的な改善が見込めるかもしれません。<br />
もちろんこれも先ほどの推測が正しければ無意味な想像ですが、夢のある話ですね。</p>
<p><span class="ascii">Gibbon</span>は将来的には、<code>Packed</code>という型クラスを提供することで、<span class="ascii">GHC</span>本体への統合も視野に入れているそうです。<br />
<code>Packed</code>を実装した型は、値をどのように配列に変換するのか定義することで、<span class="ascii">Gibbon</span>による最適化のためのヒントを与えることができます。</p>
<p>参考<span class="ascii">:</span> <a href="https://ja.wikipedia.org/w/index.php?title=%E6%9C%A8%E6%A7%8B%E9%80%A0_(%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0)&amp;oldid=72655479">木構造 <span class="ascii">(</span>データ構造<span class="ascii">) - Wikipedia</span></a></p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/hiw-ghc-future.html" style="margin-left: auto;" lang="ja">HIW 2019で発表された、GHC 8.10に導入されるであろう機能</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>HIW 2019で発表された、GHC 8.10に導入されるであろう機能</title>
    <link href="https://haskell.jp/blog/posts/2019/hiw-ghc-future.html" />
    <id>https://haskell.jp/blog/posts/2019/hiw-ghc-future.html</id>
    <published>2019-09-17T00:00:00Z</published>
    <updated>2019-09-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p><a href="/posts/2019/hiw-ghc8.8.html">前回</a>から引き続き、<a href="https://icfp19.sigplan.org/home/hiw-2019#About"><span class="ascii">Haskell Implementors</span>’ <span class="ascii">Workshop 2019</span></a>への参加レポートとして、私の印象に残った発表をいくつか紹介します。<br />
今回は、「<span class="ascii">GHC 8.10</span>に導入されるであろう機能」です。<br />
いずれも該当する<span class="ascii">Merge Request</span>は<span class="ascii">master</span>ブランチにマージ済みなので、おそらく<span class="ascii">GHC 8.10</span>で提供されるでしょう。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#holefitplugins-and-the-future-of-interactive-development-in-ghc" title="holefitplugins-and-the-future-of-interactive-development-in-ghc"><span class="ascii">HoleFitPlugins and the future of interactive development in GHC</span></a></li>
<li><a href="#visible-dependent-quantification" title="visible-dependent-quantification"><span class="ascii">Visible dependent quantification</span></a></li>
</ul>
</div>
</div>
<h2 id="holefitplugins-and-the-future-of-interactive-development-in-ghc"><span class="link-to-here-outer"><a href="#holefitplugins-and-the-future-of-interactive-development-in-ghc" title="holefitplugins-and-the-future-of-interactive-development-in-ghc"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">HoleFitPlugins and the future of interactive development in GHC</span></h2>
<ul>
<li>発表者<span class="ascii">: Matthías Páll Gissurarson</span> <em><span class="ascii">Chalmers University of Technology, Sweden</span></em></li>
<li>該当の<span class="ascii">Merge Request:</span> <a href="https://gitlab.haskell.org/ghc/ghc/merge_requests/153"><span class="ascii">!153</span></a></li>
<li>該当の<span class="ascii">GHC Proposal:</span> なし</li>
</ul>
<p><a href="https://icfp18.sigplan.org/details/haskellsymp-2018-papers/10/Suggesting-Valid-Hole-Fits-for-Typed-Holes-Experience-Report-">昨年の<span class="ascii">Haskell Symposium</span>でも発表</a>されて<span class="ascii">GHC 8.6</span>で導入された、「<span class="ascii">Valid Hole Fits</span>」という機能のさらなる拡張について。</p>
<p>まず、「<span class="ascii">Valid Hole Fits</span>」という機能について軽く紹介します<small>（詳しくは<a href="https://wataru86.github.io/slides/vhs/">こちらのスライド</a>が参考になるかと思います）</small>。<br />
「<span class="ascii">Valid Hole Fits</span>」はアンダースコア <code>_</code>で始まる識別子を書いたとき、<span class="ascii">GHC</span>が推論した型にマッチする関数をエラーメッセージに付記することで、ユーザーがどんな式を書けばよいか、ヒントを与えてくれるものです。</p>
<p>例えば、</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="fu">map</span> (<span class="fu">length</span> <span class="op">.</span> _someFunc) [<span class="dt">True</span>, <span class="dt">False</span>, <span class="dt">True</span>]</a></code></pre></div>
<p>上記のように、アンダースコア <code>_</code>で始まる識別子を書いたとき、</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">1</span><span class="op">:</span><span class="dv">16</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span></a>
<a class="sourceLine" id="cb2-2" title="2">    <span class="op">...</span></a>
<a class="sourceLine" id="cb2-3" title="3">      <span class="dt">Valid</span> hole fits include</a>
<a class="sourceLine" id="cb2-4" title="4"><span class="ot">        enumFrom ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Enum</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb2-5" title="5">          with <span class="fu">enumFrom</span> <span class="op">@</span><span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-6" title="6">          (imported from ‘<span class="dt">Prelude</span>’ (<span class="fu">and</span> originally defined <span class="kw">in</span> ‘<span class="dt">GHC.Enum</span>’))</a>
<a class="sourceLine" id="cb2-7" title="7"><span class="ot">        show ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb2-8" title="8">          with <span class="fu">show</span> <span class="op">@</span><span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-9" title="9">          (imported from ‘<span class="dt">Prelude</span>’ (<span class="fu">and</span> originally defined <span class="kw">in</span> ‘<span class="dt">GHC.Show</span>’))</a>
<a class="sourceLine" id="cb2-10" title="10"><span class="ot">        repeat ::</span> <span class="kw">forall</span> a<span class="op">.</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb2-11" title="11">          with <span class="fu">repeat</span> <span class="op">@</span><span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-12" title="12">          (imported from ‘<span class="dt">Prelude</span>’ (<span class="fu">and</span> originally defined <span class="kw">in</span> ‘<span class="dt">GHC.List</span>’))</a>
<a class="sourceLine" id="cb2-13" title="13"><span class="ot">        return ::</span> <span class="kw">forall</span> (<span class="ot">m ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>) a<span class="op">.</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb2-14" title="14">          with <span class="fu">return</span> <span class="op">@</span>[] <span class="op">@</span><span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-15" title="15">          (imported from ‘<span class="dt">Prelude</span>’ (<span class="fu">and</span> originally defined <span class="kw">in</span> ‘<span class="dt">GHC.Base</span>’))</a>
<a class="sourceLine" id="cb2-16" title="16"><span class="ot">        pure ::</span> <span class="kw">forall</span> (<span class="ot">f ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>) a<span class="op">.</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb2-17" title="17">          with <span class="fu">pure</span> <span class="op">@</span>[] <span class="op">@</span><span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-18" title="18">          (imported from ‘<span class="dt">Prelude</span>’ (<span class="fu">and</span> originally defined <span class="kw">in</span> ‘<span class="dt">GHC.Base</span>’))</a>
<a class="sourceLine" id="cb2-19" title="19"><span class="ot">        mempty ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> a</a>
<a class="sourceLine" id="cb2-20" title="20">          with <span class="fu">mempty</span> <span class="op">@</span>(<span class="dt">Bool</span> <span class="ot">-&gt;</span> [a0])</a>
<a class="sourceLine" id="cb2-21" title="21">          (imported from ‘<span class="dt">Prelude</span>’ (<span class="fu">and</span> originally defined <span class="kw">in</span> ‘<span class="dt">GHC.Base</span>’))</a></code></pre></div>
<p>といった具合に、アンダースコアで始まる識別子<code>_someFunc</code>の型を<code>Bool -&gt; [a0]</code>と推論した上で<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>、実際にその型に該当する関数を、当該のスコープにおいてアクセスできる関数の中から探して教えてくれる、それが「<span class="ascii">Valid Hole Fits</span>」という機能です。</p>
<p>今回発表された「<span class="ascii">HoleFitPlugins</span>」という機能は、名前のとおりこの「<span class="ascii">Valid Hole Fits</span>」に対するプラグイン機構です。<br />
「<span class="ascii">Valid Hole Fits</span>」が表示する「型にマッチした関数」を探す処理を、<span class="ascii">Haskell</span>のコードで書き換えられるようにしてくれます！</p>
<p>「そこまでする必要あるの？」という気もしてきますが、発表者曰く</p>
<ul>
<li><span class="ascii">Hoogle</span>をはじめ、<span class="ascii">TensorFlow</span>など<span class="ascii">GHC</span>の外部にあるものを利用して「型にマッチした関数」を探せるようにするために必要</li>
<li><span class="ascii">GHCi</span>とこの機構を組み合わせることで、もっとインタラクティブな開発を促進したい</li>
</ul>
<p>という意図があるそうです。</p>
<p>最新安定版の<span class="ascii">GHC</span>では利用できませんが、<a href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/extending_ghc.html#hole-fit-plugins">ドキュメントがこちら</a>にあるので、<span class="ascii">GHC</span>の<span class="ascii">HEAD</span><small>（<span class="ascii">master</span>ブランチで開発中のバージョン）</small>をコンパイルすれば使用できるようです。</p>
<p>加えて発表では、<code>_</code>で始まる識別子を書く際の構文を拡張することで、どのように<span class="ascii">candidate</span>を探すか指定できるようにする、なんて機能も紹介されました<small>（ドキュメントを読む限りこの機能はまだ<span class="ascii">HEAD</span>に入ってない？）</small>。<br />
例えば、<span class="ascii">Hoogle</span>を使って<span class="ascii">Valid Hole Fits</span>を探したいとき、次のように書くことで検索対象を<code>Control.Applicative</code>に限定する、といったことをできるようしてくれます。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="ot">g ::</span> [a] <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb3-2" title="2">g <span class="ot">=</span> _{hoogleLookup <span class="st">&quot;+Control.Applicative&quot;</span>}</a></code></pre></div>
<p><span class="ascii">Valid Hole Fits</span>の検索方法をその場で微調整したい、というときに使うものですね。</p>
<h2 id="visible-dependent-quantification"><span class="link-to-here-outer"><a href="#visible-dependent-quantification" title="visible-dependent-quantification"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Visible dependent quantification</span></h2>
<ul>
<li>発表者<span class="ascii">: Ryan Scott</span> <em><span class="ascii">Indiana University at Bloomington, USA</span></em></li>
<li>該当の<span class="ascii">Merge Request:</span> <a href="https://gitlab.haskell.org/ghc/ghc/merge_requests/378"><span class="ascii">!378</span></a></li>
<li>該当の<span class="ascii">GHC Proposal:</span> <a href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0081-forall-arrow.rst"><span class="ascii">0081-forall-arrow</span></a></li>
</ul>
<p>タイトルのとおり、「<span class="ascii">Visible dependent quantification</span>」という機能の紹介です。</p>
<p>最近のバージョンの<span class="ascii">GHCi</span>における<code>:kind</code>コマンドは、次のような、<span class="ascii">GHC</span>がサポートしていない構文の型注釈を出力することがあります。<br />
例えば</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="op">&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XKindSignatures</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="op">&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XPolyKinds</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="op">&gt;</span> <span class="kw">data</span> <span class="dt">SomeType</span> k (<span class="ot">a ::</span> k)</a>
<a class="sourceLine" id="cb4-4" title="4"><span class="op">&gt;</span> <span class="op">:</span>kind <span class="dt">SomeType</span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="dt">SomeType</span><span class="ot"> ::</span> <span class="kw">forall</span> k <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="op">*</span></a></code></pre></div>
<p>における、<code>SomeType :: forall k -&gt; k -&gt; *</code>の<code>forall k -&gt;</code>という部分です。<br />
現在の<span class="ascii">Haskell</span>で<code>forall k</code>などと書くときは、必ず</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="dt">SomeType</span><span class="ot"> ::</span> <span class="kw">forall</span> k<span class="op">.</span> k <span class="ot">-&gt;</span> <span class="op">*</span></a></code></pre></div>
<p>といった具合に、ピリオドで区切った構文になります。<br />
ところが先ほどの<code>:kind</code>の出力では、<code>forall k -&gt;</code>とあるとおり、<code>forall k</code>に<small>（型ではなく、カインドとしての）</small>関数を表す<code>-&gt;</code>が使われています。<br />
「<span class="ascii">Visible dependent quantification</span>」はまさにこれを、<code>:kind</code>コマンドによって出力される構文だけではなく、ユーザーが直接書ける構文にしよう、というものです。 <span class="ascii">GHC</span>に「依存型」という機能を加える「<span class="ascii">Dependent Haskell</span>」にも必要な機能だそうです。<br />
私自身はこの機能を使う機会がちょっと思い浮かばなかったので省略しますが、より詳しい解説は発表者である<a href="https://ryanglscott.github.io/2019/03/15/visible-dependent-quantification-in-haskell/"><span class="ascii">Ryan</span>自身による記事（英語）</a>をご覧ください。何が「<span class="ascii">Visible</span>」でどう「<span class="ascii">Dependent</span>」なのかわかるはずです。</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>復習<span class="ascii">:</span> この、「アンダースコアで始まる識別子<code>_someFunc</code>の型を<code>Bool -&gt; [a0]</code>と推論した上で」エラーメッセージにおいて<code>Found hole: _someFunc :: Bool -&gt; [a0]</code>と教えてくれるのが「<span class="ascii">Type Hole</span>」という機能なのでした。<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/hiw-gibbon.html" lang="ja">HIW 2019で発表された、Gibbonコンパイラーについて</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/hiw-ghc8.8.html" style="margin-left: auto;" lang="ja">HIW 2019で発表された、GHC 8.8で導入された機能</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>HIW 2019で発表された、GHC 8.8で導入された機能</title>
    <link href="https://haskell.jp/blog/posts/2019/hiw-ghc8.8.html" />
    <id>https://haskell.jp/blog/posts/2019/hiw-ghc8.8.html</id>
    <published>2019-09-11T00:00:00Z</published>
    <updated>2019-09-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>こんにちは。<br />
今回からいくつか、「<a href="https://icfp19.sigplan.org/home/hiw-2019#About"><span class="ascii">Haskell Implementors</span>’ <span class="ascii">Workshop 2019</span></a>」に私が先月参加した際のレポートとして、印象深い発表をテーマごとに分けた短い記事を執筆します。<br />
最近公開された<a href="https://www.haskell.org/ghc/download_ghc_8_8_1.html"><span class="ascii">GHC 8.8</span></a>の話はもちろん、未来の<span class="ascii">GHC</span>やその他の<span class="ascii">Haskell</span>の処理系を知るのによいイベントでしたので、その一部だけでも伝われば幸いです。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#そもそもhaskell-implementors-workshop-hiwとは" title="そもそもhaskell-implementors-workshop-hiwとは">そもそも<span class="ascii">Haskell Implementors</span>’ <span class="ascii">Workshop (HIW)</span>とは？</a></li>
<li><a href="#hie-files-in-ghc-8.8" title="hie-files-in-ghc-8.8"><span class="ascii">HIE files in GHC 8.8</span></a></li>
<li><a href="#ghc-status-report" title="ghc-status-report"><span class="ascii">GHC status report</span></a></li>
<li><a href="#とりあえず今回はここまで" title="とりあえず今回はここまで">とりあえず今回はここまで</a></li>
</ul>
</div>
</div>
<h1 id="そもそもhaskell-implementors-workshop-hiwとは"><span class="link-to-here-outer"><a href="#そもそもhaskell-implementors-workshop-hiwとは" title="そもそもhaskell-implementors-workshop-hiwとは"><span class="link-to-here">Link to<br />
here</span></a></span>そもそも<span class="ascii">Haskell Implementors</span>’ <span class="ascii">Workshop (HIW)</span>とは？</h1>
<p>シリーズ（？）第<span class="ascii">1</span>回目なので、簡単に<span class="ascii">HIW</span>そのものについて紹介しておきましょう。<br />
<span class="ascii">HIW</span>は、<a href="https://icfp19.sigplan.org/home"><span class="ascii">ICFP (International Conference on Functional Programming)</span></a>という関数型プログラミングについての国際会議に併設された、<span class="ascii">Haskell</span>の実装者のためのワークショップです。<br />
名前の通り、<span class="ascii">GHC</span>をはじめとする<span class="ascii">Haskell</span>の処理系<small>（あるいは、<span class="ascii">Haskell</span>で実装された言語処理系）</small>の実装に関する発表だけでなく、かなり緩いテーマの<span class="ascii">Lightning Talk</span>の時間があったり、<span class="ascii">GHC</span>の将来の方向性について自由に議論する時間もあったりしました。</p>
<p>今回はそのうち、掲題のとおり「<span class="ascii">HIW 2019</span>で発表された、<span class="ascii">GHC 8.8</span>で導入された機能」を紹介します。まずは「<span class="ascii">HIE files in GHC 8.8</span>」から。</p>
<h1 id="hie-files-in-ghc-8.8"><span class="link-to-here-outer"><a href="#hie-files-in-ghc-8.8" title="hie-files-in-ghc-8.8"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">HIE files in GHC 8.8</span></h1>
<p>発表者<span class="ascii">: Zubin Duggal, Matthew Pickering</span> <em><span class="ascii">University of Bristol</span></em></p>
<p><span class="ascii">GHC 8.8</span>で新たに追加された、<span class="ascii">HIE</span><small>（「<span class="ascii">Haskell Interface Extended</span>」の略と思われます）</small>ファイルについての発表です。<br />
コンパイル時に<span class="ascii">GHC</span>が得たモジュールの情報を、<a href="https://github.com/haskell/haskell-ide-engine"><span class="ascii">Haskell IDE Engine</span></a>などの<span class="ascii">IDE</span>のバックエンドが再利用しやすい形で出力する機能です。<br />
従来<span class="ascii">Haskell IDE Engine</span><small>（その裏で使われている<span class="ascii">ghc-mod</span>）</small>や<a href="https://github.com/ndmitchell/ghcid"><span class="ascii">ghcid</span></a>、<a href="https://github.com/chrisdone/intero"><span class="ascii">intero</span></a>などの、「<span class="ascii">IDE</span>バックエンド」<small>（エディターが入力の補完や入力したソースコードにおけるエラーを表示する際に通信するソフトウェア）</small>は、自前で<span class="ascii">GHC API</span>や<span class="ascii">GHCi</span>を呼ぶことで、型チェックしたり定義ジャンプに必要な位置情報を収集したりしていたのですが、そうした情報の収集をすべて<span class="ascii">GHC</span>自身が<span class="ascii">HIE</span>ファイルを出力することで賄えるようになる、ということです。</p>
<p>私は従来開発中、<code>stack test --pedantic --file-watch</code>などと<span class="ascii">Neovim</span>のターミナル機能で実行して実行ファイルをビルドしつつ、<span class="ascii">HIE</span>にエラーの表示や入力の補完をさせていたのですが、その際も二重にソースコードが解析されていたんですね！<br />
私がそのようにわざわざ<code>stack test</code>と<span class="ascii">HIE</span>を並行して実行させているのは、<span class="ascii">HIE</span>がしばしばフリーズしてしまったり<small>（<span class="ascii">Neovim</span>ごと再起動すれば直ることも多いんですが…😰）</small>、<span class="ascii">HIE</span>だけでは実行ファイルの作成やテストの実行ができない、という理由があるためです。<br />
<code>stack test</code>だけで<span class="ascii">HIE</span>ファイルが生成されるようになれば、エラーに関する情報やソースコードの解析結果といった情報が一元化されるので、より安定的に、より少ないリソースで<span class="ascii">HIE</span>が使えるようになるでしょう。本家<span class="ascii">Haskell IDE Engine</span>がサポートする日が楽しみです。</p>
<p>この、<span class="ascii">HIE</span>ファイルを利用するアプリケーションの例も紹介されました。<br />
<a href="https://github.com/wz1000/hie-lsp"><span class="ascii">hie-lsp</span></a>という小さな<span class="ascii">Language Server Protocol</span>の実装に加え、<a href="https://github.com/mpickering/hie-lsif"><span class="ascii">hie-lsif</span></a>という、<span class="ascii">HIE</span>ファイルから「<a href="https://github.com/microsoft/language-server-protocol/blob/master/indexFormat/specification.md"><span class="ascii">Language Server Index Format (LSIF)</span></a>」形式のファイルを作成するコマンドが印象的でした。<br />
この<span class="ascii">LSIF</span>というファイルは、例えば<span class="ascii">GitHub</span>のリポジトリ上でブラウザからソースコードを閲覧する際にも、定義ジャンプといった便利な機能を使えるようにするためのものです。リポジトリに置いたソースコードを処理系がどのように解釈したかを保存しておくことで、<span class="ascii">Language Server</span>はじめ処理系を実行することなく利用できるようにするものだそうです。<br />
現状は仕様策定中なためか、実際に<span class="ascii">LSIF</span>を解釈するアプリケーションは見つかりませんでしたが、今後の活用に期待が高まりますね。</p>
<p>加えて、<span class="ascii">HIE</span>ファイルが将来的にサポートしたい機能などについても発表されました。</p>
<ul>
<li>型クラスのインスタンスが、具体的にどの型のインスタンスとして解決されたかの出力
<ul>
<li>定義ジャンプしたときに、型クラス自身の宣言ではなく、実装に飛べるようにするため</li>
</ul></li>
<li>従来<span class="ascii">GHC</span>が分割コンパイルをサポートするために、モジュールの依存情報を出力していた「インターフェースファイル<small>（<code>.hi</code>という拡張子で出力されているあのファイル）</small>」との統合</li>
<li>すべての型推論の結果</li>
</ul>
<h1 id="ghc-status-report"><span class="link-to-here-outer"><a href="#ghc-status-report" title="ghc-status-report"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">GHC status report</span></h1>
<p>発表者<span class="ascii">: Simon Peyton Jones</span> <em><span class="ascii">Microsoft, UK</span></em></p>
<p><span class="ascii">GitLab</span>への移行や<span class="ascii">Hadrian</span>と呼ばれる新しいビルドシステムの導入など、インフラ周りでいろいろ変更があったこともあり、遅れてしまいましたが<span class="ascii">GHC 8.8</span>がもうすぐ出るよ、という内容の発表でした<small>（発表当時。もう<a href="https://www.haskell.org/ghc/blog/20190825-ghc-8.8.1-released.html"><span class="ascii">GHC 8.8</span>はリリースされています</a>）</small>。</p>
<p>言及された主な追加機能は以下のとおりです。</p>
<ul>
<li><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-TypeApplications"><code>TypeApplications</code></a>という言語拡張が、型変数だけでなくカインド変数に対しても適用できるようになりました。<br />
正直に言って、個人的に使いどころがまだまだなさそうな機能ではありますが…。</li>
<li><p><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-ScopedTypeVariables"><code>ScopedTypeVariables</code></a>という言語拡張を使った場合に、パターンマッチした変数に型注釈を付けることができるようになる、という機能がありまして、これが拡張されました。<br />
具体的には、従来下記のように書くことで、関数自体の型注釈にある型変数<code>a</code>と、パターンマッチした変数<code>x</code>に型注釈した<code>b</code>が等しくなるように書くことができたのを、</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="ot">f ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-2" title="2">f (<span class="dt">Just</span> (<span class="ot">x ::</span> b)) <span class="ot">=</span> <span class="co">{- ... -}</span></a></code></pre></div>
<p>さらに拡張して、関数自体の型注釈にある型変数<strong>ではない</strong><code>Int</code>と、パターンマッチした変数<code>x</code>に型注釈した<code>b</code>が等しくなるように書くことができるようにした、という拡張です。<br />
あたかも型変数でパターンマッチしているかのようですね。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="ot">f ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-2" title="2">f (<span class="dt">Just</span> (<span class="ot">x ::</span> b)) <span class="ot">=</span> <span class="co">{- ... -}</span></a></code></pre></div>
<p>一体何の役に立つの？とも思いましたが、<a href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0128-scoped-type-variables-types.rst#128motivation">この修正に向けた提案</a>曰く、</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="ot">f ::</span> <span class="dt">ReallyReallyReallyReallyLongTypeName</span> <span class="ot">-&gt;</span> <span class="dt">T</span></a>
<a class="sourceLine" id="cb3-2" title="2">f (<span class="ot">x ::</span> a) <span class="ot">=</span> … (<span class="fu">read</span> <span class="st">&quot;&quot;</span><span class="ot"> ::</span> a) …</a></code></pre></div>
<p>と書くことで、長い型名に対して別名を付けることができるようになる、というメリットがあるそうです。なるほど💡</p></li>
</ul>
<h1 id="とりあえず今回はここまで"><span class="link-to-here-outer"><a href="#とりあえず今回はここまで" title="とりあえず今回はここまで"><span class="link-to-here">Link to<br />
here</span></a></span>とりあえず今回はここまで</h1>
<p>テーマを絞って短い記事にした方が<span class="ascii">SEO</span>的にいいんじゃないかと思いまして、今回は敢えて紹介する発表を絞りました。<br />
今後は下記のテーマについて紹介する予定です。</p>
<ul>
<li><span class="ascii">HIW 2019</span>で発表された、これからの<span class="ascii">GHC</span>に入るであろう機能</li>
<li><span class="ascii">HIW 2019</span>で発表された、<span class="ascii">GHC</span>以外の言語処理系</li>
</ul>
<p>また、<span class="ascii">HIW</span>と同じく<span class="ascii">ICFP 2019</span>に併設して開催された、<a href="https://icfp19.sigplan.org/home/haskellsymp-2019"><span class="ascii">Haskell Symposium 2019</span></a>の発表についても別途共有する予定です。<br />
乞うご期待。<br />
<span class="ascii">hask(_ _)eller</span></p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/hiw-ghc-future.html" lang="ja">HIW 2019で発表された、GHC 8.10に導入されるであろう機能</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/fallible.html" style="margin-left: auto;" lang="ja">fallibleというパッケージをリリースしました</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>fallibleというパッケージをリリースしました</title>
    <link href="https://haskell.jp/blog/posts/2019/fallible.html" />
    <id>https://haskell.jp/blog/posts/2019/fallible.html</id>
    <published>2019-07-18T00:00:00Z</published>
    <updated>2019-07-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>タイトルの通り、<span class="ascii">fallible</span>というパッケージを紹介します。</p>
<ul>
<li><a href="https://github.com/matsubara0507/fallible"><span class="ascii">matsubara0507/fallible: interface for fallible data type like Maybe and Either. - GitHub</span></a></li>
</ul>
<p>ちなみに、<span class="ascii">fallible</span>は<span class="ascii">Haskell-jp Slack</span>で<span class="ascii">:</span></p>
<p><img src="../../img/2019/fallible/slack.jpg" style="width: 100%;"></p>
<p>と質問したところ、該当するようなパッケージは無さそうだったので作ったという経緯があります。 その際に助言をくれた <a href="https://github.com/fumieval"><span class="ascii">fumieval</span></a>氏のコードをほとんど引用した形になったので、<span class="ascii">Haskell-jp Blog</span>に紹介記事を載せることにしました<span class="ascii">(</span>僕は普段、自分のブログに自作したパッケージを書いています<span class="ascii">)</span>。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#fallibleパッケージ" title="fallibleパッケージ"><span class="ascii">fallible</span>パッケージ</a>
<ul>
<li><a href="#やってること" title="やってること">やってること</a></li>
<li><a href="#基本演算子" title="基本演算子">基本演算子</a></li>
</ul></li>
<li><a href="#サンプルコード" title="サンプルコード">サンプルコード</a></li>
<li><a href="#使い方" title="使い方">使い方</a></li>
<li><a href="#おしまい" title="おしまい">おしまい</a></li>
</ul>
</div>
</div>
<h2 id="fallibleパッケージ"><span class="link-to-here-outer"><a href="#fallibleパッケージ" title="fallibleパッケージ"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">fallible</span>パッケージ</h2>
<p><span class="ascii">Haskell</span>でアプリケーションを記述してると次のようなコードを書くことがありますよね？</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.List</span> <span class="kw">as</span> <span class="dt">L</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="ot">run ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Token</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-4" title="4">run targetName token verbose <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-5" title="5">  users <span class="ot">&lt;-</span> getUsers token</a>
<a class="sourceLine" id="cb1-6" title="6">  <span class="kw">case</span> users <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-7" title="7">    <span class="dt">Left</span> err <span class="ot">-&gt;</span> logDebug&#39; err</a>
<a class="sourceLine" id="cb1-8" title="8">    <span class="dt">Right</span> us <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-9" title="9">      <span class="kw">case</span> userId <span class="op">&lt;$&gt;</span> L.find isTarget us <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-10" title="10">        <span class="dt">Nothing</span>  <span class="ot">-&gt;</span> logDebug&#39; emsg</a>
<a class="sourceLine" id="cb1-11" title="11">        <span class="dt">Just</span> tid <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-12" title="12">          channels <span class="ot">&lt;-</span> getChannels token</a>
<a class="sourceLine" id="cb1-13" title="13">          <span class="kw">case</span> channels <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-14" title="14">            <span class="dt">Left</span> err  <span class="ot">-&gt;</span> logDebug&#39; err</a>
<a class="sourceLine" id="cb1-15" title="15">            <span class="dt">Right</span> chs <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-16" title="16">              <span class="kw">let</span> chs&#39; <span class="ot">=</span> <span class="fu">filter</span> (<span class="fu">elem</span> tid <span class="op">.</span> channelMembers) chs</a>
<a class="sourceLine" id="cb1-17" title="17">              <span class="fu">mapM_</span> (logDebug&#39; <span class="op">.</span> channelName) chs&#39;</a>
<a class="sourceLine" id="cb1-18" title="18">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-19" title="19">    logDebug&#39; <span class="ot">=</span> logDebug verbose</a>
<a class="sourceLine" id="cb1-20" title="20">    emsg <span class="ot">=</span> <span class="st">&quot;user not found: &quot;</span> <span class="op">++</span> targetName</a>
<a class="sourceLine" id="cb1-21" title="21">    isTarget user <span class="ot">=</span> userName user <span class="op">==</span> targetName</a>
<a class="sourceLine" id="cb1-22" title="22"></a>
<a class="sourceLine" id="cb1-23" title="23"><span class="ot">logDebug ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-24" title="24">logDebug verbose msg <span class="ot">=</span> <span class="kw">if</span> verbose <span class="kw">then</span> <span class="fu">putStrLn</span> msg <span class="kw">else</span> <span class="fu">pure</span> ()</a></code></pre></div>
<p><span class="ascii">Slack</span>のようなチャットツールをイメージしてください。 該当の名前<span class="ascii">(</span><code>targetName</code><span class="ascii">)</span>を持つユーザーを与えると、そのユーザーが参加しているチャンネルの一覧を表示するというような振る舞いです。 こう段々になってしまうのは気持ち悪いですよね。 <span class="ascii">fallible</span>の目的はこの段々を次のように平坦にすることです<span class="ascii">(</span><code>where</code> などは割愛<span class="ascii">):</span></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">import</span> <span class="dt">Data.Fallible</span> (evalContT, exit, lift, (!?=), (???))</a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="ot">run ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Token</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-4" title="4">run targetName token verbose <span class="ot">=</span> evalContT <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-5" title="5">  users    <span class="ot">&lt;-</span> lift (getUsers token) <span class="op">!?=</span> exit <span class="op">.</span> logDebug&#39;</a>
<a class="sourceLine" id="cb2-6" title="6">  targetId <span class="ot">&lt;-</span> userId <span class="op">&lt;$&gt;</span> L.find isTarget users <span class="op">???</span> exit (logDebug&#39; emsg)</a>
<a class="sourceLine" id="cb2-7" title="7">  channels <span class="ot">&lt;-</span> lift (getChannels token) <span class="op">!?=</span> exit <span class="op">.</span> logDebug&#39;</a>
<a class="sourceLine" id="cb2-8" title="8">  lift <span class="op">$</span> <span class="fu">mapM_</span> (logDebug&#39; <span class="op">.</span> channelName) <span class="op">$</span></a>
<a class="sourceLine" id="cb2-9" title="9">    <span class="fu">filter</span> (<span class="fu">elem</span> targetId <span class="op">.</span> channelMembers) channels</a></code></pre></div>
<h3 id="やってること"><span class="link-to-here-outer"><a href="#やってること" title="やってること"><span class="link-to-here">Link to<br />
here</span></a></span>やってること</h3>
<p>というか、もともとのアイデアは下記のブログです<span class="ascii">:</span></p>
<ul>
<li><a href="https://haskell.e-bigmoon.com/posts/2018/06-26-cont-param.html"><span class="ascii">ContT</span> を使ってコードを綺麗にしよう！ <span class="ascii">- BIGMOON Haskeller</span>’<span class="ascii">s BLOG</span></a></li>
</ul>
<p>これを一般化<span class="ascii">(</span><code>Maybe a</code> 固有ではなく <code>Either e a</code> でも使う<span class="ascii">)</span>できないかなぁというのがもともとの発想です。</p>
<h3 id="基本演算子"><span class="link-to-here-outer"><a href="#基本演算子" title="基本演算子"><span class="link-to-here">Link to<br />
here</span></a></span>基本演算子</h3>
<p>次の<span class="ascii">4</span>つの演算子を利用します<span class="ascii">:</span></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="ot">(!?=) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m (<span class="dt">Either</span> e a) <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="ot">(!??) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m (<span class="dt">Maybe</span> a) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb3-3" title="3"><span class="ot">(??=) ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Either</span> e a <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> f a) <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb3-4" title="4"><span class="ot">(???) ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a</a></code></pre></div>
<p>ただし、内部実装的には <code>Maybe a</code> や <code>Either e a</code> は <code>Fallible</code> 型クラスで一般化されています<span class="ascii">:</span></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">class</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Fallible</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" title="2">  <span class="kw">type</span> <span class="dt">Failure</span><span class="ot"> f ::</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="ot">  tryFallible ::</span> f a <span class="ot">-&gt;</span> <span class="dt">Either</span> (<span class="dt">Failure</span> f) a</a>
<a class="sourceLine" id="cb4-4" title="4"></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="kw">instance</span> <span class="dt">Fallible</span> <span class="dt">Maybe</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-6" title="6">  <span class="kw">type</span> <span class="dt">Failure</span> <span class="dt">Maybe</span> <span class="ot">=</span> ()</a>
<a class="sourceLine" id="cb4-7" title="7">  tryFallible <span class="ot">=</span> <span class="fu">maybe</span> (<span class="dt">Left</span> ()) <span class="dt">Right</span></a>
<a class="sourceLine" id="cb4-8" title="8"></a>
<a class="sourceLine" id="cb4-9" title="9"><span class="kw">instance</span> <span class="dt">Fallible</span> (<span class="dt">Either</span> e) <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-10" title="10">  <span class="kw">type</span> <span class="dt">Failure</span> (<span class="dt">Either</span> e) <span class="ot">=</span> e</a>
<a class="sourceLine" id="cb4-11" title="11">  tryFallible <span class="ot">=</span> <span class="fu">id</span></a>
<a class="sourceLine" id="cb4-12" title="12"></a>
<a class="sourceLine" id="cb4-13" title="13"><span class="ot">(!?=) ::</span> (<span class="dt">Monad</span> m, <span class="dt">Fallible</span> t) <span class="ot">=&gt;</span> m (t a) <span class="ot">-&gt;</span> (<span class="dt">Failure</span> t <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb4-14" title="14"><span class="ot">(???) ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Fallible</span> t) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a</a></code></pre></div>
<p>これらを継続モナドと組み合わせることで<span class="ascii">IO</span>と失敗系モナド<span class="ascii">(</span><code>Maybe a</code> や <code>Either e a</code><span class="ascii">)</span>を、モナドトランスフォーマーなしに<span class="ascii">Do</span>記法で書くことができます！</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="co">-- 継続モナドに関する関数</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="ot">evalConstT ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ContT</span> r m r <span class="ot">-&gt;</span> m r</a>
<a class="sourceLine" id="cb5-3" title="3"></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="ot">exit ::</span> m r <span class="ot">-&gt;</span> <span class="dt">ContT</span> r m a</a>
<a class="sourceLine" id="cb5-5" title="5">exit <span class="ot">=</span> <span class="dt">ContT</span> <span class="op">.</span> <span class="fu">const</span></a></code></pre></div>
<h2 id="サンプルコード"><span class="link-to-here-outer"><a href="#サンプルコード" title="サンプルコード"><span class="link-to-here">Link to<br />
here</span></a></span>サンプルコード</h2>
<p>疑似的な<span class="ascii">IO</span>で良いなら<a href="https://github.com/matsubara0507/fallible/tree/master/example"><span class="ascii">fallible</span>リポジトリの<span class="ascii">example</span>ディレクトリ</a>にあります<span class="ascii">(</span>上述の例はそれです<span class="ascii">)</span>。</p>
<p>実際の利用例であれば、最近自作した<a href="https://github.com/matsubara0507/mixlogue"><span class="ascii">matsubara0507/mixlogue</span></a>という<span class="ascii">Haskell</span>アプリケーションで多用しています<span class="ascii">(</span><a href="https://github.com/matsubara0507/mixlogue/blob/8afd16ab4048ff62976b8e38347078fdaa7417dd/src/Mixlogue/Cmd.hs#L81-L93">ココ</a>とか<a href="https://github.com/matsubara0507/mixlogue/blob/8afd16ab4048ff62976b8e38347078fdaa7417dd/src/Mixlogue/Message.hs#L15-L25">ココ</a>とか<span class="ascii">)</span>。 ちなみに、<span class="ascii">mixlogue</span>は特定の<span class="ascii">Slack</span>の分報チャンネル<span class="ascii">(</span><code>times_hoge</code><span class="ascii">)</span>の発言を収集するというだけのツールです。</p>
<h2 id="使い方"><span class="link-to-here-outer"><a href="#使い方" title="使い方"><span class="link-to-here">Link to<br />
here</span></a></span>使い方</h2>
<p><span class="ascii">README</span>を参照してください。</p>
<p>現状<span class="ascii">Hackage</span>にはあげてないので、<span class="ascii">stack</span>や<span class="ascii">Cabal</span>で<span class="ascii">GitHub</span>リポジトリから参照する方法を利用してください。</p>
<h2 id="おしまい"><span class="link-to-here-outer"><a href="#おしまい" title="おしまい"><span class="link-to-here">Link to<br />
here</span></a></span>おしまい</h2>
<p><span class="ascii">fumieval</span>氏のコードをほとんど引用するだけになったので自分でリリースするか迷ったんですけど、リリースしてくれというのも丸投げがひどいので自分でリリースしました。 まぁこういう結果が生まれるのも<span class="ascii">OSS</span>コミュニティの醍醐味ということで。 <span class="ascii">fumieval</span>氏、いつもアドバイスをくれてありがとう！</p>
<p><span class="ascii">(</span>もちろん他の<span class="ascii">Haskell-jp</span>の皆さんも！<span class="ascii">)</span></p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/hiw-ghc8.8.html" lang="ja">HIW 2019で発表された、GHC 8.8で導入された機能</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/strip-ansi-escape.html" style="margin-left: auto;" lang="ja">strip-ansi-escapeというパッケージをリリースしました</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>strip-ansi-escapeというパッケージをリリースしました</title>
    <link href="https://haskell.jp/blog/posts/2019/strip-ansi-escape.html" />
    <id>https://haskell.jp/blog/posts/2019/strip-ansi-escape.html</id>
    <published>2019-07-08T00:00:00Z</published>
    <updated>2019-07-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>現職で<span class="ascii">Haskell</span>を仕事で書き始めるようになってからというもの、度々小さなパッケージをリリースするようになりました。<br />
敢えてパッケージにするほどのものでもなさそうなぐらい小さなものが多いですが、もし再利用したくなったらな、という気持ちで書いております。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#なに作ったか" title="なに作ったか">なに作ったか</a></li>
<li><a href="#なぜ作ったか" title="なぜ作ったか">なぜ作ったか</a></li>
<li><a href="#最近のmmlh" title="最近のmmlh">最近の<span class="ascii">mmlh</span></a></li>
</ul>
</div>
</div>
<h1 id="なに作ったか"><span class="link-to-here-outer"><a href="#なに作ったか" title="なに作ったか"><span class="link-to-here">Link to<br />
here</span></a></span>なに作ったか</h1>
<p><a href="http://hackage.haskell.org/package/strip-ansi-escape"><span class="ascii">strip-ansi-escape</span></a>というパッケージです。<br />
今回もメインの処理は<span class="ascii">100</span>行にも満たないような小さなもので、また用途もニッチです。<br />
具体的には、名前のとおり<a href="https://en.wikipedia.org/wiki/ANSI_escape_code"><span class="ascii">ANSI</span>エスケープコード</a>を文字列から取り除く、ただそれだけです。<br />
使い方も極めてシンプル<span class="ascii">:</span></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1">ghci<span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">Data.String.AnsiEscapeCodes.Strip.Text</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="co">-- 現状Text型向けにしか作っていないため、OverloadedStringsを有効にした方が使いやすい</span></a>
<a class="sourceLine" id="cb1-4" title="4">ghci<span class="op">&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XOverloadedStrings</span></a>
<a class="sourceLine" id="cb1-5" title="5">ghci<span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">Data.Text</span></a>
<a class="sourceLine" id="cb1-6" title="6"></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="co">-- 出力すると下線付きで &quot;hello&quot; と表示されるANSIエスケープコード付きの文字列</span></a>
<a class="sourceLine" id="cb1-8" title="8">ghci<span class="op">&gt;</span> <span class="st">&quot;\x001B[4mhello\x001B[0m&quot;</span></a>
<a class="sourceLine" id="cb1-9" title="9"><span class="st">&quot;\ESC[4mhello\ESC[0m&quot;</span></a>
<a class="sourceLine" id="cb1-10" title="10"></a>
<a class="sourceLine" id="cb1-11" title="11">ghci<span class="op">&gt;</span> stripAnsiEscapeCodes <span class="st">&quot;\x001B[4mhello\x001B[0m&quot;</span></a>
<a class="sourceLine" id="cb1-12" title="12"><span class="st">&quot;hello&quot;</span></a></code></pre></div>
<h1 id="なぜ作ったか"><span class="link-to-here-outer"><a href="#なぜ作ったか" title="なぜ作ったか"><span class="link-to-here">Link to<br />
here</span></a></span>なぜ作ったか</h1>
<p>通常我々が<span class="ascii">ANSI</span>エスケープコードを扱うときは、<strong>ユーザーのために</strong>端末に文字列を分かりやすく表示したいときで、それをプログラムで再利用することは想定していません。<br />
そのため<span class="ascii">ANSI</span>エスケープコードを出力できるアプリケーションは、大抵の場合出力しないよう設定できる<small>（あるいは、出力先が<span class="ascii">tty</span>でないことを検出して出力しない）</small>ようになっています。<br />
なので、プログラムが<span class="ascii">ANSI</span>エスケープコードの混ざった文字列を扱わざるを得ない、という事態は、何かがおかしい事態だと言えるでしょう。</p>
<p>一体どういう事態なのかというと、それは私がずっと開発中の、対話的<span class="ascii">Haskell</span>入門コンテンツ — <a href="https://github.com/haskell-jp/makeMistakesToLearnHaskell">「失敗しながら学ぶ<span class="ascii">Haskell</span>入門」</a> — で出遭った事態でした。<br />
「失敗しながら学ぶ<span class="ascii">Haskell</span>入門」（以下、英語名を略して「<span class="ascii">mmlh</span>」と呼びます）では、ユーザーが書いた<span class="ascii">Haskell</span>のソースコードを受け取って、<span class="ascii">GHC</span>にコンパイルさせることで、型エラーなどのエラーメッセージを取得しています。<br />
当初から<span class="ascii">mmlh</span>はそれを簡単にパースしてユーザーへのヒントを出すのに使ったり、ユーザーにそのまま表示したりするのに使うため、<code>-fdiagnostics-color=always</code>というオプションを<span class="ascii">GHC</span>に渡していました。<br />
これは、エラーメッセージに色を着けるようになった<span class="ascii">GHC 8.2</span>から導入されたオプションで、「エラーメッセージに必ず<small>（<span class="ascii">ANSI</span>エスケープコードを使って）</small>色を着ける」というものです。<br />
<span class="ascii">GHC</span>が出すエラーメッセージを「簡単にパース」しつつ「ユーザーにそのまま表示」する、という<span class="ascii">2</span>つの要件を満たすためには、このオプションを利用して、強制的にエラーメッセージに色を着ける必要がありました。</p>
<p>さらに最近、<span class="ascii">GHC</span>が出したエラーメッセージをファイルに保存して、<a href="https://github.com/haskell-jp/makeMistakesToLearnHaskell/issues/101"><span class="ascii">GitHub</span>で閲覧できるようにする</a><small>（正確には、閲覧して各行にコメントできるようにする）</small>、という機能も追加した結果、<span class="ascii">ANSI</span>エスケープコードを取り除かざるを得なくなってしまったのです。<br />
というのも、<code>-fdiagnostics-color=always</code>を有効にしている限り、<span class="ascii">GHC</span>は必ず<span class="ascii">ANSI</span>エスケープコードをエラーメッセージに混ぜるので、ファイルに保存して<span class="ascii">GitHub</span>上で表示する際、下記のように余計な文字として混ざってしまい、エラーメッセージが読みづらくなってしまうためです。</p>
<pre><code>�[;1m16.hs:19:18: �[;1m�[31merror:�[0m�[0m�[;1m�[0m�[0m�[;1m
    • No instance for (Num ([Char], String))
        arising from a use of ‘countWords’
    • In the expression: countWords (concat wordsList)
      In an equation for ‘countMap’:
          countMap = countWords (concat wordsList)
      In the expression:
        do paths &lt;- getArgs
           wordsList &lt;- for paths scrapeWords
           let countMap = countWords (concat wordsList)
           for_ (toList countMap) catCount�[0m�[0m
�[;1m�[34m   |�[0m�[0m
�[;1m�[34m19 |�[0m�[0m   let countMap = �[;1m�[31mcountWords (concat wordsList)�[0m�[0m
�[;1m�[34m   |�[0m�[0m�[;1m�[31m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^�[0m�[0m
�[0m�[0m�[0m</code></pre>
<p><code>-fdiagnostics-color=always</code>を有効にしなければこんな問題は起こらないのですが、そうすると今度はユーザーにエラーメッセージを表示させる際、色が着かなくなってしまいます。<br />
せっかく<span class="ascii">GHC 8.2</span>以降を使っているのに色つきのエラーメッセージが見られないのは残念ですよね。<br />
<span class="ascii">GHC</span>を<span class="ascii">2</span>回実行することで、ユーザーに表示する用のエラーメッセージとファイルに保存する用のエラーメッセージを分けることもできますが、それでは効率が悪いでしょうし。</p>
<p>そんなわけで、<span class="ascii">GHC</span>が出力するエラーメッセージを<strong>ユーザーに端末上で表示する用途と、<span class="ascii">ANSI</span>エスケープコードを解釈しない箇所で表示する用途</strong>、両方に使用したくなったため、今回敢えて<span class="ascii">ANSI</span>エスケープコードを取り除くライブラリーを作りました。<br />
もし他に同じような事態に出遭った方がいらっしゃいましたら、試してみてください🙏</p>
<h1 id="最近のmmlh"><span class="link-to-here-outer"><a href="#最近のmmlh" title="最近のmmlh"><span class="link-to-here">Link to<br />
here</span></a></span>最近の<span class="ascii">mmlh</span></h1>
<p>ついでにここ数ヶ月弊社でやっている、<span class="ascii">mmlh</span>を使った社内勉強会のお話も書こうかと思いましたが、やっぱり社内でのことなんで、<a href="https://eng-blog.iij.ad.jp/">会社のブログ</a>に書くことにします。<br />
<del>多分今週中には上げますので乞うご期待！</del><br />
⬇️大分遅くなってしまいましたが公開しました！</p>
<p><a href="https://eng-blog.iij.ad.jp/archives/3467"><span class="ascii">Haskell</span>社内勉強会と<span class="ascii">Haskell</span>学習ツールの紹介 <span class="ascii">| IIJ Engineers Blog</span></a></p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/fallible.html" lang="ja">fallibleというパッケージをリリースしました</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/asterius.html" style="margin-left: auto;" lang="ja">AsteriusでHaskellの関数をJSから呼べるようにしてみた（けど失敗）（拡大版）</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>AsteriusでHaskellの関数をJSから呼べるようにしてみた（けど失敗）（拡大版）</title>
    <link href="https://haskell.jp/blog/posts/2019/asterius.html" />
    <id>https://haskell.jp/blog/posts/2019/asterius.html</id>
    <published>2019-05-04T00:00:00Z</published>
    <updated>2019-05-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>先日、<a href="https://emsn.connpass.com/event/121028/"><span class="ascii">Emscripten &amp; WebAssembly night !! #7</span></a>というイベントにて、<a href="https://tweag.github.io/asterius/"><span class="ascii">Asterius</span></a>という<span class="ascii">Haskell</span>を<span class="ascii">WebAssembly</span>にコンパイルするツールについて紹介いたしました。<br />
資料はこちら👇です。</p>
<p><a href="https://the.igreque.info/slides/2019-04-19-asterius.html#(1)"><span class="ascii">Asterius</span>で<span class="ascii">Haskell</span>の関数を<span class="ascii">JS</span>から呼べるようにしてみた（けど失敗）</a></p>
<p>本日は、スライドの英語で書いていた箇所を和訳しつつ、いろいろ捕捉してブログ記事の形で共有します。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#asteriusとは何か" title="asteriusとは何か">🔍<span class="ascii">Asterius</span>とは何か</a></li>
<li><a href="#asteriusのいいところ" title="asteriusのいいところ">👍<span class="ascii">Asterius</span>のいいところ</a></li>
<li><a href="#asteriusのイマイチなところ" title="asteriusのイマイチなところ">👎<span class="ascii">Asterius</span>のイマイチなところ</a></li>
<li><a href="#asteriusの仕組み" title="asteriusの仕組み">⚙️<span class="ascii">Asterius</span>の仕組み</a></li>
<li><a href="#asteriusでhaskell製の関数を実行してみた" title="asteriusでhaskell製の関数を実行してみた"><span class="ascii">Asterius</span>で<span class="ascii">Haskell</span>製の関数を実行してみた</a>
<ul>
<li><a href="#結果" title="結果">結果</a></li>
</ul></li>
<li><a href="#おわりに" title="おわりに">✅おわりに</a></li>
</ul>
</div>
</div>
<h1 id="asteriusとは何か"><span class="link-to-here-outer"><a href="#asteriusとは何か" title="asteriusとは何か"><span class="link-to-here">Link to<br />
here</span></a></span>🔍<span class="ascii">Asterius</span>とは何か</h1>
<p>冒頭でも触れたとおり、<a href="https://tweag.github.io/asterius/"><span class="ascii">Asterius</span></a>は<span class="ascii">Haskell</span>のソースを<a href="https://developer.mozilla.org/ja/docs/WebAssembly"><span class="ascii">WebAssembly</span></a>にコンパイルするコンパイラーです。<br />
<span class="ascii">GHC</span>の<span class="ascii">HEAD</span><small>（開発中のバージョン）</small>を都度フォークして、現在活発に開発中です。<br />
<span class="ascii">Template Haskell</span>と、<span class="ascii">GHC</span>標準における<span class="ascii">IO</span>を行う関数（の大半）を除いた、すべての機能が利用できるようになっています。<br />
現状の<span class="ascii">WebAssembly</span>を実用する上で必要不可欠であろう、<span class="ascii">FFI</span>もサポートされています。<br />
つまり、<span class="ascii">JavaScript</span>から<span class="ascii">WebAssembly</span>にコンパイルされた<span class="ascii">Haskell</span>の関数を呼んだり、<span class="ascii">Haskell</span>から<span class="ascii">JavaScript</span>の関数を呼ぶことができます！<br />
何かしらの<span class="ascii">IO</span>処理を行う場合は、基本的にこの<span class="ascii">FFI</span>を使って<span class="ascii">JavaScript</span>の関数を呼ぶことになります。</p>
<p>加えて、<code>ahc-cabal</code>という名前のコマンドで、<span class="ascii">cabal</span>パッケージを利用することもできます。<br />
こちらは<code>cabal</code>コマンドの単純なラッパーです。<code>ahc-cabal new-build</code>などと実行すれば、外部のパッケージに依存したアプリケーションも、まとめて<span class="ascii">WebAssembly</span>にコンパイルできます。<br />
本格的に開発する上では欠かせないツールでしょう。</p>
<h1 id="asteriusのいいところ"><span class="link-to-here-outer"><a href="#asteriusのいいところ" title="asteriusのいいところ"><span class="link-to-here">Link to<br />
here</span></a></span>👍<span class="ascii">Asterius</span>のいいところ</h1>
<p><span class="ascii">Asterius</span>は、“<span class="ascii">A linker which performs aggressive dead-code elimination, producing as small WebAssembly binary as possible.</span>”と謳っているとおり、<span class="ascii">GHC</span>のランタイムを抱えているにしては、比較的小さい<span class="ascii">WASM</span>ファイルを生成するそうです。<br />
というわけで手元で試してみたところ、下記のような結果になりました。</p>
<ul>
<li>空っぽのプログラム（<code>main = return ()</code>しかしないソース）<span class="ascii">:</span>
<ul>
<li><span class="ascii">36KB</span>（<code>.wasm</code>ファイルのみ）。なかなかいい感じですね。</li>
<li><span class="ascii">168KB</span>（実行時に必要な<code>.mjs</code>ファイルを含めた合計）。未圧縮でこれなら確かに十分軽いでしょう。<span class="ascii">Webpack</span>などで結合・<span class="ascii">minify</span>するともっと軽くできますし。</li>
</ul></li>
<li>今回私が移植を試みたアプリ（詳細は後ほど）<span class="ascii">:</span>
<ul>
<li><span class="ascii">1.9MB</span>（<code>.wasm</code>ファイルのみ）。うーん、ちょっと苦しいような…😥。</li>
<li><span class="ascii">2.1MB</span>（実行時に必要な<code>.mjs</code>ファイルを含めた合計）。<code>.mjs</code>ファイルの内容は特に変わりませんでした。</li>
</ul></li>
</ul>
<p>ちなみに、移植前の元のソースを含むアプリを、<span class="ascii">Linux 64bit</span>向けの<span class="ascii">ELF</span>ファイルとしてビルドして比較してみたところ、<code>.wasm</code>ファイルよりも少し小さいぐらいでした。<br />
詳細な内訳が気にはなりますが、今のソースですと大体これぐらいが限界なのかも知れません<small>（でも<span class="ascii">WASM</span>は現状<span class="ascii">32bit</span>バイナリー相当のはずだし、もう少し小さくならないものか…）</small>。</p>
<p>加えて、<span class="ascii">Asterius</span>を利用して開発すると、ほぼ最新の<span class="ascii">GHC</span>の開発版が使える、というところも、新しもの好きな<span class="ascii">Haskeller</span>をわくわくさせるところですね！<small>（今回はあいにく新しい機能について調べる余裕もなかったので、特に恩恵は受けてませんが…😅）</small><br />
<span class="ascii">Asterius</span>は、<span class="ascii">GHC</span>をフォークしていくつかの機能を追加して作られているものです。<br />
しかし幸いオリジナルとの差分が十分に小さく、作者が定期的に<span class="ascii">rebase</span>することができています。<br />
詳細な違いは<a href="https://tweag.github.io/asterius/custom-ghc/"><span class="ascii">About the custom GHC fork</span></a>にまとまっています。近い将来<span class="ascii">GHC</span>本体に取り込まれそうな修正ばかりではないかと。</p>
<p>それからこれは、ブラウザーで<span class="ascii">Haskell</span>を動かすことができるという点で<span class="ascii">Asterius</span>の競合に当たる、<span class="ascii">GHCJS</span>と比較した場合の話ですが、<span class="ascii">FFI</span>を利用して、<span class="ascii">JavaScript</span>から<strong>直接</strong><span class="ascii">Haskell</span>を呼ぶことができるようになっているのも、優れた点と言えるでしょう。<br />
<span class="ascii">GHCJS</span>は<a href="https://github.com/ghcjs/ghcjs/blob/3959a9321a2d3e2ad4b8d4c9cc436fcfece99237/doc/foreign-function-interface.md#calling-haskell-from-javascript">こちらのドキュメント曰く</a>、<span class="ascii">JavaScript</span>から<span class="ascii">Haskell</span>を呼ぶ機能は備えてはいるものの、簡単ではないためドキュメントも書かれておらず、推奨されていません。<br />
これでは状況によってはかなり使いづらいでしょう。<br />
今回私が試したように、コアとなる処理だけを<span class="ascii">Haskell</span>の関数として書いて、それを<span class="ascii">JavaScript</span>から呼び出すということができないのです。</p>
<p>一方<span class="ascii">Asterius</span>では、例えば👇のように書くことで、<span class="ascii">WASM</span>がエクスポートする関数として、<code>func</code>を<span class="ascii">JavaScript</span>から呼べるようにすることができます！</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1">foreign export javascript <span class="st">&quot;func&quot;</span><span class="ot"> func ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a></code></pre></div>
<p>ただし、実際に今回試してみたところ、<span class="ascii">Asterius</span>ではまだバグがあったので、この用途では依然使いにくいという状況ではありますが…（詳細は後で触れます）。</p>
<h1 id="asteriusのイマイチなところ"><span class="link-to-here-outer"><a href="#asteriusのイマイチなところ" title="asteriusのイマイチなところ"><span class="link-to-here">Link to<br />
here</span></a></span>👎<span class="ascii">Asterius</span>のイマイチなところ</h1>
<p><span class="ascii">Asterius</span>は、やっぱりまだまだ開発中で、バグが多いです。<br />
今回の目的もバグのために果たせませんでした😢。</p>
<p>先ほども触れたとおり、特に未完成なのが、<span class="ascii">IO</span>と<span class="ascii">Template Haskell</span>です。<br />
<span class="ascii">GHC</span>なら使えるはずの<code>IO</code>な関数の多くが使えませんし、<span class="ascii">Template Haskell</span>に至っては一切利用できません。</p>
<p><span class="ascii">IO</span>については、現状、<small>（<code>putStrLn</code>などのよく使われる）</small>一部を除き、<span class="ascii">FFI</span><small>（<code>foreign import javascript</code>）</small>を使って<span class="ascii">JavaScript</span>の関数経由でよばなけれなりません。<br />
これは、入出力関連の<span class="ascii">API</span>を一切持たないという現状の<span class="ascii">WebAssembly</span>の事情を考えれば、致し方ない仕様だとも言えます。<br />
<a href="https://github.com/WebAssembly/WASI"><span class="ascii">WASI</span></a>の策定によってこの辺の事情が変わるまでの間に、すべて<code>foreign import javascript</code>で賄うというのも、なかなか面倒なことでしょうし。</p>
<p><span class="ascii">Template Haskell</span>に関しては、現在<a href="https://github.com/tweag/asterius/pull/81">こちらのブランチ</a>で開発中です。…と、思ったらこの<span class="ascii">Pull request</span>、<span class="ascii">Close</span>されてますね…。<br />
これに関して詳しい事情はわかりません。いずれにしても、<span class="ascii">Template Haskell</span>を実装するには、コンパイル時にその場で<span class="ascii">Haskell</span>を評価するためのインタープリターが別途必要だったりして、結構ハードルが高いのです。</p>
<p>加えて、<span class="ascii">RTS</span><small>（この場合、コンパイルした<span class="ascii">Haskell</span>を動かすのに必要な<span class="ascii">WASM</span>や<span class="ascii">JavaScript</span>ファイル）</small>が<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/BigInt"><code>BigInt</code></a>に依存している関係で、<span class="ascii">V8</span>や<span class="ascii">SpiderMonkey</span>でないと動かない点もまだまだ、という感じです。<br />
ブラウザーで言うと、<span class="ascii">2019</span>年<span class="ascii">5</span>月<span class="ascii">3</span>日時点で<span class="ascii">Chrome</span>か、<span class="ascii">Firefox</span>の<span class="ascii">Beta</span>版以降でないと使用できません<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>。</p>
<h1 id="asteriusの仕組み"><span class="link-to-here-outer"><a href="#asteriusの仕組み" title="asteriusの仕組み"><span class="link-to-here">Link to<br />
here</span></a></span>⚙️<span class="ascii">Asterius</span>の仕組み</h1>
<p><span class="ascii">Asterius</span>のドキュメント「<a href="https://tweag.github.io/asterius/ir/"><span class="ascii">IR types and transformation passes</span></a>」をざっくり要約してみると、<span class="ascii">Asterius</span>は以下のような流れで動くそうです。<br />
実際には<code>ahc-link</code>というコマンドがこれらの手順をまとめて実行するので、ユーザーの皆さんはあまり意識する必要はないでしょう。</p>
<ol type="1">
<li><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/extending_ghc.html#frontend-plugins">フロントエンドプラグイン</a>という仕組みでラップした<span class="ascii">GHC</span><small>（のフォーク）</small>を使い、<span class="ascii">GHC</span>が生成した<span class="ascii">Cmm</span>という中間言語で書かれたコードを、<code>AsteriusModule</code>という独自のオブジェクトに変換します。</li>
<li><code>ahc-ld</code>という専用のリンカーで、<span class="ascii">WASM</span>向けにリンクします。</li>
<li>最後に、<code>ahc-dist</code>というコマンドで、リンクしたモジュールを実行できる状態にします。
<ul>
<li><a href="https://github.com/WebAssembly/binaryen"><span class="ascii">binaryen</span></a>か、<a href="https://github.com/tweag/asterius/tree/master/wasm-toolkit"><span class="ascii">wasm-toolkit</span></a>という<span class="ascii">Haskell</span>で<span class="ascii">WASM</span>を書く言語内<span class="ascii">DSL</span>を利用して、<code>ahc-ld</code>がリンクしたモジュールを検証し、<code>.wasm</code>ファイルに変換して、</li>
<li>実行時に必要な<span class="ascii">JavaScript</span>ファイルをコピーして、</li>
<li><span class="ascii">Haskell</span>のソースにおける<code>main</code>関数を実行する、エントリーモジュールを作ります。<br />
あとはこれを<span class="ascii">HTML</span>ファイルから<code>&lt;script&gt;</code>タグで参照すれば、ブラウザー上で<span class="ascii">Haskell</span>が動きます。</li>
</ul></li>
</ol>
<h1 id="asteriusでhaskell製の関数を実行してみた"><span class="link-to-here-outer"><a href="#asteriusでhaskell製の関数を実行してみた" title="asteriusでhaskell製の関数を実行してみた"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Asterius</span>で<span class="ascii">Haskell</span>製の関数を実行してみた</h1>
<p>ここからは、私が以前作った<a href="https://github.com/igrep/igrep-cashbook/tree/master/hs2">アプリケーション</a>のコアに当たる関数を<span class="ascii">Asterius</span>でコンパイルすることで、ブラウザー上で動かせるようチャレンジした時の体験談を紹介します。</p>
<p>今回試みたアプリケーションは、単純なコマンドラインアプリケーションです。<br />
詳細は省きますが、行単位で書かれたファイルをパースして、項目ごとの合計を計算するだけの、ありふれたものです。<br />
パーサーは<a href="http://hackage.haskell.org/package/megaparsec"><span class="ascii">megaparsec</span></a>を使って作り、整数の四則演算ができるようなっているのも特徴です。<br />
そのアプリケーションの処理のほとんどすべてに当たる、ファイル名とその中身を受け取って、計算結果を文字列で返す関数（<code>FilePath -&gt; Text -&gt; Text</code>）を、<span class="ascii">FFI</span>でエクスポート<small>（<code>foreign export javascript</code>）</small>し、<span class="ascii">JavaScript</span>から呼べるようにしてみました。</p>
<p>アプリケーション自体の書き換えはほとんど必要なかったものの、依存関係を減らしたり、依存するパッケージを書き換えたりするのが大変でした。<br />
というのも、先ほど触れたとおり、<span class="ascii">Asterius</span>は現状「<span class="ascii">Template Haskell</span>と、<span class="ascii">GHC</span>標準における<span class="ascii">IO</span>を行う関数（の大半）」が一切使用できないので、取り除かなければコンパイルエラーになってしまいます。<br />
<span class="ascii">template-haskell</span>パッケージに間接的に依存しているだけで依存関係の解決すらできないのはなかなかつらいものでした。<br />
<a href="https://docs.haskellstack.org/en/stable/dependency_visualization/"><code>stack dot</code></a>コマンドを使って依存関係のツリーを作り、それを見て<span class="ascii">template-haskell</span>パッケージに間接的に依存しているパッケージを割り出し、そのパッケージの必要な関数のみを切り出すことでどうにか回避できました。<br />
<a href="http://hackage.haskell.org/package/monoidal-containers"><span class="ascii">monoidal-containers</span></a>パッケージと<a href="http://hackage.haskell.org/package/foldl"><span class="ascii">foldl</span></a>パッケージがそれでした。<br />
幸い、どちらも依存しているのはごく一部だったで、必要な部分だけをコピペして使うことにしました。<br />
それから、<code>IO</code>への依存もなくすために、<a href="http://hackage.haskell.org/package/text"><span class="ascii">text</span></a>パッケージから<code>*.IO</code>なモジュールを取り除いたりもしました。</p>
<p>当然、元々のアプリケーションも<span class="ascii">text</span>パッケージの<code>*.IO</code>なモジュールを使ってはいたので、それを使わないよう修正する必要がありました。<br />
しかしそこは<span class="ascii">Haskell</span>。そうした<code>IO</code>に依存した関数から純粋な関数を切り出すのは、型システムのおかげで大変楽ちんでした！😤<br />
入出力をするのに<span class="ascii">JavaScript</span>の<span class="ascii">FFI</span>を使わないといけない、という現状の<span class="ascii">WebAssembly</span>の制約が、偶然にもマッチしたわけですね！<br />
純粋じゃない関数はときめかないので捨て去ってしまいましょう✨</p>
<h2 id="結果"><span class="link-to-here-outer"><a href="#結果" title="結果"><span class="link-to-here">Link to<br />
here</span></a></span>結果</h2>
<p>ここまで頑張った結果、目的の関数を<code>foreign export javascript</code>してコンパイルを通すことはできました🎉<br />
しかし、実際にブラウザー上で動かしてみたところ、<a href="https://github.com/tweag/asterius/issues/105"><span class="ascii">Asterius</span>の<span class="ascii">FFI</span>のバグ</a>にハマってしまいました…😢 肝心の<code>foreign export javascript</code>した関数が、返すべき値を返してくれないのです！<br />
恐らく<code>foreign export javascript</code>を使わずに、<span class="ascii">Haskell</span>側から<span class="ascii">JavaScript</span>の関数を呼ぶようにしていれば、今回の問題は回避できたのではないかと思います。<br />
しかし、それは今回のゴールではありませんし、あまり便利ではないのでひとまず移植は見送ることにしました。残念！</p>
<h1 id="おわりに"><span class="link-to-here-outer"><a href="#おわりに" title="おわりに"><span class="link-to-here">Link to<br />
here</span></a></span>✅おわりに</h1>
<p>今回<span class="ascii">Asterius</span>を試したことで、ブラウザー上で<span class="ascii">Haskell</span>を動かす、もう一つの可能性を知ることができました。<br />
とは言え、バグが多かったり依存関係から<span class="ascii">IO</span>や<span class="ascii">Template Haskell</span>を抜き出さなければならなかったりで、まだまだ実用的とは言い難いでしょう。<br />
しかし、今回報告したバグが直れば、ブラウザーによる処理のコアに当たる部分を<span class="ascii">Haskell</span>で書く、という応用が利きそうです。<br />
例えば<span class="ascii">Pandoc</span>など<span class="ascii">Haskell</span>製アプリケーションをブラウザーから操作する、なんてアプリケーション作りが捗りそうですね！</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="https://caniuse.com/#feat=bigint"><span class="ascii">Can I use</span></a>曰く安定版でも<code>about:config</code>を書き換えればすでに使えるとのことなんですが、なぜか手元の<span class="ascii">Firefox</span> 安定版ではうまくいきませんでした。確かに<code>about:config</code>にそれらしき設定はあるものの、<code>true</code>にしても何も変わらず…😰。<br />
ついでに細かいことを言うと、<span class="ascii">Firefox Nightly</span>は<code>about:config</code>を書き換えなくても使え、<span class="ascii">Beta</span>版では<code>about:config</code>を書き換えると使えました。<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/strip-ansi-escape.html" lang="ja">strip-ansi-escapeというパッケージをリリースしました</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/stack-ghc8.8.html" style="margin-left: auto;" lang="ja">GHC 8.8.1 alphaをstackでダウンロードして手持ちのパッケージをビルドする</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>GHC 8.8.1 alphaをstackでダウンロードして手持ちのパッケージをビルドする</title>
    <link href="https://haskell.jp/blog/posts/2019/stack-ghc8.8.html" />
    <id>https://haskell.jp/blog/posts/2019/stack-ghc8.8.html</id>
    <published>2019-05-02T00:00:00Z</published>
    <updated>2019-05-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>先日、我らが<span class="ascii">Haskell</span>のデファクトスタンダードなコンパイラー、<a href="https://mail.haskell.org/pipermail/ghc-devs/2019-April/017550.html"><span class="ascii">GHC</span>のバージョン<span class="ascii">8.8.1-alpha1</span>がリリースされました</a>。<br />
このリリースはまだアルファ版であることからわかるとおり、主にテスト目的で使用するためのものです。<br />
なのでいち早く試してみて、<span class="ascii">GHC</span>のデバッグに貢献してみましょう。</p>
<p>そこで今回は、最近<span class="ascii">Haskell</span>を始めた方なら使っている方も多いであろう、<span class="ascii">stack</span>を使ってこの新しい<span class="ascii">GHC</span>をインストールし、あなたのライブラリー・アプリケーションでテストする方法を紹介いたします。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#tldr-cabal-installでやったほうがよさそう" title="tldr-cabal-installでやったほうがよさそう"><span class="ascii">TL;DR cabal-install</span>でやったほうがよさそう</a></li>
<li><a href="#setup-infoを作る" title="setup-infoを作る"><span class="ascii">1.</span> <code>setup-info</code>を作る</a></li>
<li><a href="#必要ならallow-newerを有効にする" title="必要ならallow-newerを有効にする"><span class="ascii">2.</span> （必要なら）<span class="ascii">allow-newer</span>を有効にする</a></li>
<li><a href="#package-indicesを設定してhead.hackageを利用できるようにする" title="package-indicesを設定してhead.hackageを利用できるようにする"><span class="ascii">3. package-indices</span>を設定して、<span class="ascii">head.hackage</span>を利用できるようにする</a></li>
<li><a href="#stack-buildを実行しつつひたすらextra-depsを追加編集" title="stack-buildを実行しつつひたすらextra-depsを追加編集"><span class="ascii">4. stack build</span>を実行しつつ、ひたすら<span class="ascii">extra-deps</span>を追加・編集</a>
<ul>
<li><a href="#それでもうまくいかない場合-extra-depsを使い倒す" title="それでもうまくいかない場合-extra-depsを使い倒す">それでもうまくいかない場合<span class="ascii">:</span> <code>extra-deps</code>を使い倒す</a>
<ul>
<li><a href="#自分以外の人が対象のパッケージを修正した場合" title="自分以外の人が対象のパッケージを修正した場合">自分以外の人が対象のパッケージを修正した場合<span class="ascii">:</span></a></li>
<li><a href="#自分で対象のパッケージを修正するという場合" title="自分で対象のパッケージを修正するという場合">自分で対象のパッケージを修正する、という場合<span class="ascii">:</span></a></li>
<li><a href="#対象のパッケージがgitリポジトリーで管理されてない場合は" title="対象のパッケージがgitリポジトリーで管理されてない場合は">対象のパッケージが<span class="ascii">Git</span>リポジトリーで管理されてない場合は？</a></li>
</ul></li>
</ul></li>
<li><a href="#番外編-operation-vanguard" title="番外編-operation-vanguard">番外編<span class="ascii">: Operation Vanguard</span></a></li>
</ul>
</div>
</div>
<h1 id="tldr-cabal-installでやったほうがよさそう"><span class="link-to-here-outer"><a href="#tldr-cabal-installでやったほうがよさそう" title="tldr-cabal-installでやったほうがよさそう"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">TL;DR cabal-install</span>でやったほうがよさそう</h1>
<p>いきなりやろうとすることを真っ向から否定するようで恐縮ですが…😅<br />
実際に私が試しにビルドしてみた感じ、普通に<a href="https://www.haskell.org/cabal/download.html"><span class="ascii">cabal-install</span>をこちらから</a>インストールして、<code>cabal new-build --with-ghc=ghc-8.8.0.20190424</code>などと実行した方がいいんじゃないかという気がしました…。<br />
<span class="ascii">cabal-install</span>には<span class="ascii">GHC</span>をインストールする機能はないので、その場合は<span class="ascii">GHC</span>は別途インストールすることになります<small>（<a href="https://github.com/haskell/ghcup"><code>ghcup</code></a>が使える？）</small>。<br />
<a href="../2017/06-ghc-install.html"><span class="ascii">@takenobu-hs</span>さんが書いてくれた、こちらの記事</a>を参考にどうぞ！</p>
<p>なお、<span class="ascii">stack</span>でやると面倒な理由についての詳細はこれから述べる手順で適宜触れます…。</p>
<h1 id="setup-infoを作る"><span class="link-to-here-outer"><a href="#setup-infoを作る" title="setup-infoを作る"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">1.</span> <code>setup-info</code>を作る</h1>
<p>まずはじめに、<span class="ascii">stack</span>が<span class="ascii">GHC</span>をインストールする際に参照する、<a href="https://docs.haskellstack.org/en/stable/yaml_configuration/#setup-info"><code>setup-info</code></a>という<span class="ascii">YAML</span>を作りましょう。<br />
<code>setup-info</code>は<code>stack setup</code>や<code>stack build</code>を実行したとき、<span class="ascii">GHC</span>などの必要なソフトウェアがインストールされていなかった際、自動で<span class="ascii">GHC</span>をインストールするために必要な情報です。<br />
<span class="ascii">GHC</span>のバージョンや対象となるプラットフォームごとに、<span class="ascii">GHC</span>のビルド済み<span class="ascii">tarball</span>への<span class="ascii">URL</span>やそのチェックサムが書いてあります。<br />
<span class="ascii">stack</span>はここに書かれた<span class="ascii">URL</span>にアクセスすることで、<span class="ascii">GHC</span>をインストールしているんですね。</p>
<p>デフォルトでは、<span class="ascii">stack</span>は<a href="https://raw.githubusercontent.com/commercialhaskell/stackage-content/master/stack/stack-setup-2.yaml">こちらの<span class="ascii">YAML</span></a>ファイルを<code>setup-info</code>として扱っています。<br />
この<span class="ascii">YAML</span>には<a href="https://www.stackage.org/"><span class="ascii">Stackage</span></a>が参照している、安定版の<span class="ascii">GHC</span>については書いてあるものの、<span class="ascii">LTS Haskell</span>にも<span class="ascii">Stackage Nightly</span>にもまだ採用されていない<span class="ascii">GHC</span>については、書かれていません。<br />
当然アルファ版である<span class="ascii">GHC 8.8.1-alpha1</span>が書かれることはないため、<span class="ascii">GHC 8.8.1-alpha1</span>用の<code>setup-info</code>を作る必要があります。</p>
<p>それでは書いてみましょう… と、言いたいところですが、この<code>setup-info</code>、実際のところ自分で直接書く必要はなく、<span class="ascii">YAML</span>ファイルへの<span class="ascii">URL</span>やパスを指定するだけで<span class="ascii">stack</span>は参照しに行ってくれます！<br />
と、言うわけで、<a href="https://gist.github.com/igrep/7298e1e2515059ae332feaf5501c41a4">こちらに<span class="ascii">GHC 8.8.1-alpha1</span>向けの<code>setup-info</code></a>を作ってアップロードしておきました！<br />
<small>（申し訳なくも<span class="ascii">Linux</span>についてはどう書けばいいかわからず、<span class="ascii">macOS</span>と<span class="ascii">Windows 64bit</span>のみ対応いたしました… あしからず。🙇）</small></p>
<p>ひとまずみなさんは、下記のいずれかの方法で指定するだけでこの手順はクリアできます。</p>
<ul>
<li><p><code>stack.yaml</code>に記載する<span class="ascii">:</span></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb1-1" title="1"><span class="fu">resolver:</span><span class="at"> ghc-8.8</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="fu">setup-info:</span><span class="at"> </span><span class="st">&quot;https://gist.githubusercontent.com/igrep/7298e1e2515059ae332feaf5501c41a4/raw/d69cc0b75d9be6735bdfcca6aa3eb6398d98983f/stack-setup-info.yaml&quot;</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="co"># ... 以下略 ...</span></a></code></pre></div>
<ul>
<li>ビルドしたいプロジェクトや、<span class="ascii">GHC 8.8</span>を試す用のディレクトリーを作って、そこに👆の内容が書かれた<code>stack.yaml</code>を置きましょう。<br />
ちょっと試したいだけならそのディレクトリーで<code>stack exec ghci</code>などと実行すれば<span class="ascii">OK</span>です！</li>
</ul></li>
<li><p><code>stack setup</code>コマンドのオプションとして渡す<span class="ascii">:</span></p>
<pre><code>stack setup 8.8.0.20190424 --setup-info-yaml https://gist.github.com/igrep/7298e1e2515059ae332feaf5501c41a4/raw/d69cc0b75d9be6735bdfcca6aa3eb6398d98983f/stack-setup-info.yaml</code></pre>
<ul>
<li><code>--setup-info-yaml</code>オプションを指定した上で<code>8.8.0.20190424</code>という引数を与えるのがポイントです。<br />
<span class="ascii">GHC</span>の開発版の慣習上、<code>8.8.1-alpha1</code><strong>ではなく</strong><code>8.8.0.20190424</code>となっている点に注意してください！</li>
</ul></li>
</ul>
<p>「<span class="ascii">8.8.1-alpha1</span>じゃなくて、自分でビルドした<span class="ascii">GHC</span>を<code>stack</code>でインストールできるようにしたい！」というマニアなあなたは、<a href="https://gist.github.com/igrep/7298e1e2515059ae332feaf5501c41a4">今回私が作った<code>setup-info</code></a>をどうぞ参考にしてください！🙇</p>
<h1 id="必要ならallow-newerを有効にする"><span class="link-to-here-outer"><a href="#必要ならallow-newerを有効にする" title="必要ならallow-newerを有効にする"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">2.</span> （必要なら）<span class="ascii">allow-newer</span>を有効にする</h1>
<p>ここからは、何かしら依存するパッケージがあるライブラリー・アプリケーションを<span class="ascii">GHC 8.8.1-alpha1</span>で試しにビルドしたいという方向けです。<br />
<span class="ascii">GHC 8.8.1-alpha1</span>をちょっと試したいだけという方はこれ以降を読む必要はありません。</p>
<p>まずは、ひとまず対象となるプロジェクトの<code>stack.yaml</code>に</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb3-1" title="1"><span class="fu">allow-newer:</span><span class="at"> </span><span class="ch">true</span></a></code></pre></div>
<p>を追記しましょう。<br />
これは、依存している<span class="ascii">Cabal</span>パッケージのバージョンの、上限を取っ払うというものです。<br />
依存パッケージのバージョンの上限は、パッケージの開発者が自身のパッケージを確実にビルドできるよう、「このパッケージはあのパッケージのバージョン<span class="ascii">N.M</span><strong>以下</strong>じゃないとビルドできないよ！」と<span class="ascii">Cabal</span>の依存関係リゾルバーに教えてあげるためのものです。<br />
<span class="ascii">cabal-install</span><small>（と、恐らく<span class="ascii">stack</span>も必要に応じて）</small>は、通常であればこの上限を見て、どのバージョンのパッケージをインストールするか決めます。<br />
その上限により、残念ながら依存関係の解決に失敗することがあるのです。<br />
そこでそうしたエラーを避けるためにも<code>allow-newer: true</code>と設定して、上限を無視してみましょう。</p>
<p>というのも、このバージョンの上限はしばしば、予防のために実際より厳しめに設定されることがあるためです<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>。<br />
そりゃそうですよね。今作っているパッケージが依存している<span class="ascii">API</span>が、どのバージョンで使用できなくなるかなんて、大抵のパッケージではわかりませんし。<br />
<span class="ascii">Haskell</span>の世界には<a href="https://pvp.haskell.org/"><span class="ascii">PVP</span></a>という、<a href="https://semver.org/lang/ja/"><span class="ascii">Semantic Versioning</span></a>と似た思想のバージョン変更ポリシーがありまして、<span class="ascii">API</span>の互換性がなくなるような修正が含まれる場合、次のバージョンでは<code>A.B.C</code>の<code>A.B</code>の箇所を変更することになっています。<br />
これを信じて依存バージョンの上限（と下限）を設定してみても、実際にあなたが依存している<span class="ascii">API</span>が使用できなくなるとは限らないのです。</p>
<p>したがって、依存パッケージのバージョンの上限は、実際には無視してもよい場合がしばしばあります。<br />
もちろん、自分で依存パッケージのバージョンを正しく書き換えて対応するというのもアリですし、将来的にはそうした方がより望ましいやり方です。<br />
また、<code>allow-newer: true</code>を設定することにより、<strong><span class="ascii">GHC 8.8</span>とは関係のない原因でビルドが失敗</strong>する可能性がある点にも注意してください。<br />
とは言え、今回は手っ取り早くビルドしてみるために、敢えて<code>allow-newer: true</code>を設定することと致しました。<br />
「私はバージョンの上限を直してみたいんだー！」という方は、是非チャレンジしてみてください。</p>
<h1 id="package-indicesを設定してhead.hackageを利用できるようにする"><span class="link-to-here-outer"><a href="#package-indicesを設定してhead.hackageを利用できるようにする" title="package-indicesを設定してhead.hackageを利用できるようにする"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">3. package-indices</span>を設定して、<span class="ascii">head.hackage</span>を利用できるようにする</h1>
<p><code>stack.yaml</code>に書いておいた方が良い設定がもう一つあります。<br />
それは、<a href="http://head.hackage.haskell.org/"><span class="ascii">HEAD.hackage</span></a>の設定です。</p>
<p>これからビルドするあなたのパッケージは、きっとたくさんのパッケージに依存していることでしょう。<br />
残念ながら、その中には<span class="ascii">GHC 8.8</span>に対応できていないものも数多くあるでしょう😰。<br />
特に今回は<a href="https://scrapbox.io/haskell-shoen/MonadFail"><code>MonadFail</code> <span class="ascii">Proposal</span></a>による、<code>Monad</code>型クラスの仕様変更を適切に周知できていなかったこともあり、まだ多くのパッケージが対応できていないようです。</p>
<p>しかし、まだ希望はあります。<br />
あなたの依存パッケージに対する必要な修正は、すでに<span class="ascii">master</span>ブランチにマージされているかも知れませんし、すでに誰かが<span class="ascii">Pull request</span>を送っているかも知れません。<br />
さらにラッキーな場合、<span class="ascii">HEAD.hackage</span>にパッチを当てたバージョンが上がっていることでしょう！</p>
<p><span class="ascii">HEAD.hackage</span>は、今回のように<span class="ascii">GHC</span>の開発版をいち早く試したい人が、新しい<span class="ascii">GHC</span>に向けて修正を加えたパッケージを、いち早くアップロードするサイトです。<br />
<a href="https://github.com/hvr/head.hackage">こちらのリポジトリー</a>にパッチをアップロードすることで、<span class="ascii">cabal-install</span>や<span class="ascii">stack</span>から、普通の<span class="ascii">hackage</span>にあるパッケージとしてダウンロードできるようにしてくれます。</p>
<p><span class="ascii">HEAD.hackage</span>を<span class="ascii">stack</span>で利用するには、下記のように、<code>package-indices:</code>という設定を、<code>stack.yaml</code>に加えてください。<br />
下記のように記載することで、<span class="ascii">stack</span>は、<span class="ascii">HEAD.hackage</span>にある修正済みのパッケージを優先して取得してくれるようになります<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb4-1" title="1"><span class="fu">package-indices:</span></a>
<a class="sourceLine" id="cb4-2" title="2">  <span class="kw">-</span> <span class="fu">name:</span><span class="at"> head.hackage</span></a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="fu">download-prefix:</span><span class="at"> http://head.hackage.haskell.org/package/</span></a>
<a class="sourceLine" id="cb4-4" title="4">    <span class="fu">http:</span><span class="at"> http://head.hackage.haskell.org/01-index.tar.gz</span></a>
<a class="sourceLine" id="cb4-5" title="5">  <span class="kw">-</span> <span class="fu">name:</span><span class="at"> Hackage</span></a>
<a class="sourceLine" id="cb4-6" title="6">    <span class="fu">download-prefix:</span><span class="at"> https://hackage.haskell.org/package/</span></a>
<a class="sourceLine" id="cb4-7" title="7">    <span class="fu">http:</span><span class="at"> https://hackage.haskell.org/01-index.tar.gz</span></a></code></pre></div>
<p>これで<span class="ascii">GHC 8.8</span>対応済みのパッケージを、簡単に取得できるようになります！</p>
<h1 id="stack-buildを実行しつつひたすらextra-depsを追加編集"><span class="link-to-here-outer"><a href="#stack-buildを実行しつつひたすらextra-depsを追加編集" title="stack-buildを実行しつつひたすらextra-depsを追加編集"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">4. stack build</span>を実行しつつ、ひたすら<span class="ascii">extra-deps</span>を追加・編集</h1>
<p>ここまで設定できたら、いよいよ<code>stack build</code>してみましょう<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>！<br />
とは言え、この状態ではほぼ間違いなく失敗が続くので、<code>stack build --file-watch</code>と、<strong><code>--file-watch</code>オプションを付けて、<code>stack.yaml</code>を編集する度に再度</strong>ビルドが実行されるようにするのをおすすめします。</p>
<p>と、言うのも、恐らく次👇のようなエラーがたくさん出ると思われるからです。</p>
<pre><code>...
In the dependencies for wss-client-0.2.1.1:
    http-client must match &gt;=0.5.13, but the stack configuration has no specified version  (latest
                matching version is 0.6.4)
    http-client-tls needed, but the stack configuration has no specified version  (latest matching
                    version is 0.3.5.3)
    network-uri needed, but the stack configuration has no specified version  (latest matching
                version is 2.6.1.0)
    websockets must match &gt;=0.12.0 &amp;&amp; &lt;0.13, but the stack configuration has no specified version
               (latest matching version is 0.12.5.3)
needed since wss-client is a build target.

Some different approaches to resolving this:

  * Consider trying &#39;stack solver&#39;, which uses the cabal-install solver to attempt to find some
    working build configuration. This can be convenient when dealing with many complicated
    constraint errors, but results may be unpredictable.

  * Recommended action: try adding the following to your extra-deps
    in C:\Users\igrep\Downloads\direct-hs\stack-ghc-8.8.yaml:

attoparsec-0.13.2.2@sha256:6a0baba19991e84ef939056e7b411ad3a1ea0fb5e1e8fce7ca50e96c84b206c8
base-compat-0.10.5@sha256:d49e174ed0daecd059c52d13d4f4de87b5609c81212a22adbb92431f9cd58fff
...</code></pre>
<p>このエラー、見かけたことがある人も多いでしょう。<br />
そう、指定した<span class="ascii">resolver</span><small>（<span class="ascii">stack</span>が使用するパッケージのバージョンの一覧。<span class="ascii">Stackage</span>に登録されている<code>lts-13.12</code>などもその一つ）</small>に、必要なバージョンのパッケージが登録されていない場合に起こるエラーです。<br />
みなさんが普段利用する<code>lts-13.12</code>などの<span class="ascii">resolver</span>では、数多くのパッケージが登録されています<small>（<a href="https://www.stackage.org/lts-13.19">最新版の<span class="ascii">LTS Haskell 13.19</span></a>で<span class="ascii">2346</span>件。<span class="ascii">Stackage</span>をメンテしている皆さんのおかげですね）</small>。</p>
<p>一方、最初の手順で我々が指定した<span class="ascii">resolver</span>、すなわち<code>resolver: ghc-8.8</code>は、<span class="ascii">GHC 8.8</span>に添付されたパッケージ<small>（<code>base</code>パッケージや、<code>array</code>パッケージなど）</small>しか入っていない、実質空っぽな<span class="ascii">resolver</span>なのです<small>（<a href="https://docs.haskellstack.org/en/stable/yaml_configuration/#resolver">参考</a>）</small>。<br />
そのため、あなたが必要なほとんどのパッケージはないため、<span class="ascii">stack</span>はやむなく「<code>extra-deps</code>にこれらのパッケージを追加してね！」というエラーを出すことになります。<br />
これでは<span class="ascii">stack</span>の良さを生かせません…。<span class="ascii">cabal-install</span>で<code>cabal new-build</code>していれば、<span class="ascii">cabal-install</span>は黙って必要なパッケージのバージョンを決定し、あとは<code>cabal new-freeze</code>でもすれば、完全にビルドを再現可能な状態にしてくれます。<br />
やっぱり<span class="ascii">stack</span>はあくまでも<span class="ascii">Stackage</span>を活かすためのツールと捉えた方がいいのかも知れません😥。</p>
<p><code>extra-deps</code>へのパッケージの追記を何度か繰り返すと、ようやくパッケージのビルドが始まります。<br />
<span class="ascii">HEAD.hackage</span>に収録されたパッケージを正しく取得できていれば、現在<span class="ascii">Hackage</span>にアップロードされているバージョンではビルドできない依存パッケージも、無事ビルドできることでしょう。<br />
依存するパッケージの数にもよりますが、やっぱり時間がかかるかと思います。待ちましょう☕️。</p>
<h2 id="それでもうまくいかない場合-extra-depsを使い倒す"><span class="link-to-here-outer"><a href="#それでもうまくいかない場合-extra-depsを使い倒す" title="それでもうまくいかない場合-extra-depsを使い倒す"><span class="link-to-here">Link to<br />
here</span></a></span>それでもうまくいかない場合<span class="ascii">:</span> <code>extra-deps</code>を使い倒す</h2>
<p>しかしやっぱり、必要な変更が施されたパッケージが、<span class="ascii">HEAD.hackage</span>にもアップロードされていない場合はあります。<br />
そうした場合、自分で修正して<small>（<span class="ascii">Pull request</span>を送りつつ）</small>パッチを<a href="https://github.com/hvr/head.hackage"><span class="ascii">HEAD.hackage</span>のリポジトリー</a>にアップロードすることもできますが、<code>stack.yaml</code>の<code>extra-deps</code>を次のように使えば、もっと手っ取り早く修正したバージョンのビルドを試すことができます。</p>
<h3 id="自分以外の人が対象のパッケージを修正した場合"><span class="link-to-here-outer"><a href="#自分以外の人が対象のパッケージを修正した場合" title="自分以外の人が対象のパッケージを修正した場合"><span class="link-to-here">Link to<br />
here</span></a></span>自分以外の人が対象のパッケージを修正した場合<span class="ascii">:</span></h3>
<p>自分以外の人が対象のパッケージを修正したので、すでにどこかのリポジトリーに<span class="ascii">push</span>済みのコミットがある、という場合、下記👇のように書くと、<span class="ascii">Git</span>リポジトリーの特定のコミットを直接参照した状態で、依存関係に加えることができます。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb6-1" title="1"><span class="fu">extra-deps:</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="kw">-</span> <span class="fu">git:</span><span class="at"> https://github.com/github_user/repository_name.git</span></a>
<a class="sourceLine" id="cb6-3" title="3">  <span class="fu">commit:</span><span class="at"> &lt;修正したコミットのSHA&gt;</span></a></code></pre></div>
<h3 id="自分で対象のパッケージを修正するという場合"><span class="link-to-here-outer"><a href="#自分で対象のパッケージを修正するという場合" title="自分で対象のパッケージを修正するという場合"><span class="link-to-here">Link to<br />
here</span></a></span>自分で対象のパッケージを修正する、という場合<span class="ascii">:</span></h3>
<p>そうでない場合、対象のパッケージのリポジトリーを一旦<code>git submodule add</code>して、自分のリポジトリーの一部に含めてしまいましょう。<br />
その上で、<code>extra-deps</code>には下記のように書けば、<span class="ascii">stack</span>はローカルのファイルシステムに置かれたディレクトリーも、直接依存するパッケージとして追加してくれます。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb7-1" title="1"><span class="fu">extra-deps:</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="kw">-</span> ./path/to/package</a></code></pre></div>
<p>逐一別のディレクトリーに<code>git clone</code>して<code>git commit</code>して<code>git push</code>して作られたコミットの<span class="ascii">SHA</span>を参照して… なんてのを繰り返していたら、面倒だからです。</p>
<h3 id="対象のパッケージがgitリポジトリーで管理されてない場合は"><span class="link-to-here-outer"><a href="#対象のパッケージがgitリポジトリーで管理されてない場合は" title="対象のパッケージがgitリポジトリーで管理されてない場合は"><span class="link-to-here">Link to<br />
here</span></a></span>対象のパッケージが<span class="ascii">Git</span>リポジトリーで管理されてない場合は？</h3>
<p>臨機応変に対応しましょう…😰<br />
ちなみに、<a href="https://docs.haskellstack.org/en/stable/yaml_configuration/#git-and-mercurial-repos"><span class="ascii">extra-deps</span>のドキュメント</a>いわく<span class="ascii">stack</span>は<span class="ascii">Mercurial</span>もサポートしています。</p>
<h1 id="番外編-operation-vanguard"><span class="link-to-here-outer"><a href="#番外編-operation-vanguard" title="番外編-operation-vanguard"><span class="link-to-here">Link to<br />
here</span></a></span>番外編<span class="ascii">: Operation Vanguard</span></h1>
<p>以上が<span class="ascii">stack</span>を使った<span class="ascii">GHC 8.8-alpha1</span>のインストール方法や、それを利用したパッケージのビルド手順です。自分で<span class="ascii">GHC</span>をビルドしたときなども参考にしてみてください。<br />
これで終わり…！と、言いたいところですが、<span class="ascii">GHC 8.8</span>に関連して、非常に意欲的なプロジェクト💪を紹介させてください。</p>
<p>それは、<a href="https://github.com/haskell-vanguard/haskell-vanguard"><span class="ascii">Operation Vanguard</span></a>です。<br />
<a href="https://github.com/fumieval/"><span class="ascii">@fumieval</span></a>さんが始めた、「エコシステムの主要なパッケージの最新版を一挙に<span class="ascii">GHC 8.8</span>に対応させる」プロジェクトです。<br />
一旦<span class="ascii">submodule</span>として対象のパッケージのリポジトリーを<span class="ascii">clone</span>する、という方法は、<span class="ascii">Operation Vanguard</span>のリポジトリーを見ていて知りました💡。</p>
<p>すでに対応のほとんどが終了したとのことですが、<span class="ascii">GHC 8.8</span>に対応していないパッケージは恐らくまだたくさんあります。<br />
ゴールデンウィークももう半分が終わりましたが、時間をとって<span class="ascii">Operation Vanguard</span>のようにチャレンジしてみるのはいかがでしょうか💪💪💪</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>もっとも、私のようにものぐさな人間が作るパッケージには、そもそも上限も何も書いてないことが多いのですが…😰<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>本来であれば<span class="ascii">Hackage Security</span>の設定も必要なはずなんですが、なぜかうまくいかず…😱。<a href="https://github.com/commercialhaskell/stack/issues/3844">こちら</a>で紹介された<span class="ascii">workaround</span>にしたがって、関連する設定を除くことにしました…。<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p><code>stack solver</code>コマンドを使えば、この節で紹介するエラーは簡単にクリアできそうだということを聞いて試した<small>（<span class="ascii">Thanks,</span> <a href="https://github.com/mizunashi-mana"><span class="ascii">@mizunashi-mana</span></a>さん！）</small>のですが、手元のパッケージでは依存関係を解決できず、エラーになってしまいました…。<a href="#fnref3" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/asterius.html" lang="ja">AsteriusでHaskellの関数をJSから呼べるようにしてみた（けど失敗）（拡大版）</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/string-gap-for-heredoc-like.html" style="margin-left: auto;" lang="ja">Haskell でも heredoc がしたい</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>Haskell でも heredoc がしたい</title>
    <link href="https://haskell.jp/blog/posts/2019/string-gap-for-heredoc-like.html" />
    <id>https://haskell.jp/blog/posts/2019/string-gap-for-heredoc-like.html</id>
    <published>2019-04-17T00:00:00Z</published>
    <updated>2019-04-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>多くの言語では， <span class="ascii">here document (heredoc)</span> という言語機能が搭載されています．これは，複数行の文字列をコード中に文字列リテラルとして埋め込める機能です．今日は <span class="ascii">heredoc</span> ほど使い勝手がよくないものの，長い文字列を埋め込める， <span class="ascii">Haskell</span> 標準の <span class="ascii">string gap</span> という機能を紹介したいと思います．</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#string-gap" title="string-gap"><span class="ascii">string gap</span></a></li>
<li><a href="#cpp-下での注意事項" title="cpp-下での注意事項"><span class="ascii">CPP</span> 下での注意事項</a></li>
<li><a href="#まとめ" title="まとめ">まとめ</a></li>
</ul>
</div>
</div>
<h2 id="string-gap"><span class="link-to-here-outer"><a href="#string-gap" title="string-gap"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">string gap</span></h2>
<p><span class="ascii">bash</span> では，複数行の文字列を，次の記法で埋め込むことができます<span class="ascii">:</span></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" title="1"><span class="bu">echo</span> <span class="st">&quot;</span><span class="va">$(</span><span class="fu">cat</span> <span class="op">&lt;&lt;EOS</span></a>
<a class="sourceLine" id="cb1-2" title="2">some text</a>
<a class="sourceLine" id="cb1-3" title="3">is multilined</a>
<a class="sourceLine" id="cb1-4" title="4"><span class="op">EOS</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="va">)</span><span class="st">&quot;</span></a></code></pre></div>
<p>これは，</p>
<pre class="text"><code>some text
is multilined</code></pre>
<p>という文字列が出力されます．多くの言語では似たような構文で <span class="ascii">heredoc</span> が採用されていて，特殊な記号の後に終端記号を書いて，その後の終端記号までを文字列リテラルとして扱われます． <span class="ascii">Haskell</span> では残念ながらこのような機能は搭載されていませんが，代わりに次の記法が提供されています<span class="ascii">:</span></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb3-2" title="2">main <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="st">&quot;\</span></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="st">  \some text\n\</span></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="st">  \is multilined\</span></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="st">\&quot;</span></a></code></pre></div>
<p>この実行結果は，前の <span class="ascii">bash</span> スクリプトの結果と同じになります． <span class="ascii">heredoc</span> より色々ごちゃごちゃしてますが，複数行の文字列リテラルを書けます．この機能は， <span class="ascii">Haskell</span> の複数行文字列リテラルまたは <span class="ascii">Haskell</span> 標準では <span class="ascii">gap</span> と呼ばれています <a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>．記法はかなり単純で，文字列中のバックスラッシュ <code>\</code> で囲まれた空白が無視されるだけです．改行も空白に含まれます．なので，上のプログラムは以下のプログラムと同じです<span class="ascii">:</span></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-2" title="2">main <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="st">&quot;some text\nis multilined&quot;</span></a></code></pre></div>
<p>なお， <span class="ascii">gap</span> を使わないで複数行の文字列リテラルを書くことはできません．また， <span class="ascii">gap</span> は空白を全て無視するため，改行を含まない長い文字列を複数行に渡って埋め込むのにも使えます<span class="ascii">:</span></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb5-2" title="2">main <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="st">&quot;This is very very very \</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="st">  \long long long long long long long long text.&quot;</span></a></code></pre></div>
<p>なお， <span class="ascii">gap</span> は <span class="ascii">Haskell</span> 標準でレイアウトルールの処理から除外されているため<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>，インデントを考慮する必要はありません<span class="ascii">:</span></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb6-2" title="2">main <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-3" title="3">  <span class="fu">putStrLn</span> <span class="st">&quot;one line&quot;</span></a>
<a class="sourceLine" id="cb6-4" title="4">  <span class="fu">putStrLn</span> <span class="st">&quot;\</span></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="st">\multiline\n\</span></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="st">\text\</span></a>
<a class="sourceLine" id="cb6-7" title="7"><span class="st">\&quot;</span></a></code></pre></div>
<h2 id="cpp-下での注意事項"><span class="link-to-here-outer"><a href="#cpp-下での注意事項" title="cpp-下での注意事項"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">CPP</span> 下での注意事項</h2>
<p>ただ， <span class="ascii">GHC</span> の <code>CPP</code> 拡張を使用する際注意が必要です． <code>CPP</code> では，バックスラッシュで終わる行は，バックスラッシュを除いて次の行と繋げる処理が行われます<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>．この処理のため， <span class="ascii">gap</span> を使用した以下のコードは，</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="ot">{-# LANGUAGE CPP #-}</span></a>
<a class="sourceLine" id="cb7-2" title="2"></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb7-4" title="4">main <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="st">&quot;This is very very very \</span></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="st">  \long long long long long long long long text.&quot;</span></a></code></pre></div>
<p><code>cpp</code> により次のように変換されてしまいます<span class="ascii">:</span></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb8-2" title="2">main <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="st">&quot;This is very very very   \long long long long long long long long text.&quot;</span></a></code></pre></div>
<p>このため，結果的にコンパイルエラーになってしまいます．このため， <code>CPP</code> を使う際は， <span class="ascii">gap</span> を使わず <code>CPP</code> の機能を使う必要があります．例えば，上記のプログラムは，</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="ot">{-# LANGUAGE CPP #-}</span></a>
<a class="sourceLine" id="cb9-2" title="2"></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb9-4" title="4">main <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="st">&quot;This is very very very \</span></a>
<a class="sourceLine" id="cb9-5" title="5"><span class="st">\ \long long long long long long long long text.&quot;</span></a></code></pre></div>
<p>と書くと <span class="ascii">gap</span> をそのまま使った時のプログラムと同じになります．一番最初の <code>\</code> は <code>CPP</code> のためのもの，次の <span class="ascii">2</span> つは <span class="ascii">gap</span> になります．</p>
<h2 id="まとめ"><span class="link-to-here-outer"><a href="#まとめ" title="まとめ"><span class="link-to-here">Link to<br />
here</span></a></span>まとめ</h2>
<p><span class="ascii">string gap</span> は，昔から <span class="ascii">Haskell</span> 標準で付いている機能なので，ぜひ使ってみてください．</p>
<p>ただ， <span class="ascii">heredoc</span> より使い勝手は良くないです．変数展開やもう少し見栄えの良い <span class="ascii">heredoc</span> が欲しい場合は， <a href="http://hackage.haskell.org/package/here"><span class="ascii">here</span> パッケージ</a> や <a href="http://hackage.haskell.org/package/shakespeare"><span class="ascii">Shakespeare</span></a> などの <span class="ascii">TemplateHaskell</span> を使ったテンプレートエンジンの使用を検討してみるといいかもしれませんね．</p>
<p>では，今日はこれでノシ</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-200002.6"><span class="ascii">Haskell2010</span> の <span class="ascii">2.6</span> 節</a>の最後の方で紹介されています．<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p><a href="https://www.haskell.org/onlinereport/haskell2010/haskellch10.html#x17-17800010.3"><span class="ascii">Haskell2010</span> の <span class="ascii">10.3</span> 節</a> で触れられています．<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p><a href="https://gcc.gnu.org/onlinedocs/cpp/Initial-processing.html#index-continued-lines"><span class="ascii">CPP</span> の仕様の <span class="ascii">1.2</span> 節</a> で触れられています．<a href="#fnref3" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/stack-ghc8.8.html" lang="ja">GHC 8.8.1 alphaをstackでダウンロードして手持ちのパッケージをビルドする</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/hourly-antenna.html" style="margin-left: auto;" lang="ja">DroneでHaskell Antennaを毎時更新する</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>DroneでHaskell Antennaを毎時更新する</title>
    <link href="https://haskell.jp/blog/posts/2019/hourly-antenna.html" />
    <id>https://haskell.jp/blog/posts/2019/hourly-antenna.html</id>
    <published>2019-01-25T00:00:00Z</published>
    <updated>2019-01-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p><span class="ascii">Haskell-jp</span>のコンテンツの一つとして<a href="https://haskell.jp/antenna/"><span class="ascii">Haskell Antenna</span></a>という <span class="ascii">Web</span> ページの開発・運用をしております。</p>
<p><img src="../../img/2019/hourly-antenna/antenna-page.jpg" style="width: 100%;"></p>
<p>この<span class="ascii">Web</span>ページは<a href="https://github.com/haskell-jp/antenna"><span class="ascii">Haskell-jp</span>のリポジトリ</a>で開発し、<span class="ascii">GitHub Pages</span>として公開しています。 更新は<a href="https://travis-ci.org/"><span class="ascii">TravisCI</span></a>の<span class="ascii">Daily Cron</span>を使って行なっていましたが、なんとかして <strong>毎時更新を実現したい</strong> と思案していました。 ひょんなことから<a href="https://cloud.drone.io/"><span class="ascii">Drone Cloud</span></a>という<span class="ascii">CI</span>サービスを見つけ、このサービスでは<span class="ascii">Hourly Cron</span>が可能だったので試しに更新の部分だけ移行してみました。 という話です。</p>
<p>ちなみに、本稿は全く<span class="ascii">Haskell</span>のコードが出て来ません <span class="ascii">;)</span></p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#drone.io" title="drone.io"><span class="ascii">Drone.io</span></a></li>
<li><a href="#毎時更新を実現するために" title="毎時更新を実現するために">毎時更新を実現するために</a>
<ul>
<li><a href="#antennaのdockerイメージ化" title="antennaのdockerイメージ化"><span class="ascii">Antenna</span>の<span class="ascii">Docker</span>イメージ化</a></li>
<li><a href="#dockerイメージの自動更新" title="dockerイメージの自動更新"><span class="ascii">Docker</span>イメージの自動更新</a></li>
<li><a href="#drone-cloudの設定" title="drone-cloudの設定"><span class="ascii">Drone Cloud</span>の設定</a></li>
<li><a href="#personal-tokenからdeploy-keyに移行" title="personal-tokenからdeploy-keyに移行"><span class="ascii">Personal Token</span>から<span class="ascii">Deploy Key</span>に移行</a></li>
<li><a href="#slackの通知回りを整理" title="slackの通知回りを整理"><span class="ascii">Slack</span>の通知回りを整理</a></li>
</ul></li>
<li><a href="#今後やりたいこと" title="今後やりたいこと">今後やりたいこと</a></li>
</ul>
</div>
</div>
<h1 id="drone.io"><span class="link-to-here-outer"><a href="#drone.io" title="drone.io"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Drone.io</span></h1>
<p><span class="ascii">Drone Cloud</span>はパブリックリポジトリであれば無料で利用できる<span class="ascii">CI</span>サービスです。 内部では<a href="https://drone.io/"><span class="ascii">Drone</span></a>という<span class="ascii">OSS</span>の<span class="ascii">CI</span>プラットフォームを利用しています。 <span class="ascii">Drone</span>は以下のような特徴を持っています<span class="ascii">:</span></p>
<ul>
<li><span class="ascii">Jenkins</span>のような<span class="ascii">OSS</span>である<span class="ascii">(Go</span>言語製<span class="ascii">)</span></li>
<li><span class="ascii">TravisCI</span>や<span class="ascii">CircleCI</span>のようなパイプラインによる設定を行う<span class="ascii">(YAML</span>形式<span class="ascii">)</span></li>
<li><span class="ascii">Docker</span>との親和性が高く<span class="ascii">k8s</span>などでの動作もサポートしている</li>
<li><span class="ascii">Plugin</span>システムによって外部サービスとの連携が可能</li>
</ul>
<p><span class="ascii">OSS</span>のためお好みのクラウドサービスなどで自前運用も可能ですし、<span class="ascii">Drone Enterprise</span>という有料のクラウドサービスも提供しています。</p>
<h1 id="毎時更新を実現するために"><span class="link-to-here-outer"><a href="#毎時更新を実現するために" title="毎時更新を実現するために"><span class="link-to-here">Link to<br />
here</span></a></span>毎時更新を実現するために</h1>
<p>単純に<span class="ascii">Drone</span>の設定ファイルを記述するだけではなく、次のような作業を行いました<span class="ascii">:</span></p>
<ul>
<li><span class="ascii">Haskell Antenna</span>の<span class="ascii">Docker</span>イメージ化</li>
<li><span class="ascii">Antenna</span>の<span class="ascii">Docker</span>イメージを自動更新</li>
<li><span class="ascii">Drone Cloud</span>の設定</li>
<li><span class="ascii">Personal Token</span>から<span class="ascii">Deploy Key</span>に移行</li>
<li><span class="ascii">Slack</span>の通知回りを整理</li>
</ul>
<p>順に説明していきましょう。</p>
<h2 id="antennaのdockerイメージ化"><span class="link-to-here-outer"><a href="#antennaのdockerイメージ化" title="antennaのdockerイメージ化"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Antenna</span>の<span class="ascii">Docker</span>イメージ化</h2>
<p><span class="ascii">Drone Cloud</span>では無償でキャッシュを利用することができません<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>。 <span class="ascii">Haskell(</span>というか<span class="ascii">Stack)</span>の<span class="ascii">CI</span>をしている方ならわかると思いますが、キャッシュなしにビルドするとすごい時間がかかります。 なので、<span class="ascii">Haskell Antenna</span>の静的ページの生成を行う <code>antenna</code> コマンドを<span class="ascii">Docker</span>イメージとしておき、<span class="ascii">Drone</span>内ではこのイメージを利用して静的ページの生成を行う方針でいきます。</p>
<p>もちろん<span class="ascii">Docker</span>イメージの生成には、<span class="ascii">Stack</span>の<span class="ascii">Docker</span>インテグレーションを使います。 以下のような設定を<span class="ascii">stack.yaml</span>に追記し<span class="ascii">:</span></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb1-1" title="1"><span class="co"># stack.yaml</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="fu">docker:</span></a>
<a class="sourceLine" id="cb1-3" title="3">  <span class="fu">repo:</span><span class="at"> fpco/stack-build</span></a>
<a class="sourceLine" id="cb1-4" title="4">  <span class="fu">enable:</span><span class="at"> </span><span class="ch">false</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="fu">image:</span></a>
<a class="sourceLine" id="cb1-6" title="6">  <span class="fu">container:</span></a>
<a class="sourceLine" id="cb1-7" title="7">    <span class="fu">name:</span><span class="at"> antenna</span></a>
<a class="sourceLine" id="cb1-8" title="8">    <span class="fu">base:</span><span class="at"> fpco/ubuntu-with-libgmp</span></a></code></pre></div>
<p>次のようなコマンドを実行するだけで<code>antenna</code>という<span class="ascii">Docker</span>イメージが生成されます<span class="ascii">:</span></p>
<pre><code>stack docker pull
stack --docker image container</code></pre>
<p><span class="ascii">Docker Hub</span>に<a href="https://hub.docker.com/r/haskelljp/antenna/"><code>haskelljp/antenna</code></a>というネームスペースを確保した<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>のでここにプッシュしました<span class="ascii">:</span></p>
<pre><code>docker tag antenna haskelljp/antenna
docker push haskelljp/antenna</code></pre>
<p>ちなみに、<code>haskell-jp</code> ではなく <code>haskelljp</code> なのは、<span class="ascii">Docker Hub</span>の組織アカウント名には <code>-</code> が使えなかったからです。</p>
<h2 id="dockerイメージの自動更新"><span class="link-to-here-outer"><a href="#dockerイメージの自動更新" title="dockerイメージの自動更新"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Docker</span>イメージの自動更新</h2>
<p><span class="ascii">Docker Hub</span>には<span class="ascii">Automated builds</span>と呼ばれる<span class="ascii">GitHub</span>などのプッシュによって行う自動ビルドがありますが、<span class="ascii">Stack</span>の<span class="ascii">Docker Integration</span>を使うと、その機能を利用することができません。 そこで、<span class="ascii">TravisCI</span>を使って自動ビルドすることにしました。 この辺りは「<a href="https://matsubara0507.github.io/posts/2018-12-02-stack-docker-travici.html"><span class="ascii">Stack</span> の <span class="ascii">Docker Integration</span> とイメージの自動更新 <span class="ascii">-</span> ひげメモ</a>」で記事にしてあるので、細かい話は割愛します。</p>
<p>今回は次のような設定をして、<span class="ascii">master</span> ブランチにプッシュがあった時にのみ<span class="ascii">Docker Hub</span>にプッシュします<span class="ascii">:</span></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb4-1" title="1"><span class="co"># .travis.yml</span></a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="co"># ...</span></a>
<a class="sourceLine" id="cb4-4" title="4"></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="fu">install:</span></a>
<a class="sourceLine" id="cb4-6" title="6"><span class="kw">-</span> mkdir -p ~/.local/bin</a>
<a class="sourceLine" id="cb4-7" title="7"><span class="kw">-</span> export PATH=$HOME/.local/bin:$PATH</a>
<a class="sourceLine" id="cb4-8" title="8"><span class="kw">-</span> travis_retry curl -L https://www.stackage.org/stack/linux-x86_64 | tar xz --wildcards --strip-components=1 -C ~/.local/bin <span class="st">&#39;*/stack&#39;</span></a>
<a class="sourceLine" id="cb4-9" title="9"><span class="kw">-</span> stack docker pull</a>
<a class="sourceLine" id="cb4-10" title="10"><span class="fu">jobs:</span></a>
<a class="sourceLine" id="cb4-11" title="11">  <span class="fu">include:</span></a>
<a class="sourceLine" id="cb4-12" title="12">    <span class="kw">-</span> <span class="fu">stage:</span><span class="at"> build dependencies</span></a>
<a class="sourceLine" id="cb4-13" title="13">      <span class="fu">script:</span><span class="at"> stack --no-terminal --docker --install-ghc test --bench --only-dependencies</span></a>
<a class="sourceLine" id="cb4-14" title="14">    <span class="kw">-</span> <span class="fu">stage:</span><span class="at"> build antenna</span></a>
<a class="sourceLine" id="cb4-15" title="15">      <span class="fu">script:</span><span class="at"> stack --no-terminal --docker build --bench --no-run-benchmarks --no-haddock-deps --pedantic</span></a>
<a class="sourceLine" id="cb4-16" title="16">    <span class="kw">-</span> <span class="fu">stage:</span><span class="at"> push docker image</span></a>
<a class="sourceLine" id="cb4-17" title="17">      <span class="fu">if:</span><span class="at"> branch = master AND type = push</span></a>
<a class="sourceLine" id="cb4-18" title="18">      <span class="fu">script:</span></a>
<a class="sourceLine" id="cb4-19" title="19">      <span class="kw">-</span> stack --docker image container</a>
<a class="sourceLine" id="cb4-20" title="20">      <span class="kw">-</span> docker tag antenna haskelljp/antenna</a>
<a class="sourceLine" id="cb4-21" title="21">      <span class="kw">-</span> echo <span class="st">&quot;$DOCKER_PASSWORD&quot;</span> | docker login -u <span class="st">&quot;$DOCKER_USERNAME&quot;</span> --password-stdin</a>
<a class="sourceLine" id="cb4-22" title="22">      <span class="kw">-</span> docker push haskelljp/antenna</a></code></pre></div>
<p><span class="ascii">Docker</span>で<span class="ascii">Haskell</span>のビルドもするために毎回<span class="ascii">Docker Pull</span>が走るようになり少し遅くなったのが辛いですね<span class="ascii">(</span>今後要検討<span class="ascii">)</span>。</p>
<h2 id="drone-cloudの設定"><span class="link-to-here-outer"><a href="#drone-cloudの設定" title="drone-cloudの設定"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Drone Cloud</span>の設定</h2>
<p>いよいよ<span class="ascii">Drone</span>による <code>antenna</code> コマンドの実行を設定します。 元々は <span class="ascii">TravisCI</span> でこんな感じでした<span class="ascii">:</span></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb5-1" title="1"><span class="fu">jobs:</span></a>
<a class="sourceLine" id="cb5-2" title="2">  <span class="fu">include:</span></a>
<a class="sourceLine" id="cb5-3" title="3">    <span class="kw">-</span> <span class="fu">stage:</span><span class="at"> install anttena</span></a>
<a class="sourceLine" id="cb5-4" title="4">      <span class="fu">script:</span><span class="at"> stack --no-terminal install</span></a>
<a class="sourceLine" id="cb5-5" title="5">    <span class="kw">-</span> <span class="fu">stage:</span><span class="at"> exec antenna</span></a>
<a class="sourceLine" id="cb5-6" title="6">      <span class="fu">script:</span><span class="at"> git clone -b gh-pages &quot;https://${GH_TOKEN}@github.com/${TRAVIS_REPO_SLUG}.git&quot; temp</span></a>
<a class="sourceLine" id="cb5-7" title="7">      <span class="fu">if:</span><span class="at"> branch = master AND type IN (push, cron)</span></a>
<a class="sourceLine" id="cb5-8" title="8">      <span class="fu">after_success:</span></a>
<a class="sourceLine" id="cb5-9" title="9">        <span class="kw">-</span> cp sites.yaml temp/sites.yaml</a>
<a class="sourceLine" id="cb5-10" title="10">        <span class="kw">-</span> cp -r image/* temp/image</a>
<a class="sourceLine" id="cb5-11" title="11">        <span class="kw">-</span> cd temp</a>
<a class="sourceLine" id="cb5-12" title="12">        <span class="kw">-</span> stack exec -- antenna sites.yaml</a>
<a class="sourceLine" id="cb5-13" title="13">        <span class="kw">-</span> git config user.name <span class="st">&quot;${GIT_NAME}&quot;</span></a>
<a class="sourceLine" id="cb5-14" title="14">        <span class="kw">-</span> git status</a>
<a class="sourceLine" id="cb5-15" title="15">        <span class="kw">-</span> git add -A</a>
<a class="sourceLine" id="cb5-16" title="16">        <span class="kw">-</span> git diff --quiet &amp;&amp; git diff --staged --quiet || git commit -am <span class="st">&quot;[skip ci] Update planet haskell. See https://haskell.jp/antenna/ for new entries!&quot;</span></a>
<a class="sourceLine" id="cb5-17" title="17">        <span class="kw">-</span> git push origin gh-pages</a></code></pre></div>
<p><code>stack install</code> で <code>antenna</code> コマンドの実行ファイルを生成し<span class="ascii">(</span>これはキャッシュされるので早い<span class="ascii">)</span>、<code>gh-pages</code> ブランチへページの更新をプッシュするために<span class="ascii">GitHub</span>の<span class="ascii">Personal Token</span>を使って再度クローンしていました。 更新の有無は <code>git diff</code> を使って確認しています。</p>
<p>まずはこれをこのまま<span class="ascii">Drone</span>に移植します<span class="ascii">:</span></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb6-1" title="1"><span class="co"># .drone.yml</span></a>
<a class="sourceLine" id="cb6-2" title="2"></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="fu">kind:</span><span class="at"> pipeline</span></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="fu">name:</span><span class="at"> default</span></a>
<a class="sourceLine" id="cb6-5" title="5"></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="fu">steps:</span></a>
<a class="sourceLine" id="cb6-7" title="7"><span class="kw">-</span> <span class="fu">name:</span><span class="at"> exec antenna</span></a>
<a class="sourceLine" id="cb6-8" title="8">  <span class="fu">image:</span><span class="at"> matsubara0507/antenna</span></a>
<a class="sourceLine" id="cb6-9" title="9">  <span class="fu">environment:</span></a>
<a class="sourceLine" id="cb6-10" title="10">    <span class="fu">GH_TOKEN:</span></a>
<a class="sourceLine" id="cb6-11" title="11">      <span class="fu">from_secret:</span><span class="at"> github_api_token</span></a>
<a class="sourceLine" id="cb6-12" title="12">    <span class="fu">GIT_NAME:</span><span class="at"> BOT</span></a>
<a class="sourceLine" id="cb6-13" title="13">  <span class="fu">commands:</span></a>
<a class="sourceLine" id="cb6-14" title="14">  <span class="kw">-</span> git clone -b gh-pages <span class="st">&quot;https://${GH_TOKEN}@github.com/haskell-jp/antenna.git&quot;</span> temp</a>
<a class="sourceLine" id="cb6-15" title="15">  <span class="kw">-</span> cp sites.yaml temp/sites.yaml</a>
<a class="sourceLine" id="cb6-16" title="16">  <span class="kw">-</span> cp -r image/* temp/image</a>
<a class="sourceLine" id="cb6-17" title="17">  <span class="kw">-</span> cd temp</a>
<a class="sourceLine" id="cb6-18" title="18">  <span class="kw">-</span> antenna sites.yaml</a>
<a class="sourceLine" id="cb6-19" title="19">  <span class="kw">-</span> git config user.name <span class="st">&quot;${GIT_NAME}&quot;</span></a>
<a class="sourceLine" id="cb6-20" title="20">  <span class="kw">-</span> git status</a>
<a class="sourceLine" id="cb6-21" title="21">  <span class="kw">-</span> git add -A</a>
<a class="sourceLine" id="cb6-22" title="22">  <span class="kw">-</span> git diff --quiet &amp;&amp; git diff --staged --quiet || git commit -am <span class="st">&quot;[skip ci] Update planet haskell. See https://haskell.jp/antenna/ for new entries!&quot;</span></a>
<a class="sourceLine" id="cb6-23" title="23">  <span class="kw">-</span> git push origin gh-pages</a>
<a class="sourceLine" id="cb6-24" title="24">  <span class="fu">when:</span></a>
<a class="sourceLine" id="cb6-25" title="25">    <span class="fu">branch:</span></a>
<a class="sourceLine" id="cb6-26" title="26">    <span class="kw">-</span> master</a>
<a class="sourceLine" id="cb6-27" title="27">    <span class="fu">event:</span></a>
<a class="sourceLine" id="cb6-28" title="28">      <span class="fu">exclude:</span></a>
<a class="sourceLine" id="cb6-29" title="29">      <span class="kw">-</span> pull_request</a></code></pre></div>
<p>記法は違うもののそのまま移植ができました。 条件<span class="ascii">(</span><code>if</code>や<code>when</code><span class="ascii">)</span>のところですが、<span class="ascii">Drone</span>で<code>cron</code>のイベントを指定する方法がわからなかったので、動作しては困る<code>pull_request</code>だけ弾くようにしました。</p>
<p><span class="ascii">Cron</span>の設定は<span class="ascii">Web UI</span>上で行います<span class="ascii">:</span></p>
<p><img src="../../img/2019/hourly-antenna/drone-cron-setting.jpg" style="width: 100%;"></p>
<p>これで毎時間<code>master</code>ブランチのビルドが実行されます。</p>
<h2 id="personal-tokenからdeploy-keyに移行"><span class="link-to-here-outer"><a href="#personal-tokenからdeploy-keyに移行" title="personal-tokenからdeploy-keyに移行"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Personal Token</span>から<span class="ascii">Deploy Key</span>に移行</h2>
<p><span class="ascii">Personal Token</span>は他の個人のリポジトリも操作できてしまうので、兼ねてからできれば使いたくないなと思っていました<span class="ascii">(</span>特に個人プロジェクトじゃない<span class="ascii">Haskell-jp</span>のプロジェクトでは<span class="ascii">)</span>。 なので、これを機にリポジトリ固有の<span class="ascii">Deploy Key</span>に移行しました。</p>
<p><span class="ascii">CircleCI</span>のような書き込み用の<span class="ascii">SSH Key</span>を登録する機能は<span class="ascii">Drone</span>にはありません。 代わりに次のように書くと良いです<span class="ascii">:</span></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb7-1" title="1"><span class="fu">steps:</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="kw">-</span> <span class="fu">name:</span><span class="at"> clone gh-pages</span></a>
<a class="sourceLine" id="cb7-3" title="3">  <span class="fu">image:</span><span class="at"> docker:git</span></a>
<a class="sourceLine" id="cb7-4" title="4">  <span class="fu">environment:</span></a>
<a class="sourceLine" id="cb7-5" title="5">    <span class="fu">SSH_KEY:</span></a>
<a class="sourceLine" id="cb7-6" title="6">      <span class="fu">from_secret:</span><span class="at"> deploy_key</span></a>
<a class="sourceLine" id="cb7-7" title="7">  <span class="fu">commands:</span></a>
<a class="sourceLine" id="cb7-8" title="8">  <span class="kw">-</span> mkdir /root/.ssh &amp;&amp; echo <span class="st">&quot;$SSH_KEY&quot;</span> &gt; /root/.ssh/id_rsa &amp;&amp; chmod 0600 /root/.ssh/id_rsa</a>
<a class="sourceLine" id="cb7-9" title="9">  <span class="kw">-</span> echo -e <span class="st">&quot;Host github.com</span><span class="sc">\n\t</span><span class="st">StrictHostKeyChecking no</span><span class="sc">\n</span><span class="st">&quot;</span> &gt; /root/.ssh/config</a>
<a class="sourceLine" id="cb7-10" title="10">  <span class="kw">-</span> git clone -b gh-pages git@github.com:haskell-jp/antenna.git temp</a></code></pre></div>
<p><span class="ascii">Secret</span>というのは<span class="ascii">Drone</span>側で保持・秘匿できる環境変数のような機能です<span class="ascii">(</span>名前が違うだけでだいたいどの<span class="ascii">CI</span>プラットフォームにもありますね<span class="ascii">)</span>。 今回はせっかくなので、これを<span class="ascii">Drone Plugin</span>として自作した<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>、<a href="https://github.com/matsubara0507/drone-git-with-ssh"><code>matsubara0507/git-with-ssh</code></a> というのを使います<span class="ascii">:</span></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb8-1" title="1"><span class="co"># .drone.yml</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="fu">kind:</span><span class="at"> pipeline</span></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="fu">name:</span><span class="at"> default</span></a>
<a class="sourceLine" id="cb8-4" title="4"></a>
<a class="sourceLine" id="cb8-5" title="5"><span class="fu">steps:</span></a>
<a class="sourceLine" id="cb8-6" title="6"><span class="kw">-</span> <span class="fu">name:</span><span class="at"> clone gh-pages</span></a>
<a class="sourceLine" id="cb8-7" title="7">  <span class="fu">image:</span><span class="at"> matsubara0507/git-with-ssh</span></a>
<a class="sourceLine" id="cb8-8" title="8">  <span class="fu">settings:</span></a>
<a class="sourceLine" id="cb8-9" title="9">    <span class="fu">ssh_private_key:</span></a>
<a class="sourceLine" id="cb8-10" title="10">      <span class="fu">from_secret:</span><span class="at"> deploy_key</span></a>
<a class="sourceLine" id="cb8-11" title="11">    <span class="fu">ssh_hosts:</span></a>
<a class="sourceLine" id="cb8-12" title="12">    <span class="kw">-</span> github.com</a>
<a class="sourceLine" id="cb8-13" title="13">    <span class="fu">commands:</span></a>
<a class="sourceLine" id="cb8-14" title="14">    <span class="kw">-</span> git clone -b gh-pages git@github.com:haskell-jp/antenna.git temp</a>
<a class="sourceLine" id="cb8-15" title="15">  <span class="fu">when:</span></a>
<a class="sourceLine" id="cb8-16" title="16">    <span class="fu">branch:</span></a>
<a class="sourceLine" id="cb8-17" title="17">    <span class="kw">-</span> master</a>
<a class="sourceLine" id="cb8-18" title="18">    <span class="fu">event:</span></a>
<a class="sourceLine" id="cb8-19" title="19">      <span class="fu">exclude:</span></a>
<a class="sourceLine" id="cb8-20" title="20">      <span class="kw">-</span> pull_request</a>
<a class="sourceLine" id="cb8-21" title="21"></a>
<a class="sourceLine" id="cb8-22" title="22"><span class="kw">-</span> <span class="fu">name:</span><span class="at"> exec antenna</span></a>
<a class="sourceLine" id="cb8-23" title="23">  <span class="fu">image:</span><span class="at"> haskelljp/antenna</span></a>
<a class="sourceLine" id="cb8-24" title="24">  <span class="fu">commands:</span></a>
<a class="sourceLine" id="cb8-25" title="25">  <span class="kw">-</span> mkdir -p temp</a>
<a class="sourceLine" id="cb8-26" title="26">  <span class="kw">-</span> cp sites.yaml temp/sites.yaml</a>
<a class="sourceLine" id="cb8-27" title="27">  <span class="kw">-</span> cp -r image/* temp/image</a>
<a class="sourceLine" id="cb8-28" title="28">  <span class="kw">-</span> cd temp</a>
<a class="sourceLine" id="cb8-29" title="29">  <span class="kw">-</span> antenna sites.yaml</a>
<a class="sourceLine" id="cb8-30" title="30"></a>
<a class="sourceLine" id="cb8-31" title="31"><span class="kw">-</span> <span class="fu">name:</span><span class="at"> push gh-pages</span></a>
<a class="sourceLine" id="cb8-32" title="32">  <span class="fu">image:</span><span class="at"> matsubara0507/git-with-ssh</span></a>
<a class="sourceLine" id="cb8-33" title="33">  <span class="fu">settings:</span></a>
<a class="sourceLine" id="cb8-34" title="34">    <span class="fu">ssh_private_key:</span></a>
<a class="sourceLine" id="cb8-35" title="35">      <span class="fu">from_secret:</span><span class="at"> deploy_key</span></a>
<a class="sourceLine" id="cb8-36" title="36">    <span class="fu">ssh_hosts:</span></a>
<a class="sourceLine" id="cb8-37" title="37">    <span class="kw">-</span> github.com</a>
<a class="sourceLine" id="cb8-38" title="38">    <span class="fu">commands:</span></a>
<a class="sourceLine" id="cb8-39" title="39">    <span class="kw">-</span> cd temp &amp;&amp; git config user.name  BOT</a>
<a class="sourceLine" id="cb8-40" title="40">    <span class="kw">-</span> cd temp &amp;&amp; git config user.email bot@example.com</a>
<a class="sourceLine" id="cb8-41" title="41">    <span class="kw">-</span> cd temp &amp;&amp; git status</a>
<a class="sourceLine" id="cb8-42" title="42">    <span class="kw">-</span> cd temp &amp;&amp; git add -A</a>
<a class="sourceLine" id="cb8-43" title="43">    <span class="kw">-</span> cd temp &amp;&amp; git diff --quiet &amp;&amp; git diff --staged --quiet || git commit -am <span class="st">&quot;[skip ci] Update planet haskell. See https://haskell.jp/antenna/ for new entries!&quot;</span></a>
<a class="sourceLine" id="cb8-44" title="44">    <span class="kw">-</span> cd temp &amp;&amp; git push origin gh-pages</a>
<a class="sourceLine" id="cb8-45" title="45">  <span class="fu">when:</span></a>
<a class="sourceLine" id="cb8-46" title="46">    <span class="fu">branch:</span></a>
<a class="sourceLine" id="cb8-47" title="47">    <span class="kw">-</span> master</a>
<a class="sourceLine" id="cb8-48" title="48">    <span class="fu">event:</span></a>
<a class="sourceLine" id="cb8-49" title="49">      <span class="fu">exclude:</span></a>
<a class="sourceLine" id="cb8-50" title="50">      <span class="kw">-</span> pull_request</a></code></pre></div>
<p><code>cd temp &amp;&amp;</code> というのがダサいですが、そこはおいおい直します<span class="ascii">(</span><code>git-with-ssh</code> の方を<span class="ascii">)</span>。</p>
<h2 id="slackの通知回りを整理"><span class="link-to-here-outer"><a href="#slackの通知回りを整理" title="slackの通知回りを整理"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Slack</span>の通知回りを整理</h2>
<p>元々は<span class="ascii">Haskell-jp</span>の <code>#antenna</code> チャンネルに<span class="ascii">GitHub</span>の通知設定をしているだけでした。 今回の開発中、ずっとコミットの通知などが来てうるさかったので次のように分けました<span class="ascii">:</span></p>
<ul>
<li><code>#antenna</code> チャンネルは <code>gh-pages</code> ブランチのコミットだけ通知
<ul>
<li>ついでに<span class="ascii">Haskell Antenna</span>の<span class="ascii">RSS</span>を設定した</li>
</ul></li>
<li><code>#antenna-dev</code> チャンネルを新しく作り<span class="ascii">GitHub</span>の全ての更新はこっちに設定</li>
<li><code>#dockerhub</code> チャンネルもついでに作って <code>haskelljp</code> の更新を通知する</li>
</ul>
<p>最近、<span class="ascii">Docker Hub</span>の大リニューアルがあって、いつのまにか<span class="ascii">Docker Hub</span>と<span class="ascii">Slack</span>を連携できるようになっていました。 なので試しに連携して更新の通知が飛ぶようにしてみました<span class="ascii">:</span></p>
<p><img src="../../img/2019/hourly-antenna/dockerhub-slack.jpg" style="width: 100%;"></p>
<h1 id="今後やりたいこと"><span class="link-to-here-outer"><a href="#今後やりたいこと" title="今後やりたいこと"><span class="link-to-here">Link to<br />
here</span></a></span>今後やりたいこと</h1>
<p>いくつかあります<span class="ascii">:</span></p>
<ul>
<li><span class="ascii">LTS</span>の更新<span class="ascii">(</span>最新<span class="ascii">GHC</span>が<span class="ascii">Windows</span>でも動作したらかな<span class="ascii">)</span></li>
<li><span class="ascii">Feed</span>の改善
<ul>
<li><span class="ascii">Slack</span>の<span class="ascii">RSS</span>でもちゃんと更新が通知されるように</li>
</ul></li>
<li>ないしは更新差分の通知
<ul>
<li><span class="ascii">Haskell-jp Slack</span>の<span class="ascii">App</span>が満杯なので厳しいかも</li>
</ul></li>
</ul>
<p>あと、<span class="ascii">Qiita</span>の<span class="ascii">Feed</span>がコメントや追記などでも更新され、その通知が <code>#antenna</code> チャンネルに飛んで来てうるさいので修正したいです<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>。</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>キャッシュの導入の仕方は記事にしたので興味のある方は是非「<a href="https://matsubara0507.github.io/posts/2019-01-06-use-drone-cache-with-gcs.html"><span class="ascii">GCS</span> で <span class="ascii">Drone 1.0</span> をキャッシュする <span class="ascii">-</span> ひげメモ</a>」<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>もし<span class="ascii">Docker Hub</span>の<span class="ascii">haskelljp</span>組織アカウントのメンバーになりたい場合は<span class="ascii">Haskell-jp Slack</span>で声をかけてください<span class="ascii">(</span>チャンネルはどこでも良いですよ<span class="ascii">)</span>。<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>この話も記事にしておきました「<a href="https://matsubara0507.github.io/posts/2019-01-20-create-drone-git-with-ssh.html"><span class="ascii">Drone Plugin</span> を作ってみた<span class="ascii">: git-with-ssh -</span> ひげメモ</a>」<a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p>この修正は <code>haskell-jp/antenna</code> ではなく、<a href="https://github.com/matsubara0507/scrapbook"><code>matsubara0507/scrapbook</code></a> からやる必要があります。<a href="#fnref4" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/string-gap-for-heredoc-like.html" lang="ja">Haskell でも heredoc がしたい</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/tidalcycles-stack.html" style="margin-left: auto;" lang="ja">TidalCyclesをstackで確実にインストールする</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>TidalCyclesをstackで確実にインストールする</title>
    <link href="https://haskell.jp/blog/posts/2019/tidalcycles-stack.html" />
    <id>https://haskell.jp/blog/posts/2019/tidalcycles-stack.html</id>
    <published>2019-01-17T00:00:00Z</published>
    <updated>2019-01-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#背景" title="背景">背景</a></li>
<li><a href="#実行した環境" title="実行した環境">実行した環境</a></li>
<li><a href="#各種依存パッケージのインストール" title="各種依存パッケージのインストール">各種依存パッケージのインストール</a>
<ul>
<li><a href="#tidalcycles公式のwikiそのままの手順" title="tidalcycles公式のwikiそのままの手順"><span class="ascii">TidalCycles</span>公式の<span class="ascii">Wiki</span>そのままの手順</a></li>
<li><a href="#tidalcycles公式のwikiとは異なる手順" title="tidalcycles公式のwikiとは異なる手順"><span class="ascii">TidalCycles</span>公式の<span class="ascii">Wiki</span>とは異なる手順</a>
<ul>
<li><a href="#stackでのtidalcyclesのビルド" title="stackでのtidalcyclesのビルド"><span class="ascii">stack</span>での<span class="ascii">TidalCycles</span>のビルド</a></li>
<li><a href="#atomのプラグインの設定" title="atomのプラグインの設定"><span class="ascii">Atom</span>のプラグインの設定</a></li>
</ul></li>
</ul></li>
<li><a href="#使い方動作確認" title="使い方動作確認">使い方・動作確認</a>
<ul>
<li><a href="#tidalcyclesを起動する度に必要になる手順" title="tidalcyclesを起動する度に必要になる手順"><span class="ascii">TidalCycles</span>を起動する度に必要になる手順</a></li>
</ul></li>
<li><a href="#ハマったこと" title="ハマったこと">ハマったこと</a>
<ul>
<li><a href="#superdirtが見つからないという趣旨のエラーが出た" title="superdirtが見つからないという趣旨のエラーが出た">「<span class="ascii">SuperDirt</span>が見つからない！」という趣旨のエラーが出た</a></li>
<li><a href="#atom上でtidalcyclesを起動した際parse-error" title="atom上でtidalcyclesを起動した際parse-error"><span class="ascii">Atom</span>上で<span class="ascii">TidalCycles</span>を起動した際、<code>parse error</code></a></li>
<li><a href="#superdirtを起動し忘れていても何もエラーが起きない" title="superdirtを起動し忘れていても何もエラーが起きない"><span class="ascii">SuperDirt</span>を起動し忘れていても何もエラーが起きない</a></li>
</ul></li>
<li><a href="#おわりに-haskell開発者として見たtidalcycles" title="おわりに-haskell開発者として見たtidalcycles">おわりに<span class="ascii">: Haskell</span>開発者として見た<span class="ascii">TidalCycles</span></a></li>
</ul>
</div>
</div>
<h1 id="背景"><span class="link-to-here-outer"><a href="#背景" title="背景"><span class="link-to-here">Link to<br />
here</span></a></span>背景</h1>
<p>先日<span class="ascii">teratail</span>の<span class="ascii">Haskell</span>タグを眺めていたところ、下記のような質問がありました。</p>
<p><a href="https://teratail.com/questions/167461?rss"><span class="ascii">Haskell - network</span>パッケージがうまく機能しない｜<span class="ascii">teratail</span></a></p>
<p><a href="https://tidalcycles.org/index.php/Welcome"><span class="ascii">TidalCycles</span></a>という、<span class="ascii">Haskell</span>製の内部<span class="ascii">DSL</span>でシンセサイザーの演奏ができるライブラリーのインストールがうまくいかない、という質問です。<br />
<span class="ascii">network</span>パッケージがインストールできていない、ということなので<span class="ascii">cabal hell</span>にでもハマったのかな、と思ったのですが、<a href="https://github.com/tidalcycles/tidal-chocolatey/issues/1">類似しているとおぼしき報告</a>（と、<a href="https://qiita.com/yoppa/items/fe21d7136f8f3aafd55c#comment-b568fc7ecb423b9bc2ce">こちら</a>）を読む限り、どうも<span class="ascii">GHC</span>のインストール自体に何か問題があるように見えました。</p>
<p>もう当の質問者は<span class="ascii">Haskell Platform</span>をインストールすることで解決したそうですが、いずれにしても、我々<span class="ascii">Haskeller</span>としては、<span class="ascii">stack</span>なり<span class="ascii">cabal new-install</span>なりといった、慣れた方法でインストールできた方がサポートしやすいですし、きっと確実です。<br />
というわけで今回は<span class="ascii">stack</span>でのインストールに挑戦してみました。<br />
すでに<span class="ascii">stack</span>をインストールしているという<span class="ascii">Haskell</span>開発者は多いでしょうし、そうした方が<span class="ascii">TidalCycles</span>を使いたくなったときの参考になれば幸いです。</p>
<p>結論から言うとほとんど問題なくできたんですが、以下の<span class="ascii">tweet</span>で述べたポイントにご注意ください。</p>
<blockquote class="twitter-tweet" data-lang="ja">
<p lang="ja" dir="ltr">
<span class="ascii">TidalCycles, Atom</span>の<span class="ascii">package</span>の設定で<span class="ascii">stack exec ghci</span>を使うよう設定したら普通に<span class="ascii">stack</span>で入れた<span class="ascii">GHC</span>から使えましたわ。<br>ポイントは、<br><span class="ascii">- hosc-0.17</span>の<span class="ascii">stack.yaml</span>の<span class="ascii">extra-deps</span>に加えないといけない<br><span class="ascii">- Windows</span>で<span class="ascii">GHC 8.6.3</span>は地雷なので<span class="ascii">LTS 12.26</span>を使う<br><span class="ascii">- ~/.ghci</span>で<span class="ascii">:set +m</span>してるとうまく動かない<br>ぐらいか。
</p>
— <span class="ascii">Yuji Yamamoto:</span> 山本悠滋 <span class="ascii">(</span><span class="citation" data-cites="igrep"><span class="ascii">@igrep</span></span><span class="ascii">)</span> <a href="https://twitter.com/igrep/status/1082475580753207296?ref_src=twsrc%5Etfw"><span class="ascii">2019</span>年<span class="ascii">1</span>月<span class="ascii">8</span>日</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<h1 id="実行した環境"><span class="link-to-here-outer"><a href="#実行した環境" title="実行した環境"><span class="link-to-here">Link to<br />
here</span></a></span>実行した環境</h1>
<ul>
<li><span class="ascii">Windows 10 Pro 64bit ver. 1809</span></li>
<li><code>stack --version</code><span class="ascii">: Version 1.9.1, Git revision f9d0042c141660e1d38f797e1d426be4a99b2a3c (6168 commits) x86_64 hpack-0.31.0</span></li>
<li><span class="ascii">TidalCycles:</span> <a href="http://hackage.haskell.org/package/tidal-1.0.6"><span class="ascii">1.0.6</span></a></li>
<li><span class="ascii">SuperCollider: 3.10.0, 64bit</span></li>
<li><span class="ascii">Atom: 1.34.0</span></li>
<li><span class="ascii">Atom</span>の<span class="ascii">tidalcycles</span>プラグイン<span class="ascii">: 0.14.0</span></li>
</ul>
<h1 id="各種依存パッケージのインストール"><span class="link-to-here-outer"><a href="#各種依存パッケージのインストール" title="各種依存パッケージのインストール"><span class="link-to-here">Link to<br />
here</span></a></span>各種依存パッケージのインストール</h1>
<p>冒頭に挙げた質問をされた方が参考にしたページ <a href="https://qiita.com/yoppa/items/fe21d7136f8f3aafd55c"><span class="ascii">TidalCycles</span>のインストール<span class="ascii">2018</span>年版 <span class="ascii">- Qiita</span></a> では、<span class="ascii">Chocolatey</span>を使ったインストール方法を紹介していますが、この方法では、直接<span class="ascii">GHC</span>の<span class="ascii">Windows</span>向け<span class="ascii">tarball</span>をダウンロードしてインストールしているようです。<br />
私が知る限り特にその方法でも問題はないはずなんですが、なぜか質問者が挙げたようなエラーが発生してしまいます。<br />
また、<span class="ascii">TidalCycles</span>が実行時に依存している<span class="ascii">SuperCollider</span>や<span class="ascii">SuperDirt</span>といったソフトウェアを、別の<span class="ascii">Chocolatey</span>のパッケージに分けることなく、<span class="ascii">TidalCycles</span>のインストールスクリプトで直接インストールしているようです<small>（詳細は<a href="https://chocolatey.org/packages/TidalCycles"><span class="ascii">Chocolatey</span>のパッケージ情報</a>に書かれた<span class="ascii">chocolateyinstall.ps1</span>を参照されたし）</small>。<br />
そのため、<span class="ascii">Chocolatey</span>で<span class="ascii">TidalCycles</span>をインストールしようとすると、問題のある<span class="ascii">GHC</span>と、<span class="ascii">SuperCollider</span>などの依存パッケージを一緒にインストールしなければなりませんし、<span class="ascii">SuperCollider</span>や<span class="ascii">SuperDirt</span>だけを<span class="ascii">Chocolatey</span>でインストールすることもできません。</p>
<p>なので、ここは素直に<a href="https://tidalcycles.org/index.php/Windows_installation"><span class="ascii">TidalCycles</span>公式の<span class="ascii">Wiki</span></a>に書かれた方法に従って<span class="ascii">SuperCollider</span>や<span class="ascii">SuperDirt</span>をインストールしつつ、<span class="ascii">Haskell</span>関連のものだけ<span class="ascii">stack</span>でインストールしようと思います。</p>
<h2 id="tidalcycles公式のwikiそのままの手順"><span class="link-to-here-outer"><a href="#tidalcycles公式のwikiそのままの手順" title="tidalcycles公式のwikiそのままの手順"><span class="link-to-here">Link to<br />
here</span></a></span><a href="https://tidalcycles.org/index.php/Windows_installation"><span class="ascii">TidalCycles</span>公式の<span class="ascii">Wiki</span></a>そのままの手順</h2>
<p><strong>⚠️行く先々で<span class="ascii">Windows</span>のファイアウォールの警告が出るかと思います。適当に承認しちゃってください！⚠️</strong></p>
<ol type="1">
<li><a href="https://supercollider.github.io/download"><span class="ascii">SuperCollider</span>を公式サイトからインストール</a>します。<br />
今回は「<span class="ascii">Windows</span>」の箇所に書いてある「<span class="ascii">3.10.0, 64-bit (no SuperNova)</span>」というリンクをクリックしてダウンロードされた実行ファイルでインストールしました。</li>
<li><a href="https://atom.io/"><span class="ascii">Atom</span></a>も公式サイトからインストールしました。<br />
後で触れます<span class="ascii">TidalCycles</span>の対話環境を、<span class="ascii">Atom</span>上で呼び出すためのプラグインがあるためです。他のエディタ向けのプラグインもありますが、公式サイトで紹介していたのは<span class="ascii">Atom</span>なので、一番これがサポートされているのでしょう。</li>
<li><span class="ascii">Git</span>も<span class="ascii">Prerequisites</span>として挙げられていますが、すでに私の環境に入っているので今回は特に何もしていません。なければ普通に<a href="https://gitforwindows.org/"><span class="ascii">Git for Windows</span></a>を入れるのが無難かと思います。</li>
<li><span class="ascii">SuperDirt</span>のインストール
<ol type="1">
<li><span class="ascii">SuperCollider</span>をスタートメニューから起動します。</li>
<li>ウィンドウの左側にある「<span class="ascii">Untitled</span>」と書かれた箇所の下が<span class="ascii">SuperCollider</span>のエディタになっているようです<small>（色がわかりづらい！）</small>。<br />
そこに<code>include("SuperDirt")</code>と書いて、「<span class="ascii">Shift + Enter</span>」を押せば、<span class="ascii">SuperDirt</span>のインストールが始まります。</li>
<li>次のセクションで<span class="ascii">SuperDirt</span>を起動する前に、<strong>一旦<span class="ascii">SuperCollider</span>を終了</strong>させましょう。</li>
</ol></li>
<li><span class="ascii">Atom</span>向け<span class="ascii">tidalcycles</span>プラグインのインストール
<ul>
<li>面倒なので省略します。他のプラグインと変わらないはずなので適当に検索してください！</li>
</ul></li>
</ol>
<h2 id="tidalcycles公式のwikiとは異なる手順"><span class="link-to-here-outer"><a href="#tidalcycles公式のwikiとは異なる手順" title="tidalcycles公式のwikiとは異なる手順"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">TidalCycles</span>公式の<span class="ascii">Wiki</span>とは異なる手順</h2>
<p>ここからはこの記事特有の手順です。<br />
最近の<span class="ascii">Haskell</span>開発者は、<a href="https://docs.haskellstack.org/en/stable/README/"><span class="ascii">stack</span></a>というツールを使って開発環境を整えることが多いですので、冒頭の予告通りここでは<span class="ascii">stack</span>を使います。<br />
ちなみに、現在は<span class="ascii">Haskell Platform</span>にも<span class="ascii">stack</span>が添付されていますが、<span class="ascii">Haskell Platform</span>に含まれる、<span class="ascii">GHC</span>は<span class="ascii">stack</span>を使うことでも簡単にインストールできるため、<span class="ascii">stack</span>のみをインストールすれば十分です。<br />
なお、<span class="ascii">stack</span>自体のインストール方法については拙作の<a href="https://github.com/haskell-jp/makeMistakesToLearnHaskell#%E3%81%BE%E3%81%A0stack%E3%82%84haskell-platform%E3%82%92%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB%E3%81%97%E3%81%A6%E3%81%84%E3%81%AA%E3%81%84%E5%A0%B4%E5%90%88%E3%81%AF">「失敗しながら学ぶ<span class="ascii">Haskell</span>入門」の<span class="ascii">README</span></a>をご覧ください。<br />
<span class="ascii">Windows</span>ではインストーラーをダウンロードして実行するだけで十分でしょう。</p>
<p><span class="ascii">stack</span>のインストールが終わったら、次の手順を踏んでください。</p>
<h3 id="stackでのtidalcyclesのビルド"><span class="link-to-here-outer"><a href="#stackでのtidalcyclesのビルド" title="stackでのtidalcyclesのビルド"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">stack</span>での<span class="ascii">TidalCycles</span>のビルド</h3>
<p><span class="ascii">stack</span>で<span class="ascii">TidalCycles</span>のビルドをするには、<code>C:\sr\global-project\stack.yaml</code>というファイルを、下記でコメントしたように書き換えてください。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb1-1" title="1"><span class="co"># ... 省略 ...</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="fu">packages:</span><span class="at"> </span><span class="kw">[]</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="fu">resolver:</span><span class="at"> lts-12.26 </span><span class="co"># &lt;= ここを編集</span></a>
<a class="sourceLine" id="cb1-4" title="4"></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="fu">extra-deps:</span><span class="at">         </span><span class="co"># &lt;= この行と、</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="kw">-</span> hosc-0.17         <span class="co"># &lt;= この行を追記</span></a></code></pre></div>
<p>簡単に編集した内容について解説させてください。</p>
<p>まず、<code>resolver:</code>で始まる行ですが、これは「<span class="ascii">LTS Haskell</span>」という、パッケージの一覧のバージョンを指定するものです。<br />
「<span class="ascii">LTS Haskell</span>」は、「確実にビルドできるバージョンのパッケージをまとめた一覧」です。<br />
<span class="ascii">LTS Haskell</span>のメンテナーの方々は、毎日登録された大量のパッケージをまとめてビルド・テストしてみることで、実際に登録されたバージョンのパッケージのビルドとテストが成功することを確認しています。<br />
なので、この<span class="ascii">LTS Haskell</span>に登録されているバージョンのパッケージを使う限りは、私たちは安心してビルドができると言うことです。</p>
<p>なぜ<span class="ascii">LTS Haskell</span>のバージョンを書き換えたのかというと、それは、<span class="ascii">LTS Haskell</span>には実際にはパッケージの一覧だけでなく、それらをビルドできる<span class="ascii">GHC</span>のバージョンも含まれているからです。<br />
したがって、<span class="ascii">LTS Haskell</span>のバージョンを指定する、ということは、そのままインストールする<span class="ascii">GHC</span>のバージョンも指定することになります<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>。<br />
実は特に今回の場合、インストールする<span class="ascii">GHC</span>のバージョンを指定しなければ、ビルドできない可能性が高かったのです。<br />
現在の最新の<span class="ascii">LTS Haskell</span>に登録されている<span class="ascii">GHC</span>のバージョンは「<span class="ascii">8.6.3</span>」ですが、残念ながらこのバージョンの<span class="ascii">GHC</span>には、<a href="https://ghc.haskell.org/trac/ghc/ticket/16057"><span class="ascii">Windows</span>版のみにおいて深刻なバグ</a>があります。<br />
実際に<span class="ascii">TidalCycles</span>をビルドする際にこのバグに遭遇するかは確かめてませんが、内容からして遭遇する確率が高そうであるという点と、遭遇するとビルドができないという点を考慮して、念のため確実にビルドできるバージョンの<span class="ascii">GHC</span>を指定しておきました。</p>
<p>そして、<code>extra-deps</code>という項目は、ビルドしようとしているパッケージ<small>（今回の場合<code>tidal</code>パッケージ）</small>が依存しているパッケージが、<span class="ascii">LTS Haskell</span>に登録されていない場合に指定するものです。<br />
<a href="http://hackage.haskell.org/package/tidal-1.0.6"><span class="ascii">tidal</span>パッケージ <span class="ascii">ver. 1.0.6</span>のパッケージ情報</a>を確認すると、確かに<span class="ascii">hosc</span>というパッケージに依存していると書かれていますね！<br />
残念ながらこの<span class="ascii">hosc</span>パッケージは今回指定した、<span class="ascii">LTS Haskell</span>の<span class="ascii">ver. 12.26</span>には登録されていないので、上記のとおり<code>extra-deps</code>に明記しておいてください。</p>
<p><code>C:\sr\global-project\stack.yaml</code>の編集が終わったら、</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" title="1"><span class="ex">stack</span> build tidal</a></code></pre></div>
<p>と実行しましょう。<br />
初回は<span class="ascii">GHC</span>のインストールも含めて行われるので、結構時間がかかると思います。</p>
<p>ちなみに、<code>stack install tidal</code>と実行してもいいですが、<span class="ascii">stack</span>の仕様上、特に結果は変わりません。<br />
<code>stack install</code>は、実行ファイルがついたパッケージをビルドして<code>PATH</code>にインストールするためのコマンドなので、<code>tidal</code>のように実行ファイルがないパッケージでは意味がありません。</p>
<h3 id="atomのプラグインの設定"><span class="link-to-here-outer"><a href="#atomのプラグインの設定" title="atomのプラグインの設定"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Atom</span>のプラグインの設定</h3>
<p>続いて、<span class="ascii">Atom</span>の<span class="ascii">tidalcycles</span>プラグインの設定をしましょう。<br />
<span class="ascii">stack</span>は使用する<span class="ascii">GHC</span>を、前述の<span class="ascii">stack.yaml</span>に書いた<span class="ascii">LTS Haskell</span>のバージョンに応じて切り替える関係上、<code>PATH</code>の通ったところに<span class="ascii">GHC</span>をインストールしません。<br />
そのため、<span class="ascii">Atom</span>の<span class="ascii">tidalcycles</span>プラグインに、<span class="ascii">stack</span>がインストールした<span class="ascii">GHC</span>を認識させるには、下記のように設定を書き換える必要があります。</p>
<ol type="1">
<li><span class="ascii">Atom</span>を起動し、「<span class="ascii">File</span>」 <span class="ascii">-&gt;</span> 「<span class="ascii">Settings</span>」の順にメニューをクリックして、<span class="ascii">Atom</span>の設定画面を開きます。</li>
<li>画面左側の「📦<span class="ascii">Packages</span>」と書かれた箇所をクリックすると、インストールした<span class="ascii">Atom</span>のプラグインの一覧が表示されるはずです。</li>
<li>一覧から「<span class="ascii">tidalcycles</span>」を探して、「⚙️<span class="ascii">Settings</span>」をクリックします。</li>
<li>「<span class="ascii">Ghci Path</span>」という設定項目があるので、それを<code>stack exec ghci</code>に書き換えてください。</li>
</ol>
<h1 id="使い方動作確認"><span class="link-to-here-outer"><a href="#使い方動作確認" title="使い方動作確認"><span class="link-to-here">Link to<br />
here</span></a></span>使い方・動作確認</h1>
<h2 id="tidalcyclesを起動する度に必要になる手順"><span class="link-to-here-outer"><a href="#tidalcyclesを起動する度に必要になる手順" title="tidalcyclesを起動する度に必要になる手順"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">TidalCycles</span>を起動する度に必要になる手順</h2>
<p>※<a href="https://tidalcycles.org/index.php/Start_tidalcycles_and_superdirt_for_the_first_time">公式サイトのこちらのページ</a>に対応しています。</p>
<ol type="1">
<li><span class="ascii">SuperDirt</span>の起動
<ol type="1">
<li><span class="ascii">SuperCollider</span>をスタートメニューから起動します。</li>
<li>先ほど<code>include("SuperDirt")</code>と入力した、<span class="ascii">SuperCollider</span>のエディタに、今度は<code>SuperDirt.start</code>と入力して、同じく「<span class="ascii">Shift + Enter</span>」しましょう。<br />
<span class="ascii">SuperDirt</span>が起動します。</li>
</ol></li>
<li><span class="ascii">Atom</span>上での<span class="ascii">TidalCycles</span>の起動
<ol type="1">
<li><span class="ascii">Atom</span>を起動して、拡張子が<code>.tidal</code>なファイルを開くか作成します。</li>
<li>メニューを「<span class="ascii">Packages</span>」 <span class="ascii">-&gt;</span> 「<span class="ascii">TidalCycles</span>」 <span class="ascii">-&gt;</span> 「<span class="ascii">Boot TidalCycles</span>」の順に選択してください。</li>
<li>画面下部で<span class="ascii">GHCi</span>が起動し、<span class="ascii">TidalCycles</span>の式を実行するのに必要なパッケージの<code>import</code>や、<code>import</code>では賄いきれない関数の定義などが自動的に行われます。
<ul>
<li><a href="https://github.com/tidalcycles/Tidal/blob/master/BootTidal.hs"><span class="ascii">BootTidal.hs</span></a>というファイルの中身を<span class="ascii">GHCi</span>に貼り付けているみたいです。</li>
</ul></li>
</ol></li>
<li>動作確認のために、適当な<span class="ascii">TidalCycles</span>の式 — 例えば公式サイトの<span class="ascii">Wiki</span>どおり<code>d1 $ sound "bd sn"</code> — を入力して、入力した行にカーソルを置き、「<span class="ascii">Shift + Enter</span>」を押しましょう。
<ol type="1">
<li>入力した式が画面下部で起動した<span class="ascii">GHCi</span>に送信され、実行されます。うまくいっていれば音が鳴るはずです。</li>
<li>停止させたいときは、<code>d1 silence</code>と入力して同じく「<span class="ascii">Shift + Enter</span>」を押してください。</li>
</ol></li>
<li>より詳しい<span class="ascii">TidalCycles</span>の使い方は、<a href="https://qiita.com/mk668a/items/6e8e0151817f484a526c"><span class="ascii">TidalCycles</span>のチュートリアル<span class="ascii">1 - Qiita</span></a>など、他の方が書いた記事を検索してみてください。</li>
</ol>
<h1 id="ハマったこと"><span class="link-to-here-outer"><a href="#ハマったこと" title="ハマったこと"><span class="link-to-here">Link to<br />
here</span></a></span>ハマったこと</h1>
<h2 id="superdirtが見つからないという趣旨のエラーが出た"><span class="link-to-here-outer"><a href="#superdirtが見つからないという趣旨のエラーが出た" title="superdirtが見つからないという趣旨のエラーが出た"><span class="link-to-here">Link to<br />
here</span></a></span>「<span class="ascii">SuperDirt</span>が見つからない！」という趣旨のエラーが出た</h2>
<p>正確なエラーメッセージは申し訳なくも忘れてしまったのですが、<span class="ascii">SuperCollider</span>上で<code>SuperDirt.start</code>と入力した際、エラーになることがあります。<br />
この場合、<span class="ascii">SuperCollider</span>を再起動するのを忘れている可能性がありますので、再起動してみてください。<br />
<span class="ascii">SuperDirt</span>のインストールを終えた直後では、まだ<span class="ascii">SuperDirt</span>は利用できないのです。</p>
<h2 id="atom上でtidalcyclesを起動した際parse-error"><span class="link-to-here-outer"><a href="#atom上でtidalcyclesを起動した際parse-error" title="atom上でtidalcyclesを起動した際parse-error"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Atom</span>上で<span class="ascii">TidalCycles</span>を起動した際、<code>parse error</code></h2>
<p>先ほどの「<span class="ascii">Atom</span>上での<span class="ascii">TidalCycles</span>の起動」という手順で、<code>parse error (possibly incorrect indentation or mismatched brackets)</code>というエラーに出遭うことがあります。<br />
そのまま<span class="ascii">TidalCycles</span>の式を入力して「<span class="ascii">Shift + Enter</span>」しても、<code>Variable not in scope: d1 :: ControlPattern -&gt; t</code>などというエラーになってしまうでしょう。<br />
これは、前のセクションで触れた<span class="ascii">BootTidal.hs</span>というファイルを<span class="ascii">GHCi</span>が読み込む際に、エラーになってしまったからです。</p>
<p>原因はいろいろあり得るかと思いますが、私の場合、<code>~/.ghci</code>という<span class="ascii">GHCi</span>の設定ファイルに<code>:set +m</code>という行を加えていたためでした。<br />
まず、<code>~/.ghci</code>は、<span class="ascii">GHCi</span>が起動するときに必ず読み込まれるファイルです。<br />
必ず有効にしたい言語拡張や、<code>:set +m</code>のような<span class="ascii">GHCi</span>の設定を記載しておくファイルとなっています。要するに<code>~/.vimrc</code>などと似たようなものですね。<br />
そして<code>:set +m</code>は、<span class="ascii">GHCi</span>で複数行の入力を有効にするためのものです。<br />
<span class="ascii">GHCi</span>上で<code>:set +m</code>と実行すると、<span class="ascii">GHCi</span>は入力した行を見て「あっ、この入力はまだ続きがありそうだな」と判断したとき、次の行を自動で前の行の続きとして扱うようになります。<br />
そして、その場合入力の終了を<span class="ascii">GHCi</span>に伝えたい場合は、空行を入力しなければなりません。<br />
結果、<span class="ascii">BootTidal.hs</span>を読み込む際に、空行が入力されないため、意図しない行が「前の行の続き」と<span class="ascii">GHCi</span>に認識されてしまい、<code>parse error (possibly incorrect indentation or mismatched brackets)</code>となってしまうようです。</p>
<p>仕方ないので、直すために<code>~/.ghci</code>を開いて<code>:set +m</code>と書いた行をコメントアウトするか削除しちゃいましょう。<br />
再び<span class="ascii">Atom</span>で「<span class="ascii">Packages</span>」 <span class="ascii">-&gt;</span> 「<span class="ascii">TidalCycles</span>」 <span class="ascii">-&gt;</span> 「<span class="ascii">Boot TidalCycles</span>」の順にメニューをクリックすれば、今度は該当のエラーがなく起動するかと思います😌。</p>
<p>このエラーは、特にすでに<span class="ascii">Haskell</span>の開発環境を導入している方で遭遇するケースが多いかと思います。ご注意ください。</p>
<h2 id="superdirtを起動し忘れていても何もエラーが起きない"><span class="link-to-here-outer"><a href="#superdirtを起動し忘れていても何もエラーが起きない" title="superdirtを起動し忘れていても何もエラーが起きない"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">SuperDirt</span>を起動し忘れていても何もエラーが起きない</h2>
<p>表題の通りです。<br />
困ったことに<span class="ascii">SuperDirt</span>を起動し忘れた状態で<code>d1 $ sound "bd sn"</code>などの式を実行しても、特に何のエラーもなく、音も鳴りません。<br />
<small>（サーバーとして起動しているべき）</small><span class="ascii">SuperDirt</span>に接続し損ねたんだから、何かしらエラーが表示されてもいいはずなんですが、困ったことにウンともスンとも言いません😰。<br />
と、言うわけで、何のエラーもなく音も出なかった場合は、<span class="ascii">SuperDirt</span>を起動し忘れてないか確認しましょう。</p>
<h1 id="おわりに-haskell開発者として見たtidalcycles"><span class="link-to-here-outer"><a href="#おわりに-haskell開発者として見たtidalcycles" title="おわりに-haskell開発者として見たtidalcycles"><span class="link-to-here">Link to<br />
here</span></a></span>おわりに<span class="ascii">: Haskell</span>開発者として見た<span class="ascii">TidalCycles</span></h1>
<p><strong>※ここから先はおまけ <span class="ascii">+</span> 宣伝です。<span class="ascii">TidalCycles</span>をインストールしたいだけの方は適当に読み飛ばしてください</strong></p>
<p>ここまで、<span class="ascii">stack</span>という、昨今の<span class="ascii">Haskeller</span>の多くが好んで利用するツールで、<span class="ascii">TidalCycles</span>を利用する方法を説明しました。<br />
<span class="ascii">TidalCycles</span>の公式サイトの<span class="ascii">Wiki</span>にはこの方法は書かれてませんが、より確実なインストール方法として、覚えておいていただけると幸いです。<br />
すでに<span class="ascii">Haskell</span>の開発環境をインストールしている方にも参考になるかと思います。</p>
<p>ところで、ここまで<span class="ascii">TidalCycles</span>を自分でインストールしてみて、<span class="ascii">Haskeller</span>としていくつか気になった点があります。<br />
<span class="ascii">TidalCycles</span>は、<span class="ascii">Haskell</span>製の内部<span class="ascii">DSL</span>としては、ちょっと変わっているように感じました。</p>
<p>それは、<span class="ascii">TidalCycles</span>が「標準」として提供している関数を実行する際、<span class="ascii">tidal</span>パッケージに含まれるモジュールを<code>import</code>するだけでなく、<span class="ascii">BootTidal.hs</span>というファイルを読んで、追加の関数を定義する必要がある、という点です。<br />
大抵の<span class="ascii">Haskell</span>製の内部<span class="ascii">DSL</span>は、そんなことしなくてもモジュールを<code>import</code>するだけで使えるようになっています<small>（<a href="http://hspec.github.io/"><span class="ascii">Hspec</span></a>とか<a href="https://github.com/chrisdone/lucid"><span class="ascii">lucid</span></a>とか<a href="http://hackage.haskell.org/package/clay"><span class="ascii">clay</span></a>とか<a href="http://khibino.github.io/haskell-relational-record/"><span class="ascii">relational-record</span></a>とか）</small>。<br />
つまり本来ならばわざわざ、<span class="ascii">BootTidal.hs</span>のような、<span class="ascii">GHCi</span>が読み込む専用のファイルを用意しなくとも良いはずなのです。<br />
この<span class="ascii">BootTidal.hs</span>は<span class="ascii">Atom</span>のプラグインの設定で簡単に切り替えることができるものなので、もし間違ったファイルに設定してしまったら、言語の標準にあたる関数がおかしな動作をすることになりかねませんし、あまり良いやり方だとは思えません。本来なら設定に混ぜて書くべきものではないでしょう。</p>
<p>なぜ<span class="ascii">TidalCycles</span>はこんな仕様になっているかというと、それにはある意味<span class="ascii">Haskell</span>らしい制約が絡んでいると推測されます。<br />
<span class="ascii">Atom</span>上で<span class="ascii">TidalCycles</span>を起動する、というのは、実際には<span class="ascii">GHCi</span>を起動して、<a href="https://github.com/tidalcycles/Tidal/blob/master/BootTidal.hs"><span class="ascii">BootTidal.hs</span></a>というファイルを読み込ませる、ということなのでした<small>（事実、<span class="ascii">Atom</span>などのエディターを介さなくとも、お使いのターミナルエミュレーターから<code>ghci</code>コマンドを起動して<span class="ascii">BootTidal.hs</span>ファイルの中身をコピペするだけで、<span class="ascii">TidalCycles</span>は利用できます）</small>。<br />
その<span class="ascii">BootTidal.hs</span>の中身を見てみると、サンプルで実行した<code>d1</code>という関数が、下記のように定義されていることがわかります。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="co">-- ... 省略 ...</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="kw">import</span> <span class="dt">Sound.Tidal.Context</span></a>
<a class="sourceLine" id="cb3-3" title="3"></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="co">-- total latency = oLatency + cFrameTimespan</span></a>
<a class="sourceLine" id="cb3-5" title="5">tidal <span class="ot">&lt;-</span> startTidal (superdirtTarget {oLatency <span class="ot">=</span> <span class="fl">0.1</span>, oAddress <span class="ot">=</span> <span class="st">&quot;127.0.0.1&quot;</span>, oPort <span class="ot">=</span> <span class="dv">57120</span>}) (defaultConfig {cFrameTimespan <span class="ot">=</span> <span class="dv">1</span><span class="op">/</span><span class="dv">20</span>})</a>
<a class="sourceLine" id="cb3-6" title="6"></a>
<a class="sourceLine" id="cb3-7" title="7"><span class="kw">let</span> p <span class="ot">=</span> streamReplace tidal</a>
<a class="sourceLine" id="cb3-8" title="8"></a>
<a class="sourceLine" id="cb3-9" title="9"><span class="co">-- ... 省略 ...</span></a>
<a class="sourceLine" id="cb3-10" title="10"></a>
<a class="sourceLine" id="cb3-11" title="11"><span class="kw">let</span> d1 <span class="ot">=</span> p <span class="dv">1</span></a>
<a class="sourceLine" id="cb3-12" title="12"><span class="kw">let</span> d2 <span class="ot">=</span> p <span class="dv">2</span></a>
<a class="sourceLine" id="cb3-13" title="13"><span class="kw">let</span> d3 <span class="ot">=</span> p <span class="dv">3</span></a>
<a class="sourceLine" id="cb3-14" title="14"><span class="co">-- ...</span></a></code></pre></div>
<p><code>tidal &lt;- startTidal</code>で始まる行で、<span class="ascii">TidalCycles</span>の初期化を行っていると思われます。<br />
初期化の際には、サーバーとして起動している<span class="ascii">SuperDirt</span>への接続設定<small>（この場合<code>127.0.0.1</code>の<code>57120</code>番ポートへ接続している）</small>を渡しているようです。<br />
恐らくこの<code>startTidal</code>関数が、<span class="ascii">SuperDirt</span>へ接続し、代入した<code>tidal</code>という変数に、<span class="ascii">SuperDirt</span>への接続を含んでいるんでしょう。<br />
そして、<code>let p = streamReplace tidal</code>という行で、その<code>tidal</code>を<code>streamReplace</code>関数に<a href="http://capm-network.com/?tag=Haskell-%E9%83%A8%E5%88%86%E9%81%A9%E7%94%A8">部分適用</a>することで、<code>p</code>が<span class="ascii">SuperDirt</span>への接続を参照できるようにしています。<br />
さらに、<code>let d1 = p 1</code>などの行で、前の行で定義した<code>p</code>に整数<small>（シンセサイザーの番号だそうです）</small>を部分適用することで、結果、<code>d1</code>、<code>d2</code>などの関数へ、間接的に<code>tidal</code>を渡すことになります。</p>
<p>つまり<code>d1</code>や<code>d2</code>などの関数は、何らかの形で、<span class="ascii">SuperDirt</span>への接続情報を持っているのです。<br />
<span class="ascii">DSL</span>として、<code>d1</code>や<code>d2</code>などの関数に毎回接続情報を渡すのは煩雑だと考えたためでしょう。<br />
残念ながら、通常の<span class="ascii">Haskell</span>がそうであるように、外部のサーバーに接続した結果取得されるものを、関数が暗黙に参照できるようにしたい場合、 — つまり、今回のようにユーザーが接続情報を明示的に渡すことなく使えるようにしたい場合 — 少なくともパッケージを<code>import</code>するだけではうまくいきません<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>。<br />
<span class="ascii">BootTidal.hs</span>のように、<span class="ascii">SuperDirt</span>のような外部に接続する処理を、<span class="ascii">GHCi</span>の実行時に書かなければならないのです。</p>
<p>しかし、<code>tidal &lt;- startTidal</code>の行で作られる<span class="ascii">SuperDirt</span>への接続情報を<code>d1</code>などの関数が暗黙に利用できるようにすることは、実際には<span class="ascii">BootTidal.hs</span>で行っているような方法を使わなくともできます。<br />
そうすることで、<span class="ascii">BootTidal.hs</span>を変なファイルに切り替えてしまって、<code>d1</code>などの関数の定義が間違ったものになってしまう<small>（あるいはそもそも定義されなくなってしまう）</small>リスクを回避できます。<br />
具体的には、下記のような方法が考えられます。<br />
申し訳なくも私はこれ以上<span class="ascii">TidalCycles</span>に入れ込むつもりもないので、誰か<span class="ascii">TidalCycles</span>を気に入った方が適当に提案するなりパッチを送るなりしてみてください<small>（他力本願😰）</small>。</p>
<ul>
<li><span class="ascii">GHCi</span>の中で<code>ReaderT</code>を使う
<ul>
<li><span class="ascii">Haskell</span>で「関数に渡した引数を暗黙に利用できるようにする」といえば、やはり<code>ReaderT</code>モナドトランスフォーマーが一番オーソドックスな方法でしょう。<br />
実は<span class="ascii">GHCi</span>上では、<code>IO</code>以外のモナドのアクションで<code>print</code>することができます。<br />
<a href="https://www.reddit.com/r/haskell/comments/87otrn/you_can_override_the_monad_that_ghci_uses/"><span class="ascii">You can override the monad that GHCi uses</span></a>という<span class="ascii">Reddit</span>のスレッドでは、<code>ReaderT</code>を使ったサンプルが紹介されています。<br />
これと同じ要領で、<span class="ascii">GHCi</span>の<code>-interactive-print</code>というオプションに、<code>tidal</code>を<code>ReaderT</code>経由で渡してから結果を<code>print</code>する関数を設定しましょう。<br />
あとは<code>d1</code>などを<code>ReaderT</code>のアクションにするだけで、それらを<span class="ascii">BootTidal.hs</span>から消し去ることができます。<br />
残念ながらこの方法を使うと、<span class="ascii">GHCi</span>に与えた式の結果がすべて当該のモナドのアクションになっていなければならなくなるため、例えば単純な計算結果でさえ<code>return</code>をいちいち書かないといけなくなります。しかし、<span class="ascii">TidalCycles</span>の利用方法を見る限り、大きな問題にはならないだろうと思います。</li>
</ul></li>
<li><code>ImplicitParams</code>という<span class="ascii">GHC</span>の言語拡張を使う
<ul>
<li><span class="ascii">GHC</span>には、<code>ImplicitParams</code>という、もっと直接的にこれを実現する言語拡張があります。文字通り、暗黙の引数を実現するための拡張です<small>（<a href="https://qiita.com/philopon/items/e6d2522f5b514c219a5f">参考</a>）</small>。<br />
これを利用して、例えば<code>d1</code>を<code>?tidal :: Stream =&gt; ControlPattern -&gt; IO ()</code>のように型宣言しておき、<code>?tidal</code><small>（頭に<code>?</code>を付けたものが暗黙の引数となります）</small>を暗黙の引数として参照するようにしましょう。後は<span class="ascii">GHCi</span>の起動時に<code>?tidal</code>を定義すれば、<code>?tidal</code>の後に<code>d1</code>などを定義する必要がなくなるので、<span class="ascii">BootTidal.hs</span>はもっとコンパクトに済むはずです。</li>
</ul></li>
<li>その他、<code>unsafePerformIO</code>や<span class="ascii">Template Haskell</span>など、ちょっと危ない手段を使う
<ul>
<li>こちらについては詳細を割愛します。<code>d1</code>などの再利用性が下がるので、おすすめしません。</li>
</ul></li>
</ul>
<p><span class="ascii">TidalCycles</span>の技術的な側面で気になった点は以上です。<br />
ちょっと難しい話になってしまいましたが、これを機会に、<span class="ascii">Haskell</span>そのものへの興味を持っていただけると幸いです。<br />
素晴らしいことに、<span class="ascii">TidalCycles</span>そのものは<span class="ascii">Haskell</span>を知らなくてもそれなりに使えるようになっているようですが、<span class="ascii">Haskell</span>を知った上で使えば、より簡単にトラブルシューティングができるようになりますし、<span class="ascii">TidalCycles</span>をより柔軟に使えるようになるでしょう。</p>
<p>もし、今回の記事や<span class="ascii">TidalCycles</span>をきっかけに<span class="ascii">Haskell</span>を勉強してみたいと思ったら、<a href="https://wiki.haskell.jp/Links"><span class="ascii">Haskell-jp Wiki</span>の日本語のリンク集</a>を読んで、自分に合う入門コンテンツを見つけてみてください！<br />
それから、何か困ったことがあれば<a href="https://haskell-jp.slack.com/messages/C5666B6BB/convo/C4M4TT8JJ-1547294914.091800/"><span class="ascii">Haskell-jp</span>の<span class="ascii">Slack Workspace</span>にある、<span class="ascii">#questions</span>チャンネル</a>で質問してみてください。<br />
<a href="https://join.slack.com/t/haskell-jp/shared_invite/enQtNDY4Njc1MTA5MDQxLTAzZGNkZDlkMWYxZDRlODI3NmNlNTQ1ZDc3MjQxNzg3OTg4YzUzNmUyNmU5YWVkMjFmMjFjYzk1OTE3Yzg4ZTM">登録はこちら</a>からどうぞ！</p>
<p>それでは<span class="ascii">2019</span>年も<span class="ascii">Haskell</span>と<span class="ascii">TidalCycles</span>で<span class="ascii">Happy Hacking!!</span> 🎶🎶🎶</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>どのバージョンの<span class="ascii">LTS Haskell</span>でどのバージョンの<span class="ascii">GHC</span>がインストールされるかは、<span class="ascii">LTS Haskell</span>を管理している<a href="https://www.stackage.org/">「<span class="ascii">Stackage</span>」というウェブサイトのトップページ</a>にある、「<span class="ascii">Latest LTS per GHC version</span>」というセクションをご覧ください。<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>後で軽く触れる、<span class="ascii">Template Haskell</span>という邪悪なテクニックを使わない限りは。<a href="#fnref2" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/hourly-antenna.html" lang="ja">DroneでHaskell Antennaを毎時更新する</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2018/super-precure-monad.html" style="margin-left: auto;" lang="ja">モナドの新しい力！スーパープリキュアモナド！</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>

</feed>
