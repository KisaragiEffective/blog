<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Haskell-jp Blog</title>
    <link href="https://haskell.jp/blog/feed.xml" rel="self" />
    <link href="https://haskell.jp/blog" />
    <id>https://haskell.jp/blog/feed.xml</id>
    <author>
        <name>Haskell-jp</name>
        <email></email>
    </author>
    <updated>2018-11-20T00:00:00Z</updated>
    <entry>
    <title>Haskell Day 2018 開催レポート</title>
    <link href="https://haskell.jp/blog/posts/2018/haskell-day-2018.html" />
    <id>https://haskell.jp/blog/posts/2018/haskell-day-2018.html</id>
    <published>2018-11-20T00:00:00Z</published>
    <updated>2018-11-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <p>こんにちは<span class="ascii">kakkun61</span>こと岡本和樹です。</p>
<p>去る<span class="ascii">11</span>月<span class="ascii">10</span>日に<span class="ascii">Haskell Day 2018</span>が開催されましたので、そのイベントレポートをお送りします。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#haskell-day-2018とは" title="haskell-day-2018とは"><span class="ascii">Haskell Day 2018</span>とは</a></li>
<li><a href="#セッション" title="セッション">セッション</a>
<ul>
<li><a href="#作りながら学ぶhaskell入門を使ったハンズオン" title="作りながら学ぶhaskell入門を使ったハンズオン">「作りながら学ぶ<span class="ascii">Haskell</span>入門」を使ったハンズオン</a></li>
<li><a href="#haskellを導入した話とhrrの紹介" title="haskellを導入した話とhrrの紹介"><span class="ascii">Haskell</span>を導入した話と<span class="ascii">HRR</span>の紹介</a></li>
<li><a href="#servantで実現する高速かつ安全なapi開発" title="servantで実現する高速かつ安全なapi開発"><span class="ascii">Servant</span>で実現する高速かつ安全な<span class="ascii">API</span>開発</a></li>
<li><a href="#並列並行言語haskell" title="並列並行言語haskell">並列並行言語<span class="ascii">Haskell</span></a></li>
<li><a href="#dhall-haskellの新たなキラーアプリ" title="dhall-haskellの新たなキラーアプリ"><span class="ascii">Dhall: Haskell</span>の新たなキラーアプリ</a></li>
<li><a href="#semigroupとはmonoid環" title="semigroupとはmonoid環"><span class="ascii">Semigroup</span>とは？<span class="ascii">Monoid</span>？環？</a></li>
<li><a href="#haskellでcli" title="haskellでcli"><span class="ascii">Haskell</span>で<span class="ascii">CLI</span></a></li>
<li><a href="#gloss-動かして遊んで学ぶhaskell" title="gloss-動かして遊んで学ぶhaskell"><span class="ascii">gloss:</span> 動かして遊んで学ぶ<span class="ascii">Haskell</span></a></li>
<li><a href="#lisztあるいは永続データ構造を真に永続させる方法" title="lisztあるいは永続データ構造を真に永続させる方法"><span class="ascii">Liszt</span>あるいは永続データ構造を真に永続させる方法</a></li>
<li><a href="#懇親会" title="懇親会">懇親会</a></li>
</ul></li>
<li><a href="#アンケート" title="アンケート">アンケート</a>
<ul>
<li><a href="#haskellを始めてどれくらい経ちますか" title="haskellを始めてどれくらい経ちますか"><span class="ascii">Haskell</span>を始めてどれくらい経ちますか？</a></li>
<li><a href="#読んだことのある日本語のhaskell本は" title="読んだことのある日本語のhaskell本は">読んだことのある日本語の<span class="ascii">Haskell</span>本は？</a></li>
</ul></li>
<li><a href="#終わりに" title="終わりに">終わりに</a></li>
</ul>
</div>
</div>
<h1 id="haskell-day-2018とは"><span class="link-to-here-outer"><a href="#haskell-day-2018とは" title="haskell-day-2018とは"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Haskell Day 2018</span>とは</h1>
<p><img src="../../img/2018/haskell-day-2018/connpass.png" alt="Connpass" style="width: 100%; max-width: 600px;"></p>
<p><a href="https://haskell-jp.connpass.com/event/92617/"><span class="ascii">https://haskell-jp.connpass.com/event/92617/</span></a></p>
<p><span class="ascii">Haskell Day</span>は<span class="ascii">2012</span>年<span class="ascii">2016</span>年と不定期に開催しており今回で<span class="ascii">3</span>度目となります。</p>
<p><span class="ascii">2018</span>年の今回は「<span class="ascii">Haskell</span>ちょっと興味あるからちょっとできるまで」というテーマで開催されました。</p>
<p><img src="../../img/2018/haskell-day-2018/_DSC1173.jpg" alt="受付" style="width: 100%; max-width: 600px;"></p>
<h1 id="セッション"><span class="link-to-here-outer"><a href="#セッション" title="セッション"><span class="link-to-here">Link to<br />
here</span></a></span>セッション</h1>
<h2 id="作りながら学ぶhaskell入門を使ったハンズオン"><span class="link-to-here-outer"><a href="#作りながら学ぶhaskell入門を使ったハンズオン" title="作りながら学ぶhaskell入門を使ったハンズオン"><span class="link-to-here">Link to<br />
here</span></a></span>「作りながら学ぶ<span class="ascii">Haskell</span>入門」を使ったハンズオン</h2>
<p>開発中の対話的チュートリアル<a href="https://github.com/haskell-jp/makeMistakesToLearnHaskell">「作りながら学ぶ<span class="ascii">Haskell</span>入門」</a>を使って、参加者の皆さんにもくもくと入門していただきました。「作りながら学ぶ<span class="ascii">Haskell</span>入門」では、簡単な課題を解くことで、<span class="ascii">Haskell</span>の初歩的な使い方を学びつつ、学んだ知識をその場でテストできます。</p>
<p><a href="https://github.com/haskell-jp/makeMistakesToLearnHaskell"><span class="ascii">https://github.com/haskell-jp/makeMistakesToLearnHaskell</span></a></p>
<p><img src="../../img/2018/haskell-day-2018/_DSC1176.jpg" alt="ハンズオン" style="width: 100%; max-width: 600px;"></p>
<hr />
<h2 id="haskellを導入した話とhrrの紹介"><span class="link-to-here-outer"><a href="#haskellを導入した話とhrrの紹介" title="haskellを導入した話とhrrの紹介"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Haskell</span>を導入した話と<span class="ascii">HRR</span>の紹介</h2>
<p><a href="https://htmlpreview.github.io/?https://github.com/khibino/haskell-day-2018/blob/master/presentation.html"><img src="../../img/2018/haskell-day-2018/khibino.png" alt="Haskell を導入した話と HRR の紹介" style="width: 100%; max-width: 600px;"></a></p>
<p><img src="../../img/2018/haskell-day-2018/_DSC1177.jpg" alt="khibino" style="width: 100%; max-width: 600px;"></p>
<hr />
<h2 id="servantで実現する高速かつ安全なapi開発"><span class="link-to-here-outer"><a href="#servantで実現する高速かつ安全なapi開発" title="servantで実現する高速かつ安全なapi開発"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Servant</span>で実現する高速かつ安全な<span class="ascii">API</span>開発</h2>
<script async class="speakerdeck-embed" data-id="413d120b6bee433c985c1d2b3395ff0e" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>
<p><img src="../../img/2018/haskell-day-2018/_DSC1193.jpg" alt="nakaji-dayo" style="width: 100%; max-width: 600px;"></p>
<hr />
<h2 id="並列並行言語haskell"><span class="link-to-here-outer"><a href="#並列並行言語haskell" title="並列並行言語haskell"><span class="link-to-here">Link to<br />
here</span></a></span>並列並行言語<span class="ascii">Haskell</span></h2>
<script async class="speakerdeck-embed" data-id="07d92af9d7aa40bca6cc3959d3f56b28" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>
<p><img src="../../img/2018/haskell-day-2018/_DSC1178.jpg" alt="syocy" style="width: 100%; max-width: 600px;"></p>
<hr />
<h2 id="dhall-haskellの新たなキラーアプリ"><span class="link-to-here-outer"><a href="#dhall-haskellの新たなキラーアプリ" title="dhall-haskellの新たなキラーアプリ"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Dhall: Haskell</span>の新たなキラーアプリ</h2>
<script async class="speakerdeck-embed" data-id="7a16b1e09882433ca2dac9a6a81eb236" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>
<hr />
<h2 id="semigroupとはmonoid環"><span class="link-to-here-outer"><a href="#semigroupとはmonoid環" title="semigroupとはmonoid環"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Semigroup</span>とは？<span class="ascii">Monoid</span>？環？</h2>
<p><a href="https://aiya000.github.io/Maid/haskell-day-2018-algebra/#/"><img src="../../img/2018/haskell-day-2018/aiya000.png" alt="Semigroup とは？Monoid？環？" style="width: 100%; max-width: 600px;"></a></p>
<p><img src="../../img/2018/haskell-day-2018/_DSC1179.jpg" alt="aiya000" style="width: 100%; max-width: 600px;"></p>
<hr />
<h2 id="haskellでcli"><span class="link-to-here-outer"><a href="#haskellでcli" title="haskellでcli"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Haskell</span>で<span class="ascii">CLI</span></h2>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/FQE1QxbCST8kYi" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen>
</iframe>
<div style="margin-bottom:5px">
<strong> <a href="//www.slideshare.net/noob00/haskell-cli" title="Haskell で CLI" target="_blank"><span class="ascii">Haskell</span> で <span class="ascii">CLI</span></a> </strong> <span class="ascii">from</span> <strong><a href="https://www.slideshare.net/noob00" target="_blank"><span class="ascii">Nobutada Matsubara</span></a></strong>
</div>
<p><img src="../../img/2018/haskell-day-2018/_DSC1183.jpg" alt="matsubara0507" style="width: 100%; max-width: 600px;"></p>
<hr />
<h2 id="gloss-動かして遊んで学ぶhaskell"><span class="link-to-here-outer"><a href="#gloss-動かして遊んで学ぶhaskell" title="gloss-動かして遊んで学ぶhaskell"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">gloss:</span> 動かして遊んで学ぶ<span class="ascii">Haskell</span></h2>
<p><a href="https://qiita.com/lotz/items/bdb04c771efc8919b79c"><img src="../../img/2018/haskell-day-2018/lotz.png" alt="動かして遊んで学ぶ Haskell" style="width: 100%; max-width: 600px;"></a></p>
<p><img src="../../img/2018/haskell-day-2018/_DSC1186.jpg" alt="lotz" style="width: 100%; max-width: 600px;"></p>
<hr />
<h2 id="lisztあるいは永続データ構造を真に永続させる方法"><span class="link-to-here-outer"><a href="#lisztあるいは永続データ構造を真に永続させる方法" title="lisztあるいは永続データ構造を真に永続させる方法"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Liszt</span>あるいは永続データ構造を真に永続させる方法</h2>
<p><a href="https://shared-assets.adobe.com/link/353213c2-281a-4a53-6cff-a52bff1314c1"><img src="../../img/2018/haskell-day-2018/fumieval.png" alt="Liszt あるいは永続データ構造を真に永続させる方法" style="width: 100%; max-width: 600px; border: solid 1px black;"></a></p>
<p><img src="../../img/2018/haskell-day-2018/_DSC1191.jpg" alt="fumieval" style="width: 100%; max-width: 600px;"></p>
<h2 id="懇親会"><span class="link-to-here-outer"><a href="#懇親会" title="懇親会"><span class="link-to-here">Link to<br />
here</span></a></span>懇親会</h2>
<p>スポンサーとして<span class="ascii">IIJ</span>に飲食物の提供をしていただきました。</p>
<p><img src="../../img/2018/haskell-day-2018/_DSC1194.jpg" alt="懇親会" style="width: 100%; max-width: 600px;"></p>
<h1 id="アンケート"><span class="link-to-here-outer"><a href="#アンケート" title="アンケート"><span class="link-to-here">Link to<br />
here</span></a></span>アンケート</h1>
<p>約<span class="ascii">110</span>名の方が出席し約<span class="ascii">40</span>名の方が回答してくださいました。</p>
<p>参加できなくなった約<span class="ascii">40</span>名の方は事前のキャンセルをよろしくお願いします。</p>
<h2 id="haskellを始めてどれくらい経ちますか"><span class="link-to-here-outer"><a href="#haskellを始めてどれくらい経ちますか" title="haskellを始めてどれくらい経ちますか"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Haskell</span>を始めてどれくらい経ちますか？</h2>
<p><img src="../../img/2018/haskell-day-2018/questionnaire1.png" alt="Haskell を始めてどれくらい経ちますか？" style="width: 100%; max-width: 600px;"></p>
<p>ここ<span class="ascii">1</span>年以内に始めた方が全体の<span class="ascii">21.4</span>％、<span class="ascii">1</span>年以上<span class="ascii">5</span>年未満前に始めた方がちょうど半分程度となりました。<span class="ascii">1</span>年以上<span class="ascii">5</span>年未満前に始めた方の<span class="ascii">57%</span>の方は今でも<span class="ascii">Haskell</span>を使い続けているようです。</p>
<p><span class="ascii">5</span>年以上前に始めた方は全体の<span class="ascii">1/4</span>となりました。</p>
<h2 id="読んだことのある日本語のhaskell本は"><span class="link-to-here-outer"><a href="#読んだことのある日本語のhaskell本は" title="読んだことのある日本語のhaskell本は"><span class="link-to-here">Link to<br />
here</span></a></span>読んだことのある日本語の<span class="ascii">Haskell</span>本は？</h2>
<p><img src="../../img/2018/haskell-day-2018/questionnaire2.png" alt="Haskell を始めてどれくらい経ちますか？" style="width: 100%; max-width: 600px;"></p>
<p>項目は下記となります。</p>
<ul>
<li>すごい <span class="ascii">Haskell</span> たのしく学ぼう！</li>
<li>プログラミング <span class="ascii">Haskell</span></li>
<li><span class="ascii">Haskell</span> による並列・並行プログラミング</li>
<li>関数プログラミング実践入門 ── 完結で正しいコードを書くために</li>
<li>関数プログラミング入門 ── <span class="ascii">Haskell</span> で学ぶ原理と技法</li>
<li><span class="ascii">Real World Haskell</span></li>
<li>関数プログラミング ── 珠玉のアルゴリズムデザイン</li>
<li>簡約！λカ娘</li>
<li><span class="ascii">Haskell</span> ── 教養としての関数型プログラミング</li>
<li>その他（自由記述）</li>
</ul>
<p>この項目にはアンケートの途中で追加したものもあるので、結果があまり厳密でないことに注意してください。</p>
<p>その他の選択肢で自由記述では次の票がありました。</p>
<ul>
<li><span class="ascii">Haskell</span>入門 <span class="ascii">10</span>票</li>
<li>ふつうの<span class="ascii">Haskell 1</span>票</li>
<li><span class="ascii">Haskell</span>による関数プログラミングの思考法 <span class="ascii">1</span>票</li>
</ul>
<h1 id="終わりに"><span class="link-to-here-outer"><a href="#終わりに" title="終わりに"><span class="link-to-here">Link to<br />
here</span></a></span>終わりに</h1>
<p>参加者の発表者、スタッフのみなさんのおかげで無事開催することができました。ありがとうございました。</p>
<p>今後とも<span class="ascii">Haskell-jp</span>をよろしくお願いします。</p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2018/tech-book-fest-5.html" style="margin-left: auto;" lang="ja">技術書典 5 での Haskell 関連サークルのまとめ</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>技術書典 5 での Haskell 関連サークルのまとめ</title>
    <link href="https://haskell.jp/blog/posts/2018/tech-book-fest-5.html" />
    <id>https://haskell.jp/blog/posts/2018/tech-book-fest-5.html</id>
    <published>2018-10-05T00:00:00Z</published>
    <updated>2018-10-05T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <p>こんにちは<span class="ascii">kakkun61</span>こと岡本和樹です。</p>
<p>来たる<span class="ascii">10</span>月<span class="ascii">8</span>日（月・祝）に池袋にて技術系同人誌即売会「技術書典<span class="ascii">5</span>」が開催されます。</p>
<p><span class="ascii">Haskell</span>を題材にした同人誌もいくつかあるようですのでまとめてみました。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#技術書典とは" title="技術書典とは">技術書典とは？</a></li>
<li><a href="#か36-鴨川書房" title="か36-鴨川書房">か<span class="ascii">36</span> — 鴨川書房</a>
<ul>
<li><a href="#data-a-la-carte-vol.1" title="data-a-la-carte-vol.1"><span class="ascii">Data A la carte vol. 1</span></a></li>
</ul></li>
<li><a href="#か38-だめぽラボ" title="か38-だめぽラボ">か<span class="ascii">38</span> — だめぽラボ</a>
<ul>
<li><a href="#代数的数を作る-多項式の根と因数分解のアルゴリズム" title="代数的数を作る-多項式の根と因数分解のアルゴリズム">代数的数を作る 多項式の根と因数分解のアルゴリズム</a></li>
</ul></li>
<li><a href="#か61-趣味はデバッグ" title="か61-趣味はデバッグ">か<span class="ascii">61</span> — 趣味はデバッグ……</a>
<ul>
<li><a href="#手続きhaskell" title="手続きhaskell">手続き<span class="ascii">Haskell</span></a></li>
<li><a href="#haskellで作るwebアプリケーション-遠回りして学ぶyesod入門" title="haskellで作るwebアプリケーション-遠回りして学ぶyesod入門"><span class="ascii">Haskell</span>で作る<span class="ascii">Web</span>アプリケーション 遠回りして学ぶ<span class="ascii">Yesod</span>入門</a></li>
</ul></li>
<li><a href="#か74-大宇宙銀河no.1-haskeller-にこにー" title="か74-大宇宙銀河no.1-haskeller-にこにー">か<span class="ascii">74</span> — 大宇宙銀河<span class="ascii">No.1-Haskeller-</span>にこにー</a>
<ul>
<li><a href="#矢澤にこ先輩といっしょに代数" title="矢澤にこ先輩といっしょに代数">矢澤にこ先輩といっしょに代数！</a></li>
</ul></li>
<li><a href="#それでは当日に" title="それでは当日に">それでは当日に</a></li>
</ul>
</div>
</div>
<h1 id="技術書典とは"><span class="link-to-here-outer"><a href="#技術書典とは" title="技術書典とは"><span class="link-to-here">Link to<br />
here</span></a></span>技術書典とは？</h1>
<p><img src="../../img/2018/tech-book-fest-5-banner.png" alt="技術書典 5 バナー" style="width: 100%;"></p>
<p>（バナー画像は技術書典<span class="ascii">5</span>サイトよりの引用です。）</p>
<p>技術書典とは技術系同人誌即売会としておそらく日本最大のもので、今回で<span class="ascii">6</span>回目の開催となります。（ニコニコ超会議内での超技術書典があったのでナンバリングがずれています。）</p>
<ul>
<li><a href="https://techbookfest.org/event/tbf05">サイト</a></li>
<li><a href="https://blog.techbookfest.org/">ブログ</a></li>
<li><a href="https://twitter.com/techbookfest"><span class="ascii">Twitter</span></a></li>
</ul>
<p>これまでは秋葉原での開催でしたが、今回はなんと場所を<span class="ascii">3</span>倍の広さに拡張して池袋で開催されます。</p>
<p>それにともないサークル数もどどんと<span class="ascii">470</span>超となり、<span class="ascii">1</span>サークル<span class="ascii">45</span>秒で回っても全サークルは見て回れないことになります。</p>
<p>事前準備の重要性が高まった今回、<span class="ascii">Haskeller</span>向けに<span class="ascii">Haskell</span>サークルをまとめてみました。</p>
<h1 id="か36-鴨川書房"><span class="link-to-here-outer"><a href="#か36-鴨川書房" title="か36-鴨川書房"><span class="link-to-here">Link to<br />
here</span></a></span>か<span class="ascii">36</span> — 鴨川書房</h1>
<p><a href="https://techbookfest.org/event/tbf05/circle/32370012">カタログ</a></p>
<h2 id="data-a-la-carte-vol.1"><span class="link-to-here-outer"><a href="#data-a-la-carte-vol.1" title="data-a-la-carte-vol.1"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Data A la carte vol. 1</span></h2>
<blockquote class="twitter-tweet" data-lang="ja">
<p lang="ja" dir="ltr">
あと技術書典<span class="ascii">5</span>に、鴨川書房というサークル名で合同本を出品します。<span class="ascii">Haskell</span>による<span class="ascii">NN</span>実装<span class="ascii">(</span><a href="https://twitter.com/lotz84_?ref_src=twsrc%5Etfw"><span class="citation" data-cites="lotz84_"><span class="ascii">@lotz84_</span></span></a><span class="ascii">)</span> や、<span class="ascii">FPGA</span>での<span class="ascii">auto encoder</span>実装に関する苦労話等が掲載される予定です。ぜひに🙏……
</p>
— ✨🤩😝🤪パリピ🤭🤢🤮✨ <span class="ascii">(</span><span class="citation" data-cites="chaoticCats"><span class="ascii">@chaoticCats</span></span><span class="ascii">)</span> <a href="https://twitter.com/chaoticCats/status/1027501210494853120?ref_src=twsrc%5Etfw"><span class="ascii">2018</span>年<span class="ascii">8</span>月<span class="ascii">9</span>日</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<blockquote class="twitter-tweet" data-lang="ja">
<p lang="ja" dir="ltr">
形態素解析ライブラリ<span class="ascii">nagisa</span>については，技術書典の合同本に寄稿してもらえるよう作成者に依頼中なので興味ある方は是非<span class="ascii">(</span>表紙は鋭意作成中<span class="ascii">)</span>。 <a href="https://t.co/zUtngAS23t"><span class="ascii">pic.twitter.com/zUtngAS23t</span></a>
</p>
— ✨🤩😝🤪パリピ🤭🤢🤮✨ <span class="ascii">(</span><span class="citation" data-cites="chaoticCats"><span class="ascii">@chaoticCats</span></span><span class="ascii">)</span> <a href="https://twitter.com/chaoticCats/status/1042018372207108099?ref_src=twsrc%5Etfw"><span class="ascii">2018</span>年<span class="ascii">9</span>月<span class="ascii">18</span>日</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<h1 id="か38-だめぽラボ"><span class="link-to-here-outer"><a href="#か38-だめぽラボ" title="か38-だめぽラボ"><span class="link-to-here">Link to<br />
here</span></a></span>か<span class="ascii">38</span> — だめぽラボ</h1>
<p><a href="https://techbookfest.org/event/tbf05/circle/37190001">カタログ</a></p>
<h2 id="代数的数を作る-多項式の根と因数分解のアルゴリズム"><span class="link-to-here-outer"><a href="#代数的数を作る-多項式の根と因数分解のアルゴリズム" title="代数的数を作る-多項式の根と因数分解のアルゴリズム"><span class="link-to-here">Link to<br />
here</span></a></span>代数的数を作る 多項式の根と因数分解のアルゴリズム</h2>
<ul>
<li>同人誌</li>
<li><span class="ascii">268</span>ページ</li>
<li><span class="ascii">¥2500</span></li>
</ul>
<p><a href="https://blog.miz-ar.info/2018/09/techbookfest5/">ブログの告知記事</a></p>
<blockquote>
<p>代数的数（整数係数多項式の根として表される数）を実装するためのアルゴリズムを解説します。代数的数を使うと、ルートを含むような数に関して、浮動小数点数の誤差に煩わされることなく正確な演算が行えます。<span class="ascii">Haskell</span>によるサンプルコードを掲載しています。</p>
<p>この本は、<span class="ascii">Web</span>連載していた「週刊 代数的実数を作る」 <span class="ascii">https://miz-ar.info/math/algebraic-real/</span> の書籍化です。本文の加筆修正の他、「付録<span class="ascii">A</span> ユークリッドの互除法と拡張された互除法」「付録<span class="ascii">B</span> 部分分数分解」を追加しています。</p>
<p><a href="https://techbookfest.org/event/tbf05/circle/37190001">カタログ</a>より</p>
</blockquote>
<blockquote class="twitter-tweet" data-lang="ja">
<p lang="ja" dir="ltr">
技術書典<span class="ascii">5</span> か<span class="ascii">38</span>で「代数的数を作る 多項式の根と因数分解のアルゴリズム」を頒布します。よろしくお願いします。 <a href="https://t.co/HkLF1YFDuN"><span class="ascii">https://t.co/HkLF1YFDuN</span></a> <a href="https://t.co/V17ZIj2Iub"><span class="ascii">pic.twitter.com/V17ZIj2Iub</span></a>
</p>
— だめぽラボ<span class="ascii">@</span>技術書典<span class="ascii">5</span> か<span class="ascii">38 (</span><span class="citation" data-cites="mod_poppo"><span class="ascii">@mod_poppo</span></span><span class="ascii">)</span> <a href="https://twitter.com/mod_poppo/status/1045885679232737281?ref_src=twsrc%5Etfw"><span class="ascii">2018</span>年<span class="ascii">9</span>月<span class="ascii">29</span>日</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<h1 id="か61-趣味はデバッグ"><span class="link-to-here-outer"><a href="#か61-趣味はデバッグ" title="か61-趣味はデバッグ"><span class="link-to-here">Link to<br />
here</span></a></span>か<span class="ascii">61</span> — 趣味はデバッグ……</h1>
<p>私のサークルです。新刊落としました……</p>
<h2 id="手続きhaskell"><span class="link-to-here-outer"><a href="#手続きhaskell" title="手続きhaskell"><span class="link-to-here">Link to<br />
here</span></a></span>手続き<span class="ascii">Haskell</span></h2>
<p><a href="https://techbookfest.org/event/tbf05/circle/45000003">カタログ</a></p>
<ul>
<li>同人誌</li>
<li><span class="ascii">28</span>ページ</li>
<li><span class="ascii">¥500</span></li>
<li><a href="http://doujin.kakkun61.com/procedural-haskell"><span class="ascii">http://doujin.kakkun61.com/procedural-haskell</span></a></li>
</ul>
<blockquote>
<p><span class="ascii">Haskell</span>での手続きプログラミングの側面について解説します。</p>
<p>対象読者 <span class="ascii">- Haskell</span>入門書程度が読める <span class="ascii">-</span> 特に読めるが書こうとすると悩む人に読んでほしいです <span class="ascii">-</span> 手続きプログラミングのプログラマー <span class="ascii">-</span> 厳密に本書を読むためには<span class="ascii">Haskell</span>を読めた方がよいですが、手続きプログラミングですのでプログラマーなら雰囲気で読めると思います</p>
<p>書かれてあること <span class="ascii">-</span> 書き換え可能な変数 <span class="ascii">-</span> 手続きプログラミング的な制御構造 <span class="ascii">-</span> 配列 <span class="ascii">-</span> サンプルプログラム <span class="ascii">-</span> 手続き的な実装と<span class="ascii">Haskell</span>的な実装の対比</p>
<p>電子版（<span class="ascii">PDF</span>）はこちらで販売中です。 <span class="ascii">https://kakkun61.booth.pm/items/829369</span></p>
<p><a href="https://techbookfest.org/event/tbf05/circle/45000003">カタログ</a>より</p>
</blockquote>
<h2 id="haskellで作るwebアプリケーション-遠回りして学ぶyesod入門"><span class="link-to-here-outer"><a href="#haskellで作るwebアプリケーション-遠回りして学ぶyesod入門" title="haskellで作るwebアプリケーション-遠回りして学ぶyesod入門"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Haskell</span>で作る<span class="ascii">Web</span>アプリケーション 遠回りして学ぶ<span class="ascii">Yesod</span>入門</h2>
<ul>
<li>商業誌</li>
<li><span class="ascii">76</span>ページ</li>
<li><span class="ascii">¥1500</span></li>
<li><a href="https://nextpublishing.jp/book/9979.html"><span class="ascii">https://nextpublishing.jp/book/9979.html</span></a></li>
</ul>
<blockquote>
<p>【<span class="ascii">Haskell</span>のウェブアプリケーションフレームワーク<span class="ascii">Yesod</span>の入門書！】</p>
<p>本書は、<span class="ascii">Haskell</span>の入門書レベルの知識をもつ読者を対象とした、ウェブアプリケーションフレームワーク<span class="ascii">Yesod</span>の入門書です。比較的学習コストの高い<span class="ascii">Yesod</span>ですが、本書を通じて<span class="ascii">Yesod</span>の基本的な知識と<span class="ascii">Haskell</span>でのウェブアプリケーション開発に挑んで見ましょう！ 〈本書の対象読者〉 <span class="ascii">Haskell</span>の入門書は既に読みこなしているプログラマ <span class="ascii">Haskell</span>でウェブアプリを作ってみたいプログラマ</p>
<p><a href="https://nextpublishing.jp/book/9979.html">出版社ページ</a>より</p>
</blockquote>
<p>ちなみにこんな本を作るつもりでした。欲しい方いらっしゃったら次で書けとお伝えください。はげみになります。</p>
<blockquote class="twitter-tweet" data-lang="ja">
<p lang="ja" dir="ltr">
技術書典<span class="ascii">5</span>にサークル「趣味はデバッグ……」として参加申込をしました！ <span class="ascii">|</span> 技術書典 <a href="https://t.co/nD4eBo9622"><span class="ascii">https://t.co/nD4eBo9622</span></a> 「自作静的型付け言語を作ってそれに対して型推論する方法を解説する」書籍を作るぞ！
</p>
— <span class="ascii">kakkun61@</span>技術書典<span class="ascii">5</span> か<span class="ascii">61 (</span><span class="citation" data-cites="kakkun61"><span class="ascii">@kakkun61</span></span><span class="ascii">)</span> <a href="https://twitter.com/kakkun61/status/1009271813107474432?ref_src=twsrc%5Etfw"><span class="ascii">2018</span>年<span class="ascii">6</span>月<span class="ascii">20</span>日</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<h1 id="か74-大宇宙銀河no.1-haskeller-にこにー"><span class="link-to-here-outer"><a href="#か74-大宇宙銀河no.1-haskeller-にこにー" title="か74-大宇宙銀河no.1-haskeller-にこにー"><span class="link-to-here">Link to<br />
here</span></a></span>か<span class="ascii">74</span> — 大宇宙銀河<span class="ascii">No.1-Haskeller-</span>にこにー</h1>
<p><a href="https://techbookfest.org/event/tbf05/circle/43260001">カタログ</a></p>
<h2 id="矢澤にこ先輩といっしょに代数"><span class="link-to-here-outer"><a href="#矢澤にこ先輩といっしょに代数" title="矢澤にこ先輩といっしょに代数"><span class="link-to-here">Link to<br />
here</span></a></span>矢澤にこ先輩といっしょに代数！</h2>
<ul>
<li>同人誌</li>
<li><span class="ascii">84</span>ページ</li>
<li><span class="ascii">¥1000</span></li>
</ul>
<p><a href="http://aiya000.github.io/posts/2018-09-12-techbookfest5.html">ブログの告知記事</a></p>
<blockquote>
<p>ゆるふわにこまき数学！</p>
<p>以下のような人に向けて、頒布します。</p>
<ul>
<li>数学・代数の雰囲気をゆるく知りたい</li>
<li>軽い<span class="ascii">Haskell</span>を知りたい</li>
<li>なんでもいいから技術系にこまきが読みたい</li>
</ul>
<p><a href="https://techbookfest.org/event/tbf05/circle/43260001">カタログ</a>より</p>
</blockquote>
<blockquote class="twitter-tweet" data-lang="ja">
<p lang="ja" dir="ltr">
技術書典<span class="ascii">5</span>の「か<span class="ascii">74</span>」で、矢澤にこ先輩が簡単な<span class="ascii">Haskell</span>で代数（半群・モノイド・群・環・体）を教えてくれる本を頒布します。<br>よろしくお願いします🐕<a href="https://t.co/KBFxqX69m3"><span class="ascii">https://t.co/KBFxqX69m3</span></a><br>☝サークルページ<a href="https://twitter.com/hashtag/%E6%8A%80%E8%A1%93%E6%9B%B8%E5%85%B8?src=hash&amp;ref_src=twsrc%5Etfw"><span class="ascii">#</span>技術書典</a> <a href="https://twitter.com/hashtag/%E6%8A%80%E8%A1%93%E6%9B%B8%E5%85%B85?src=hash&amp;ref_src=twsrc%5Etfw"><span class="ascii">#</span>技術書典<span class="ascii">5</span></a> <a href="https://t.co/HvD5ql4gFl"><span class="ascii">pic.twitter.com/HvD5ql4gFl</span></a>
</p>
— あいや🤘🙄🤘技術書典<span class="ascii">5@</span>か<span class="ascii">74 (</span><span class="citation" data-cites="public_ai000ya"><span class="ascii">@public_ai000ya</span></span><span class="ascii">)</span> <a href="https://twitter.com/public_ai000ya/status/1045946096327962624?ref_src=twsrc%5Etfw"><span class="ascii">2018</span>年<span class="ascii">9</span>月<span class="ascii">29</span>日</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<h1 id="それでは当日に"><span class="link-to-here-outer"><a href="#それでは当日に" title="それでは当日に"><span class="link-to-here">Link to<br />
here</span></a></span>それでは当日に</h1>
<p>当日は安全に配慮しつつ楽しんでいきましょう！！</p>
<p><span class="ascii">1000</span>円札と<span class="ascii">500</span>円玉の準備はしっかりとね。</p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2018/haskell-day-2018.html" lang="ja">Haskell Day 2018 開催レポート</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2018/substring-parser.html" style="margin-left: auto;" lang="ja">substring-parserで「タイプセーフプリキュア！」を移行した話</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>substring-parserで「タイプセーフプリキュア！」を移行した話</title>
    <link href="https://haskell.jp/blog/posts/2018/substring-parser.html" />
    <id>https://haskell.jp/blog/posts/2018/substring-parser.html</id>
    <published>2018-09-04T00:00:00Z</published>
    <updated>2018-09-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>先日私は<a href="https://cure-hack.connpass.com/event/91157/">プリキュアハッカソン <span class="ascii">NewStage</span></a>というちょっと変わったイベントで、「<a href="https://github.com/igrep/typesafe-precure">タイプセーフプリキュア！</a>」の最近の更新について発表いたしました。<br />
今回は<a href="http://the.igreque.info/slides/2018-08-18-substring-parser.html">その際使用したスライド</a>を、ブログ記事として拡大して共有させていただきたいと思います！</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#予告編はじめにまとめ" title="予告編はじめにまとめ">予告編（はじめにまとめ）</a></li>
<li><a href="#これまでのあらすじ" title="これまでのあらすじ">これまでのあらすじ</a>
<ul>
<li><a href="#タイプセーフプリキュアとは" title="タイプセーフプリキュアとは">「タイプセーフプリキュア！」とは？</a></li>
<li><a href="#cure-index.jsonとは" title="cure-index.jsonとは"><span class="ascii">cure-index.json</span>とは？</a></li>
</ul></li>
<li><a href="#今回のプリキュアハッカソンに向けて行ったこと" title="今回のプリキュアハッカソンに向けて行ったこと">今回のプリキュアハッカソンに向けて行ったこと</a>
<ul>
<li><a href="#修正前の書式" title="修正前の書式">🔴修正<strong>前</strong>の書式</a></li>
<li><a href="#修正後の書式" title="修正後の書式">🔵修正<strong>後</strong>の書式</a></li>
<li><a href="#どうやって修正する" title="どうやって修正する">どうやって修正する？</a>
<ul>
<li><a href="#パーサーコンビネーターとは" title="パーサーコンビネーターとは">パーサーコンビネーターとは</a></li>
<li><a href="#パーサーコンビネーターが正規表現より良いところ悪いところ" title="パーサーコンビネーターが正規表現より良いところ悪いところ">パーサーコンビネーターが正規表現より良いところ・悪いところ</a>
<ul>
<li><a href="#パーツとしてパーサーを組み合わせるのが簡単" title="パーツとしてパーサーを組み合わせるのが簡単">👍パーツとしてパーサーを組み合わせるのが簡単</a></li>
<li><a href="#パースした結果を文字列から複雑なデータ構造に割り当てるのが簡単" title="パースした結果を文字列から複雑なデータ構造に割り当てるのが簡単">👍パースした結果を、文字列から複雑なデータ構造に割り当てるのが簡単</a></li>
<li><a href="#パースした結果に基づいてパーサーの挙動を変えることができる" title="パースした結果に基づいてパーサーの挙動を変えることができる">👍パースした結果に基づいて、パーサーの挙動を変えることができる</a></li>
<li><a href="#記述が冗長" title="記述が冗長">👎記述が冗長</a></li>
<li><a href="#ユーザーからの入力として直接受け取ることは難しい" title="ユーザーからの入力として直接受け取ることは難しい">👎ユーザーからの入力として直接受け取ることは難しい。</a></li>
<li><a href="#正規表現でいうところの-にあたるmanyが必ず強欲なマッチになる" title="正規表現でいうところの-にあたるmanyが必ず強欲なマッチになる">👎正規表現でいうところの <code>*</code> にあたる<code>many</code>が、必ず強欲なマッチになる</a></li>
<li><a href="#文字列の先頭からのマッチしかできない" title="文字列の先頭からのマッチしかできない">👎文字列の先頭からのマッチしかできない</a></li>
</ul></li>
<li><a href="#ソースコードの書き換えとsubstring-parser" title="ソースコードの書き換えとsubstring-parser">ソースコードの書き換えと<span class="ascii">substring-parser</span></a>
<ul>
<li><a href="#substring-parserの仕組み" title="substring-parserの仕組み"><span class="ascii">substring-parser</span>の仕組み</a></li>
</ul></li>
</ul></li>
<li><a href="#結果できたもの" title="結果できたもの">結果、できたもの</a></li>
</ul></li>
<li><a href="#その他の似たソリューション" title="その他の似たソリューション">その他の似たソリューション</a>
<ul>
<li><a href="#codemod" title="codemod"><span class="ascii">codemod</span></a></li>
<li><a href="#jscodeshift" title="jscodeshift"><span class="ascii">jscodeshift</span></a></li>
<li><a href="#refactorio" title="refactorio"><span class="ascii">refactorio</span></a></li>
</ul></li>
<li><a href="#次のゴール" title="次のゴール">次のゴール</a></li>
<li><a href="#まとめ" title="まとめ">まとめ</a></li>
</ul>
</div>
</div>
<h1 id="予告編はじめにまとめ"><span class="link-to-here-outer"><a href="#予告編はじめにまとめ" title="予告編はじめにまとめ"><span class="link-to-here">Link to<br />
here</span></a></span>予告編（はじめにまとめ）</h1>
<ul>
<li><span class="ascii">Haskell</span>界に伝わる伝説のアイテム「パーサーコンビネーター」を応用して、「タイプセーフプリキュア！」の古いソースコードを半自動で変換しました。</li>
<li>「パーサーコンビネーター」は正規表現よりいいところたくさんですが、文字列の先頭からのマッチしかできないのがつらいです。
<ul>
<li><a href="https://gitlab.com/igrep/substring-parser"><span class="ascii">substring-parser</span></a>というライブラリーを書いて、対応しました。</li>
</ul></li>
<li>パーサーコンビネーター最高！ ✌️😆✌️</li>
</ul>
<h1 id="これまでのあらすじ"><span class="link-to-here-outer"><a href="#これまでのあらすじ" title="これまでのあらすじ"><span class="link-to-here">Link to<br />
here</span></a></span>これまでのあらすじ</h1>
<h2 id="タイプセーフプリキュアとは"><span class="link-to-here-outer"><a href="#タイプセーフプリキュアとは" title="タイプセーフプリキュアとは"><span class="link-to-here">Link to<br />
here</span></a></span>「タイプセーフプリキュア！」とは？</h2>
<p><a href="https://github.com/sue445/rubicure"><span class="ascii">rubicure</span></a>や<a href="https://github.com/kan/p5-acme-prettycure"><span class="ascii">ACME::PrettyCure</span></a>のような「<a href="https://qiita.com/sue445/items/b41a4f5bdca46f1736c3">プリキュア実装</a>」の<span class="ascii">1</span>つです。<br />
詳しくはこれから挙げる過去の記事をご覧ください、と言いたいところですが、よくよく見たら「プリキュア実装」が何かを明記してる記事ではないようなので😅、ここで軽く説明しましょう。<br />
「プリキュア実装」とは一言で言うと「プリキュアやプリキュアに変身する女の子たち、変身時の台詞など諸々のプリキュアの設定をソースコードに収録したライブラリー」です。</p>
<p>例えば、今回取り上げます私の「タイプセーフプリキュア！」は（もちろん）<span class="ascii">Haskell</span>で書かれたプリキュア実装で、次のように書くことで、キュアアンジュが変身する際の台詞を取得することができます。<br />
<small>（出力されるリストは、手で整形しています）</small></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="fu">&gt;</span> <span class="kw">import</span> <span class="dt">ACME.PreCure</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="co">-- キュアアンジュには、薬師寺さあやが「ミライクリスタル・ブルー」を</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="co">-- セットした「プリハート」を使うことで変身します。</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="fu">&gt;</span> transformationSpeech <span class="dt">Saaya</span> (<span class="dt">PreHeart</span> <span class="dt">MiraiCrystalBlue</span>)</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">[ <span class="st">&quot;ミライクリスタル！&quot;</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">, <span class="st">&quot;ハートキラっと！&quot;</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">, <span class="st">&quot;は～ぎゅ～～！&quot;</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">, <span class="st">&quot;ぎゅ～！&quot;</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">, <span class="st">&quot;ぎゅ～～！&quot;</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">, <span class="st">&quot;輝く未来をー、抱きしめて！&quot;</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">, <span class="st">&quot;みんなを癒す！知恵のプリキュア！キュアアンジュ！&quot;</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12">]</a></code></pre></div>
<p><span class="ascii">GHCi</span>で上記のコードを試す場合は、下記のコードで<span class="ascii">typesafe-precure</span>と<a href="https://github.com/haskell-jp/unicode-show"><span class="ascii">unicode-show</span></a>をインストールした上で起動するとよいでしょう。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1">$ <span class="ex">stack</span> build typesafe-precure unicode-show</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">$ <span class="ex">stack</span> exec ghci -- -interactive-print=<span class="st">&quot;Text.Show.Unicode.uprint&quot;</span></a></code></pre></div>
<p>その他の機能や、使っている<span class="ascii">GHC</span>の拡張などについては下記の記事をご覧ください。</p>
<ul>
<li><a href="http://the.igreque.info/posts/2016/06-type-safe-precure.html"><span class="ascii">igreque : Info -&gt; Haskell</span>でプリキュアを作ってみた</a></li>
<li><a href="https://qiita.com/igrep/items/5496fa405fae00b5a737">「タイプセーフプリキュア！」を支える技術 <span class="ascii">- Qiita</span></a></li>
</ul>
<h2 id="cure-index.jsonとは"><span class="link-to-here-outer"><a href="#cure-index.jsonとは" title="cure-index.jsonとは"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">cure-index.json</span>とは？</h2>
<p>そんな「タイプセーフプリキュア！」ですが、前述の<span class="ascii">Qiita</span>の記事の最後で「<span class="ascii">typesafe-precure</span>は現状非常に冗長で、非実用的な実装になってしまっています」と述べているとおり、ほかのプリキュア実装と異なり、<del>実用性を度外視して</del>「設定の正しさ」を最優先事項とした結果、変身時の台詞や浄化技（「必殺技」ともしばしば呼ばれます）の台詞を取得するのに、非常に冗長なコードが必要になってしまいました。<br />
それではせっかく<span class="ascii">YouTube</span>やら<span class="ascii">Wikipedia</span>やら<span class="ascii">Blu-ray</span>やらを見直してせっせと集めた情報が勿体ないので、集めた情報を、コンパイル時に<span class="ascii">JSON</span>として出力することにしました。<br />
そうして生まれたのが<a href="https://github.com/igrep/typesafe-precure/blob/master/gen/cure-index.json"><span class="ascii">cure-index.json</span></a>とそれをプリティープリントした<a href="https://github.com/igrep/typesafe-precure/blob/master/gen/pretty-cure-index.json"><span class="ascii">pretty-cure-index.json</span></a>です。<br />
将来的には、<a href="http://the.igreque.info/posts/2014-12-25-unite-precure.vim.html">かつて<span class="ascii">rubicure</span>で作ったユナイトプリキュア</a>を書き直すのに使用しようかと考えています。</p>
<p>作るに当たって新たに「タイプセーフプリキュア！」のソースコードに仕込んだ仕組みについては、<a href="https://haskell.jp/blog/posts/2017/typesafe-precure2.html">去年の<span class="ascii">Haskell Advent Calendar</span>の記事</a>をご覧ください。<br />
<span class="ascii">Template Haskell</span>や<span class="ascii">GHC</span>の<code>ANN</code>という機能を濫用することで達成しました。😎</p>
<h1 id="今回のプリキュアハッカソンに向けて行ったこと"><span class="link-to-here-outer"><a href="#今回のプリキュアハッカソンに向けて行ったこと" title="今回のプリキュアハッカソンに向けて行ったこと"><span class="link-to-here">Link to<br />
here</span></a></span>今回のプリキュアハッカソンに向けて行ったこと</h1>
<p>従来の<span class="ascii">cure-index.json</span>には、最新作である「<span class="ascii">HUG</span>っと！プリキュア」と、その一つ前の作品である「キラキラ☆プリキュアアラモード」の情報しか収録されていませんでした。<br />
前述の<a href="https://haskell.jp/blog/posts/2017/typesafe-precure2.html">去年の<span class="ascii">Haskell Advent Calendar</span>の記事</a>でも触れましたが、収録のためにはプリキュアの設定の書式を大幅に変更しなければならず、面倒なのでひとまず後回しにしていたのです。</p>
<p>そこで今年のプリキュアハッカソンにて発表するのによいネタだろうと思い、あの手この手を使って、全シリーズを<span class="ascii">cure-index.json</span>に含める対応を行いました<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>🎉。</p>
<h2 id="修正前の書式"><span class="link-to-here-outer"><a href="#修正前の書式" title="修正前の書式"><span class="link-to-here">Link to<br />
here</span></a></span>🔴修正<strong>前</strong>の書式</h2>
<p>それでは、具体的にどんな修正を行ったのか紹介しましょう。<br />
修正前は、プリキュアの設定を収録した各モジュール（<code>ACME.PreCure.Textbook</code>以下にあるので、今後は「<strong>各<code>Textbook</code>モジュール</strong>」と呼びます）には<a href="https://github.com/igrep/typesafe-precure/blob/73948fb4a82baaf4e33900d77326791c7703f786/src/ACME/PreCure/Textbook/MahoGirls/Types.hs#L71">👇こんな感じの<span class="ascii">Types.hs</span>がたくさん</a>ありました。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> <span class="dt">CureMiracle</span> <span class="fu">=</span> <span class="dt">CureMiracle</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">transformedInstance</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  [t| CureMiracle |]</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">  cureName_Miracle</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">  introducesHerselfAs_Miracle</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">  variation_Dia</a></code></pre></div>
<p>上記はキュアミラクルを表す型の定義と、その日本語での名前、変身時の名乗りといったプロフィールを設定しているコードです。<br />
このほかにも、プリキュアに変身する女の子の設定や、変身の際に必要な変身アイテムなどの型定義がたくさんあります。<br />
<code>transformedInstance</code>で始まる行は、<span class="ascii">Template Haskell</span>を使った、型クラスのインスタンス宣言です。<br />
<a href="https://github.com/igrep/typesafe-precure/blob/477fc23a018020fe67895e79361520016fd844bf/src/ACME/PreCure/Types/TH.hs#L151-L158"><code>transformedInstance</code>というマクロ</a>が、<a href="https://github.com/igrep/typesafe-precure/blob/477fc23a018020fe67895e79361520016fd844bf/src/ACME/PreCure/Types.hs#L15-L19"><code>Transformed</code>という型クラス</a>のインスタンスを生成することで、プリキュアを表す型と、日本語での名前、変身時の名乗りを実際に紐付けているのです。<br />
<small>（実際の日本語での名前はご覧のとおり<code>cureName_Miracle</code>といった変数に束縛されております。<a href="https://github.com/igrep/typesafe-precure/blob/73948fb4a82baaf4e33900d77326791c7703f786/src/ACME/PreCure/Textbook/MahoGirls/Words.hs#L18"><span class="ascii">Words.hs</span></a>というファイルから参照しています）</small></p>
<p>修正前はこのように、あくまでも<span class="ascii">Haskell</span>のソースコードとして、プリキュアの設定を書いていたため、このままでは<span class="ascii">cure-index.json</span>のデータとして扱うのが難しい状態でした。</p>
<h2 id="修正後の書式"><span class="link-to-here-outer"><a href="#修正後の書式" title="修正後の書式"><span class="link-to-here">Link to<br />
here</span></a></span>🔵修正<strong>後</strong>の書式</h2>
<p>そのため、今回修正した後の各<code>Textbook</code>モジュールでは、<a href="https://github.com/igrep/typesafe-precure/blob/fd5f89797372f616a551e07251c0fcd2ca1531c2/src/ACME/PreCure/Textbook/MahoGirls/Profiles.hs#L20">👇こんな感じの<span class="ascii">Profiles.hs</span></a>で、各種の設定を宣言することにしました。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">transformees ::</span> [<span class="dt">Transformee</span>]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">transformees <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  [ mkTransformee</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">      <span class="st">&quot;Cure Miracle&quot;</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">      <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">      cureName_Miracle</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">      variation_Dia</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">      introducesHerselfAs_Miracle</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">  , <span class="fu">...</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">  ]</a></code></pre></div>
<p><code>mkTransformee</code>関数で作っている<code>Transformee</code>型の値は、<span class="ascii">cure-index.json</span>の一部として、<span class="ascii">JSON</span>に変換する中間データです。もちろん<code>ToJSON</code>のインスタンスになっております。<br />
このように新しい各<code>Textbook</code>モジュールでは、直接<span class="ascii">Haskell</span>のソースコードとしてプリキュアの設定を書く代わりに、<strong>一旦<span class="ascii">JSON</span>に変換する用の中間データを設けることで、<span class="ascii">cure-index.json</span>に収録しやすい状態に</strong>しています。</p>
<p>こうして作られた<code>Transformee</code>などの中間データ用の値は、各<code>Textbook</code>モジュールのルートに当たるモジュールで、型クラスのインスタンス宣言を行ったり、<code>ANN</code>という機能でモジュールに紐付けられます。<br />
以下は「魔法つかいプリキュア！」のルートに当たるモジュール<a href="https://github.com/igrep/typesafe-precure/blob/477fc23a018020fe67895e79361520016fd844bf/src/ACME/PreCure/Textbook/MahoGirls.hs"><code>MahoGirls.hs</code></a>からの抜粋です。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">module</span> <span class="dt">ACME.PreCure.Textbook.MahoGirls</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="kw">import</span> <span class="dt">ACME.PreCure.Textbook.MahoGirls.Profiles</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="fu">...</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="ot">{-# ANN module transformees #-}</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="fu">$</span>(declareTransformees transformees)</a>
<a class="sourceLine" id="cb5-9" data-line-number="9"></a>
<a class="sourceLine" id="cb5-10" data-line-number="10"><span class="fu">...</span></a></code></pre></div>
<p><code>Profiles.hs</code>で定義した<code>transformees</code>というリストを、<code>ANN</code>で<code>MahoGirls</code>モジュールに紐付け、<code>declareTransformees</code>という<span class="ascii">Template Haskell</span>のマクロで型宣言やインスタンス宣言を生成するのに使っています。<br />
<code>ANN</code>については<a href="https://haskell.jp/blog/posts/2017/typesafe-precure2.html">前回の「タイプセーフプリキュア！を支える技術」</a>をご覧ください<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>。</p>
<p>修正前との違いにおける要点を繰り返しましょう。修正後の各<code>Textbook</code>モジュールでは、</p>
<ul>
<li>プリキュアの情報を、
<ul>
<li><span class="ascii">cure-index.json</span>として書き出すためのデータ</li>
<li><span class="ascii">Template Haskell</span>で型や型クラスのインスタンスとして生成するためのデータ</li>
</ul></li>
<li><strong>両方で扱えるようにするために、専用の型の値として保存</strong></li>
</ul>
<p>するようにしています。</p>
<h2 id="どうやって修正する"><span class="link-to-here-outer"><a href="#どうやって修正する" title="どうやって修正する"><span class="link-to-here">Link to<br />
here</span></a></span>どうやって修正する？</h2>
<p>それではここからは、各<code>Textbook</code>モジュールの書式を、どうやって前節で説明したような、「修正前」から「修正後」の書式に移行したのか説明します。</p>
<p>当然、手で修正するには大変な量です。<br />
従来より「タイプセーフプリキュア！」では<span class="ascii">TV</span>シリーズ<span class="ascii">15</span>作品に加えてキュアエコーが出てくる映画もサポートしているため、各<code>Textbook</code>モジュールは<span class="ascii">16</span>作品分存在しています。<br />
すでに「修正後」の書式に移行済みの「<span class="ascii">HUG</span>っと！プリキュア」と「キラキラ☆プリキュアアラモード」を除いても、<span class="ascii">14</span>作品分書き換えないといけません。<br />
シリーズごとに定義されている型やインスタンス宣言の数にはばらつきがありますが、すべて移行してから数えてみたところ、型の数だけで<span class="ascii">313</span>個、変身や浄化技のインスタンス宣言だけで<span class="ascii">211</span>個ありました。<br />
プリキュアやプリキュアに変身する女の子、変身アイテムだけでなく、それぞれの変種も別の型として定義しているため、実際のプリキュアの数よりも遙かに多いのです😵。<br />
<span class="ascii">Vim</span>のマクロなどを駆使すれば決して人間の手でも移行できない規模ではありませんが、そこは「タイプセーフプリキュア！」です。<br />
始まって以来私が<span class="ascii">GHC</span>の拡張を始めいろいろな技術を試すための実験場としても機能していたので、ここは是非ちょっと凝ったことをしてぱーっと書き換えてみたいものでしょう😏。<br />
そこで思いついたのがパーサーコンビネーター、並びに拙作のライブラリー<a href="https://gitlab.com/igrep/substring-parser"><span class="ascii">substring-parser</span></a>だったのです💡！</p>
<h3 id="パーサーコンビネーターとは"><span class="link-to-here-outer"><a href="#パーサーコンビネーターとは" title="パーサーコンビネーターとは"><span class="link-to-here">Link to<br />
here</span></a></span>パーサーコンビネーターとは</h3>
<p><span class="ascii">substring-parser</span>の紹介の前に、パーサーコンビネーターについて簡単に紹介しておきましょう。<br />
<small>（「すでに知ってるよ！」という方はこの節は飛ばした方が良いかと思います）</small><br />
パーサーコンビネーターは、例えば正規表現のような、文字列を解析する技術の一つです。<br />
<span class="ascii">Haskell</span>の<a href="http://hackage.haskell.org/package/megaparsec"><span class="ascii">megaparsec</span></a>や<a href="http://hackage.haskell.org/package/attoparsec"><span class="ascii">attoparsec</span></a>をはじめ、多くのプログラミング言語にライブラリーとして提供されています。</p>
<p>実装はいろいろありますが、本質的にパーサーコンビネーターは「文字列を受け取って『文字列を解析した結果』と、『残りの文字列』を返す関数」として表現されます。<br />
加えて、それらを簡単に組み合わせるための<span class="ascii">API</span>を提供することで、複雑な文字列から複雑なデータ構造を抽出できるようにしてくれます。</p>
<p>実際のパーサーコンビネーターのライブラリーを単純化して例を挙げましょう。<br />
例えば、通例パーサーコンビネーターのライブラリーは<code>decimal</code>という、「<span class="ascii">10</span>進数の文字列を受け取って、整数を返すパーサー」を提供していることが多いです。</p>
<p><code>parse</code>関数に、解析したい文字列と一緒に渡すことで、「文字列を解析した結果」と、「残りの文字列」を取得することができます。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="fu">&gt;</span> parse decimal <span class="st">&quot;123abc&quot;</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">(<span class="dv">123</span>, <span class="st">&quot;abc&quot;</span>)</a></code></pre></div>
<p>👆上記の例では「解析したい文字列」として<code>123abc</code>を渡したので、パースした結果の整数<code>123</code>と、その残りの文字列<code>&quot;abc&quot;</code>を返しています。</p>
<p>これだけではつまらないので、ほかのパーサーの例も挙げましょう。<br />
👇今度は「文字 セミコロン <code>;</code> を受け取って、そのまま返すパーサー」です。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="fu">&gt;</span> parse (char <span class="ch">&#39;;&#39;</span>) <span class="st">&quot;;aaa&quot;</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">(<span class="ch">&#39;;&#39;</span>, <span class="st">&quot;aaa&quot;</span>)</a></code></pre></div>
<p>「パースした結果」がセミコロン <code>;</code> で、「残りの文字列」が<code>&quot;aaa&quot;</code>となっていますね。</p>
<p>それでは以上<span class="ascii">2</span>つのパーサーを組み合わせて、<strong><span class="ascii">10</span>進数の文字列を受け取った後、セミコロンを受け取り、整数を返すパーサー</strong>を作ってみましょう。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="fu">&gt;</span> decimalAndSemicolon <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">    n <span class="ot">&lt;-</span> decimal</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">    char <span class="ch">&#39;;&#39;</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    return n</a>
<a class="sourceLine" id="cb8-5" data-line-number="5"></a>
<a class="sourceLine" id="cb8-6" data-line-number="6"><span class="fu">&gt;</span> parse decimalAndSemicolon <span class="st">&quot;123;abc&quot;</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">(<span class="dv">123</span>, <span class="st">&quot;abc&quot;</span>) <span class="co">-- 結果にセミコロンが含まれてない点に注意</span></a></code></pre></div>
<p><span class="ascii">Haskell</span>におけるパーサーコンビネーターのライブラリーは、パーサーを<code>Monad</code>として提供することで、上記のように<code>do</code>記法でパーサーを組み合わせることができるようになっています。<br />
ここでは詳細は割愛しますが、</p>
<ol type="1">
<li><code>decimal</code>で整数をパースしたあと、</li>
<li><code>char ';'</code> で文字セミコロン <code>;</code>をパース（でも結果は無視）し</li>
<li>パースした結果として「<code>decimal</code>がパースした整数」<code>n</code>を返す</li>
</ol>
<p>という処理を行っているのがわかるでしょうか？</p>
<p>ちなみに、パーサーコンビネーターに慣れた読者の方なら、いわゆる<span class="ascii">Applicative</span>スタイルを使って、次のようにも書けると気づくでしょう。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">decimalAndSemicolon <span class="fu">=</span> decimal <span class="fu">&lt;*</span> char <span class="ch">&#39;;&#39;</span></a></code></pre></div>
<p>これならパースした結果をいちいち変数に束縛する必要もなく、より簡潔に書くことができますね！</p>
<p>パーサーコンビネーターのパワーを実感していただくために、もう一つ例を紹介します。<br />
<code>many</code>という関数にパーサーコンビネーターを渡すと、「受け取ったパーサーコンビネーターで失敗するまで繰り返しパースして、その結果をリストとして返す」パーサーが作れます。<br />
例えば先ほどの「<span class="ascii">10</span>進数の文字列を受け取った後、セミコロンを受け取り、整数を返すパーサー」から、「セミコロンが末尾に着けられた整数のリストを返すパーサー」を作ることができます。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">parse (many decimalAndSemicolon) <span class="st">&quot;12;34;56;&quot;</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">([<span class="dv">12</span>, <span class="dv">34</span>, <span class="dv">56</span>], <span class="st">&quot;&quot;</span>)</a></code></pre></div>
<p>このようにパーサーコンビネーターは、小さなパーサーをどんどん組み合わせることで、複雑な文字列から複雑なデータ構造を取り出すパーサーを、クールに作れるようにしてくれます。</p>
<h3 id="パーサーコンビネーターが正規表現より良いところ悪いところ"><span class="link-to-here-outer"><a href="#パーサーコンビネーターが正規表現より良いところ悪いところ" title="パーサーコンビネーターが正規表現より良いところ悪いところ"><span class="link-to-here">Link to<br />
here</span></a></span>パーサーコンビネーターが正規表現より良いところ・悪いところ</h3>
<p>そんなパーサーコンビネーターについて、正規表現と比べた場合の長所短所を明確にしておきましょう。<br />
まずはよいところから。</p>
<h4 id="パーツとしてパーサーを組み合わせるのが簡単"><span class="link-to-here-outer"><a href="#パーツとしてパーサーを組み合わせるのが簡単" title="パーツとしてパーサーを組み合わせるのが簡単"><span class="link-to-here">Link to<br />
here</span></a></span>👍パーツとしてパーサーを組み合わせるのが簡単</h4>
<p>前節で示したように、複雑なパーサーも、小さなパーサーの組み合わせからコツコツと作れるようになっています。</p>
<h4 id="パースした結果を文字列から複雑なデータ構造に割り当てるのが簡単"><span class="link-to-here-outer"><a href="#パースした結果を文字列から複雑なデータ構造に割り当てるのが簡単" title="パースした結果を文字列から複雑なデータ構造に割り当てるのが簡単"><span class="link-to-here">Link to<br />
here</span></a></span>👍パースした結果を、文字列から複雑なデータ構造に割り当てるのが簡単</h4>
<p>さっきの<code>decimal</code>は、パースした結果を直接整数<span class="ascii">(</span><code>Int</code><span class="ascii">)</span>として返していたことにお気づきでしょうか？<br />
正規表現で欲しい文字列からデータ構造を取り出したい際は、通常グルーピング機能を使うことになりますが、必ず一旦文字列として取り出すことになります。<br />
それに対してパーサーコンビネーターには、取り出した文字列を対象のデータ構造に変換する仕組みが組み込まれています。<br />
再帰的なパーサーを書いて再帰的なデータ構造に割り当てるのも楽ちんです。</p>
<h4 id="パースした結果に基づいてパーサーの挙動を変えることができる"><span class="link-to-here-outer"><a href="#パースした結果に基づいてパーサーの挙動を変えることができる" title="パースした結果に基づいてパーサーの挙動を変えることができる"><span class="link-to-here">Link to<br />
here</span></a></span>👍パースした結果に基づいて、パーサーの挙動を変えることができる</h4>
<p>今回の例にはありませんでしたが、例えばパースして取り出した整数の数だけ、続きの文字列を繰り返しパースする、といったことも簡単にできます。</p>
<p>一方、正規表現と比べて悪いところもあります。</p>
<h4 id="記述が冗長"><span class="link-to-here-outer"><a href="#記述が冗長" title="記述が冗長"><span class="link-to-here">Link to<br />
here</span></a></span>👎記述が冗長</h4>
<p>正規表現はいわゆる「外部<span class="ascii">DSL</span>」、すなわちプログラミング言語から独立した構文で提供されています。<br />
<span class="ascii">Perl</span>や<span class="ascii">Ruby</span>などの構文で言えば、<code>/.../</code>の中は別世界ですよね。<br />
パーサーコンビネーターは、本質的に「文字列を受け取って『文字列を解析した結果』と、『残りの文字列』を返す関数」であるとおり、あくまでプログラミング言語標準の関数<small>（のうち、文字列の解析に特化したもの）</small>として提供されます。「内部<span class="ascii">DSL</span>」なんて呼ばれることもあります。</p>
<p>そのため、正規表現とは異なり、あくまでもプログラミング言語の構文の中で使えなければならないため、使用できる文字列に限りがあり、必然的に長くなります。<br />
例えば先ほどの<code>many</code>は正規表現で言うところの<code>*</code><small>（<span class="ascii">0</span>回以上の量指定子）</small>とちょっと似てますが、正規表現の方が<span class="ascii">3</span>文字も短いですよね。</p>
<p>しかしながら、冗長であることはメリットにもなり得ます👍。<br />
<code>*</code>をはじめ、正規表現の特殊な機能を使うには、専用の記号（メタキャラクター）をその数だけ覚えなければなりません。<br />
片やパーサーコンビネーターは<code>many</code>のような機能も普通の関数として提供されるため、冗長である分分かりやすい名前をつけやすいのです。</p>
<h4 id="ユーザーからの入力として直接受け取ることは難しい"><span class="link-to-here-outer"><a href="#ユーザーからの入力として直接受け取ることは難しい" title="ユーザーからの入力として直接受け取ることは難しい"><span class="link-to-here">Link to<br />
here</span></a></span>👎ユーザーからの入力として直接受け取ることは難しい。</h4>
<p>パーサーコンビネーターは先ほども触れた「内部<span class="ascii">DSL</span>」です。<br />
つまり、プログラミング言語の普通の関数として使用されるものです。<br />
したがって、例えば正規表現をエディターの検索機能に利用すると言ったような、「ユーザーからの入力として受け取る」と言ったことは、不可能ではないものの、正規表現に比べれば難しいです。</p>
<h4 id="正規表現でいうところの-にあたるmanyが必ず強欲なマッチになる"><span class="link-to-here-outer"><a href="#正規表現でいうところの-にあたるmanyが必ず強欲なマッチになる" title="正規表現でいうところの-にあたるmanyが必ず強欲なマッチになる"><span class="link-to-here">Link to<br />
here</span></a></span>👎正規表現でいうところの <code>*</code> にあたる<code>many</code>が、必ず強欲なマッチになる</h4>
<p>こちらについてはちょっと難しいので後述します。</p>
<h4 id="文字列の先頭からのマッチしかできない"><span class="link-to-here-outer"><a href="#文字列の先頭からのマッチしかできない" title="文字列の先頭からのマッチしかできない"><span class="link-to-here">Link to<br />
here</span></a></span>👎文字列の先頭からのマッチしかできない</h4>
<p>この問題は、パーサーコンビネーターをベター正規表現として使おうと思った場合に、しばしばパーサー作りを面倒くさくします。<br />
パーサーコンビネーターは、原理上必ず文字列の先頭から解析するよう作られています。<br />
例えば先ほど紹介したパーサー<code>decimal</code>の場合、</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="fu">&gt;</span> parse decimal <span class="st">&quot;abc123&quot;</span></a></code></pre></div>
<p>と書いても、<code>&quot;abc123&quot;</code>は先頭が「<span class="ascii">10</span>進数の文字列」ではないので、失敗してしまいます<small>（実際の戻り値はライブラリーによって異なります。試してみましょう！）</small>。</p>
<p>パーサーコンビネーターはそもそもの用途が<span class="ascii">0</span>からプログラミング言語などのマシンリーダブルな構文を作るところにあるので、妥当と言えば妥当な制限です。<br />
その場合は必ず、文字列を頭から読んでパースすることになるでしょうから。</p>
<p>とはいえ、これは正規表現で例えるなら、常に先頭に<code>\A</code> <span class="ascii">(</span>あるいは <code>^</code><span class="ascii">)</span>を付けなければならない、あるいは自動的に付いてしまう、というような制限です。<br />
正規表現は行の中にある一部の文字列を抽出したり置換したりするのによく使われるので、役に立たないケースがたくさん出てきてしまいます。</p>
<p>パーサーコンビネーターでこの問題に対応するには、マッチさせたい文字列に到達するまで、スキップするための処理を書かないといけません。<br />
残念ながらこれは、正規表現で言うところの <code>\A.*(本当にマッチさせたい文字列)</code> と書けばよい話<strong>ではありません</strong>。<br />
<code>\A(マッチさせたくない文字列)*(本当にマッチさせたい文字列)</code> という書き方をしなければならないのです。<br />
なぜなら、先ほど触れた「正規表現でいうところの <code>*</code> にあたる<code>many</code>が強欲なマッチになる」という問題があるためです。<br />
正規表現で言うところの<code>\A.*(本当にマッチさせたい文字列)</code>を書くと、<code>.*</code>が「マッチさせたくない文字列」だけでなく「本当にマッチさせたい文字列」までマッチしてしまい、結果肝心の「本当にマッチさせたい文字列」を扱うことができなくなってしまうのです。</p>
<h3 id="ソースコードの書き換えとsubstring-parser"><span class="link-to-here-outer"><a href="#ソースコードの書き換えとsubstring-parser" title="ソースコードの書き換えとsubstring-parser"><span class="link-to-here">Link to<br />
here</span></a></span>ソースコードの書き換えと<span class="ascii">substring-parser</span></h3>
<p>さて、今回の目的は「『タイプセーフプリキュア！』のソースコードの書式を書き換えることで、全シリーズのプリキュアの情報を<span class="ascii">cure-index.json</span>に収録する」ことでした。<br />
そのためには、各<code>Textbook</code>モジュールのソースコードにおいて<strong>途中</strong>に含まれている、プリキュアを表す型の定義や、型クラスのインスタンス宣言を集める必要があります。<br />
しかもそれらは、一つの定義が行をまたいでいたりまたいでなかったりするので、よくある行単位で処理するツールを使うのも、なかなか難しいと思います。<br />
また、抽出したいデータ構造も多様かつそこそこに複雑で、中には再帰的なデータ構造もあります。正規表現を用いてのパースも、かなり困難なことでしょう。<br />
とはいえパーサーコンビネーターを通常のとおりに使うと、これまでに述べたとおり、「文字列の先頭からしかマッチできない」という制限が、考えることを複雑にします。</p>
<p>こうした状況は今回の問題に限らず、このように、ソースコードの多くの類似箇所を書き換える場面において、しばしば発生するでしょう。<br />
そこで今回は<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>こうした問題全般に対応するライブラリーとして、<a href="https://gitlab.com/igrep/substring-parser"><span class="ascii">substring-parser</span></a>というライブラリーを作りました。</p>
<p><span class="ascii">substring-parser</span>を使えば、任意のパーサーコンビネーター<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>を<strong>文字列の中間でも</strong>マッチさせることができます。<br />
残念ながらドキュメントらしいドキュメントが全く書けてない状況ではありますが、一応動きます。<br />
<a href="https://gitlab.com/igrep/substring-parser/blob/master/test/Spec.hs"><span class="ascii">Spec.hs</span></a>が動作を知る際の参考になるかも知れません。</p>
<h4 id="substring-parserの仕組み"><span class="link-to-here-outer"><a href="#substring-parserの仕組み" title="substring-parserの仕組み"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">substring-parser</span>の仕組み</h4>
<p><span class="ascii">substring-parser</span>はどのようにして、任意のパーサーコンビネーターを文字列の中間でもマッチできるようにしているのでしょう？<br />
仕組みは単純です。<br />
引数として受け取ったパーサーを、</p>
<ol type="1">
<li>とりあえず先頭からマッチさせてみる。</li>
<li>失敗したら先頭の一文字をスキップして、次の文字からまたマッチさせてみる。</li>
</ol>
<p>という手順を繰り返すだけです。 結果として文字列の先頭にある「マッチさせたくない文字列」をスキップすることができるのです。</p>
<p>⚠️残念ながら決して効率のいい方法ではないので、真面目なパーサーを書くときはおすすめしません！<br />
あくまでも今回のような、書き捨てだけど、それなりに複雑な文字列を解析する必要がある場合のみ使うべきでしょう。</p>
<h2 id="結果できたもの"><span class="link-to-here-outer"><a href="#結果できたもの" title="結果できたもの"><span class="link-to-here">Link to<br />
here</span></a></span>結果、できたもの</h2>
<p>ここまで説明した<span class="ascii">substring-parser</span>を駆使することで、私は無事、各<code>Textbook</code>モジュールを半自動で古い書式から新しい書式に書き換えることに成功しました。<br />
<small>（残念ながら古い<code>Textbook</code>モジュールには存在しない情報を補ったり、体裁を整えたりする必要があったため、完全に自動で書き換えられたわけではありません）</small><br />
<a href="https://github.com/igrep/typesafe-precure/pull/25"><span class="ascii">typesafe-precure#25</span></a>という大きな<span class="ascii">Pull request</span>に、移行したもののほぼすべてが刻まれています。</p>
<p>なお、上記の<span class="ascii">Pull request</span>では消してしまってますが、実際に実行した、移行用スクリプトは<a href="https://github.com/igrep/typesafe-precure/blob/ed038aa57a4df6b1fcc23fb071253888ebd7d477/app/migrate2cure-index.hs"><span class="ascii">typesafe-precure/app/migrate2cure-index.hs</span></a>にあります。<br />
ご興味のある方はご覧になってみてください。</p>
<p>また、もう少し小さいサンプルとして、プリキュアハッカソンの成果発表でデモをした時点のコミットも載せておきます。<br />
👇のコマンドを実行すれば、<a href="https://github.com/igrep/typesafe-precure/blob/73948fb4a82baaf4e33900d77326791c7703f786/app/migrate2cure-index.hs#L101-L118">こちらのコミット時点のパーサー</a>で、<a href="https://github.com/igrep/typesafe-precure/blob/73948fb4a82baaf4e33900d77326791c7703f786/src/ACME/PreCure/Textbook/Dokidoki/Types.hs#L19-L23">同時点の<span class="ascii">Types.hs</span></a>から、<span class="ascii">cure-index.json</span>で使用する<a href="https://github.com/igrep/typesafe-precure/blob/73948fb4a82baaf4e33900d77326791c7703f786/src/ACME/PreCure/Index/Types.hs#L44-L46"><code>Girl</code></a>という型の値を取り出すことができます！</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="fu">&gt;</span> git clone https<span class="fu">://</span>github<span class="fu">.</span>com<span class="fu">/</span>igrep<span class="fu">/</span>typesafe<span class="fu">-</span>precure</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="fu">&gt;</span> cd typesafe<span class="fu">-</span>precure</a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="fu">&gt;</span> git checkout 73948fb4a82baaf4e33900d77326791c7703f786</a>
<a class="sourceLine" id="cb12-4" data-line-number="4"><span class="fu">&gt;</span> stack build <span class="fu">:</span>migrate2cure<span class="fu">-</span>index</a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="fu">&gt;</span> stack exec migrate2cure<span class="fu">-</span>index</a>
<a class="sourceLine" id="cb12-6" data-line-number="6"></a>
<a class="sourceLine" id="cb12-7" data-line-number="7"><span class="fu">...</span> 略 <span class="fu">...</span></a>
<a class="sourceLine" id="cb12-8" data-line-number="8"></a>
<a class="sourceLine" id="cb12-9" data-line-number="9"><span class="co">-- src/ACME/PreCure/Textbook/Dokidoki --</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10"><span class="dt">Girl</span> {girlId <span class="fu">=</span> <span class="st">&quot;\&quot;Mana\&quot;&quot;</span>, girlNameEn <span class="fu">=</span> <span class="st">&quot;\&quot;Mana\&quot; ++ error \&quot;Need family name!\&quot;&quot;</span>, girlNameJa <span class="fu">=</span> <span class="st">&quot;girlName&quot;</span>}</a>
<a class="sourceLine" id="cb12-11" data-line-number="11"><span class="dt">Girl</span> {girlId <span class="fu">=</span> <span class="st">&quot;\&quot;Rikka\&quot;&quot;</span>, girlNameEn <span class="fu">=</span> <span class="st">&quot;\&quot;Rikka\&quot; ++ error \&quot;Need family name!\&quot;&quot;</span>, girlNameJa <span class="fu">=</span> <span class="st">&quot;girlName&quot;</span>}</a>
<a class="sourceLine" id="cb12-12" data-line-number="12"><span class="dt">Girl</span> {girlId <span class="fu">=</span> <span class="st">&quot;\&quot;Alice\&quot;&quot;</span>, girlNameEn <span class="fu">=</span> <span class="st">&quot;\&quot;Alice\&quot; ++ error \&quot;Need family name!\&quot;&quot;</span>, girlNameJa <span class="fu">=</span> <span class="st">&quot;girlName&quot;</span>}</a>
<a class="sourceLine" id="cb12-13" data-line-number="13"><span class="dt">Girl</span> {girlId <span class="fu">=</span> <span class="st">&quot;\&quot;Makoto\&quot;&quot;</span>, girlNameEn <span class="fu">=</span> <span class="st">&quot;\&quot;Makoto\&quot; ++ error \&quot;Need family name!\&quot;&quot;</span>, girlNameJa <span class="fu">=</span> <span class="st">&quot;girlName&quot;</span>}</a>
<a class="sourceLine" id="cb12-14" data-line-number="14"><span class="dt">Girl</span> {girlId <span class="fu">=</span> <span class="st">&quot;\&quot;Aguri\&quot;&quot;</span>, girlNameEn <span class="fu">=</span> <span class="st">&quot;\&quot;Aguri\&quot; ++ error \&quot;Need family name!\&quot;&quot;</span>, girlNameJa <span class="fu">=</span> <span class="st">&quot;girlName&quot;</span>}</a></code></pre></div>
<h1 id="その他の似たソリューション"><span class="link-to-here-outer"><a href="#その他の似たソリューション" title="その他の似たソリューション"><span class="link-to-here">Link to<br />
here</span></a></span>その他の似たソリューション</h1>
<p>今回は、自前で作ったライブラリーと一から書いたパーサーを組み合わせることで「ソースコードの多くの類似箇所を書き換える」問題に対応しましたが、似たようなことを行うツールはほかにもあります。<br />
いずれも私はほぼ使ったことがないので詳しい解説はできませんが、軽く紹介しておきます。</p>
<h2 id="codemod"><span class="link-to-here-outer"><a href="#codemod" title="codemod"><span class="link-to-here">Link to<br />
here</span></a></span><a href="https://github.com/facebook/codemod"><span class="ascii">codemod</span></a></h2>
<p><span class="ascii">Facebook</span>製の一括置換ツールです。指定したディレクトリーのファイル群を、正規表現で一括置換できます。<br />
ここまで書くと<code>perl</code>や<code>sed</code>、<code>awk</code>などで十分できそうにも聞こえますが、修正前後の状態を色つきで見ながら対話的に修正できるそうです。<br />
正規表現での単純な修正が気に入らなければ、その場で該当箇所だけをエディタで修正できるとのこと。<br />
<span class="ascii">Python 2</span>に依存しているのがちょっとつらいところでしょうか…😨。</p>
<h2 id="jscodeshift"><span class="link-to-here-outer"><a href="#jscodeshift" title="jscodeshift"><span class="link-to-here">Link to<br />
here</span></a></span><a href="https://github.com/facebook/jscodeshift"><span class="ascii">jscodeshift</span></a></h2>
<p>同じく<span class="ascii">Facebook</span>が作った、名前のとおり<span class="ascii">JavaScript</span>に特化したソースコードの修正ツールです。<br />
こちらは正規表現は使用せず、「<span class="ascii">Transform module</span>」と呼ばれる、<span class="ascii">JavaScript</span>の<span class="ascii">AST</span>を変換するための専用のスクリプトを実行することで修正するそうです。<br />
様々な状況に特化した「<span class="ascii">Transform module</span>」を別パッケージとしても提供しているようです。</p>
<p>📝以上の<span class="ascii">2</span>つについては「<a href="https://www.webprofessional.jp/getting-started-with-codemods/"><span class="ascii">JavaScript</span>疲れに効く！ <span class="ascii">codemod</span>と<span class="ascii">JSCodeshift</span>でリファクタリングが捗る <span class="ascii">- WPJ</span></a>」も参考にしました。</p>
<h2 id="refactorio"><span class="link-to-here-outer"><a href="#refactorio" title="refactorio"><span class="link-to-here">Link to<br />
here</span></a></span><a href="https://github.com/SuperpowersCorp/refactorio"><span class="ascii">refactorio</span></a></h2>
<p><a href="https://www.superpowerscorp.com/"><span class="ascii">SuperPowers Corp</span></a>という会社が開発中の、<span class="ascii">lens</span>をはじめとする<span class="ascii">Haskell</span>のパワーを集大成させた、ソースコードの一括置換ツールです。<br />
<code>ByteString -&gt; ByteString</code>という型の<span class="ascii">Haskell</span>の関数を渡すことで、指定したディレクトリーのファイルすべてに対して関数を適用し、書き換えます。</p>
<p>加えて、<code>--haskell</code>や<code>--html</code>、<code>--javascript</code>など、各言語に特化したオプションを渡すと、各言語のソースコードを修正する<span class="ascii">lens</span>ベースの<span class="ascii">module</span>を<span class="ascii">import</span>した状態で、関数を作れるようにしてくれます。<br />
具体的には、例えば<code>--haskell</code>オプションを渡すと、<a href="https://hackage.haskell.org/package/haskell-src-exts"><span class="ascii">haskell-src-exts</span></a>と<a href="https://hackage.haskell.org/package/haskell-src-exts-prisms"><span class="ascii">haskell-src-exts-prisms</span></a>パッケージのモジュールを<span class="ascii">import</span>することで、<span class="ascii">Haskell</span>の<span class="ascii">AST</span>の各トークンに対応した<code>Prism</code>などが使えるようになります。</p>
<p>後は<a href="https://www.stackage.org/haddock/lts-12.8/lens-4.16.1/Data-Data-Lens.html#v:biplate"><code>biplate</code></a>など<span class="ascii">lens</span>ライブラリーのコンビネーターと組み合わせれば、一気に<span class="ascii">Haskell</span>のソースコードを編集することができます。 「任意のデータ構造に対する<span class="ascii">jQuery</span>」とも言われる<span class="ascii">lens</span>ライブラリーのパワーを存分に生かしたツールなのです。</p>
<p>残念なところは、今でも開発中である点と、<span class="ascii">lens</span>ライブラリーに習熟していなければ使いこなせないという点でしょうか。<br />
よく使う<code>Lens</code>型や<code>Prism</code>型だけでなく、<code>Traversal</code>も使えなければなりません。<br />
特に<a href="https://github.com/SuperpowersCorp/refactorio#haskell-via-haskell-src-exts-and-haskell-src-exts-prisms">サンプル</a>で紹介されているような<a href="https://www.stackage.org/haddock/lts-12.8/lens-4.16.1/Data-Data-Lens.html#v:biplate"><code>biplate</code></a>を使った場合において、指定した<code>Prism</code>がマッチしなかった場合、何事もなかったかのようにソースが書き換えられないため、デバッグが面倒なところもつらいです。</p>
<h1 id="次のゴール"><span class="link-to-here-outer"><a href="#次のゴール" title="次のゴール"><span class="link-to-here">Link to<br />
here</span></a></span>次のゴール</h1>
<p>「タイプセーフプリキュア！」の開発は、これからもプリキュアハッカソンの前後とプリキュア<span class="ascii">Advent Calendar</span>の前後を中心に、今後も続ける予定です。<br />
先にも触れましたが、次回は今回完成させた<span class="ascii">cure-index.json</span>を使用することで、<a href="http://the.igreque.info/posts/2014-12-25-unite-precure.vim.html">かつて<span class="ascii">rubicure</span>で作ったユナイトプリキュア</a>を「ユナイトプリキュア」を「ディナイトプリキュア」として書き直すかも知れません。<br />
ただ、それ以外にももうちょっと<span class="ascii">Haskell</span>で遊びたいことがあるので、後回しにするかも知れません。<br />
<span class="ascii">Vim script</span>、あんまり書きたくないんですよね…😥</p>
<h1 id="まとめ"><span class="link-to-here-outer"><a href="#まとめ" title="まとめ"><span class="link-to-here">Link to<br />
here</span></a></span>まとめ</h1>
<ul>
<li><span class="ascii">Haskell</span>界に伝わる伝説のアイテム「パーサーコンビネーター」を応用して、「タイプセーフプリキュア！」の古いソースコードを半自動で変換しました。</li>
<li>「パーサーコンビネーター」は正規表現よりいいところたくさんですが、文字列の先頭からのマッチしかできないのがつらいです。
<ul>
<li><a href="https://gitlab.com/igrep/substring-parser"><span class="ascii">substring-parser</span></a>というライブラリーを書いて、対応しました。</li>
</ul></li>
<li>パーサーコンビネーター最高！ ✌️😆✌️</li>
</ul>
<p>それではこの秋もパーサーコンビネーターで<span class="ascii">Happy Haskell Hacking!!</span>✌️✌️✌️</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>プリキュアハッカソンは「ハッカソン」の名を冠してはいるものの、実態としてはプリキュアの映画を観ながら好き勝手に開発するというゆるい会です。<br />
また、そもそもそれほど時間もないので、私は当日の<span class="ascii">3</span>～<span class="ascii">4</span>週間ほど前から今回の対応を始めておりました。「今回のプリキュアハッカソンに<strong>向けて</strong>行ったこと」なる見出しなのは、そのためです。<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>当時は各<code>Textbook</code>モジュールの<code>Types.hs</code>というファイルで<code>ANN</code>や<code>declareTransformees</code>などを使っていましたが、現在は「ルートに当たるモジュール」で行うことにしました。ファイル数を減らすのと、<span class="ascii">export</span>する識別子を型に絞ることで、<code>transformeesHugtto</code>のような、あまりかっこよくない識別子を隠す、というのがその目的です。<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>実際には、前職時代に同様の問題に遭遇した際作成しました。今後も必要になったときにちょっとずつ開発していく予定です。<a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p>一応<a href="http://hackage.haskell.org/package/parsers"><code>parsers</code></a>パッケージを使って様々なパーサーコンビネーターのライブラリーをサポートするように作りましたが、現状<a href="http://hackage.haskell.org/package/attoparsec"><code>attoparsec</code></a>でのみテストしています。用途を考えれば多分十分じゃないかと思っています。<a href="#fnref4" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2018/tech-book-fest-5.html" lang="ja">技術書典 5 での Haskell 関連サークルのまとめ</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2018/derive-json-no-prefix.html" style="margin-left: auto;" lang="ja">deriveJsonNoPrefixをリリースしました</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>deriveJsonNoPrefixをリリースしました</title>
    <link href="https://haskell.jp/blog/posts/2018/derive-json-no-prefix.html" />
    <id>https://haskell.jp/blog/posts/2018/derive-json-no-prefix.html</id>
    <published>2018-07-18T00:00:00Z</published>
    <updated>2018-07-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>前回の更新からちょっと時間が空いてしまいました 💦<br />
小ネタです。掲題の通り<a href="http://hackage.haskell.org/package/deriveJsonNoPrefix"><span class="ascii">deriveJsonNoPrefix</span></a>というパッケージをリリースしました。<br />
地味に有用だと思うので、<a href="https://gitlab.com/igrep/deriveJsonNoPrefix/blob/master/README.md"><span class="ascii">README</span></a>をやや意訳気味に翻訳して記事にします。<br />
十分に単純なので、仕様が変わることもまさかないでしょうし。</p>
<p>以下、<a href="https://gitlab.com/igrep/deriveJsonNoPrefix/blob/6114e0fc55cf5b57a771871e53971a51592f618b/README.md">こちらのコミットの時点の<span class="ascii">README</span></a>の翻訳です。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#derivejsonnoprefix" title="derivejsonnoprefix"><span class="ascii">deriveJsonNoPrefix</span></a>
<ul>
<li><a href="#例" title="例">例</a></li>
<li><a href="#同じ問題を解決するほかのライブラリー" title="同じ問題を解決するほかのライブラリー">同じ問題を解決するほかのライブラリー</a></li>
</ul></li>
</ul>
</div>
</div>
<h1 id="derivejsonnoprefix"><span class="link-to-here-outer"><a href="#derivejsonnoprefix" title="derivejsonnoprefix"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">deriveJsonNoPrefix</span></h1>
<p>プレフィックスに優しい<code>ToJSON</code>と<code>FromJSON</code>のインスタンスを定義する<span class="ascii">Template Haskell</span>のマクロを提供します。</p>
<h2 id="例"><span class="link-to-here-outer"><a href="#例" title="例"><span class="link-to-here">Link to<br />
here</span></a></span>例</h2>
<p>こんな感じの<span class="ascii">JSON</span>を作りたいとしましょう<span class="ascii">:</span></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode json"><code class="sourceCode json"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="fu">{</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="dt">&quot;id&quot;</span><span class="fu">:</span> <span class="st">&quot;ID STRING&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    <span class="dt">&quot;max&quot;</span><span class="fu">:</span> <span class="fl">0.789</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    <span class="dt">&quot;min&quot;</span><span class="fu">:</span> <span class="fl">0.123</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="fu">}</span></a></code></pre></div>
<p>きっと<a href="http://hackage.haskell.org/package/aeson/docs/Data-Aeson.html#t:ToJSON"><span class="ascii">ToJSON</span></a>（おそらくそれに加えて<a href="http://hackage.haskell.org/package/aeson/docs/Data-Aeson.html#t:FromJSON"><span class="ascii">FromJSON</span></a>も）のインスタンスを自動的に定義するための、次のようなレコード型を定義したくなるでしょう。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Data.Aeson.TH</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="kw">data</span> <span class="dt">SomeRecord</span> <span class="fu">=</span> <span class="dt">SomeRecord</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  {<span class="ot"> id ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  ,<span class="ot"> max ::</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">  ,<span class="ot"> min ::</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb2-10" data-line-number="10"></a>
<a class="sourceLine" id="cb2-11" data-line-number="11"><span class="fu">$</span>(deriveToJSON defaultOptions <span class="ch">&#39;&#39;</span><span class="dt">SomeRecord</span>)</a></code></pre></div>
<p>しかし、こんなレコード型は定義すべきではありません。<br />
<code>id</code>も<code>max</code>も<code>min</code>も、<code>Prelude</code>に定義済みなのですから！</p>
<p>この問題を回避するために、レコードラベルに型の名前をプレフィックスとして加える、ということをわれわれはよくやります。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> <span class="dt">SomeRecord</span> <span class="fu">=</span> <span class="dt">SomeRecord</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  {<span class="ot"> someRecordId ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  ,<span class="ot"> someRecordMax ::</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  ,<span class="ot"> someRecordMin ::</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>そして、<code>deriveToJSON</code>にデフォルトと異なるオプションを渡して実行します。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">deriveToJSON Json.defaultOptions { fieldLabelModifier <span class="fu">=</span> firstLower <span class="fu">.</span> drop (length <span class="st">&quot;SomeRecord&quot;</span>) } <span class="ch">&#39;&#39;</span><span class="dt">SomeRecord</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="ot">firstLower ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">firstLower (x<span class="fu">:</span>xs) <span class="fu">=</span> toLower x <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">firstLower _ <span class="fu">=</span> error <span class="st">&quot;firstLower: Assertion failed: empty string&quot;</span></a></code></pre></div>
<p><code>fieldLabelModifier</code>オプションは文字通り、対象のレコードを<span class="ascii">JSON</span>に変換するとき、あるいは<span class="ascii">JSON</span>から対象のレコードの値に変換する時、レコードのラベルを変換する関数を設定するために使います。<br />
👆の場合、プレフィックスである<code>SomeRecord</code>の文字数分レコードラベルから<code>drop</code>して、先頭の文字<small>（<code>someRecordId</code>で言えば<code>Id</code>の<code>I</code>に相当します）</small>を小文字に変換しているのがわかるでしょうか？</p>
<p>そう、これが<code>deriveToJsonNoTypeNamePrefix</code>がやっていることとほぼ同等のことです。<br />
<code>deriveToJsonNoTypeNamePrefix</code>は、実質次のように定義されています。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">deriveToJsonNoTypeNamePrefix ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> [<span class="dt">Dec</span>]</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">deriveToJsonNoTypeNamePrefix deriver name <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  deriveToJSON Json.defaultOptions { fieldLabelModifier <span class="fu">=</span> dropPrefix name } name</a>
<a class="sourceLine" id="cb5-4" data-line-number="4"></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="ot">dropPrefix ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">dropPrefix name <span class="fu">=</span> firstLower <span class="fu">.</span> drop (length <span class="fu">$</span> nameBase name)</a>
<a class="sourceLine" id="cb5-7" data-line-number="7"></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="ot">firstLower ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">firstLower (x<span class="fu">:</span>xs) <span class="fu">=</span> toLower x <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">firstLower _ <span class="fu">=</span> error <span class="st">&quot;firstLower: Assertion failed: empty string&quot;</span></a></code></pre></div>
<p>結果、これからは<code>fieldLabelModifier</code>をもう自分で定義する必要がありません！🙌</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.Aeson.DeriveNoPrefix</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="fu">$</span>(deriveJsonNoTypeNamePrefix <span class="ch">&#39;&#39;</span><span class="dt">SomeRecord</span>)</a></code></pre></div>
<p>👆 の<code>deriveJsonNoTypeNamePrefix</code> は <a href="https://hackage.haskell.org/package/aeson/docs/Data-Aeson-TH.html#v:deriveJSON"><span class="ascii">deriveJSON</span></a>と同様に、<code>ToJSON</code>と<code>FromJSON</code>のインスタンス、両方を生成します。<br />
もちろん、<code>FromJSON</code>のインスタンスを生成するときのオプションとしても、プレフィックスを削除するための<code>fieldLabelModifier</code>を渡してくれます！</p>
<h2 id="同じ問題を解決するほかのライブラリー"><span class="link-to-here-outer"><a href="#同じ問題を解決するほかのライブラリー" title="同じ問題を解決するほかのライブラリー"><span class="link-to-here">Link to<br />
here</span></a></span>同じ問題を解決するほかのライブラリー</h2>
<ul>
<li><a href="https://hackage.haskell.org/package/extensible"><span class="ascii">extensible</span></a><span class="ascii">.</span></li>
<li>など、<code>ToJSON</code>・<code>FromJSON</code>のインスタンスが定義された<span class="ascii">extensible record</span>を提供するライブラリー</li>
</ul>
<p>なので、そうした<span class="ascii">extensible record</span>を提供するライブラリーが学習コストや依存関係などの事情で「重たい」と感じたときにこのパッケージを使ってください。</p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2018/substring-parser.html" lang="ja">substring-parserで「タイプセーフプリキュア！」を移行した話</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2018/windows-gotchas-en.html" style="margin-left: auto;" lang="en">Errors and the workarounds frequently encountered when dealing with Haskell on Windows</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>Errors and the workarounds frequently encountered when dealing with Haskell on Windows</title>
    <link href="https://haskell.jp/blog/posts/2018/windows-gotchas-en.html" />
    <id>https://haskell.jp/blog/posts/2018/windows-gotchas-en.html</id>
    <published>2018-05-25T00:00:00Z</published>
    <updated>2018-05-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="en">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>This is the English version of <a href="https://haskell.jp/blog/posts/2017/windows-gotchas.html">WindowsでHaskellを扱う時によく遭遇するエラーと対処法</a>.<br />
The original article is the 4th article of <a href="https://qiita.com/advent-calendar/2017/haskell4">Haskell (その4) Advent Calendar 2017 (Japanese)</a>.</p>
<p>What I’m going to tell is summarized as <a href="https://twitter.com/igrep/status/938056578934042626">just one tweet (originally in Japanese)</a>:</p>
<blockquote>
<p>What I’ve learned:</p>
<ul>
<li>chcp65001 if ‘Invalid character’</li>
<li>rebuild if ‘Permission Denied’</li>
<li>Don’t mix Japanese characters in file paths.</li>
<li>Some libraries in C are available, and others are not.</li>
</ul>
<p>Perhaps they’re helpful in other languages.</p>
</blockquote>
<p>Let me add more details.</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#chcp-65001-if-invalid-character" title="chcp-65001-if-invalid-character">chcp 65001 if “Invalid character”</a>
<ul>
<li><a href="#workaround" title="workaround">Workaround</a>
<ul>
<li><a href="#if-you-encounter-as-a-user" title="if-you-encounter-as-a-user">If you encounter as a user</a></li>
<li><a href="#if-it-still-doesnt-work-or-youre-the-developer-of-the-libraries-etc." title="if-it-still-doesnt-work-or-youre-the-developer-of-the-libraries-etc.">If it still doesn’t work, or you’re the developer of the libraries etc.</a></li>
</ul></li>
</ul></li>
<li><a href="#rebuild-if-permission-denied" title="rebuild-if-permission-denied">Rebuild if “Permission Denied”</a></li>
<li><a href="#try-hard-to-build-libraries-in-c" title="try-hard-to-build-libraries-in-c">Try hard to build libraries in C…</a></li>
</ul>
</div>
</div>
<h1 id="chcp-65001-if-invalid-character"><span class="link-to-here-outer"><a href="#chcp-65001-if-invalid-character" title="chcp-65001-if-invalid-character"><span class="link-to-here">Link to<br />
here</span></a></span>chcp 65001 if “Invalid character”</h1>
<p>You would have encountered this frequently, especially if you don’t know how to avoid/fix this.<br />
Oh, it’s caused again by building with hakyll!</p>
<pre><code>&gt; stack exec -- site rebuild
...
  [ERROR] preprocessed-site\posts/2017/01-first.md: hGetContents: invalid argument (invalid byte sequence)</code></pre>
<p>The object called <a href="https://www.stackage.org/haddock/lts-10.0/base-4.10.1.0/System-IO.html#t:Handle"><code>Handle</code></a>, used by GHC to read and write a file, knows its character encoding.</p>
<p>This resembles Ruby’s <a href="https://ruby-doc.org/core-2.5.0/IO.html"><code>IO</code></a> and Perl’s file handler.<br />
Both of them represent the “gateway” of data, and assigning character encoding to them enables us to handle the only, consistently encoded strings by converting the incoming data.<br />
In Haskell’s type <code>Char</code>, the only default encoding is UTF-32 (is this the right name in this case?).</p>
<p>The character encoding assigned to a <code>Handle</code> by default depends on the locale settings of the OS: in Japanese Windows, Windows-31J (a.k.a CP932).<br />
But it’s now soon becoming 2018 (when writing the original article). Most files you create should be in UTF-8 unless you write programs in notepad.exe<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.<br />
It doesn’t work to read a UTF-8 file as a Windows-31J file because they’re very different encoding system.<br />
The <code>invalid byte sequence</code> error, shown at the head of this section, is caused by that inconsistency.<br />
Remember this kind of errors are often caused when reading or writing stdout/stdin, as well as plain files.</p>
<h2 id="workaround"><span class="link-to-here-outer"><a href="#workaround" title="workaround"><span class="link-to-here">Link to<br />
here</span></a></span>Workaround</h2>
<h3 id="if-you-encounter-as-a-user"><span class="link-to-here-outer"><a href="#if-you-encounter-as-a-user" title="if-you-encounter-as-a-user"><span class="link-to-here">Link to<br />
here</span></a></span>If you encounter as a user</h3>
<p>In many cases you can avoid these kind of errors by running the below command in advance.</p>
<pre><code>&gt; chcp 65001
&gt; stack exec -- site rebuild
... Should work!</code></pre>
<p>This command temporarily changes the character encoding in the current Command Prompt session.<br />
The number <code>65001</code> seems to stand for UTF-8.<br />
To roll it back, run <code>chcp 932</code>.</p>
<pre><code>&gt; chcp 932</code></pre>
<p>It seems that the “932” of “CP932” is the same “932” entered here!</p>
<p>The <code>chcp</code> command is available in MSYS2’s bash (Surprises me a little. Wondering how it works…😕).<br />
But you should know that <code>chcp</code> exists at <code>C:\Windows\System32\</code>, which MSYS2 users usually don’t want to include in the <code>PATH</code>.<br />
The directory contains many incompatible commands whose names conflict with the tools loved by Unix people (e.g. <code>find.exe</code>)!</p>
<p>So I’ve dropped <code>C:\Windows\System32\</code> from <code>PATH</code> when using MSYS2.<br />
If you’ve done like me, run by full path:</p>
<pre><code>/c/Windows/System32/chcp.com 932</code></pre>
<h3 id="if-it-still-doesnt-work-or-youre-the-developer-of-the-libraries-etc."><span class="link-to-here-outer"><a href="#if-it-still-doesnt-work-or-youre-the-developer-of-the-libraries-etc." title="if-it-still-doesnt-work-or-youre-the-developer-of-the-libraries-etc."><span class="link-to-here">Link to<br />
here</span></a></span>If it still doesn’t work, or you’re the developer of the libraries etc.</h3>
<p>Unfortunately, the error can often persist even after running <code>chcp 65001</code><a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>.<br />
According to my guess, the <code>chcp 65001</code> command doesn’t affect the grandchild processes of the Command Prompt (or bash etc.) on which the <code>chcp</code> is run (i.e. the child processes of the command you enter).</p>
<p>If the error still happens you can either report to the developer, or fix it yourself!<br />
When reporting; asking the developer to run after doing <code>chcp 932</code> could help him/her reproduce the bug (Sorry, I’ve never tried it).<br />
When fixing by yourself, perhaps the best and most certain way would be to switch the character encoding of the <code>Handle</code> object.</p>
<p>This problem is caused by the inconsistency between the <code>Handle</code>'s character encoding and the encoding of the bytes that are actually transferred. So switching into the proper encoding should fix it.<br />
If the error happens when reading/writing a common UTF-8 file via the <code>Handle</code>, writing like below can avoid it:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">import</span> <span class="dt">System.IO</span> (hSetEncoding)</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="kw">import</span> <span class="dt">GHC.IO.Encoding</span> (utf8)</a>
<a class="sourceLine" id="cb5-3" data-line-number="3"></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">hSetEncoding handle utf8</a></code></pre></div>
<p>As a bonus, I’ll show you an example of how <a href="https://github.com/haskell/haddock/pull/566">I myself addressed a problem caused by the standard output (or standard error output), and fixed a bug in haddock</a>. In short, it can at least suppress the error to paste the code below before your program uses the <code>Handle</code> (Copied from <a href="https://github.com/haskell/haddock/pull/566/commits/855118ee45e323fd9b2ee32103c7ba3eb1fbe4f2">this commit</a>).</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">{-# LANGUAGE CPP #-}</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">import</span> <span class="dt">System.IO</span> (hSetEncoding, stdout)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="ot">#if defined(mingw32_HOST_OS)</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="kw">import</span> <span class="dt">GHC.IO.Encoding.CodePage</span> (mkLocaleEncoding)</a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="kw">import</span> <span class="dt">GHC.IO.Encoding.Failure</span> (<span class="dt">CodingFailureMode</span>(<span class="dt">TransliterateCodingFailure</span>))</a>
<a class="sourceLine" id="cb6-8" data-line-number="8"><span class="ot">#endif</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9"></a>
<a class="sourceLine" id="cb6-10" data-line-number="10"><span class="fu">...</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11"></a>
<a class="sourceLine" id="cb6-12" data-line-number="12"><span class="ot">#if defined(mingw32_HOST_OS)</span></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">  liftIO <span class="fu">$</span> hSetEncoding stdout <span class="fu">$</span> mkLocaleEncoding <span class="dt">TransliterateCodingFailure</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14"><span class="ot">#endif</span></a></code></pre></div>
<p>CPP macros to <code>import</code> modules only available on Windows makes this code hard to read, so let’s cut out the verbose part:</p>
<pre><code>hSetEncoding stdout $ mkLocaleEncoding TransliterateCodingFailure</code></pre>
<p>Here’re the details:<br />
First of all, <code>hSetEncoding</code> is the function to change the <code>Handle</code>‘s character encoding, as I referred before.<br />
Then <code>stdout</code> is the <code>Handle</code> for the standard output as its name.<br />
The last function call <code>mkLocaleEncoding TransliterateCodingFailure</code> returns a character encoding object for the current Windows’ character encoding (i.e. <code>chcp</code>ed character encoding), configured as “Even if the <code>Handle</code> detects any characters which can’t be converted into/from a Unicode character, don’t raise an error, convert it into some likable character instead.”.</p>
<p>As the result of the <code>hSetEncoding</code> above, and the current character encoding is Windows-31J, the character used in the compilation error of GHC:</p>
<pre><code>↓This character
• No instance for (Transformation Nagisa CardCommune_Mepple)
↑</code></pre>
<p>is converted into</p>
<pre><code>? No instance for (Transformation Nagisa CardCommune_Mepple)</code></pre>
<p>the question mark. Yeah, this is the “?” I bet most users of GHC on Japanese Windows have seen at least once 😅<br />
This makes me guess GHC executes <code>hSetEncoding stderr $ mkLocaleEncoding TransliterateCodingFailure</code> by default before printing out the compilation error.<br />
Anyway, it’s good that the program doesn’t abort due to the error!</p>
<p>As the last note of this section: Read <a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/GHC-IO-Encoding.html">the document of GHC.IO.Encoding</a> for the details of how GHC handles various character encodings.</p>
<h1 id="rebuild-if-permission-denied"><span class="link-to-here-outer"><a href="#rebuild-if-permission-denied" title="rebuild-if-permission-denied"><span class="link-to-here">Link to<br />
here</span></a></span>Rebuild if “Permission Denied”</h1>
<p>I’ve made the first section too long for “Quick-and-dirty checklist”, but I’ll tell you in short from this section.<br />
We often encounter some errors like “Permission Denied”, “Directory not empty” and similar ones when running <code>stack build</code>, <code>ghc</code>, <code>elm-make</code>, and any other commands written in Haskell.<br />
To tell the truth, I’m completely not sure of the cause, but those errors disappear by running the same command several times.<br />
The key is to repeat many times. Never give up only by once or twice 😅<br />
Turning off your antivirus software’s scanning of the problematic directory, Dropbox’s synchronisation, etc. might also fix such errors.</p>
<h1 id="try-hard-to-build-libraries-in-c"><span class="link-to-here-outer"><a href="#try-hard-to-build-libraries-in-c" title="try-hard-to-build-libraries-in-c"><span class="link-to-here">Link to<br />
here</span></a></span>Try hard to build libraries in C…</h1>
<p>On Windows, it frequently troubles us to install libraries which depend on libraries written in C (registered as <code>lib***</code> in your OS’s package manager).<br />
But this is not the case only for Haskell.</p>
<p>The way to fix depends on the case, so let me give you some examples as external links (Sorry, all pages are written in Japanese!).</p>
<ul>
<li>HDBC-sqlite3:
<ul>
<li><a href="https://qiita.com/igrep/items/d947ab871eb5b20b57e4">Windows版stackでもHDBC-sqlite3をビルドする - Qiita</a></li>
<li><a href="http://hiratara.hatenadiary.jp/entry/2017/01/29/110100">MSYS2でHDBC-sqlite3をコンパイル - 北海道苫小牧市出身の初老PGが書くブログ</a></li>
</ul></li>
<li><a href="https://teratail.com/questions/102462">Haskell - Haskellにてstackでiconvパッケージを利用する方法【Windows環境】(102462)｜teratail</a></li>
</ul>
<p>That’s all!<br />
Then, Happy Hacking in Haskell on Windows 10!! I don’t know WSL!🏁🏁🏁</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Translator’s note: In Japanese locale, notepad.exe saves the file in Windows-31J. This will be changed (into UTF-8) in the future release of Windows 10.<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>By the way, when I once tried to build the compiler of <a href="http://eta-lang.org/">Eta</a>, (as far as I remember) <code>chcp 65001</code> didn’t fix the problem, but <code>chcp 20127</code> did.<br />
As <code>chcp 20127</code> switches into US-ASCII, I suspect the local environment of the developer of Eta is US-ASCII…<a href="#fnref2" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2018/derive-json-no-prefix.html" lang="ja">deriveJsonNoPrefixをリリースしました</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2018/about-ghc-exts-1.html" style="margin-left: auto;" lang="ja">GHC拡張ノック(Part 1)</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>GHC拡張ノック(Part 1)</title>
    <link href="https://haskell.jp/blog/posts/2018/about-ghc-exts-1.html" />
    <id>https://haskell.jp/blog/posts/2018/about-ghc-exts-1.html</id>
    <published>2018-05-15T00:00:00Z</published>
    <updated>2018-05-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p><span class="ascii">Haskell</span><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>では各処理系で言語拡張を提供し，<code>LANGUAGE</code>プラグマというものを利用することで，言語拡張を利用することが許容されています．<span class="ascii">Haskell</span>のデファクト標準的な処理系<span class="ascii">GHC</span>も多くの言語拡張を提供しており，その拡張は<strong><span class="ascii">GHC</span>拡張</strong>と呼ばれています．</p>
<p>今回は，この<span class="ascii">GHC</span>拡張の簡単な紹介と，個人的に良く使う拡張についての簡単な紹介を，全<span class="ascii">3</span>回に分けて行いたいと思います．対象としては，<span class="ascii">GHC</span>で<span class="ascii">Haskell</span>プログラミングをしたことがあり，通常の<span class="ascii">Haskell</span>の構文や動作方法が分かっている人を考えています．また，この記事はあくまで簡単な紹介に留めるもので，付随する留意点や詳細な機能説明は，大事な箇所は漏らさないよう注意するつもりですが，全てを網羅するつもりはありませんのでその点は注意してください．もし，実際に<span class="ascii">GHC</span>拡張を使用する際は，<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/"><span class="ascii">GHC</span>のユーザーガイド</a>をよく読んでから使用するのが良いでしょう．</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#ghc拡張について" title="ghc拡張について"><span class="ascii">GHC</span>拡張について</a>
<ul>
<li><a href="#haskellの言語拡張" title="haskellの言語拡張"><span class="ascii">Haskell</span>の言語拡張</a></li>
<li><a href="#ghc拡張" title="ghc拡張"><span class="ascii">GHC</span>拡張</a></li>
<li><a href="#ghc拡張の使い方" title="ghc拡張の使い方"><span class="ascii">GHC</span>拡張の使い方</a></li>
</ul></li>
<li><a href="#主要なghc拡張" title="主要なghc拡張">主要な<span class="ascii">GHC</span>拡張</a>
<ul>
<li><a href="#preludeの暗黙的な使用を抑制する" title="preludeの暗黙的な使用を抑制する"><span class="ascii">Prelude</span>の暗黙的な使用を抑制する</a></li>
<li><a href="#便利な構文の導入" title="便利な構文の導入">便利な構文の導入</a>
<ul>
<li><a href="#新たなリテラル表記を可能にする" title="新たなリテラル表記を可能にする">新たなリテラル表記を可能にする</a></li>
<li><a href="#空のデータ型に対するより強力なサポートを導入する" title="空のデータ型に対するより強力なサポートを導入する">空のデータ型に対するより強力なサポートを導入する</a></li>
<li><a href="#新たな基本構文を導入する" title="新たな基本構文を導入する">新たな基本構文を導入する</a></li>
<li><a href="#正格化に対するサポートを導入する" title="正格化に対するサポートを導入する">正格化に対するサポートを導入する</a></li>
<li><a href="#パターンマッチをより柔軟に扱えるようにする" title="パターンマッチをより柔軟に扱えるようにする">パターンマッチをより柔軟に扱えるようにする</a></li>
<li><a href="#レコードに対するサポートを強化する" title="レコードに対するサポートを強化する">レコードに対するサポートを強化する</a></li>
<li><a href="#型演算子を導入する" title="型演算子を導入する">型演算子を導入する</a></li>
<li><a href="#型クラスを拡張する" title="型クラスを拡張する">型クラスを拡張する</a></li>
<li><a href="#型ワイルドカードをより柔軟に扱う" title="型ワイルドカードをより柔軟に扱う">型ワイルドカードをより柔軟に扱う</a></li>
<li><a href="#新たな表記法の導入" title="新たな表記法の導入">新たな表記法の導入</a></li>
</ul></li>
</ul></li>
<li><a href="#次回予告" title="次回予告">次回予告</a></li>
<li><a href="#参考文献" title="参考文献">参考文献</a></li>
</ul>
</div>
</div>
<h1 id="ghc拡張について"><span class="link-to-here-outer"><a href="#ghc拡張について" title="ghc拡張について"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">GHC</span>拡張について</h1>
<h2 id="haskellの言語拡張"><span class="link-to-here-outer"><a href="#haskellの言語拡張" title="haskellの言語拡張"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Haskell</span>の言語拡張</h2>
<p><span class="ascii">Haskell</span>には，言語拡張を取り込む方法が標準で提供されています．<span class="ascii">Haskell</span>標準では，コンパイラプラグマというものが策定されており，これを通してコンパイラに追加情報を提供することができます．コンパイラプラグマは<code>{-#</code>と<code>#-}</code>で囲まれ，字句的にはコメントとして扱われます．標準では，インラインプラグマや特殊化プラグマの他に，<code>LANGUAGE</code>プラグマというものが策定されており，このプラグマを通して言語拡張を指定することができます．</p>
<p>例えば，実装によって<code>CPP</code>と<code>ScopedTypeVariables</code>という名前の言語拡張が提供されており，それを使いたい場合，次のような文をモジュールの開始前に指定することで，言語拡張が有効になります．</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE CPP, ScopedTypeVariables #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">module</span> <span class="dt">A</span> <span class="kw">where</span></a></code></pre></div>
<p>また，<code>LANGUAGE</code>プラグマを複数指定することもできます．</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">{-# LANGUAGE CPP                 #-}</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">module</span> <span class="dt">A</span> <span class="kw">where</span></a></code></pre></div>
<p>この機能を通して，多くの<span class="ascii">Haskell</span>処理系では言語拡張を提供しています．</p>
<h2 id="ghc拡張"><span class="link-to-here-outer"><a href="#ghc拡張" title="ghc拡張"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">GHC</span>拡張</h2>
<p><span class="ascii">Haskell</span>のデファクト標準な処理系<span class="ascii">GHC</span>も，多数の拡張を提供しており，この拡張が<span class="ascii">GHC</span>拡張と呼ばれるものです．<span class="ascii">GHC</span>拡張は，バージョン<span class="ascii">8.4.2</span>現在，以下の数が提供されています<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>．</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" data-line-number="1">$ <span class="ex">ghc</span> --supported-extensions <span class="kw">|</span> <span class="fu">wc</span> -l</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="ex">235</span></a></code></pre></div>
<p><code>--supported-extensions</code>オプションは，現在の<span class="ascii">GHC</span>で使用できる<span class="ascii">GHC</span>拡張を表示してくれるオプションです．ただ，<span class="ascii">GHC</span>拡張は全てが独立した拡張ではなく，互いに依存しあった拡張が多く存在します．また，先頭に<code>No</code>がついている拡張は，その<span class="ascii">GHC</span>拡張を無効にするような拡張になっています <a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a> <a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>（例えば，<code>NoImplicitPrelude</code>拡張は<code>ImplicitPrelude</code>拡張を無効にする拡張です<span class="ascii">)</span>．</p>
<p>また，デフォルトで有効になっている拡張などもあります．例えば，<code>ImplicitPrelude</code>という拡張はデフォルトで有効になります．現在デフォルトの<span class="ascii">Haskell 2010</span>をベースにしたモードで<span class="ascii">GHC 8.4.2</span>を使用する場合，以下の拡張が<a href="https://github.com/ghc/ghc/blob/ghc-8.4.2-release/compiler/main/DynFlags.hs#L2022">デフォルトで有効になります</a> <a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a> <a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a> <a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a>．</p>
<ul>
<li><a href="https://prime.haskell.org/wiki/NondecreasingIndentation"><code>NondecreasingIndentation</code></a><span class="ascii">: Haskell</span>のレイアウトルールを変更する拡張です．この拡張を有効にすると，ネストされた<code>do</code>式の場合，インデントをしなくていいようになります．</li>
<li><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#rebindable-syntax-and-the-implicit-prelude-import"><code>ImplicitPrelude</code></a><span class="ascii">:</span> 暗黙的に<code>Prelude</code>モジュールがインポートされるようになる拡張です．</li>
<li><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#switching-off-the-dreaded-monomorphism-restriction"><code>MonomorphismRestriction</code></a><span class="ascii">:</span> <a href="https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-930004.5.5">単相性制限</a>を課すようにする拡張です．この制限により，関数束縛でなく型注釈もない束縛変数の型は，デフォルティングルールによって単相化されます．</li>
<li><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#traditional-record-syntax"><code>TraditionalRecordSyntax</code></a><span class="ascii">:</span> レコード構文を有効にする拡張です．この拡張では，名前付きのフィールドを持つデータ型を定義し，それを使用することが可能になります．</li>
<li><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-EmptyDataDecls"><code>EmptyDataDecls</code></a><span class="ascii">:</span> コンストラクタを持たないデータ型の定義を許容する拡張です．</li>
<li><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi-chap.html#extension-ForeignFunctionInterface"><code>ForeignFunctionInterface</code></a><span class="ascii">: FFI</span>が使えるようになる拡張です．この拡張により，<code>foreign import</code>構文を使用することで，<span class="ascii">Haskell</span>から<span class="ascii">C</span>の関数を読み込むことができるようになります．</li>
<li><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pattern-guards"><code>PatternGuards</code></a><span class="ascii">:</span> <code>case</code>式において，通常のパターンに加えて，<code>&lt;-</code>を使用してガードの中でさらにマッチした条件下でパターンマッチができるようになる拡張です．例えば，<code>case (x, y) of { (True, y) | False &lt;- y -&gt; True; _ -&gt; False }</code>というような式が書けるようになります．</li>
<li><a href="https://prime.haskell.org/wiki/DoAndIfThenElse"><code>DoAndIfThenElse</code></a><span class="ascii">:</span> <code>if</code>式の構文を，<code>then</code>と<code>else</code>の前に<code>;</code>を許容するよう変更する拡張です．これにより，<code>do</code>式において<code>then</code>や<code>else</code>をインデントする必要がなくなります．</li>
</ul>
<p>歴史的経緯で生まれ，互換性のために残されているものの，現状使用が推奨されていない拡張もあります．他に実験的な拡張やかなり大胆な拡張も存在するため，<span class="ascii">GHC</span>拡張を使用する際は<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/"><span class="ascii">GHC</span>のユーザーガイド</a>をよく読んでから使用するのが良いでしょう．</p>
<h2 id="ghc拡張の使い方"><span class="link-to-here-outer"><a href="#ghc拡張の使い方" title="ghc拡張の使い方"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">GHC</span>拡張の使い方</h2>
<p><span class="ascii">GHC</span>で<span class="ascii">GHC</span>拡張を使用する方法は，<span class="ascii">Haskell</span>標準の<code>LANGUAGE</code>プラグマを使用する他に，幾つかあります．まず，<span class="ascii">GHC</span>にオプションを渡して有効にする方法です．例えば，<code>NoImplicitPrelude</code>拡張と<code>Strict</code>拡張を有効にした状態で<code>Main.hs</code>をコンパイルしたい場合，次のように書けます．</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ex">ghc</span> -XNoImplicitPrelude -XStrict --make Main.hs</a></code></pre></div>
<p><span class="ascii">GHC</span>では<code>-X</code>の後に拡張名を続けることで，言語拡張を有効にしてコンパイルすることができます．通常は，<code>LANGUAGE</code>プラグマを使用するのが良いですが，何らかの事情で<code>LANGUAGE</code>プラグマを使用できない場合や，デフォルトで有効にしたい言語拡張がある場合などに便利でしょう．特に<span class="ascii">GHCi</span>で言語拡張を有効にしたくなった場合，このオプションを<code>set</code>コマンドで指定すると良いでしょう．</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span>set <span class="fu">-</span><span class="dt">XNoImplicitPrelude</span> <span class="fu">-</span><span class="dt">XStrict</span></a></code></pre></div>
<p>他に<span class="ascii">GHC</span>拡張を有効にする方法として，<code>Cabal</code>の機能を活用する方法があります．<code>cabal</code>ファイルのビルド情報欄には，<a href="https://www.haskell.org/cabal/users-guide/developing-packages.html#pkg-field-default-extensions"><code>default-extensions</code>というフィールド</a>を指定することができ，そこにデフォルトで有効にしたい言語拡張のリストを書くことで，その拡張を有効にした状態で<code>Cabal</code>がビルドを行ってくれます．例えば，<code>NoImplicitPrelude</code>拡張と<code>Strict</code>拡張をデフォルトで有効にしてビルドしたい場合，次のように書きます．</p>
<pre class="cabal"><code>name:           TestPackage
version:        0.0
synopsis:       Small package with a program
author:         Angela Author
license:        BSD3
build-type:     Simple
cabal-version:  &gt;= 1.2

executable program1
  build-depends:      base
  main-is:            Main.hs
  default-extensions: NoImplicitPrelude, Strict</code></pre>
<h1 id="主要なghc拡張"><span class="link-to-here-outer"><a href="#主要なghc拡張" title="主要なghc拡張"><span class="link-to-here">Link to<br />
here</span></a></span>主要な<span class="ascii">GHC</span>拡張</h1>
<p>以下では，個人的にデフォルトで有効化して使っている拡張を幾つか紹介します．なお，<span class="ascii">GHC</span>のバージョンは<span class="ascii">8.4.2</span>で<span class="ascii">Haskell2010</span>モードで使用することを前提にしています．</p>
<h2 id="preludeの暗黙的な使用を抑制する"><span class="link-to-here-outer"><a href="#preludeの暗黙的な使用を抑制する" title="preludeの暗黙的な使用を抑制する"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Prelude</span>の暗黙的な使用を抑制する</h2>
<p>この節では，以下の拡張を紹介します．</p>
<ul>
<li><code>NoImplicitPrelude</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-NoImplicitPrelude">ユーザーガイド <span class="ascii">- NoImplicitPrelude</span>拡張</a></li>
</ul>
<p><span class="ascii">Haskell</span>では，<a href="https://www.stackage.org/haddock/lts-10.8/base-4.10.1.0/Prelude.html"><span class="ascii">Prelude</span>モジュール</a>が暗黙的に<span class="ascii">import</span>されます．つまり，<span class="ascii">Haskell</span>プログラムは暗黙に</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Prelude</span></a></code></pre></div>
<p>と書いてあると，解釈されるということです．<a href="https://www.stackage.org/haddock/lts-10.8/base-4.10.1.0/Prelude.html"><span class="ascii">Prelude</span>モジュール</a>には，<code>Int</code><span class="ascii">/</span><code>IO</code>といった基本的なデータ型や，<code>Eq</code><span class="ascii">/</span><code>Functor</code>といった基本的な型クラス，<code>zip</code><span class="ascii">/</span><code>putStrLn</code>といった基本的な関数が含まれています．</p>
<p><a href="https://www.stackage.org/haddock/lts-10.8/base-4.10.1.0/Prelude.html"><span class="ascii">Prelude</span>モジュール</a>の暗黙的な<span class="ascii">import</span>は，<span class="ascii">Haskell</span>プログラムを簡潔に書く上では便利ですが，これを無効にしたい場合もあります．</p>
<ol type="1">
<li><a href="https://www.stackage.org/haddock/lts-10.8/base-4.10.1.0/Prelude.html"><span class="ascii">Prelude</span>モジュール</a>にあるデータ型や関数と同じ名前の，別モジュールの関数を使いたい時</li>
<li>別の代替となる<span class="ascii">prelude</span>パッケージを使う時</li>
</ol>
<p>といった場合です．<code>NoImplicitPrelude</code>拡張はまさしくこのような場合に，<a href="https://www.stackage.org/haddock/lts-10.8/base-4.10.1.0/Prelude.html"><span class="ascii">Prelude</span>モジュール</a>を暗黙的に<span class="ascii">import</span>しないようにする<span class="ascii">GHC</span>拡張です．<span class="ascii">1</span>番目の理由の場合，この拡張をデフォルトで入れずモジュール度に指定すればいいと思いますが，私的には<span class="ascii">2</span>番目の理由でこの拡張を使うためデフォルトで有効にしています．代替となる<span class="ascii">prelude</span>パッケージは幾つか存在しますが，主に</p>
<ul>
<li><span class="ascii">classy-prelude:</span> <a href="https://hackage.haskell.org/package/classy-prelude"><span class="ascii">Hackage</span>リンク</a></li>
<li><span class="ascii">protolude:</span> <a href="https://hackage.haskell.org/package/protolude"><span class="ascii">Hackage</span>リンク</a></li>
<li><span class="ascii">universum:</span> <a href="https://hackage.haskell.org/package/universum"><span class="ascii">Hackage</span>リンク</a></li>
<li><span class="ascii">basic-prelude:</span> <a href="https://hackage.haskell.org/package/basic-prelude"><span class="ascii">Hackage</span>リンク</a></li>
</ul>
<p>などがあります<a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a>．これらのパッケージを探すには<a href="https://hackage.haskell.org/packages/#cat:Prelude"><span class="ascii">Hackage</span>の<span class="ascii">Prelude</span>カテゴリ</a>を参照するといいでしょう．</p>
<p>私の場合，<span class="ascii">classy-prelude</span>を使っていますが，それも生で使用しているわけではなく，パッケージごとに<span class="ascii">prelude</span>モジュールを作って使用しています．<span class="ascii">Prelude</span>は，最もよく使うものが提供されているモジュールですから，<span class="ascii">API</span>の変更の影響を最も強く受けます．それを外部パッケージに依存させると，パッケージ保守が結構大変です．もし，パッケージごとに<span class="ascii">prelude</span>モジュールを作っておけば，パッケージ側や<span class="ascii">GHC</span>のバージョン変更の影響などで<span class="ascii">API</span>が変更されても，そのモジュール内でフォールバックを設定することで他のモジュールに変更を持ち越す必要がなくなります．これを<code>NoImplicitPrelude</code>拡張と組み合わせ，</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="kw">module</span> <span class="dt">A</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="kw">import</span> <span class="dt">MyPrelude</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6"></a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="fu">...</span></a></code></pre></div>
<p>と書くことで，保守がかなりしやすくなります．</p>
<h2 id="便利な構文の導入"><span class="link-to-here-outer"><a href="#便利な構文の導入" title="便利な構文の導入"><span class="link-to-here">Link to<br />
here</span></a></span>便利な構文の導入</h2>
<h3 id="新たなリテラル表記を可能にする"><span class="link-to-here-outer"><a href="#新たなリテラル表記を可能にする" title="新たなリテラル表記を可能にする"><span class="link-to-here">Link to<br />
here</span></a></span>新たなリテラル表記を可能にする</h3>
<p>この節では，以下の<span class="ascii">3</span>つの拡張を紹介します．</p>
<ul>
<li><code>BinaryLiterals</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-BinaryLiterals">ユーザーガイド <span class="ascii">- BinaryLiterals</span>拡張</a></li>
<li><code>NagativeLiterals</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-NegativeLiterals">ユーザーガイド <span class="ascii">- NagativeLiterals</span>拡張</a></li>
<li><code>HexFloatLiterals</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#ghc-flag--XHexFloatLiterals">ユーザーガイド <span class="ascii">- HexFloatLiterals</span>拡張</a></li>
</ul>
<p><span class="ascii">Haskell</span>には幾つかのリテラルが存在します．例えば，<code>'c'</code>は文字<span class="ascii">c</span>を表す<span class="ascii">Char</span>型のリテラルです．<code>100</code>は整数<span class="ascii">100</span>を表す<code>Num a =&gt; a</code>型のリテラルで，<code>100.1</code>は浮動小数点数<span class="ascii">100.1</span>を表す<code>Fractional a =&gt; a</code>型のリテラルになります．<span class="ascii">Haskell</span>標準には他にも幾つかリテラルが存在しますが，特に数値は非常に多様な使われ方がなされるため，他の多くの言語はより強力なリテラル表現を持つことがあります．<span class="ascii">GHC</span>拡張ではこの背景を元に，リテラルに対する幾つかの拡張を提供しています．<code>BinaryLiterals</code>は<code>Num a =&gt; a</code>型のリテラルに対して，<code>HexFloatLiterals</code>は<code>Fractional a =&gt; a</code>型のリテラルに対して，<code>NegativeLiterals</code>はどちらに対してもの拡張を，それぞれ提供します．</p>
<p>数値型に対するリテラルは，既存のものでも数種類存在します．通常の数値表現<code>20</code>，オクテット<span class="ascii">(8</span>進数<span class="ascii">)</span>表現<code>0o24</code>，ヘックス<span class="ascii">(16</span>進数<span class="ascii">)</span>表現<code>0x14</code>の<span class="ascii">3</span>つです．<code>BinaryLiterals</code>拡張は，これに加え<code>0b</code>を接頭辞に付けることでバイナリ<span class="ascii">(2</span>進数<span class="ascii">)</span>表現<code>0b10100</code>を可能にする拡張です．</p>
<p>これらのオクテット表現やヘックス，バイナリ表現は浮動小数点数の表現はできません．しかし，浮動小数点数は実際には<span class="ascii">IEEE</span>の規格に則ったデータ表現になりますから，<span class="ascii">10</span>進数表現よりも<span class="ascii">16</span>進数表現の方が実態として分かりやすい場合があります．このため<code>HexFloatLiterals</code>拡張では，接頭に<code>0x</code>の付くヘックス表現でも浮動小数点数のリテラルを記述できるようにしています．この拡張によって，<code>0.25</code>は<code>0x0.4</code>と表記できるようになります．また，指数表記も<span class="ascii">10</span>進方式のものではなく，ビット方式のものになります．指数表記には<code>e</code>ではなく<code>p</code>を使い，何ビット移動させるか<span class="ascii">(</span>つまり，<span class="ascii">2</span>の何乗を掛けるか<span class="ascii">)</span>を書くようにします．例えば，<code>1.0</code>は<code>0x0.4p2</code>と表記できます．また，<code>0.125</code>は<code>0x0.4p-1</code>と表記できます．</p>
<p>さて，<span class="ascii">Haskell</span>には唯一の単項演算子<code>-</code>があります．この演算子を使用することで<code>negate 1</code>の代わりに<code>-1</code>という表記が可能になります．しかし，この演算子の結合度は非常に弱く，また二項演算子の<code>-</code>も存在することから<code>f -1</code>という表記は<code>(f) - (1)</code>というように解釈されてしまうなどの問題があり，非常に使い勝手が悪い演算子となっていました．また，<span class="ascii">Haskell</span>の仕様上，<code>-128</code>という表現は最終的に<code>negate (fromInteger 128)</code>という式に<a href="https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-280003.4">脱糖されます</a>が，例えば<code>Int8</code>などの，負数は<code>-128</code>まで扱えるが正数は<code>+127</code>までしか扱えないといったデータ型の場合に，この式は<code>fromInteger</code>で一度<code>+128</code>の値になってしまいオーバーフローを起こしてしまうという問題がありました．これを解決するため導入されたのが<code>NagativeLiterals</code>拡張です．この拡張を導入することで空白を挟まない<code>-1.0</code>などは<span class="ascii">1</span>つのリテラルと解釈されるようになります．この拡張を導入後は，次のようになります．</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> max <span class="fu">-</span><span class="dv">1</span> <span class="dv">2</span> <span class="fu">==</span> max (<span class="fu">-</span><span class="dv">1</span>) <span class="dv">2</span> <span class="co">-- before: max -1 2 == max - (1 2)</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="dt">True</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="fu">&gt;&gt;&gt;</span> <span class="kw">data</span> <span class="dt">SamplePZ</span> <span class="fu">=</span> <span class="dt">SamplePZ</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="fu">&gt;&gt;&gt;</span> <span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">SamplePZ</span> <span class="kw">where</span> { fromInteger i <span class="fu">|</span> i <span class="fu">&lt;=</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dt">SamplePZ</span> }</a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="fu">&gt;&gt;&gt;</span> <span class="fu">-</span><span class="dv">100</span><span class="ot"> ::</span> <span class="dt">SamplePZ</span> <span class="co">-- before: raise error</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6"><span class="dt">SamplePZ</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7"><span class="fu">&gt;&gt;&gt;</span> <span class="fu">-</span> <span class="dv">100</span><span class="ot"> ::</span> <span class="dt">SamplePZ</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8"><span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9"><span class="fu">&gt;&gt;&gt;</span> <span class="kw">instance</span> <span class="dt">Fractional</span> <span class="dt">SamplePZ</span> <span class="kw">where</span> { fromRational r <span class="fu">|</span> r <span class="fu">&lt;=</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dt">SamplePZ</span> }</a>
<a class="sourceLine" id="cb9-10" data-line-number="10"><span class="fu">&gt;&gt;&gt;</span> <span class="fu">-</span><span class="fl">100.10</span><span class="ot"> ::</span> <span class="dt">SamplePZ</span> <span class="co">-- before: raise error</span></a>
<a class="sourceLine" id="cb9-11" data-line-number="11"><span class="dt">SamplePZ</span></a>
<a class="sourceLine" id="cb9-12" data-line-number="12"><span class="fu">&gt;&gt;&gt;</span> <span class="fu">-</span> <span class="fl">100.10</span><span class="ot"> ::</span> <span class="dt">SamplePZ</span></a>
<a class="sourceLine" id="cb9-13" data-line-number="13"><span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> <span class="fu">...</span></a></code></pre></div>
<h3 id="空のデータ型に対するより強力なサポートを導入する"><span class="link-to-here-outer"><a href="#空のデータ型に対するより強力なサポートを導入する" title="空のデータ型に対するより強力なサポートを導入する"><span class="link-to-here">Link to<br />
here</span></a></span>空のデータ型に対するより強力なサポートを導入する</h3>
<p>この節では，以下の<span class="ascii">2</span>つの拡張を紹介します．</p>
<ul>
<li><code>EmptyCase</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-EmptyCase">ユーザーガイド <span class="ascii">- EmptyCase</span>拡張</a></li>
<li><code>EmptyDataDeriving</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#ghc-flag--XEmptyDataDeriving">ユーザーガイド <span class="ascii">- EmptyDataDeriving</span>拡張</a></li>
</ul>
<p><span class="ascii">Haskell</span>では，コンストラクタを一切持たない型を定義できます．これは空のデータ型と呼ばれ，次のように書けます．</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Empty</span></a></code></pre></div>
<p>このような型は<code>base</code>パッケージの<code>Data.Void</code>モジュールでも提供されており，有用な場合があります．しかし，<span class="ascii">Haskell</span>標準ではこのようなデータ型に対するサポートが薄く，使用する上で不便な場面があります．このサポートを強化する拡張が，<code>EmptyCase</code>拡張と<code>EmptyDataDeriving</code>拡張です．</p>
<p><code>EmptyCase</code>拡張は，空のパターンマッチを書けるようにする拡張です．<span class="ascii">Haskell</span>標準では，空のパターンマッチは書けません．つまり，<code>case x of {}</code>というような式が書けないということです．通常はデータ型は何らかのコンストラクタを持っていますから，このようなパターンマッチを書きたいと思う場面はないでしょう．しかし，空のデータ型においてこのようなパターンマッチを書きたいと思うことがあります．</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">f ::</span> <span class="dt">Empty</span> <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">f x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span> {}</a></code></pre></div>
<p>このような表記を可能にするのが<code>EmptyCase</code>拡張です．なお，このケース式は次のように書くのと同値になります．</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">f ::</span> <span class="dt">Empty</span> <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">f x <span class="fu">=</span> x <span class="ot">`seq`</span> error <span class="st">&quot;Non-exhaustive patterns in case&quot;</span></a></code></pre></div>
<p>もう<span class="ascii">1</span>つの<code>EmptyDataDeriving</code>拡張は，空のデータ型に対して<code>deriving</code>構文を使用できるようにする拡張です．空のデータ型は，通常のデータ型と違い<code>Eq</code>や<code>Show</code>などの型クラスインスタンスを<a href="https://www.haskell.org/onlinereport/haskell2010/haskellch11.html#x18-182014x6"><code>deriving</code>することができません</a>．つまり以下のようなことができません．</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Empty</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>しかし，これでは不便な場合があります．それを可能にするのが<code>EmptyDataDeriving</code>拡張です．この拡張では，<code>Eq</code><span class="ascii">/</span><code>Ord</code><span class="ascii">/</span><code>Show</code><span class="ascii">/</span><code>Read</code>の<span class="ascii">4</span>つが<code>deriving</code>可能になり，それぞれは次のようなインスタンスを生成します．</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Empty</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  _ <span class="fu">==</span> _ <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3"></a>
<a class="sourceLine" id="cb14-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Ord</span> <span class="dt">Empty</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">  compare _ _ <span class="fu">=</span> <span class="dt">EQ</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6"></a>
<a class="sourceLine" id="cb14-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">Read</span> <span class="dt">Empty</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-8" data-line-number="8">  readPrec <span class="fu">=</span> pfail</a>
<a class="sourceLine" id="cb14-9" data-line-number="9"></a>
<a class="sourceLine" id="cb14-10" data-line-number="10"><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Empty</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-11" data-line-number="11">  showsPrec _ x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span> {}</a></code></pre></div>
<h3 id="新たな基本構文を導入する"><span class="link-to-here-outer"><a href="#新たな基本構文を導入する" title="新たな基本構文を導入する"><span class="link-to-here">Link to<br />
here</span></a></span>新たな基本構文を導入する</h3>
<p>この節では，以下の<span class="ascii">3</span>つの拡張を紹介します．</p>
<ul>
<li><code>TupleSections</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-TupleSections">ユーザーガイド <span class="ascii">- TupleSections</span>拡張</a></li>
<li><code>MultiWayIf</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-MultiWayIf">ユーザーガイド <span class="ascii">- MultiWayIf</span>拡張</a></li>
<li><code>LambdaCase</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-LambdaCase">ユーザーガイド <span class="ascii">- LambdaCase</span>拡張</a></li>
</ul>
<p><span class="ascii">Haskell</span>では，タプルやラムダ抽象，セクション，<code>if</code>式や<code>case</code>式といった構文が導入されていますが，これらを組み合わせて多用する場合，幾つか冗長な表現が生まれる場合があります．その中でも頻出する表現に対して，新たな構文を提供する<span class="ascii">GHC</span>拡張があります．それが，<code>TupleSections</code>，<code>MultiWayIf</code>，<code>LambdaCase</code>の<span class="ascii">3</span>つの拡張です．</p>
<p><span class="ascii">Haskell</span>には，セクションと呼ばれる二項演算子の部分適用を表す構文があります．また，<span class="ascii">Haskell</span>ではタプルにも独自の構文が充てがわれています．このタプルを使用する際，セクションのように部分適用を簡潔に書きたい場合があります．例えば，<code>\x -&gt; (1, x)</code>という表現をもっと簡潔に書きたい場合があります．この場合は<code>(,) 1</code>というな表記が可能ですが，<span class="ascii">2</span>番目に部分適用したい場合や，<span class="ascii">3</span>つ組のタプルに部分適用したい場合などは非常に面倒です．このため，<code>TupleSections</code>拡張は<code>(1, )</code>という表記でタプルの部分適用を書ける構文を提供します．<span class="ascii">2</span>つ以上空きがある場合は，左から引数を受け取っていくようになります．例えば，<code>(True, , &quot;str&quot;, )</code>は<code>\x y -&gt; (True, x, &quot;str&quot;, y)</code>と同等です．</p>
<p><code>MultiWayIf</code>は名前の通り複数の条件をガード構文のように指定できる<code>if</code>式を提供する拡張です．つまり，以下のようなことがかけます．</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">f ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">f xs <span class="fu">=</span> sequence_ <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  x <span class="ot">&lt;-</span> xs</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">  pure <span class="fu">$</span> <span class="kw">if</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    <span class="fu">|</span> x <span class="fu">&lt;=</span> <span class="dv">0</span>          <span class="ot">-&gt;</span> fail <span class="st">&quot;non-positive number&quot;</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6">    <span class="fu">|</span> x <span class="ot">`mod`</span> <span class="dv">15</span> <span class="fu">==</span> <span class="dv">0</span> <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;FizzBuzz&quot;</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7">    <span class="fu">|</span> x <span class="ot">`mod`</span> <span class="dv">3</span>  <span class="fu">==</span> <span class="dv">0</span> <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;Fizz&quot;</span></a>
<a class="sourceLine" id="cb15-8" data-line-number="8">    <span class="fu">|</span> x <span class="ot">`mod`</span> <span class="dv">5</span>  <span class="fu">==</span> <span class="dv">0</span> <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;Buzz&quot;</span></a>
<a class="sourceLine" id="cb15-9" data-line-number="9">    <span class="fu">|</span> otherwise       <span class="ot">-&gt;</span> print x</a></code></pre></div>
<p>この<code>MultiWayIf</code>は次のように<code>case</code>式で書き換えることが可能です．</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">f ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">f xs <span class="fu">=</span> sequence_ <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  x <span class="ot">&lt;-</span> xs</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">  pure <span class="fu">$</span> <span class="kw">case</span> () <span class="kw">of</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5">    _ <span class="fu">|</span> x <span class="fu">&lt;=</span> <span class="dv">0</span>          <span class="ot">-&gt;</span> fail <span class="st">&quot;non-positive number&quot;</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">    _ <span class="fu">|</span> x <span class="ot">`mod`</span> <span class="dv">15</span> <span class="fu">==</span> <span class="dv">0</span> <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;FizzBuzz&quot;</span></a>
<a class="sourceLine" id="cb16-7" data-line-number="7">    _ <span class="fu">|</span> x <span class="ot">`mod`</span> <span class="dv">3</span>  <span class="fu">==</span> <span class="dv">0</span> <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;Fizz&quot;</span></a>
<a class="sourceLine" id="cb16-8" data-line-number="8">    _ <span class="fu">|</span> x <span class="ot">`mod`</span> <span class="dv">5</span>  <span class="fu">==</span> <span class="dv">0</span> <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;Buzz&quot;</span></a>
<a class="sourceLine" id="cb16-9" data-line-number="9">    _ <span class="fu">|</span> otherwise       <span class="ot">-&gt;</span> print x</a></code></pre></div>
<p><span class="ascii">3</span>つ目の<code>LambdaCase</code>拡張は，ラムダ抽象と<code>case</code>式を組み合わせた際に良く使う表現をより簡潔に書けるようにする拡張です．この拡張を使うと，<code>\x -&gt; case x of (a, b) -&gt; a + b</code>というようなラムダ抽象を，<code>\case (a, b) -&gt; a + b</code>と書けるようになります．もちろんレイアウトルールも<code>case-of</code>式と同じように作用するため，改行を含んだ式も書けます．</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="ot">f ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">f <span class="fu">=</span> negate <span class="fu">.</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3">  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  <span class="dt">Just</span> x  <span class="ot">-&gt;</span> x</a></code></pre></div>
<h3 id="正格化に対するサポートを導入する"><span class="link-to-here-outer"><a href="#正格化に対するサポートを導入する" title="正格化に対するサポートを導入する"><span class="link-to-here">Link to<br />
here</span></a></span>正格化に対するサポートを導入する</h3>
<p>この節では，以下の<span class="ascii">3</span>つの拡張を紹介します．</p>
<ul>
<li><code>BangPatterns</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-BangPatterns">ユーザーガイド <span class="ascii">- BangPatterns</span>拡張</a></li>
<li><code>StrictData</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-StrictData">ユーザーガイド <span class="ascii">- StrictData</span>拡張</a></li>
<li><code>Strict</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-Strict">ユーザーガイド <span class="ascii">- Strict</span>拡張</a></li>
</ul>
<p><span class="ascii">Haskell</span>はデフォルトの評価戦略として，グラフ簡約の遅延評価を採用しています．これはリストや再帰に関する表現を非常に豊かにする反面，パフォーマンスを悪化させたりデバッグを困難にさせる場面が多いなどの負の面もあります．このため<span class="ascii">Haskell</span>標準では，<code>seq</code>関数や正格フラグといった正格評価へのサポートも提供しています．しかし，このサポートは表現が冗長な場合が多く，使い勝手が悪い側面があります．この面を解決するための拡張が，<code>BangPatterns</code>，<code>StrictData</code>，<code>Strict</code>の<span class="ascii">3</span>つの拡張です．</p>
<p>再帰関数において，累積引数は多くの場合正格に計算した方が効率が良いですが，<span class="ascii">Haskell</span>標準では以下のように書く必要がありました．</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1">sum<span class="ot"> ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">sum xs y <span class="fu">=</span> y <span class="ot">`seq`</span> <span class="kw">case</span> xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  x<span class="fu">:</span>xs&#39; <span class="ot">-&gt;</span> sum xs&#39; (x <span class="fu">+</span> y)</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">  []    <span class="ot">-&gt;</span> y</a></code></pre></div>
<p>このような<code>seq</code>による評価をより簡潔に書けるよう，<code>BangPatterns</code>拡張というものが提供されています．これはパターンを拡張し，バンパターンというものを導入します．このバンパターンは，通常のパターンに<code>!</code>を付けることで書けます．例えば，上の例はバンパターンを使うと以下のように書けます．</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">sum<span class="ot"> ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2">sum xs <span class="fu">!</span>y <span class="fu">=</span> <span class="kw">case</span> xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  x<span class="fu">:</span>xs&#39; <span class="ot">-&gt;</span> sum xs&#39; (x <span class="fu">+</span> y)</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">  []    <span class="ot">-&gt;</span> y</a></code></pre></div>
<p>バンパターンはパターンの<span class="ascii">1</span>つですから，もちろん<code>let</code>式や<code>case</code>式でも<code>let !y = f x in y</code>や<code>case f x of !y -&gt; y</code>というように使えます．また，<code>case x of (!y, z) -&gt; y + z</code>というように部分パターンとしても有効です．バンパターンは<a href="https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-610003.17.3"><span class="ascii">Haskell</span>の<code>case</code>式の翻訳ルール</a>に次の規則を加えることで実現されます．</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">case</span> v <span class="kw">of</span> { <span class="fu">!</span>pat <span class="ot">-&gt;</span> e; _ <span class="ot">-&gt;</span> e&#39; }</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">≡ v <span class="ot">`seq`</span> <span class="kw">case</span> v <span class="kw">of</span> { pat <span class="ot">-&gt;</span> e; _ <span class="ot">-&gt;</span> e&#39; }</a></code></pre></div>
<p><span class="ascii">Haskell</span>標準では，データ型の宣言において，コンストラクタの引数に正格フラグというものを付けることが許容されています．このフラグをつけた引数は，正格に評価された後コンストラクタに渡されます．ただ，一般にデータ型の引数は正格な方が効率が良いため，データ型宣言時に正格フラグを付けるという慣習がありました．この慣習を打破するために導入されたのが，<code>StrictData</code>拡張です．<code>StrictData</code>拡張下のモジュールでは，データ型宣言時，コンストラクタの引数は全て正格フラグをつけているものとして扱われます．また，<code>~</code>というフラグが新たに導入され，このフラグをつけた引数の場合は<span class="ascii">Haskell</span>標準化のデフォルトの動作，つまり引数は正格に評価されず遅延されるようになります．<code>StrictData</code>下で宣言された</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">data</span> <span class="dt">T</span> <span class="fu">=</span> <span class="dt">Normal</span> <span class="dt">Int</span> <span class="fu">|</span> <span class="dt">Strict</span> <span class="fu">!</span><span class="dt">Int</span> <span class="fu">|</span> <span class="dt">Lazy</span> <span class="fu">~</span><span class="dt">Int</span></a></code></pre></div>
<p>というデータ型は，通常の<span class="ascii">Haskell</span>の以下のデータ型と同等になります．</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">data</span> <span class="dt">T</span> <span class="fu">=</span> <span class="dt">Normal</span> <span class="fu">!</span><span class="dt">Int</span> <span class="fu">|</span> <span class="dt">Strict</span> <span class="fu">!</span><span class="dt">Int</span> <span class="fu">|</span> <span class="dt">Lazy</span> <span class="dt">Int</span></a></code></pre></div>
<p><code>Strict</code>拡張は，<code>StrictData</code>拡張に加え，ほとんどのパターンを暗黙的にバンパターンにする拡張です．つまり，殆どの評価を正格にする拡張です．バンパターンに変わる箇所は，関数の引数，<code>let</code><span class="ascii">/</span><code>where</code>句の束縛変数，<code>case</code>式のパターンマッチなどです．これらのパターンには，最外の場所に<code>!</code>が暗黙的に付与されます．例えば，<code>Strict</code>拡張下で定義された</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="ot">f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">f x (z, y) <span class="fu">=</span> <span class="kw">let</span> zy <span class="fu">=</span> z <span class="fu">*</span> y <span class="kw">in</span> <span class="kw">case</span> x <span class="fu">-</span> z <span class="kw">of</span> z&#39; <span class="ot">-&gt;</span> z&#39; <span class="fu">^</span> z</a></code></pre></div>
<p>という関数は，<code>BangPatterns</code>拡張下の<span class="ascii">Haskell</span>の以下の関数と同等になります．</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="ot">f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2">f <span class="fu">!</span>x <span class="fu">!</span>(z, y) <span class="fu">=</span> <span class="kw">let</span> <span class="fu">!</span>zy <span class="fu">=</span> z <span class="fu">*</span> y <span class="kw">in</span> <span class="kw">case</span> x <span class="fu">-</span> z <span class="kw">of</span> <span class="fu">!</span>z&#39; <span class="ot">-&gt;</span> z&#39; <span class="fu">^</span> z</a></code></pre></div>
<p>注意して欲しいのは，このバンパターンは<code>seq</code>に置き換わるため，<span class="ascii">WHNF</span>までしか評価されないということです．つまり，<code>!(z, y)</code>というパターンは単なる<code>(z, y)</code>と完全に同じです．またトップレベルの束縛にバンパターンを付与することは許されておらず，遅延されるということにも注意が必要です．</p>
<h3 id="パターンマッチをより柔軟に扱えるようにする"><span class="link-to-here-outer"><a href="#パターンマッチをより柔軟に扱えるようにする" title="パターンマッチをより柔軟に扱えるようにする"><span class="link-to-here">Link to<br />
here</span></a></span>パターンマッチをより柔軟に扱えるようにする</h3>
<p>この節では，以下の<span class="ascii">2</span>つの拡張を紹介します．</p>
<ul>
<li><code>ViewPatterns</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-ViewPatterns">ユーザーガイド <span class="ascii">- ViewPatterns</span>拡張</a></li>
<li><code>PatternSynonyms</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-PatternSynonyms">ユーザーガイド <span class="ascii">- PatternSynonyms</span>拡張</a></li>
</ul>
<p><span class="ascii">GHC</span>拡張では，<span class="ascii">Haskell</span>標準のパターンをさらに強力なものにする拡張があります．<code>ViewPatterns</code>はビューパターンという新たなパターンを導入します．また，<code>PatternSynonyms</code>はパターンの別名を付けることができるようにする拡張です．</p>
<p><span class="ascii">Haskell</span>標準にあるパターンガードは，非常に強力ですが，表現が非常に冗長になる場合があります．これを短縮して書けるように，<code>ViewPatterns</code>拡張はビューパターンというものを導入します．ビューパターンは，<code>-&gt;</code>の左側に式を，右側にパターンを書くことで，左の式に対象を適用して結果が右側のパターンにマッチした時，マッチするようなパターンです．例えば，</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1">f ((<span class="ot">`mod`</span> <span class="dv">2</span>) <span class="ot">-&gt;</span> <span class="dv">0</span>) <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2">f x                <span class="fu">=</span> <span class="dt">Just</span> x</a></code></pre></div>
<p>というように使用でき，<code>f 0</code>は<code>Nothing</code>を，<code>f 3</code>は<code>Just 3</code>をそれぞれ返すようになります．この関数宣言は，以下のパターンガードを用いて書いた関数と一致します．</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1">f x <span class="fu">|</span> <span class="dv">0</span> <span class="ot">&lt;-</span> x <span class="ot">`mod`</span> <span class="dv">2</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb26-2" data-line-number="2">f x                  <span class="fu">=</span> <span class="dt">Just</span> x</a></code></pre></div>
<p>ビューパターンは<a href="https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-610003.17.3"><span class="ascii">Haskell</span>の<code>case</code>式の翻訳ルール</a>に次の規則を加えることで実現されます．</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">case</span> v <span class="kw">of</span> { (e <span class="ot">-&gt;</span> p) <span class="ot">-&gt;</span> e1; _ <span class="ot">-&gt;</span> e2 }</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">≡ <span class="kw">case</span> (e v) <span class="kw">of</span> { p <span class="ot">-&gt;</span> e1; _ <span class="ot">-&gt;</span> e2 }</a></code></pre></div>
<p><code>PatternSynonyms</code>拡張は，非常に強力で大きな拡張です<a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a>．<code>PatternSynonyms</code>拡張は名前の通り，パターンに別名を与えるパターンシノニム機能を提供します．パターンシノニムは通常の関数と同じように，次のように定義できます．</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1">pattern <span class="dt">Nil</span><span class="ot"> ::</span> [a]</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">pattern <span class="dt">Nil</span> <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb28-3" data-line-number="3"></a>
<a class="sourceLine" id="cb28-4" data-line-number="4">pattern <span class="dt">Cons</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb28-5" data-line-number="5">pattern <span class="dt">Cons</span> x xs <span class="fu">=</span> x <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb28-6" data-line-number="6"></a>
<a class="sourceLine" id="cb28-7" data-line-number="7"><span class="ot">{-# COMPLETE Nil, Cons #-}</span></a></code></pre></div>
<p>このように定義したパターンは，以下のように使用できます．</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="ot">len ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb29-2" data-line-number="2">len (<span class="dt">Cons</span> _ xs) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> len xs</a>
<a class="sourceLine" id="cb29-3" data-line-number="3">len <span class="dt">Nil</span>         <span class="fu">=</span> <span class="dv">0</span></a></code></pre></div>
<p>パターンシノニムは非常に便利な機能ですが，一方で注意する事項も幾つかあります．</p>
<p>まず，パターンシノニムの定義は関数定義と非常に似ていますが，パターンの別名であることに注意してください．パターンシノニムの定義において変数が出現する場合，関数の引数のように錯覚してしまいがちですが，この変数にはパターンにマッチした時そのマッチした部分が当てがわれます．つまり，右の式でマッチしたものが左の変数に束縛されるため，左の変数に束縛された後右の式を実行する関数と，流れが逆になるということです．このため，パターンシノニムの引数の変数は必ず右に出現する必要があります．また，パターンシノニムの右側には変数を含むパターンしかかけません．そのため，式を書きたい場合，<code>ViewPatterns</code>拡張などを用いなければなりません．さらにパターンシノニムは，デフォルトではパターンの網羅性検査が非常に難しいため，網羅性検査を行わないようになっています．ただし，<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#complete-pragma"><code>COMPLETE</code>プラグマ</a>を用いてパターンシノニムの網羅条件を与えることで，その範囲で網羅性検査を行うようになります．</p>
<p>パターンシノニムはパターンの種類に応じて<span class="ascii">3</span>種類の書き方が存在します．上の単純なパターンシノニムは，双方向<span class="ascii">(bidirectional)</span>パターンシノニムと呼ばれ，暗黙的にパターンの名前と等しい関数が作られます．この関数を用いることで，<code>[0, 1, 2]</code>の代わりに<code>Cons 0 (Cons 1 (Cons 2 Nil))</code>といった式も書くことができるようになります．ただし，このような関数が単純には作れないパターンも存在します．例えば，<code>(x, _)</code>というパターンに，<code>First x</code>というパターンシノニムを与えたい場合，この<code>First</code>に対する関数は<code>_</code>の部分に入れるべき値が分からないため，作りようがありません．このような関数が単純に作れないパターンシノニムは単方向<span class="ascii">(unidirectional)</span>パターンシノニムと呼ばれ，双方向パターンシノニムが<code>=</code>を使って定義されるのに対し，次のように<code>&lt;-</code>を使って書きます．</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1">pattern <span class="dt">First</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">pattern <span class="dt">First</span> x <span class="ot">&lt;-</span> (x, _)</a></code></pre></div>
<p>このパターンシノニムは<code>First</code>という関数は作らず，単純にパターンの別名だけを提供します．ただし，<code>First</code>関数の定義を次のように与えることが可能になっています．</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1">pattern <span class="dt">First</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb31-2" data-line-number="2">pattern <span class="dt">First</span> x <span class="ot">&lt;-</span> (x, _)</a>
<a class="sourceLine" id="cb31-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb31-4" data-line-number="4">    <span class="dt">First</span> x <span class="fu">|</span> x <span class="fu">&lt;</span> <span class="dv">0</span> <span class="fu">=</span> (x, <span class="dt">False</span>)</a>
<a class="sourceLine" id="cb31-5" data-line-number="5">    <span class="dt">First</span> x         <span class="fu">=</span> (x, <span class="dt">True</span>)</a></code></pre></div>
<p>また，パターンシノニムはパターンの評価順序にも注意する必要があります．例えば，次の例をみてください．</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Pair</span> a b <span class="fu">=</span> <span class="dt">Pair</span> a b</a>
<a class="sourceLine" id="cb32-2" data-line-number="2"></a>
<a class="sourceLine" id="cb32-3" data-line-number="3"><span class="kw">type</span> <span class="dt">Pair3</span> a b c <span class="fu">=</span> <span class="dt">Pair</span> a (<span class="dt">Pair</span> b c)</a>
<a class="sourceLine" id="cb32-4" data-line-number="4"></a>
<a class="sourceLine" id="cb32-5" data-line-number="5">pattern <span class="dt">Pair3</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> <span class="dt">Pair3</span> a b c</a>
<a class="sourceLine" id="cb32-6" data-line-number="6">pattern <span class="dt">Pair3</span> x y z <span class="fu">=</span> <span class="dt">Pair</span> x (<span class="dt">Pair</span> y z)</a>
<a class="sourceLine" id="cb32-7" data-line-number="7"></a>
<a class="sourceLine" id="cb32-8" data-line-number="8"><span class="ot">f ::</span> <span class="dt">Pair3</span> <span class="dt">Bool</span> <span class="dt">Bool</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb32-9" data-line-number="9">f (<span class="dt">Pair3</span> <span class="dt">True</span> <span class="dt">True</span> <span class="dt">True</span>) <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb32-10" data-line-number="10">f _                      <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb32-11" data-line-number="11"></a>
<a class="sourceLine" id="cb32-12" data-line-number="12"><span class="ot">f&#39; ::</span> <span class="dt">Pair3</span> <span class="dt">Bool</span> <span class="dt">Bool</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb32-13" data-line-number="13">f&#39; (<span class="dt">Pair</span> <span class="dt">True</span> (<span class="dt">Pair</span> <span class="dt">True</span> <span class="dt">True</span>)) <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb32-14" data-line-number="14">f&#39; _                            <span class="fu">=</span> <span class="dt">False</span></a></code></pre></div>
<p>この<code>f</code>と<code>f'</code>は評価順が異なり，<code>f (Pair False undefined)</code>が例外を投げるのに対し，<code>f' (Pair False undefined)</code>は<code>False</code>を返します．これは，パターンシノニムを使ったパターンマッチでは，自身のパターンを先に調べ，次に引数のパターンマッチを行うからです．つまり，<code>f</code>は以下と同等になります．</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="ot">f ::</span> <span class="dt">Pair3</span> <span class="dt">Bool</span> <span class="dt">Bool</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb33-2" data-line-number="2">f (<span class="dt">Pair</span> x (<span class="dt">Pair</span> y z)) <span class="fu">|</span> <span class="dt">True</span> <span class="ot">&lt;-</span> x, <span class="dt">True</span> <span class="ot">&lt;-</span> y, <span class="dt">True</span> <span class="ot">&lt;-</span> z <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb33-3" data-line-number="3">f _                                                     <span class="fu">=</span> <span class="dt">False</span></a></code></pre></div>
<p>パターンシノニムは，モジュールエクスポートを書く際にも注意が必要で，<code>module A (pattern Cons, pattern Nil) where ...</code>というように接頭に<code>pattern</code>をつける必要があります．</p>
<h3 id="レコードに対するサポートを強化する"><span class="link-to-here-outer"><a href="#レコードに対するサポートを強化する" title="レコードに対するサポートを強化する"><span class="link-to-here">Link to<br />
here</span></a></span>レコードに対するサポートを強化する</h3>
<p>この節では，以下の<span class="ascii">4</span>つの拡張を紹介します．</p>
<ul>
<li><code>DuplicateRecordFields</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-DuplicateRecordFields">ユーザーガイド <span class="ascii">- DuplicateRecordFields</span>拡張</a></li>
<li><code>OverloadedLabels</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-OverloadedLabels">ユーザーガイド <span class="ascii">- OverloadedLabels</span>拡張</a></li>
<li><code>NamedFieldPuns</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-NamedFieldPuns">ユーザーガイド <span class="ascii">- NamedFieldPuns</span>拡張</a></li>
<li><code>RecordWildCards</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-RecordWildCards">ユーザーガイド <span class="ascii">- RecordWildCards</span>拡張</a></li>
</ul>
<p><span class="ascii">Haskell</span>のレコード構文は，便利な反面幾つか機能が劣る場面もあります．このため，<span class="ascii">GHC</span>では，レコードをより扱いやすくするための拡張を幾つか提供しています．それが，<code>DuplicateRecordFields</code>，<code>OverloadedLabels</code>，<code>NamedFieldPuns</code>，<code>RecordWildCards</code>の<span class="ascii">4</span>つの拡張です<a href="#fn10" class="footnote-ref" id="fnref10"><sup>10</sup></a>．</p>
<p><span class="ascii">Haskell</span>標準では，同じモジュール内で同じフィールド名を持つ複数のレコード構文を使用したデータ型の定義を行うことができません．これはどのデータ型のフィールドかが曖昧であるようなプログラムを書けてしまうからですが，そういう状況に遭遇するとこの制約は非常に不便です．これを解決するのが，<code>DuplicateRecordFields</code>拡張です．<code>DuplicateRecordFields</code>拡張は，曖昧になるような式を書けなくする代わりに，同一モジュールの複数のデータ型が同じフィールド名を持つことを許容する拡張です．つまり，以下のようなことが可能になります．</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="kw">data</span> <span class="dt">A</span> <span class="fu">=</span> <span class="dt">A</span> {<span class="ot"> d ::</span> <span class="dt">Int</span> }</a>
<a class="sourceLine" id="cb34-2" data-line-number="2"><span class="kw">data</span> <span class="dt">B</span> <span class="fu">=</span> <span class="dt">B</span> {<span class="ot"> d ::</span> <span class="dt">Bool</span> }</a></code></pre></div>
<p>ただし，この拡張下では，曖昧なフィールドを用いたレコードのアップデート構文やフィールドの選択関数の使用の際は型を明記する必要があったり，モジュールのエクスポートリストで選択関数をエクスポートすることが出来なくなったりします．</p>
<p><code>OverloadedLabels</code>拡張は，<code>#foo</code>というような<code>#</code>から始まる新たな構文を導入します．<code>#foo</code>は<code>GHC.OverloadedLabels</code>モジュールの<code>fromLabel</code>メソッドにおいて<code>IsLabel &quot;foo&quot; a =&gt; a</code>というような型を持つ場合と同等になります．これを用いることで，同じフィールドを持つデータ型に対する選択関数を次のように書けます<a href="#fn11" class="footnote-ref" id="fnref11"><sup>11</sup></a>．</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="ot">{-# LANGUAGE OverloadedLabels       #-}</span> <span class="co">-- the main extension</span></a>
<a class="sourceLine" id="cb35-2" data-line-number="2"><span class="ot">{-# LANGUAGE DataKinds              #-}</span> <span class="co">-- for Symbol kind</span></a>
<a class="sourceLine" id="cb35-3" data-line-number="3"><span class="ot">{-# LANGUAGE KindSignatures         #-}</span> <span class="co">-- for HasField&#39;s `l` parameter</span></a>
<a class="sourceLine" id="cb35-4" data-line-number="4"><span class="ot">{-# LANGUAGE MultiParamTypeClasses  #-}</span> <span class="co">-- for HasField and IsLabel classes</span></a>
<a class="sourceLine" id="cb35-5" data-line-number="5"><span class="ot">{-# LANGUAGE FunctionalDependencies #-}</span> <span class="co">-- for HasField class</span></a>
<a class="sourceLine" id="cb35-6" data-line-number="6"><span class="ot">{-# LANGUAGE FlexibleInstances      #-}</span> <span class="co">-- for HasField instances</span></a>
<a class="sourceLine" id="cb35-7" data-line-number="7"><span class="ot">{-# LANGUAGE ScopedTypeVariables    #-}</span> <span class="co">-- for the IsLabel instance</span></a>
<a class="sourceLine" id="cb35-8" data-line-number="8"><span class="ot">{-# LANGUAGE DuplicateRecordFields  #-}</span> <span class="co">-- for A and B data types</span></a>
<a class="sourceLine" id="cb35-9" data-line-number="9"></a>
<a class="sourceLine" id="cb35-10" data-line-number="10"><span class="kw">import</span> <span class="dt">GHC.OverloadedLabels</span> (<span class="dt">IsLabel</span>(..))</a>
<a class="sourceLine" id="cb35-11" data-line-number="11"><span class="kw">import</span> <span class="dt">GHC.TypeLits</span> (<span class="dt">Symbol</span>)</a>
<a class="sourceLine" id="cb35-12" data-line-number="12"><span class="kw">import</span> <span class="dt">Data.Proxy</span> (<span class="dt">Proxy</span>(..))</a>
<a class="sourceLine" id="cb35-13" data-line-number="13"></a>
<a class="sourceLine" id="cb35-14" data-line-number="14"><span class="kw">data</span> <span class="dt">A</span> <span class="fu">=</span> <span class="dt">A</span> {<span class="ot"> d ::</span> <span class="dt">Int</span> }</a>
<a class="sourceLine" id="cb35-15" data-line-number="15"><span class="kw">data</span> <span class="dt">B</span> <span class="fu">=</span> <span class="dt">B</span> {<span class="ot"> d ::</span> <span class="dt">Bool</span> }</a>
<a class="sourceLine" id="cb35-16" data-line-number="16"></a>
<a class="sourceLine" id="cb35-17" data-line-number="17"><span class="kw">class</span> <span class="dt">HasField</span> a (<span class="ot">l ::</span> <span class="dt">Symbol</span>) b <span class="fu">|</span> a l <span class="ot">-&gt;</span> b <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-18" data-line-number="18"><span class="ot">  selectField ::</span> <span class="dt">Proxy</span> l <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb35-19" data-line-number="19"></a>
<a class="sourceLine" id="cb35-20" data-line-number="20"><span class="kw">instance</span> <span class="dt">HasField</span> <span class="dt">A</span> <span class="st">&quot;d&quot;</span> <span class="dt">Int</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-21" data-line-number="21">  selectField _ (<span class="dt">A</span> x) <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb35-22" data-line-number="22"></a>
<a class="sourceLine" id="cb35-23" data-line-number="23"><span class="kw">instance</span> <span class="dt">HasField</span> <span class="dt">B</span> <span class="st">&quot;d&quot;</span> <span class="dt">Bool</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-24" data-line-number="24">  selectField _ (<span class="dt">B</span> x) <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb35-25" data-line-number="25"></a>
<a class="sourceLine" id="cb35-26" data-line-number="26"><span class="kw">instance</span> <span class="dt">HasField</span> a l b <span class="ot">=&gt;</span> <span class="dt">IsLabel</span> l (a <span class="ot">-&gt;</span> b) <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-27" data-line-number="27">  fromLabel <span class="fu">=</span> selectField (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> l)</a></code></pre></div>
<p>これを使うことで，<code>#d A { d = 0 }</code>は<code>0</code>を，<code>#d B { d = True }</code>は<code>True</code>を返してくるようになります．また，<code>#d</code>には型を明記しなくても型推論が働くようになります．</p>
<p>さて他にレコードのパターンマッチやコンストラクトを非常に便利にしてくれる拡張として，<code>NamedFieldPuns</code>拡張と<code>RecordWildCards</code>拡張があります．レコードのパターンマッチは多くの場合冗長になりがちで，次のようなボイラープレートを書きがちです．</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="kw">data</span> <span class="dt">A</span> <span class="fu">=</span> <span class="dt">A</span> {<span class="ot"> x ::</span> <span class="dt">Int</span>,<span class="ot"> y ::</span> <span class="dt">Bool</span> }</a>
<a class="sourceLine" id="cb36-2" data-line-number="2"></a>
<a class="sourceLine" id="cb36-3" data-line-number="3"><span class="ot">f ::</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb36-4" data-line-number="4">f <span class="dt">A</span>{ x <span class="fu">=</span> x } <span class="fu">=</span> x <span class="fu">+</span> <span class="dv">1</span></a></code></pre></div>
<p><code>NamedFieldPuns</code>拡張は，同等のことを次のように書けるようにする拡張です．</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="ot">f ::</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb37-2" data-line-number="2">f <span class="dt">A</span>{ x } <span class="fu">=</span> x <span class="fu">+</span> <span class="dv">1</span></a></code></pre></div>
<p>また，このパターンは旧来の書き方と合わせて書くこともできます．</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="ot">g ::</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb38-2" data-line-number="2">g <span class="dt">A</span>{ x, y <span class="fu">=</span> <span class="dt">False</span> } <span class="fu">=</span> <span class="fu">-</span> x</a>
<a class="sourceLine" id="cb38-3" data-line-number="3">g <span class="dt">A</span>{ x }            <span class="fu">=</span> x</a></code></pre></div>
<p>さらにこの拡張は，コンストラクトの際も役に立ちます．<code>let x = 1 in A { x, y = True }</code>と書くとこの式は，<code>A { x = 1, y = True }</code>と書くのと同等になります．</p>
<p><code>NamedFieldPuns</code>拡張ではフィールド名を明記する必要がありましたが，<code>RecordWildCards</code>拡張はさらにフィールド名を明記する必要がなくなります．以下のように<code>{..}</code>と書くことで，全てのフィールドを展開してくれるようになります．</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="ot">f ::</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb39-2" data-line-number="2">f <span class="dt">A</span>{<span class="fu">..</span>} <span class="fu">=</span> x <span class="fu">+</span> <span class="dv">1</span></a></code></pre></div>
<p>また，部分的に明記することも可能で，その場合以下のように書きます．</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" data-line-number="1"><span class="ot">g ::</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb40-2" data-line-number="2">g <span class="dt">A</span>{ y <span class="fu">=</span> <span class="dt">False</span>, <span class="fu">..</span>} <span class="fu">=</span> <span class="fu">-</span>x</a>
<a class="sourceLine" id="cb40-3" data-line-number="3">g <span class="dt">A</span>{<span class="fu">..</span>}             <span class="fu">=</span> x</a></code></pre></div>
<p>コンストラクトの際も，この拡張は有効です．<code>let x = 1 in A { y = True, ..}</code>と書いた場合，<code>A { x = 1, y = True }</code>と書くのと同等になります．</p>
<h3 id="型演算子を導入する"><span class="link-to-here-outer"><a href="#型演算子を導入する" title="型演算子を導入する"><span class="link-to-here">Link to<br />
here</span></a></span>型演算子を導入する</h3>
<p>この節では，以下の拡張を紹介します．</p>
<ul>
<li><code>TypeOperators</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-TypeOperators">ユーザーガイド <span class="ascii">- TypeOperators</span>拡張</a></li>
</ul>
<p><span class="ascii">Haskell</span>ではユーザー定義の関数やデータ型のコンストラクタにおいて，演算子表記のものも定義できるようになっています．例えば，以下のようにです．</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Pair</span> a b <span class="fu">=</span> a <span class="fu">:*:</span> b</a>
<a class="sourceLine" id="cb41-2" data-line-number="2"><span class="kw">infixl</span> <span class="dv">7</span> <span class="fu">:*:</span></a>
<a class="sourceLine" id="cb41-3" data-line-number="3"></a>
<a class="sourceLine" id="cb41-4" data-line-number="4"><span class="ot">(&amp;) ::</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb41-5" data-line-number="5">x <span class="fu">&amp;</span> f <span class="fu">=</span> f x</a>
<a class="sourceLine" id="cb41-6" data-line-number="6"><span class="kw">infixl</span> <span class="dv">1</span> <span class="fu">&amp;</span></a></code></pre></div>
<p>しかし<span class="ascii">Haskell</span>標準では，型を定義する場合そのようなことはできません．これを可能にするのが，<code>TypeOperators</code>拡張です．この拡張の有効下では，</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="kw">type</span> a <span class="fu">+</span> b <span class="fu">=</span> <span class="dt">Either</span> a b</a>
<a class="sourceLine" id="cb42-2" data-line-number="2"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">+</span></a></code></pre></div>
<p>ということが可能になります．ただし，このように定義した型演算子は，同じ名前の値としての演算子があった場合区別ができません．このため，モジュールのエクスポートリストを書く際，型演算子か値レベルの演算子かの区別が付かなくなった場合，値レベルの方が優先されます．この時，型演算子を明示したい場合，<code>type</code>を付けます<a href="#fn12" class="footnote-ref" id="fnref12"><sup>12</sup></a>．</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" data-line-number="1"><span class="ot">{-# LANGUAGE TypeOperators #-}</span></a>
<a class="sourceLine" id="cb43-2" data-line-number="2"></a>
<a class="sourceLine" id="cb43-3" data-line-number="3"><span class="kw">module</span> <span class="dt">A</span></a>
<a class="sourceLine" id="cb43-4" data-line-number="4">  ( <span class="kw">type</span> (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb43-5" data-line-number="5">  ) <span class="kw">where</span></a>
<a class="sourceLine" id="cb43-6" data-line-number="6"></a>
<a class="sourceLine" id="cb43-7" data-line-number="7"><span class="kw">type</span> a <span class="fu">+</span> b <span class="fu">=</span> <span class="dt">Either</span> a b</a></code></pre></div>
<h3 id="型クラスを拡張する"><span class="link-to-here-outer"><a href="#型クラスを拡張する" title="型クラスを拡張する"><span class="link-to-here">Link to<br />
here</span></a></span>型クラスを拡張する</h3>
<p>この節では，以下の<span class="ascii">4</span>つの拡張を紹介します．</p>
<ul>
<li><code>MultiParamTypeClasses</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-MultiParamTypeClasses">ユーザーガイド <span class="ascii">- MultiParamTypeClasses</span>拡張</a></li>
<li><code>FlexibleContexts</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-FlexibleContexts">ユーザーガイド <span class="ascii">- FlexibleContexts</span>拡張</a></li>
<li><code>FlexibleInstances</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-FlexibleInstances">ユーザーガイド <span class="ascii">- FlexibleInstances</span>拡張</a></li>
<li><code>InstanceSigs</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-InstanceSigs">ユーザーガイド <span class="ascii">- InstanceSigs</span>拡張</a></li>
</ul>
<p><span class="ascii">Haskell</span>の型クラスは非常に強力な機構です．しかしながら，<span class="ascii">Haskell</span>標準の型クラスの構文は非常に制約がきつく，これらを緩和したいと思うことがよくあります．このため，<span class="ascii">GHC</span>では制約を緩和する拡張をいくつか提供しています．それが，<code>MultiParamTypeClasses</code>，<code>FlexibleContexts</code>，<code>FlexibleInstances</code>，<code>InstanceSigs</code>の<span class="ascii">4</span>つの拡張です．</p>
<p><span class="ascii">Haskell</span>標準では，クラスは<span class="ascii">1</span>つの変数しか持てません．なので，次のような型クラスは作れません．</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" data-line-number="1"><span class="kw">class</span> <span class="dt">C</span> a b</a></code></pre></div>
<p>これは非常に不便な制約なため，複数のパラメータを使うような型クラスを許容する拡張が<code>MultiParamTypeClasses</code>拡張です．この拡張により，上のコードが許容されるようになる他，以下のように変数が全くない型クラスも宣言することができるようになります．</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Nullary</span></a></code></pre></div>
<p>また，<span class="ascii">Haskell</span>標準では，メソッドにおいてクラスの型変数に型制約をかけるということも許容されていませんが，<code>MultiParamTypeClasses</code>拡張ではこれも可能にします<a href="#fn13" class="footnote-ref" id="fnref13"><sup>13</sup></a>．これによって以下のようなクラス定義も書けるようになります．</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Setable</span> s a <span class="kw">where</span></a>
<a class="sourceLine" id="cb46-2" data-line-number="2"><span class="ot">  elem ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> s a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a></code></pre></div>
<p><span class="ascii">Haskell</span>標準では，型制約の解決を安全に，しかも単純にするために，<a href="https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-660004.1.3">型注釈における制約の書き方</a>や<a href="https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-760004.3.1">クラス定義，インスタンス定義の際の制約の書き方</a>を大きく制限しています．しかし，より複雑な型制約を書きたい時が往々にしてあります．そこで，この制限を緩め，クラス階層が非循環である場合には許容するようにする拡張が，<code>FlexibleContexts</code>拡張です．この拡張下では，</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb47-1" data-line-number="1"><span class="co">-- valid</span></a>
<a class="sourceLine" id="cb47-2" data-line-number="2"><span class="kw">class</span> (<span class="dt">Monad</span> m, <span class="dt">Monad</span> (t m)) <span class="ot">=&gt;</span> <span class="dt">Transform</span> t m <span class="kw">where</span></a>
<a class="sourceLine" id="cb47-3" data-line-number="3"><span class="ot">  lift ::</span> m a <span class="ot">-&gt;</span> (t m) a</a>
<a class="sourceLine" id="cb47-4" data-line-number="4"></a>
<a class="sourceLine" id="cb47-5" data-line-number="5"><span class="co">-- valid</span></a>
<a class="sourceLine" id="cb47-6" data-line-number="6"><span class="ot">f ::</span> <span class="dt">Functor</span> <span class="dt">Maybe</span> <span class="ot">=&gt;</span> ()</a>
<a class="sourceLine" id="cb47-7" data-line-number="7">f <span class="fu">=</span> ()</a>
<a class="sourceLine" id="cb47-8" data-line-number="8"></a>
<a class="sourceLine" id="cb47-9" data-line-number="9"><span class="co">-- invalid</span></a>
<a class="sourceLine" id="cb47-10" data-line-number="10"><span class="kw">class</span> <span class="dt">A</span> a <span class="ot">=&gt;</span> <span class="dt">B</span> a</a>
<a class="sourceLine" id="cb47-11" data-line-number="11"><span class="kw">class</span> <span class="dt">B</span> a <span class="ot">=&gt;</span> <span class="dt">A</span> a</a></code></pre></div>
<p>となります．</p>
<p><code>FlexibleInstances</code>拡張も<code>FlexibleContexts</code>拡張と同じく，<span class="ascii">Haskell</span>標準での<a href="https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-770004.3.2">型クラスインスタンスの書き方</a>の制限を，<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#instance-termination">停止制限</a>を守る場合に許容するというように緩和する拡張です．停止制限は簡単に言ってしまえば，インスタンス宣言において，型制約がインスタンスより小さく<a href="#fn14" class="footnote-ref" id="fnref14"><sup>14</sup></a>，型関数を使っていないというものです<a href="#fn15" class="footnote-ref" id="fnref15"><sup>15</sup></a>．この拡張下では，</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb48-1" data-line-number="1"><span class="co">-- valid</span></a>
<a class="sourceLine" id="cb48-2" data-line-number="2"><span class="kw">instance</span> <span class="dt">C1</span> (<span class="dt">Maybe</span> [a])</a>
<a class="sourceLine" id="cb48-3" data-line-number="3"></a>
<a class="sourceLine" id="cb48-4" data-line-number="4"><span class="co">-- valid</span></a>
<a class="sourceLine" id="cb48-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">C2</span> a a <span class="ot">=&gt;</span> <span class="dt">C2</span> [a] [a]</a>
<a class="sourceLine" id="cb48-6" data-line-number="6"></a>
<a class="sourceLine" id="cb48-7" data-line-number="7"><span class="co">-- valid</span></a>
<a class="sourceLine" id="cb48-8" data-line-number="8"><span class="kw">instance</span> (<span class="dt">Eq</span> a, <span class="dt">Show</span> b) <span class="ot">=&gt;</span> <span class="dt">C3</span> a b</a>
<a class="sourceLine" id="cb48-9" data-line-number="9"></a>
<a class="sourceLine" id="cb48-10" data-line-number="10"><span class="co">-- valid</span></a>
<a class="sourceLine" id="cb48-11" data-line-number="11"><span class="kw">instance</span> (<span class="dt">Show</span> a, <span class="dt">Show</span> (s a)) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">S</span> s a)</a>
<a class="sourceLine" id="cb48-12" data-line-number="12"></a>
<a class="sourceLine" id="cb48-13" data-line-number="13"><span class="co">-- invalid</span></a>
<a class="sourceLine" id="cb48-14" data-line-number="14"><span class="kw">instance</span> <span class="dt">C4</span> a <span class="ot">=&gt;</span> <span class="dt">C4</span> a</a>
<a class="sourceLine" id="cb48-15" data-line-number="15"></a>
<a class="sourceLine" id="cb48-16" data-line-number="16"><span class="co">-- invalid</span></a>
<a class="sourceLine" id="cb48-17" data-line-number="17"><span class="kw">instance</span> <span class="dt">C2</span> a a <span class="ot">=&gt;</span> <span class="dt">C1</span> [a]</a>
<a class="sourceLine" id="cb48-18" data-line-number="18"></a>
<a class="sourceLine" id="cb48-19" data-line-number="19"><span class="co">-- invalid</span></a>
<a class="sourceLine" id="cb48-20" data-line-number="20"><span class="kw">instance</span> <span class="dt">Functor</span> [] <span class="ot">=&gt;</span> <span class="dt">C1</span> a</a></code></pre></div>
<p>となります．また，この拡張下では，型シノニムをインスタンスにすることもできます<a href="#fn16" class="footnote-ref" id="fnref16"><sup>16</sup></a>．</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb49-1" data-line-number="1"><span class="kw">type</span> <span class="dt">List</span> a <span class="fu">=</span> [a]</a>
<a class="sourceLine" id="cb49-2" data-line-number="2"></a>
<a class="sourceLine" id="cb49-3" data-line-number="3"><span class="co">-- Instead of `instance C [a]`</span></a>
<a class="sourceLine" id="cb49-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">C</span> (<span class="dt">List</span> a)</a></code></pre></div>
<p>ただし，型シノニムを使う場合そのシノニムの引数は全て適用しなければならないことに注意が必要です．</p>
<p><span class="ascii">Haskell</span>標準では，型クラスインスタンスの定義時，そのメソッドの型注釈は書けないようになっています．しかし，複雑な型クラスインスタンスを書く際，メソッドの型注釈を書きたい場合があります<a href="#fn17" class="footnote-ref" id="fnref17"><sup>17</sup></a>．これを可能にするのが<code>InstanceSigs</code>拡張です．<code>InstanceSigs</code>拡張の元では，以下のようなインスタンス宣言が書けます．</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb50-1" data-line-number="1"><span class="kw">data</span> <span class="dt">A</span> <span class="fu">=</span> <span class="dt">A</span></a>
<a class="sourceLine" id="cb50-2" data-line-number="2"></a>
<a class="sourceLine" id="cb50-3" data-line-number="3"><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">A</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb50-4" data-line-number="4"><span class="ot">  (==) ::</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb50-5" data-line-number="5">  <span class="dt">A</span> <span class="fu">==</span> <span class="dt">A</span> <span class="fu">=</span> <span class="dt">True</span></a></code></pre></div>
<h3 id="型ワイルドカードをより柔軟に扱う"><span class="link-to-here-outer"><a href="#型ワイルドカードをより柔軟に扱う" title="型ワイルドカードをより柔軟に扱う"><span class="link-to-here">Link to<br />
here</span></a></span>型ワイルドカードをより柔軟に扱う</h3>
<p>この節では，以下の拡張を紹介します．</p>
<ul>
<li><code>NamedWildCards</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-NamedWildCards">ユーザーガイド <span class="ascii">- NamedWildCards</span>拡張</a></li>
</ul>
<p><span class="ascii">GHC</span>には型ワイルドカードという機能があります．この機能は，<code>_</code>と型シグネチャ上で書いておくと，そこの部分の型を推論してエラーメッセージとして表示してくれる機能です．この機能は，以下のように部分的に記述したり複数指定したりすることも可能です．</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb51-1" data-line-number="1"><span class="co">-- Inferred type: (a, b) -&gt; (a, Maybe a1)</span></a>
<a class="sourceLine" id="cb51-2" data-line-number="2"><span class="ot">ignoreSecond ::</span> _ <span class="ot">-&gt;</span> _</a>
<a class="sourceLine" id="cb51-3" data-line-number="3">ignoreSecond (x, _) <span class="fu">=</span> (x, <span class="dt">Nothing</span>)</a></code></pre></div>
<p>これを活用すれば，複雑な型をある程度ヒントを与えた状態で推論してもらい，型を追記するプログラミングスタイルや，<span class="ascii">GHC</span>が実際に型をどう推論するかを見るための補助に応用できます．しかし，例えば<code>ignoreSecond</code>が引数と返り値で型が同じであるという情報が分かっていた場合に，これをヒントとして伝えたい場合がありますが，型ワイルドカードでそれを伝える方法はありません．これを解決するのが<code>NamedWildCards</code>拡張です．この拡張を使うと，以下のようなプログラムに対しても，接頭に<code>_</code>が付いている型をワイルドカードとみなして，エラーメッセージで型の推論結果を表示してくれるようになります．</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb52-1" data-line-number="1"><span class="co">-- Inferred type: (a, Maybe a1) -&gt; (a, Maybe a1)</span></a>
<a class="sourceLine" id="cb52-2" data-line-number="2"><span class="ot">ignoreSecond ::</span> _a <span class="ot">-&gt;</span> _a</a>
<a class="sourceLine" id="cb52-3" data-line-number="3">ignoreSecond (x, _) <span class="fu">=</span> (x, <span class="dt">Nothing</span>)</a></code></pre></div>
<h3 id="新たな表記法の導入"><span class="link-to-here-outer"><a href="#新たな表記法の導入" title="新たな表記法の導入"><span class="link-to-here">Link to<br />
here</span></a></span>新たな表記法の導入</h3>
<p>この節では，以下の<span class="ascii">2</span>つの拡張を紹介します．</p>
<ul>
<li><code>Arrows</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-Arrows">ユーザーガイド <span class="ascii">- Arrows</span>拡張</a></li>
<li><code>RecursiveDo</code><span class="ascii">:</span> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-RecursiveDo">ユーザーガイド <span class="ascii">- RecursiveDo</span>拡張</a></li>
</ul>
<p><span class="ascii">Haskell</span>では，モナドを扱いやすくするための，<span class="ascii">do</span>構文という専用の構文が用意されています．この構文は<span class="ascii">Haskell</span>プログラミングにおいて広く利用されています．<span class="ascii">GHC</span>では，これに加え<code>Arrow</code>と<code>MonadFix</code>というクラスに対しての専用の構文も提供しています．これは<span class="ascii">GHC</span>拡張で実装されており，それぞれ<code>Arrows</code>拡張，<code>RecursiveDo</code>拡張を有効にすることで使用可能です．</p>
<p><code>Arrow</code>クラスは，モナドの一般化として導入されました<a href="#fn18" class="footnote-ref" id="fnref18"><sup>18</sup></a>．このクラスには，モナドの<code>do</code>構文と同様に，クラスメソッドだけの式に脱糖できる構文が考案され，<span class="ascii">GHC</span>拡張として実装されています．それが<code>Arrows</code>拡張で利用できる<code>proc</code>構文です．</p>
<p>例えば，<code>Arrow</code>クラスのメソッドを使った次のような関数は，</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb53-1" data-line-number="1"><span class="ot">doSomething ::</span> <span class="dt">Arrow</span> a <span class="ot">=&gt;</span> a <span class="dt">Int</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="dt">Int</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="dt">Int</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="dt">Int</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb53-2" data-line-number="2">doSomething f g h</a>
<a class="sourceLine" id="cb53-3" data-line-number="3">  <span class="fu">=</span>   arr (\x <span class="ot">-&gt;</span> (x <span class="fu">+</span> <span class="dv">1</span>, x))</a>
<a class="sourceLine" id="cb53-4" data-line-number="4">  <span class="fu">&gt;&gt;&gt;</span> first (f <span class="fu">&gt;&gt;&gt;</span> (arr (\y <span class="ot">-&gt;</span> <span class="dv">2</span> <span class="fu">*</span> y) <span class="fu">&gt;&gt;&gt;</span> g) <span class="fu">&amp;&amp;&amp;</span> returnA <span class="fu">&gt;&gt;&gt;</span> arr snd)</a>
<a class="sourceLine" id="cb53-5" data-line-number="5">  <span class="fu">&gt;&gt;&gt;</span> arr (\(y, x) <span class="ot">-&gt;</span> (x, x <span class="fu">+</span> y))</a>
<a class="sourceLine" id="cb53-6" data-line-number="6">  <span class="fu">&gt;&gt;&gt;</span> arr (\(x, z) <span class="ot">-&gt;</span> (z, x <span class="fu">*</span> z))</a>
<a class="sourceLine" id="cb53-7" data-line-number="7">  <span class="fu">&gt;&gt;&gt;</span> second h</a>
<a class="sourceLine" id="cb53-8" data-line-number="8">  <span class="fu">&gt;&gt;&gt;</span> arr (\(z, t) <span class="ot">-&gt;</span> t <span class="fu">+</span> z)</a></code></pre></div>
<p><code>proc</code>構文を使うと，</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb54-1" data-line-number="1"><span class="ot">doSomething ::</span> <span class="dt">Arrow</span> a <span class="ot">=&gt;</span> a <span class="dt">Int</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="dt">Int</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="dt">Int</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="dt">Int</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb54-2" data-line-number="2">doSomething f g h <span class="fu">=</span> proc x <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb54-3" data-line-number="3">  y <span class="ot">&lt;-</span> f <span class="fu">-&lt;</span> x <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb54-4" data-line-number="4">  g <span class="fu">-&lt;</span> <span class="dv">2</span> <span class="fu">*</span> y</a>
<a class="sourceLine" id="cb54-5" data-line-number="5">  <span class="kw">let</span> z <span class="fu">=</span> x <span class="fu">+</span> y</a>
<a class="sourceLine" id="cb54-6" data-line-number="6">  t <span class="ot">&lt;-</span> h <span class="fu">-&lt;</span> x <span class="fu">*</span> z</a>
<a class="sourceLine" id="cb54-7" data-line-number="7">  returnA <span class="fu">-&lt;</span> t <span class="fu">+</span> z</a></code></pre></div>
<p>というように書けます<a href="#fn19" class="footnote-ref" id="fnref19"><sup>19</sup></a>．また，<code>ArrowLoop</code>クラスの<code>loop</code>メソッドに変換される，<code>rec</code>構文も搭載されており次のようなフィードバック制御を相互再帰で行うプログラムを書くことができます．</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb55-1" data-line-number="1"><span class="ot">counter ::</span> <span class="dt">ArrowLoop</span> a <span class="ot">=&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="dt">Int</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> a <span class="dt">Bool</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb55-2" data-line-number="2">counter delay <span class="fu">=</span> proc reset <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb55-3" data-line-number="3">  rec output <span class="ot">&lt;-</span> returnA <span class="fu">-&lt;</span> <span class="kw">if</span> reset <span class="kw">then</span> <span class="dv">0</span> <span class="kw">else</span> next</a>
<a class="sourceLine" id="cb55-4" data-line-number="4">      next <span class="ot">&lt;-</span> delay <span class="dv">0</span> <span class="fu">-&lt;</span> output <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb55-5" data-line-number="5">  returnA <span class="fu">-&lt;</span> output</a></code></pre></div>
<p><code>proc</code>構文については<a href="https://www.haskell.org/arrows/syntax.html"><span class="ascii">Arrow syntax</span></a>のページにまとめられている他，<a href="http://www.staff.city.ac.uk/~ross/papers/notation.html">提案論文</a>にて変換規則を確認することが可能です．</p>
<p>さて，もう<span class="ascii">1</span>つの<code>MonadFix</code>クラスは，モナドを拡張し，再帰的なバインディングを許すようなものです．このクラスを元に，<code>RecursiveDo</code>拡張は<span class="ascii">do</span>構文をさらに拡張します．具体的には，次のように使用できる<code>rec</code>という構文を新たに導入します．</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb56-1" data-line-number="1"><span class="ot">doSomething ::</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb56-2" data-line-number="2">doSomething <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb56-3" data-line-number="3">  rec x <span class="ot">&lt;-</span> [y, y <span class="fu">*</span> <span class="dv">10</span>]</a>
<a class="sourceLine" id="cb56-4" data-line-number="4">      y <span class="ot">&lt;-</span> [<span class="dv">1</span>, <span class="dv">2</span>]</a>
<a class="sourceLine" id="cb56-5" data-line-number="5">  pure <span class="fu">$</span> x <span class="fu">+</span> y</a></code></pre></div>
<p>この関数は，次のように<code>MonadFix</code>クラスのメソッド<code>mfix</code>を使った関数と同等です．</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb57-1" data-line-number="1"><span class="ot">doSomething ::</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb57-2" data-line-number="2">doSomething <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb57-3" data-line-number="3">  (x, y) <span class="ot">&lt;-</span> mfix <span class="fu">$</span> \<span class="fu">~</span>(x, y) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb57-4" data-line-number="4">    x <span class="ot">&lt;-</span> [y, y <span class="fu">*</span> <span class="dv">10</span>]</a>
<a class="sourceLine" id="cb57-5" data-line-number="5">    y <span class="ot">&lt;-</span> [<span class="dv">1</span>, <span class="dv">2</span>]</a>
<a class="sourceLine" id="cb57-6" data-line-number="6">    pure (x, y)</a>
<a class="sourceLine" id="cb57-7" data-line-number="7">  pure <span class="fu">$</span> x <span class="fu">+</span> y</a></code></pre></div>
<p>また，<code>rec</code>を省略して書ける<code>mdo</code>という構文も提供されます．</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb58-1" data-line-number="1"><span class="ot">doSomething ::</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb58-2" data-line-number="2">doSomething <span class="fu">=</span> mdo</a>
<a class="sourceLine" id="cb58-3" data-line-number="3">  x <span class="ot">&lt;-</span> [y, y <span class="fu">*</span> <span class="dv">10</span>]</a>
<a class="sourceLine" id="cb58-4" data-line-number="4">  y <span class="ot">&lt;-</span> [<span class="dv">1</span>, <span class="dv">2</span>]</a>
<a class="sourceLine" id="cb58-5" data-line-number="5">  pure <span class="fu">$</span> x <span class="fu">+</span> y</a></code></pre></div>
<p><code>mdo</code>構文は，それぞれの文と変数の依存関係を解析し，自動的に<code>rec</code>ブロックに分けてくれます．後は，その分けられた<code>rec</code>文を<code>mfix</code>に翻訳することで，通常の<code>do</code>構文に翻訳することができます．例えば，</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb59-1" data-line-number="1">mdo</a>
<a class="sourceLine" id="cb59-2" data-line-number="2">  a <span class="ot">&lt;-</span> m</a>
<a class="sourceLine" id="cb59-3" data-line-number="3">  b <span class="ot">&lt;-</span> f a c</a>
<a class="sourceLine" id="cb59-4" data-line-number="4">  c <span class="ot">&lt;-</span> f b a</a>
<a class="sourceLine" id="cb59-5" data-line-number="5">  z <span class="ot">&lt;-</span> h a b</a>
<a class="sourceLine" id="cb59-6" data-line-number="6">  d <span class="ot">&lt;-</span> g d e</a>
<a class="sourceLine" id="cb59-7" data-line-number="7">  e <span class="ot">&lt;-</span> g a z</a>
<a class="sourceLine" id="cb59-8" data-line-number="8">  pure c</a></code></pre></div>
<p>という式は，</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb60-1" data-line-number="1"><span class="kw">do</span></a>
<a class="sourceLine" id="cb60-2" data-line-number="2">  a <span class="ot">&lt;-</span> m</a>
<a class="sourceLine" id="cb60-3" data-line-number="3">  (b, c) <span class="ot">&lt;-</span> mfix <span class="fu">$</span> \<span class="fu">~</span>(b, c) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb60-4" data-line-number="4">    b <span class="ot">&lt;-</span> f a c</a>
<a class="sourceLine" id="cb60-5" data-line-number="5">    c <span class="ot">&lt;-</span> f b a</a>
<a class="sourceLine" id="cb60-6" data-line-number="6">    pure (b, c)</a>
<a class="sourceLine" id="cb60-7" data-line-number="7">  z <span class="ot">&lt;-</span> h a b</a>
<a class="sourceLine" id="cb60-8" data-line-number="8">  (d, e) <span class="ot">&lt;-</span> mfix <span class="fu">$</span> \<span class="fu">~</span>(d, e) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb60-9" data-line-number="9">    d <span class="ot">&lt;-</span> g d e</a>
<a class="sourceLine" id="cb60-10" data-line-number="10">    e <span class="ot">&lt;-</span> g a z</a>
<a class="sourceLine" id="cb60-11" data-line-number="11">    pure (d, e)</a>
<a class="sourceLine" id="cb60-12" data-line-number="12">  pure c</a></code></pre></div>
<p>という式に翻訳されます．<code>mdo</code>と<code>rec</code>の変換規則は，<a href="https://dl.acm.org/citation.cfm?doid=581690.581693">提案論文</a>にて確認が可能です．</p>
<h1 id="次回予告"><span class="link-to-here-outer"><a href="#次回予告" title="次回予告"><span class="link-to-here">Link to<br />
here</span></a></span>次回予告</h1>
<p>今回は，<span class="ascii">GHC</span>拡張の簡単な紹介と使い方について，それから個人的にデフォルトで有効化している，<span class="ascii">Prelude</span>の暗黙的なインポートを抑制する拡張，新たな構文を導入する拡張を紹介しました．</p>
<p>次回は，他のデフォルトで有効化している拡張について紹介したいと思います．</p>
<h1 id="参考文献"><span class="link-to-here-outer"><a href="#参考文献" title="参考文献"><span class="link-to-here">Link to<br />
here</span></a></span>参考文献</h1>
<ul>
<li><a href="https://downloads.haskell.org/~ghc/8.4.2/docs/html/users_guide/"><span class="ascii">GHC 8.4.2 User</span>’<span class="ascii">s Guide</span></a>
<ul>
<li><a href="https://downloads.haskell.org/~ghc/8.4.2/docs/html/users_guide/glasgow_exts.html#options-language"><span class="ascii">GHC 8.4.2 User</span>’<span class="ascii">s Guide - 9. GHC Language Features</span></a></li>
<li><a href="https://downloads.haskell.org/~ghc/8.4.2/docs/html/users_guide/ffi-chap.html"><span class="ascii">GHC 8.4.2 User</span>’<span class="ascii">s Guide - 10. Foreign function interface (FFI)</span></a></li>
</ul></li>
<li><a href="http://dev.stephendiehl.com/hask/#language-extensions"><span class="ascii">What I Wish I Knew When Learning Haskell - Language Extensions</span></a></li>
<li><a href="https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/language-standards"><span class="ascii">Guide to GHC Extensions - Language Standards</span></a></li>
<li><a href="https://www.haskell.org/onlinereport/haskell2010/"><span class="ascii">Haskell 2010 Language Report</span></a></li>
<li><a href="https://www.haskell.org/cabal/users-guide/cabal-projectindex.html"><span class="ascii">Cabal reference</span></a></li>
</ul>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>この記事では特に断らない限り，<a href="https://www.haskell.org/onlinereport/haskell2010/"><span class="ascii">Haskell2010</span></a>を「<span class="ascii">Haskell</span>標準」または「<span class="ascii">Haskell</span>」と呼称します．<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>このオプションは，拡張を無効にする<span class="ascii">GHC</span>拡張<span class="ascii">(</span>例えば，<code>NoImplicitPrelude</code>拡張など<span class="ascii">)</span>も含めて表示します．実際には<code>No</code>が付いている拡張を抜くと，提供されている数は<span class="ascii">120</span>個になります．<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p><span class="ascii">Haskell</span>標準では，ある拡張を無効にするといった機能は提供されていません．このため，<span class="ascii">GHC</span>では無効にする機能を<span class="ascii">1</span>つの拡張として，<span class="ascii">Haskell</span>標準に則った形で提供しています．<a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p>有効にする拡張と無効にする拡張を両方指定した場合，<span class="ascii">GHC</span>は指定された順番に沿って最後に指定された方を拡張として採用します．<a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p><span class="ascii">Haskell2010</span>標準では，<code>Haskell2010</code>というプラグマをサポートすること，また<span class="ascii">Haskell98</span>から新たに<span class="ascii">Haskell2010</span>までに取り込まれた機能を切り離した<code>PatternGuards</code><span class="ascii">/</span><code>NoNPlusKPatterns</code><span class="ascii">/</span><code>RelaxedPolyRec</code><span class="ascii">/</span><code>EmptyDataDecls</code><span class="ascii">/</span><code>EmptyDataDecls</code>という拡張をそれぞれサポートすることが望ましいと規定されています．<span class="ascii">GHC</span>も<code>Haskell2010</code>という拡張を指定できるようになっており，ここにあるほとんどはこの拡張を有効にした場合にも有効になります．<a href="#fnref5" class="footnote-back">↩</a></p></li>
<li id="fn6"><p>デフォルトで有効になる拡張のほとんどは，<span class="ascii">Haskell 2010</span>を元にしたものです．ただし全てがそうというわけではありません．<code>NondecreasingIndentation</code>は<span class="ascii">Haskell</span>標準にはない機能です．また<span class="ascii">GHC</span>は<span class="ascii">Haskell 2010</span>で規定されている仕様を全てデフォルトで取り込んでいる訳でもありません．特に<span class="ascii">Haskell</span>標準ではデータ型の宣言に型制約を書くことができますが，<span class="ascii">GHC</span>ではデフォルトではできません．これを有効にする場合，<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-DatatypeContexts"><code>DatatypeContexts</code>拡張</a>を有効にする必要があります．<a href="#fnref6" class="footnote-back">↩</a></p></li>
<li id="fn7"><p><span class="ascii">GHC</span>の内部では<code>RelaxedPolyRec</code>という拡張も一緒に有効になります．しかし，現在この拡張は実装上の問題で<span class="ascii">GHC</span>上で無効にすることができないため，ドキュメント上からも削除されています．この記事でも<span class="ascii">GHC</span>の方針に従って，この拡張は特に扱いませんのでご留意ください．<a href="#fnref7" class="footnote-back">↩</a></p></li>
<li id="fn8"><p>現在，<span class="ascii">Prelude</span>の代替を目指す，<a href="https://hackage.haskell.org/package/rio"><span class="ascii">rio</span></a>というパッケージが作成されています．このパッケージは現在まだ<span class="ascii">prerelease</span>の段階で，<a href="https://github.com/commercialhaskell/stack"><span class="ascii">stack</span></a>において実験的に使用されています．様々な最新の<span class="ascii">Haskell</span>プログラミングの知見を取り入れており，標準の<span class="ascii">Prelude</span>に大きく拡張を施しているため，<span class="ascii">Haskell</span>で大規模な開発を行う場合注目する価値があるかもしれません．<a href="#fnref8" class="footnote-back">↩</a></p></li>
<li id="fn9"><p><span class="ascii">GHC 8.2.2</span>の段階では，パターンシノニムはコンパイラがクラッシュするなどの非常に多くのバグを抱えていました．私は<span class="ascii">8.4.2</span>をまだあまり試していませんが，パターンシノニムの仕様が非常に複雑なため，<span class="ascii">8.4.2</span>でもまだバグを多く抱えている可能性があります．パターンシノニムをプロダクトで多用する場合，その点に注意した方が良いでしょう．<a href="#fnref9" class="footnote-back">↩</a></p></li>
<li id="fn10"><p><span class="ascii">GHC</span>のレコードシステムの拡張は非常に強力ですが，その反面システムが非常に複雑になっています．このため，<span class="ascii">8.2.2</span>の段階でコンパイラがクラッシュするなど非常に多くのバグを抱えていました．レコードシステムの仕様の改良は現在も進んでいますが，<span class="ascii">8.4.2</span>でもまだバグを多く抱えている可能性があります．これらの拡張をプロダクトで多用する場合，その点に注意した方が良いでしょう．特に，<span class="ascii">GHC 8.0</span>以降に導入された拡張には注意が必要です．<a href="#fnref10" class="footnote-back">↩</a></p></li>
<li id="fn11"><p><code>OverloadedLabels</code>拡張はかなり最近入った拡張で，多数の<span class="ascii">GHC</span>拡張，特に強力な型システムを前提にして書かれています．このため，選択関数の実装にもかなり多くの<span class="ascii">GHC</span>拡張を使用しています．ここでは，特に解説しないのでそういうものだと思っておいてください．なお，このプログラムはプロダクションで使うことを前提にしていませんので，そこはご注意ください．<a href="#fnref11" class="footnote-back">↩</a></p></li>
<li id="fn12"><p>この機能は型演算子を定義しないで再エクスポートなどをする場合にも使用されるため，<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-ExplicitNamespaces"><code>ExplicitNamespaces</code>拡張</a>として切り離されています．<a href="#fnref12" class="footnote-back">↩</a></p></li>
<li id="fn13"><p>この機能は<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-ConstrainedClassMethods"><code>ConstrainedClassMethods</code>拡張</a>として切り離されており，<code>MultiParamTypeClasses</code>拡張を有効にすると一緒に有効になります．<a href="#fnref13" class="footnote-back">↩</a></p></li>
<li id="fn14"><p>型制約が小さいとは，型変数とコンストラクタと変数の組の出現が少ないということです．<a href="#fnref14" class="footnote-back">↩</a></p></li>
<li id="fn15"><p>より正確には，<code>FunctionalDependencies</code>に対する制限もありますが，ここでは割愛します．<a href="#fnref15" class="footnote-back">↩</a></p></li>
<li id="fn16"><p>この拡張は，<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-TypeSynonymInstances"><code>TypeSynonymInstances</code>拡張</a>として切り離されており，<code>FlexibleInstances</code>拡張を有効にすると一緒に有効になります．<a href="#fnref16" class="footnote-back">↩</a></p></li>
<li id="fn17"><p>特に<code>ScopedTypeVariables</code>拡張を指定する場合，型注釈は必要です．<a href="#fnref17" class="footnote-back">↩</a></p></li>
<li id="fn18"><p><a href="https://dl.acm.org/citation.cfm?id=347246">“<span class="ascii">Generalising Monads to Arrows</span>”</a><span class="ascii">, John Hughes, in Science of Computer Programming 37, pp. 67</span>–<span class="ascii">111, May 2000</span><a href="#fnref18" class="footnote-back">↩</a></p></li>
<li id="fn19"><p>一見，この構文は単純な脱糖を行うと脱糖後のプログラムが非常に冗長になるように思えます．しかし，<code>Arrow</code>クラスのメソッドに設けられている書き換え規則によって，最終的に妥当な大きさまで脱糖後のプログラムが小さくなってくれます．<a href="#fnref19" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2018/windows-gotchas-en.html" lang="en">Errors and the workarounds frequently encountered when dealing with Haskell on Windows</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2018/main-tester.html" style="margin-left: auto;" lang="ja">CLIアプリのE2Eテストを行うためのライブラリー main-testerをリリースしました</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>CLIアプリのE2Eテストを行うためのライブラリー main-testerをリリースしました</title>
    <link href="https://haskell.jp/blog/posts/2018/main-tester.html" />
    <id>https://haskell.jp/blog/posts/2018/main-tester.html</id>
    <published>2018-04-09T00:00:00Z</published>
    <updated>2018-04-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>こんにちは。みなさん、テストは書いてますか？<br />
「<a href="http://syocy.hatenablog.com/entry/haskell-library-2016#%E3%83%86%E3%82%B9%E3%83%88"><span class="ascii">Haskell</span>ライブラリ所感<span class="ascii">2016</span></a>」という記事でも紹介されているとおり、<span class="ascii">Haskell</span>にも様々なテスト用ライブラリーがあります。<br />
今回は、「<span class="ascii">Haskell</span>ライブラリ所感<span class="ascii">2016</span>」でも紹介されている<a href="https://hackage.haskell.org/package/silently"><span class="ascii">silently</span></a>というパッケージにインスパイアされた、新しいテスト用ライブラリーを作りました。<br />
タイトルにも書きましたが<a href="https://hackage.haskell.org/package/main-tester"><span class="ascii">main-tester</span></a>といいます。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#main-testerができること" title="main-testerができること"><span class="ascii">main-tester</span>ができること</a></li>
<li><a href="#ほかのライブラリーとの違い" title="ほかのライブラリーとの違い">ほかのライブラリーとの違い</a></li>
<li><a href="#使い方バグ報告" title="使い方バグ報告">使い方・バグ報告</a></li>
</ul>
</div>
</div>
<h1 id="main-testerができること"><span class="link-to-here-outer"><a href="#main-testerができること" title="main-testerができること"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">main-tester</span>ができること</h1>
<p><span class="ascii">main-tester</span>は名前の通り、<code>main</code>関数のテストをサポートするライブラリーです。<br />
<span class="ascii">Haskell</span>製のプログラムを起動すると最初に実行される、あの<code>main</code>関数です。</p>
<p><code>main</code>関数は<code>IO ()</code>という型であるとおり、原則として必ず入出力を伴うので、自動テストがしにくい関数です。<br />
一般的なベストプラクティスとしては、できるだけ<code>IO</code>でない、純粋な関数を中心にテストを書いていくのが普通でしょう。<br />
それでも敢えて<code>main</code>関数の自動テストを書くのには、以下のメリットがあります。</p>
<ol type="1">
<li><code>main</code>関数をテストすると言うことは、作っているコマンドの、ユーザーの要求に最も近いレベルのテスト、<span class="ascii">E2E</span>テスト（<span class="ascii">end-to-end</span> テスト）をすることができる。</li>
<li><code>main</code>関数（や、その他の<code>IO</code>を伴う関数）に対するテストは、データベースやファイルシステムなど、外部のソフトウェアとの「組み合わせ」で起こるバグを検出できる。
<ul>
<li>経験上、特に単純なアプリケーションでは、そうした外部のソフトウェアに対する「誤解」が原因となったバグが比較的多いように感じています。</li>
</ul></li>
<li>私の個人的な都合ですが、趣味では小さなアプリケーションを書くことが多いので、そうした<span class="ascii">E2E</span>テストの方が効果的だったりする。</li>
</ol>
<p>このように、<code>main</code>関数をはじめとする、<code>IO</code>な関数に対して敢えて自動テストを書くことには、様々なメリットがあります。<br />
<code>main-tester</code>はそうした<code>IO</code>な関数をテストする際に伴う、<span class="ascii">2</span>つの問題を解決しました。</p>
<ol type="1">
<li>標準出力・標準エラー出力に出力した文字列がテストしにくい
<ul>
<li>➡️ <code>captureProcessResult</code>という関数で、標準出力・標準エラー出力に出力した文字列をそれぞれ<code>ByteString</code>として取得することができます。</li>
</ul></li>
<li>標準入力から文字列を読み出そうとすると、テストの実行が停止してしまう。
<ul>
<li>➡️ <code>withStdin</code>という関数で、標準入力に与えたい文字列を<code>ByteString</code>として与えることができます。</li>
</ul></li>
</ol>
<p>ここに書いたことは、ビルドした実行ファイルを子プロセスとして呼び出すことによってもできます。<br />
入出力の順番など、標準出力や標準エラー出力のより細かい挙動をテストするにはその方がいいでしょう<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>。<br />
しかし、テストのために<code>PATH</code>を分離させる必要があったり、そのために<a href="https://github.com/commercialhaskell/stack/issues/2885"><code>stack exec</code>を使ったらめっちゃ遅い</a>という問題があったり、そもそも子プロセス呼び出しはそれだけでオーバーヘッドがあったりと、様々な問題があります。<br />
物事をよりシンプルにするには、<code>main</code>関数を直接呼び出した方がよいでしょう。<br />
<span class="ascii">main-tester</span>は、<span class="ascii">CLI</span>アプリケーションの<span class="ascii">E2E</span>テストにおける、そうした子プロセスの呼び出しの問題と、より大きな関数をテストしたいというニーズに応えるためのライブラリーなのです。</p>
<h1 id="ほかのライブラリーとの違い"><span class="link-to-here-outer"><a href="#ほかのライブラリーとの違い" title="ほかのライブラリーとの違い"><span class="link-to-here">Link to<br />
here</span></a></span>ほかのライブラリーとの違い</h1>
<p>「<span class="ascii">silently</span>というパッケージにインスパイアされた」と冒頭で申しましたとおり、前節で紹介した機能は、実はすでにほかのライブラリーに似たものがあります。<br />
<span class="ascii">silently</span>に加え、<a href="https://hackage.haskell.org/package/imperative-edsl-0.7.1/docs/System-IO-Fake.html"><span class="ascii">imperative-edsl</span>というパッケージに含まれる、<code>System.IO.Fake</code>というモジュール</a>です<small>（ほかにもあったらすみません！🙇🙇🙇）</small>。<br />
これらと<span class="ascii">main-tester</span>との違いは何でしょう？</p>
<p>第一に、先ほども触れましたが、<span class="ascii">main-tester</span>の<code>captureProcessResult</code>関数や<code>withStdin</code>関数は、標準出力・標準エラー出力・標準入力でやりとりする文字列を<span class="ascii">strict</span>な<code>ByteString</code>でやりとりします。<br />
<span class="ascii">silently</span>や<code>System.IO.Fake</code>は、<code>String</code>なのです。<br />
<code>ByteString</code>は文字通り任意のバイト列を扱うことができるので、「<span class="ascii">Unicode</span>の文字のリスト」である<code>String</code>よりも、多様なデータを扱うことができます。</p>
<p>これは、特に複数の種類の文字コードを扱うとき、非常に重要な機能となります。<br />
<a href="https://haskell.jp/blog/posts/2017/windows-gotchas.html">以前の記事で取り上げた、<code>Invalid character</code>というエラー</a>を再現させる場合も、ないと大変やりづらいでしょう。</p>
<p>第二に、<span class="ascii">main-tester</span>の<code>captureProcessResult</code>関数は、<code>main</code>関数の終了コードも<a href="https://hackage.haskell.org/package/base-4.11.0.0/docs/System-Exit.html#t:ExitCode"><code>ExitCode</code>型</a>の値として取得できます。<br />
<code>main</code>関数の中で<code>exitFailure</code>等の関数を呼び出すと、<code>ExitCode</code>が例外として投げられます。<br />
既存のライブラリーでこれを行うと、<code>ExitCode</code>が例外として処理されるため、テストしたい<code>main</code>関数の実行が終了してしまいます。<br />
結果、<code>main</code>関数が標準出力・標準エラー出力に書き込んだ文字列を取得することができないのです。<br />
「○○というエラーメッセージを出力して異常終了する」といったことをテストしたい場合、これでは使いづらいでしょう。<br />
<strong>「<code>main</code>関数の<span class="ascii">E2E</span>テストを行うためのライブラリーである」</strong>という観点から、必須の機能であると判断し、実装しました。 ちなみに、<code>ExitCode</code>以外の例外についてはそのまま投げられます。仕様を単純にするために、これはユーザーのテストコードの中で処理することとしています。</p>
<h1 id="使い方バグ報告"><span class="link-to-here-outer"><a href="#使い方バグ報告" title="使い方バグ報告"><span class="link-to-here">Link to<br />
here</span></a></span>使い方・バグ報告</h1>
<p>機能は非常にシンプルなので、使い方については<a href="https://hackage.haskell.org/package/main-tester-0.1.0.0/docs/Test-Main.html">ドキュメント</a>のサンプルコードを読めば大体わかるかなぁと思いますが、簡単にサンプルを載せておきましょう。</p>
<p>例えばこんなソース👇のプログラムがあった場合、</p>
<p><span class="ascii">ExampleMain.hs:</span></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">module</span> <span class="dt">ExampleMain</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Data.List</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="kw">import</span> <span class="dt">System.Exit</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">  putStr <span class="st">&quot;What&#39;s your name?: &quot;</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">  name <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">  <span class="kw">if</span> <span class="st">&quot;Yuji&quot;</span> <span class="ot">`isInfixOf`</span> name</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">    <span class="kw">then</span> putStrLn <span class="st">&quot;Nice name!&quot;</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12">    <span class="kw">else</span> die <span class="fu">$</span> name <span class="fu">++</span> <span class="st">&quot;? Sorry I don&#39;t know such a guy!&quot;</span></a></code></pre></div>
<p><span class="ascii">main-tester</span>を使えば、次のように<span class="ascii">Hspec</span>でテストできます。</p>
<p><span class="ascii">ExampleSpec.hs:</span></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">import</span> <span class="dt">System.Exit</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Test.Main</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="kw">import</span> <span class="dt">Test.Hspec</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">ExampleMain</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString</span> <span class="kw">as</span> <span class="dt">B</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">main <span class="fu">=</span> hspec <span class="fu">$</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">  describe <span class="st">&quot;your-cool-command&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">    context <span class="st">&quot;Given &#39;Yuji&#39; to stdin&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12">      it <span class="st">&quot;prints a string including &#39;Nice name&#39; without an error&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-13" data-line-number="13">        result <span class="ot">&lt;-</span> withStdin <span class="st">&quot;Yuji&quot;</span><span class="fu">$</span> captureProcessResult ExampleMain.main</a>
<a class="sourceLine" id="cb2-14" data-line-number="14">        prExitCode result <span class="ot">`shouldBe`</span> <span class="dt">ExitSuccess</span></a>
<a class="sourceLine" id="cb2-15" data-line-number="15">        prStderr result <span class="ot">`shouldSatisfy`</span> B.null</a>
<a class="sourceLine" id="cb2-16" data-line-number="16">        prStdout result <span class="ot">`shouldSatisfy`</span> (<span class="st">&quot;Nice name&quot;</span> <span class="ot">`B.isInfixOf`</span>)</a>
<a class="sourceLine" id="cb2-17" data-line-number="17"></a>
<a class="sourceLine" id="cb2-18" data-line-number="18">    context <span class="st">&quot;Given other name to stdin&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb2-19" data-line-number="19">      it <span class="st">&quot;prints an error message&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-20" data-line-number="20">        result <span class="ot">&lt;-</span> withStdin <span class="st">&quot;other name&quot;</span> <span class="fu">$</span> captureProcessResult ExampleMain.main</a>
<a class="sourceLine" id="cb2-21" data-line-number="21">        prExitCode result <span class="ot">`shouldBe`</span> <span class="dt">ExitFailure</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-22" data-line-number="22">        prStderr result <span class="ot">`shouldSatisfy`</span> (not <span class="fu">.</span> B.null)</a></code></pre></div>
<p>それぞれのファイルを同じディレクトリーに置いた上で、次のように実行すれば試せるはずです <small>（<span class="ascii">cabal</span>ユーザーの皆さんは適当に読み替えてください…）</small>。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="op">&gt;</span> <span class="ex">stack</span> build hspec main-tester</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="op">&gt;</span> <span class="ex">stack</span> exec runghc -- --ghc-arg=-i. ExampleSpec.hs</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="ex">your-cool-command</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">  <span class="ex">Given</span> <span class="st">&#39;Yuji&#39;</span> to stdin</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    <span class="ex">prints</span> a string including <span class="st">&#39;Nice name&#39;</span> without an error</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">  <span class="ex">Given</span> other name to stdin</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">    <span class="ex">prints</span> an error message</a>
<a class="sourceLine" id="cb3-9" data-line-number="9"></a>
<a class="sourceLine" id="cb3-10" data-line-number="10"><span class="ex">Finished</span> in 0.0130 seconds</a>
<a class="sourceLine" id="cb3-11" data-line-number="11"><span class="ex">2</span> examples, 0 failures</a></code></pre></div>
<p>バグを見つけたら<a href="https://gitlab.com/igrep/main-tester/issues">こちらの<span class="ascii">GitLab</span>の<span class="ascii">Issue</span></a>に報告してください<small>（最近の個人的な判官贔屓により、敢えて<span class="ascii">GitLab</span>にしております 😏）</small>。<br />
それではこの春は<span class="ascii">main-tester</span>で<span class="ascii">Happy Haskell Testing!!</span> 💚💚💚</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p><code>main</code>関数を子スレッドとして<code>forkIO</code>することで同じことが恐らくできますが、テスト結果の報告に使うべき、標準出力・標準エラー出力を食い合うことになってしまうので、非常にやりづらいと思います。<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2018/about-ghc-exts-1.html" lang="ja">GHC拡張ノック(Part 1)</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2018/renew-haskell-antenna.html" style="margin-left: auto;" lang="ja">Haskell Antenna をリニューアルしました</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>Haskell Antenna をリニューアルしました</title>
    <link href="https://haskell.jp/blog/posts/2018/renew-haskell-antenna.html" />
    <id>https://haskell.jp/blog/posts/2018/renew-haskell-antenna.html</id>
    <published>2018-03-21T00:00:00Z</published>
    <updated>2018-03-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <p><a href="https://haskell.jp/antenna/"><span class="ascii">Haskell Antenna</span></a>は<a href="https://github.com/lotz84"><span class="ascii">lotz84</span></a>氏が作った<span class="ascii">Haskell</span>の日本語情報を収集するウェブサイトです。 下記の記事を読むと、動機付けなどが分かると思います。</p>
<ul>
<li><a href="https://haskell.jp/blog/posts/2017/03-haskell-antenna.html"><span class="ascii">Haskell Antenna</span> を公開しました <span class="ascii">- Haskell-jp</span></a></li>
</ul>
<p>残念なことに<span class="ascii">Haskell Antenna</span>は動作が重く、なかなか満足に閲覧することが出来ませんでした。 そこで、<span class="ascii">Haskell Antenna</span>をリニューアルしました！</p>
<p>正確には、<a href="https://planet.haskell.org/"><span class="ascii">Planet Haskell</span></a>の日本語版として作成した<a href="https://github.com/matsubara0507/planet-haskell-jp-demo">もの</a>を、新しい<span class="ascii">Haskell Antenna</span>として置き換えました。 新<span class="ascii">Antenna</span>は旧<span class="ascii">Antenna</span>と比べると見た目も機能も更新頻度も残念なことになってしまいましたが、各サイトのフィードから記事の一覧を取得し静的サイトとして生成しているだけなので動作は軽快です。</p>
<p>旧<span class="ascii">Antenna</span>同様に新<span class="ascii">Antenna</span>でも配信する情報源<span class="ascii">(</span>今のところ<span class="ascii">Atom</span>か<span class="ascii">RSS2.0</span>形式のフィード<span class="ascii">)</span>をいつでも募集しています。 もし追加すべき情報源にアイデアがあれば<a href="https://github.com/haskell-jp/antenna#サイトの追加方法"><span class="ascii">GitHub</span>レポジトリの<span class="ascii">README</span></a>にかかれている方法を参考に<span class="ascii">Pull Request</span>を送っていただくことが可能です。 また、<span class="ascii">PR</span>を送るのは面倒だという方は<span class="ascii">Haskell-jp</span>の<span class="ascii">Slack</span>の<span class="ascii">#antenna</span>チャンネルを通じて提案を行ってもらうことも大歓迎です。 <span class="ascii">(Planet Haskell</span>がそうであるように<span class="ascii">)Haskell</span>中心でなくても良いので、<span class="ascii">Haskell</span>の情報を発信しているブログを持っている方は是非、追加提案をしていただけると助かります。</p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2018/main-tester.html" lang="ja">CLIアプリのE2Eテストを行うためのライブラリー main-testerをリリースしました</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2018/windows-long-path.html" style="margin-left: auto;" lang="ja">WindowsでHaskellを扱う時によく遭遇するNo such file or directoryについて</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>WindowsでHaskellを扱う時によく遭遇するNo such file or directoryについて</title>
    <link href="https://haskell.jp/blog/posts/2018/windows-long-path.html" />
    <id>https://haskell.jp/blog/posts/2018/windows-long-path.html</id>
    <published>2018-03-13T00:00:00Z</published>
    <updated>2018-03-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>去年、<a href="/posts/2017/windows-gotchas.html"><span class="ascii">Windows</span>で<span class="ascii">Haskell</span>を扱う時によく遭遇するエラーと対処法</a>という記事で、<span class="ascii">Windows</span>ユーザーが<span class="ascii">Haskell</span>で開発したとき、あるいは<span class="ascii">Haskell</span>製のプログラムを使用した際によく遭遇するエラーやその回避方法を紹介しました。<br />
今回は、そこに追記したい内容として、最近私がよく出遭うようになったエラーを紹介します。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#openfile-does-not-exist-no-such-file-or-directoryといわれたら短いパスに移そう" title="openfile-does-not-exist-no-such-file-or-directoryといわれたら短いパスに移そう"><code>openFile: does not exist (No such file or directory)</code>といわれたら短いパスに移そう</a>
<ul>
<li><a href="#回避方法" title="回避方法">回避方法</a>
<ul>
<li><a href="#長いパスをより短くするためにカレントディレクトリーを変更して相対パスを短くする" title="長いパスをより短くするためにカレントディレクトリーを変更して相対パスを短くする">長いパスをより短くするために、カレントディレクトリーを変更して、相対パスを短くする。</a></li>
<li><a href="#win32-apiのユニコード版の関数にというプレフィックスを着けた絶対パスを渡す" title="win32-apiのユニコード版の関数にというプレフィックスを着けた絶対パスを渡す"><span class="ascii">Win32 API</span>のユニコード版の関数に、<code>\\?\</code>というプレフィックスを着けた絶対パスを渡す。</a></li>
</ul></li>
</ul></li>
<li><a href="#おわりに" title="おわりに">おわりに</a></li>
<li><a href="#参考url" title="参考url">参考<span class="ascii">URL</span></a></li>
</ul>
</div>
</div>
<h1 id="openfile-does-not-exist-no-such-file-or-directoryといわれたら短いパスに移そう"><span class="link-to-here-outer"><a href="#openfile-does-not-exist-no-such-file-or-directoryといわれたら短いパスに移そう" title="openfile-does-not-exist-no-such-file-or-directoryといわれたら短いパスに移そう"><span class="link-to-here">Link to<br />
here</span></a></span><code>openFile: does not exist (No such file or directory)</code>といわれたら短いパスに移そう</h1>
<p><code>does not exist (No such file or directory)</code>というエラーは、本当に読んで字のごとく、開こうとしたファイルが存在しないためのエラーであることとがもちろん多いのですが、エラーメッセージに反して違う原因である場合もあります。</p>
<p>例えば、最近私はとあるプロジェクトを数文字長い名前にリネームしたのですが、たったそれだけで、<code>stack test</code>した際必ず問題のエラーが発生するようになってしまいました。</p>
<pre><code>$ stack test
a-little-longer-name-project-0.1.0.0: build (lib + exe + test)
Preprocessing library for a-little-longer-name-project-0.1.0.0..
Building library for a-little-longer-name-project-0.1.0.0..
Preprocessing executable &#39;mmlh&#39; for a-little-longer-name-project-0.1.0.0..
Building executable &#39;mmlh&#39; for a-little-longer-name-project-0.1.0.0..
Preprocessing test suite &#39;a-little-longer-name-project-test&#39; for a-little-longer-name-project-0.1.0.0..
Building test suite &#39;a-little-longer-name-project-test&#39; for a-little-longer-name-project-0.1.0.0..
[1 of 5] Compiling Paths_aLittleLongerNameProject ( .stack-work\dist\5c8418a7\build\a-little-longer-name-project-test\autogen\Paths_aLittleLongerNameProject.hs, .stack-work\dist\5c8418a7\build\a-little-longer-name-project-test\a-little-longer-name-project-test-tmp\Paths_aLittleLongerNameProject.o )
.stack-work\dist\5c8418a7\build\a-little-longer-name-project-test\a-little-longer-name-project-test-tmp\.stack-work\dist\5c8418a7\build\a-little-longer-name-project-test\autogen\Paths_aLittleLongerNameProject.dump-hi: openFile: does not exist (No such file or directory)</code></pre>
<p>どういうことかと悩んでいたところ、<a href="https://github.com/commercialhaskell/stack/issues/3649">こんな<span class="ascii">Issue</span></a>を見つけました。<br />
<a href="https://github.com/commercialhaskell/stack/issues/3649#issuecomment-351612621"><span class="ascii">Snoyman</span>の指摘</a>のとおり、こちらの問題は<span class="ascii">Windows</span>で使えるパスの長さが原因のエラーのようです。<br />
どういうことかというと、<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247%20(v=vs.85)#maxpath"><span class="ascii">MSDN</span>のこちらのページ</a>でも触れているとおり、<span class="ascii">Windows</span>の（<span class="ascii">C</span>言語レベルでの）各種ファイル操作用<span class="ascii">API</span>では、一度に扱えるパスの長さが<span class="ascii">260</span>文字までと決められていて、その制限にかかったためのエラーだというのです！<br />
<code>does not exist (No such file or directory)</code>なんてエラーメッセージで表されるのでわかりづらい！<small>（おそらく<span class="ascii">Windows</span>のエラーコードの出し方に問題があるんじゃないかと思います）</small></p>
<p><span class="ascii">DOS</span>時代から残るこの制限、完全に時代錯誤なものでしかないのですが、<span class="ascii">Windows</span>でパッケージマネージャーなどが自動的に作ったパスを扱っていると、しばしば出くわすことがあります。<br />
<span class="ascii">stack</span>においても、<a href="https://github.com/commercialhaskell/stack/issues/3285">こちらの<span class="ascii">Issue</span></a>で同じ問題が議論されていたり、<a href="https://github.com/commercialhaskell/stack/releases/tag/v1.6.5"><span class="ascii">ver. 1.6.5</span>の<span class="ascii">ChangeLog</span></a>でも言及されていたりと、至る所で格闘している跡があります。</p>
<h2 id="回避方法"><span class="link-to-here-outer"><a href="#回避方法" title="回避方法"><span class="link-to-here">Link to<br />
here</span></a></span>回避方法</h2>
<p>そんな<code>does not exist (No such file or directory)</code>ですが、残念ながら私が知る限り、プロジェクトなどのパスを（<code>C:\</code>などのよりルートに近い場所に置いて）より短くする以外の回避方法はありません。<br />
<a href="https://github.com/haskell/haskell-ide-engine#installation-on-windows"><span class="ascii">haskell-ide-engine</span>のインストール方法のページ</a>曰く、（新しめの）<span class="ascii">Windows 10</span>であれば、グループポリシーを編集して、「<span class="ascii">Win32</span>の長いパスを有効にする」を「有効」にすれば回避できるとのことですが、残念ながら手元で試した限りうまくいきませんでした。何かやり方がまずかったのかもしれませんが。<br />
いずれにしても、<code>stack build</code>コマンドなどを実行したときに問題のエラーに遭遇した場合、ビルドしたいもののパスをなんとかして短くする以上の方法はありません。<br />
<code>C:\</code>直下をホームディレクトリのように使う人が今でもたくさんいるわけです。</p>
<p>一方、あなたが問題のエラーが発生するプログラムを<strong>修正する</strong>ことができる立場にある場合、次の方法で回避できるかもしれません。</p>
<h3 id="長いパスをより短くするためにカレントディレクトリーを変更して相対パスを短くする"><span class="link-to-here-outer"><a href="#長いパスをより短くするためにカレントディレクトリーを変更して相対パスを短くする" title="長いパスをより短くするためにカレントディレクトリーを変更して相対パスを短くする"><span class="link-to-here">Link to<br />
here</span></a></span>長いパスをより短くするために、カレントディレクトリーを変更して、相対パスを短くする。</h3>
<p>本件はあくまでも、<span class="ascii">Windows</span>の各種ファイル操作用<span class="ascii">API</span>の<span class="ascii">1</span>回の呼び出しで渡せる長さの制限ですので、制限を超えてしまうような場合はパスを分割すればよいのです。<br />
<a href="https://hackage.haskell.org/package/filepath-1.4.2/docs/System-FilePath-Posix.html#v:splitFileName"><span class="ascii">filepath</span>パッケージの<code>splitFileName</code>関数</a>や<a href="https://hackage.haskell.org/package/filepath-1.4.2/docs/System-FilePath-Posix.html#v:splitPath"><code>splitPath</code>関数</a>を駆使してパスを分割した上で、対象のファイルの親ディレクトリーまで<a href="https://hackage.haskell.org/package/directory-1.3.2.1/docs/System-Directory.html#v:setCurrentDirectory"><span class="ascii">directory</span>パッケージの<code>setCurrentDirectory</code>関数</a>で移動すれば、制限に引っかからないはずです<small>（時間の都合でこちらについては試すコードを用意しておりません。あしからず）</small>。</p>
<p>残念ながらカレントディレクトリーはプロセス全体で共有される情報ですので、マルチスレッドなプログラムでは頭の痛い問題が出てきてしまいますが、一番確実に回避できる方法のはずです。<br />
マルチスレッドである場合を考慮したくない場合は、次に紹介する方法を検討するとよいでしょう。</p>
<h3 id="win32-apiのユニコード版の関数にというプレフィックスを着けた絶対パスを渡す"><span class="link-to-here-outer"><a href="#win32-apiのユニコード版の関数にというプレフィックスを着けた絶対パスを渡す" title="win32-apiのユニコード版の関数にというプレフィックスを着けた絶対パスを渡す"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Win32 API</span>のユニコード版の関数に、<code>\\?\</code>というプレフィックスを着けた絶対パスを渡す。</h3>
<p>ここまでに出てきた、「<span class="ascii">Windows</span>の各種ファイル操作用<span class="ascii">API</span>」は、すべて「<span class="ascii">Win32 API</span>」と呼ばれる<span class="ascii">Windows</span>固有の<span class="ascii">API</span>群の一部です。<br />
この「<span class="ascii">Win32 API</span>」に含まれる関数の多くは、「ユニコード版」とそうでないものに分かれます<small>（詳細は<a href="https://msdn.microsoft.com/ja-jp/library/windows/desktop/dd317766(v=vs.85).aspx"><span class="ascii">Conventions for Function Prototypes (Windows)</span></a>をご覧ください）</small>。</p>
<p>このうち、「ユニコード版」の<span class="ascii">API</span>には、この制限を緩和する専用の機能が含まれています。<br />
先ほども触れた<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247%20(v=vs.85)#maxpath"><span class="ascii">MSDN</span>のページ</a>曰く、なんと<code>\\?\</code>という変な文字列を絶対パスの頭に着けると、最大約<span class="ascii">32,767</span>文字のパスまで受け付けるようになるというのです！<br />
なんともアドホックな感じのする解決方法ですが、<span class="ascii">Microsoft</span>が言うんだから間違いありません。<br />
いずれにしても<span class="ascii">32,767</span>文字という微妙な最大文字数ができてしまいますが、<span class="ascii">UTF-16</span>での<span class="ascii">32,767</span>文字なので、そう簡単に超えることはないでしょう。<br />
いちいち絶対パスに変えて変なプレフィックスを加えないといけないという面倒くささはありますが、いちいち分割して相対パスに変換するよりは簡単なはずですので、検討する価値があります。</p>
<p>この、<code>\\?\</code>機能を試す場合、下記のコードを適当なファイルに貼り付けて保存し、<code>stack runghc file.hs</code>などと実行してみてください <span class="ascii">(Thanks,</span> <span class="citation" data-cites="matsubara0507"><span class="ascii">@matsubara0507</span></span><span class="ascii">!)</span>。<br />
<code>catch</code>関数を使って例外を捕捉している箇所では、実際にパスが長すぎるためにエラーが発生し、<code>catch</code>されているはずです。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">import</span>           <span class="dt">Control.Exception</span> (catch, <span class="dt">IOException</span>)</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="kw">import</span>           <span class="dt">Data.List</span>        (replicate)</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">import</span>           <span class="dt">System.Directory</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  crDir <span class="ot">&lt;-</span> getCurrentDirectory</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">    path1 <span class="fu">=</span> mconcat <span class="fu">$</span> replicate <span class="dv">20</span> <span class="st">&quot;abcdefgh/&quot;</span> <span class="co">-- ok</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">    path2 <span class="fu">=</span> mconcat <span class="fu">$</span> replicate <span class="dv">30</span> <span class="st">&quot;abcdefgh/&quot;</span> <span class="co">-- error</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">    path3 <span class="fu">=</span> crDir <span class="fu">++</span> <span class="st">&quot;/&quot;</span> <span class="fu">++</span> path2 <span class="co">-- error</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12">    path4 <span class="fu">=</span> <span class="st">&quot;\\\\?\\&quot;</span> <span class="fu">++</span> path3 <span class="co">-- ok</span></a>
<a class="sourceLine" id="cb2-13" data-line-number="13"></a>
<a class="sourceLine" id="cb2-14" data-line-number="14">  putStrLn <span class="fu">$</span> <span class="st">&quot;path1: &quot;</span> <span class="fu">++</span> show path1</a>
<a class="sourceLine" id="cb2-15" data-line-number="15">  createDirectoryIfMissing <span class="dt">True</span> path1</a>
<a class="sourceLine" id="cb2-16" data-line-number="16"></a>
<a class="sourceLine" id="cb2-17" data-line-number="17">  putStrLn <span class="fu">$</span> <span class="st">&quot;path2: &quot;</span> <span class="fu">++</span> show path2</a>
<a class="sourceLine" id="cb2-18" data-line-number="18">  createDirectoryIfMissing <span class="dt">True</span> path2 <span class="ot">`catch`</span> (\e <span class="ot">-&gt;</span> putStrLn <span class="fu">$</span> <span class="st">&quot;  &quot;</span> <span class="fu">++</span> show (<span class="ot">e ::</span> <span class="dt">IOException</span>))</a>
<a class="sourceLine" id="cb2-19" data-line-number="19"></a>
<a class="sourceLine" id="cb2-20" data-line-number="20">  putStrLn <span class="fu">$</span> <span class="st">&quot;path3: &quot;</span> <span class="fu">++</span> show path3</a>
<a class="sourceLine" id="cb2-21" data-line-number="21">  createDirectoryIfMissing <span class="dt">True</span> path3 <span class="ot">`catch`</span> (\e <span class="ot">-&gt;</span> putStrLn <span class="fu">$</span> <span class="st">&quot;  &quot;</span> <span class="fu">++</span> show (<span class="ot">e ::</span> <span class="dt">IOException</span>))</a>
<a class="sourceLine" id="cb2-22" data-line-number="22"></a>
<a class="sourceLine" id="cb2-23" data-line-number="23">  putStrLn <span class="fu">$</span> <span class="st">&quot;path4: &quot;</span> <span class="fu">++</span> show path4</a>
<a class="sourceLine" id="cb2-24" data-line-number="24">  createDirectoryIfMissing <span class="dt">True</span> path4</a></code></pre></div>
<h1 id="おわりに"><span class="link-to-here-outer"><a href="#おわりに" title="おわりに"><span class="link-to-here">Link to<br />
here</span></a></span>おわりに</h1>
<p>さて、またしても<span class="ascii">Windows</span>固有の面倒な問題を紹介することとなってしまいましたが、俗世の喜び（主にゲーム）と簡単にインストールできる<span class="ascii">GUI</span>に慣らされてしまった私は、今後も<span class="ascii">Windows</span>を使い続けるつもりです。<br />
いろいろ困難は尽きませんがこれからも<span class="ascii">Windows</span>で<span class="ascii">Happy Haskell Life</span>を！🏁🏁🏁</p>
<h1 id="参考url"><span class="link-to-here-outer"><a href="#参考url" title="参考url"><span class="link-to-here">Link to<br />
here</span></a></span>参考<span class="ascii">URL</span></h1>
<p>※本文中で言及していないもののみ</p>
<ul>
<li><a href="http://kkamegawa.hatenablog.jp/entry/2016/07/27/220014">プログラマ的に<span class="ascii">Windows 10 Anniversary Update</span>のうれしいところ <span class="ascii">- kkamegawa</span>’<span class="ascii">s weblog</span></a></li>
<li><a href="https://superuser.com/questions/1119883/windows-10-enable-ntfs-long-paths-policy-option-missing"><span class="ascii">Windows 10</span> “<span class="ascii">Enable NTFS long paths policy</span>” <span class="ascii">option missing - Super User</span></a></li>
</ul>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2018/renew-haskell-antenna.html" lang="ja">Haskell Antenna をリニューアルしました</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2018/topic-request.html" style="margin-left: auto;" lang="ja">Haskell-jp Blogで書いてほしいネタを募集します！</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>Haskell-jp Blogで書いてほしいネタを募集します！</title>
    <link href="https://haskell.jp/blog/posts/2018/topic-request.html" />
    <id>https://haskell.jp/blog/posts/2018/topic-request.html</id>
    <published>2018-02-18T00:00:00Z</published>
    <updated>2018-02-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p><span class="ascii">Haskell-jp Blog</span>では、設立当初より<span class="ascii">Haskell</span>に関する記事を幅広く募集してきました。<br />
このたびはそれに加え、この<span class="ascii">Haskell-jp Blog</span>で「書いて欲しい！」「読んでみたい！」<span class="ascii">Haskell</span>に関する話題も募集することにしました！ 例えば、下記のような話題が考えられるでしょう。</p>
<ul>
<li>○○パッケージの解説記事が欲しい</li>
<li>数学用語と<span class="ascii">Haskell</span>用語の対応関係が知りたい</li>
<li><span class="ascii">Real World Haskell</span>を今読むならの注意点</li>
<li>そのほか、<span class="ascii">Haskell</span>に関する話題であれば何でも！</li>
</ul>
<p><strong>ただし、提案していただいたネタに関する知見の持ち主が居ないかもしれませんし、誰かの負担になるものなので必ず記事になるとは限りません。</strong> また、場合によっては既に記事があるため、既存の記事を薦められるかもしれません。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#ネタを提案してくれる場合" title="ネタを提案してくれる場合">ネタを提案してくれる場合</a></li>
<li><a href="#書いてもいいよって場合" title="書いてもいいよって場合">書いてもいいよって場合</a></li>
</ul>
</div>
</div>
<h2 id="ネタを提案してくれる場合"><span class="link-to-here-outer"><a href="#ネタを提案してくれる場合" title="ネタを提案してくれる場合"><span class="link-to-here">Link to<br />
here</span></a></span>ネタを提案してくれる場合</h2>
<p><a href="https://github.com/haskell-jp/blog/issues/new?template=topic-request.md&amp;labels=Topic+Request">この<span class="ascii">Blog</span>のリポジトリの<span class="ascii">Issue</span></a>からお願いします。 既に提案されていたら、その<span class="ascii">Issue</span>に対して 👍 するといいと思います。</p>
<h2 id="書いてもいいよって場合"><span class="link-to-here-outer"><a href="#書いてもいいよって場合" title="書いてもいいよって場合"><span class="link-to-here">Link to<br />
here</span></a></span>書いてもいいよって場合</h2>
<p><code>TopicRequest</code> というラベルを作ったので、<a href="https://github.com/haskell-jp/blog/issues?q=is:issue+is:Aopen+label:%22Topic+Request%22"><span class="ascii">Issue</span>をそのラベルで検索</a>してください。 書いてもいいという提案があった場合は、<span class="ascii">Issue</span>に「書いてもいいよ」という旨をコメントしていただけるとバッティングが無くて助かります。</p>
<p>それでは、今後は<span class="ascii">Haskell</span>に関するあなたの記事だけでなく、あなたが<span class="ascii">Haskell</span>について読みたい記事も募集していきますので、どしどし応募してください！ 🙏</p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2018/windows-long-path.html" lang="ja">WindowsでHaskellを扱う時によく遭遇するNo such file or directoryについて</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2018/ghc-proposal-and-patch.html" style="margin-left: auto;" lang="ja">GHCへの変更提案とパッチ送付の手順例</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>

</feed>
