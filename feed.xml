<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Haskell-jp Blog</title>
    <link href="https://haskell.jp/blog/feed.xml" rel="self" />
    <link href="https://haskell.jp/blog" />
    <id>https://haskell.jp/blog/feed.xml</id>
    <author>
        <name>Haskell-jp</name>
        <email></email>
    </author>
    <updated>2019-07-08T00:00:00Z</updated>
    <entry>
    <title>strip-ansi-escapeというパッケージをリリースしました</title>
    <link href="https://haskell.jp/blog/posts/2019/strip-ansi-escape.html" />
    <id>https://haskell.jp/blog/posts/2019/strip-ansi-escape.html</id>
    <published>2019-07-08T00:00:00Z</published>
    <updated>2019-07-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>現職で<span class="ascii">Haskell</span>を仕事で書き始めるようになってからというもの、度々小さなパッケージをリリースするようになりました。<br />
敢えてパッケージにするほどのものでもなさそうなぐらい小さなものが多いですが、もし再利用したくなったらな、という気持ちで書いております。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#なに作ったか" title="なに作ったか">なに作ったか</a></li>
<li><a href="#なぜ作ったか" title="なぜ作ったか">なぜ作ったか</a></li>
<li><a href="#最近のmmlh" title="最近のmmlh">最近の<span class="ascii">mmlh</span></a></li>
</ul>
</div>
</div>
<h1 id="なに作ったか"><span class="link-to-here-outer"><a href="#なに作ったか" title="なに作ったか"><span class="link-to-here">Link to<br />
here</span></a></span>なに作ったか</h1>
<p><a href="http://hackage.haskell.org/package/strip-ansi-escape"><span class="ascii">strip-ansi-escape</span></a>というパッケージです。<br />
今回もメインの処理は<span class="ascii">100</span>行にも満たないような小さなもので、また用途もニッチです。<br />
具体的には、名前のとおり<a href="https://en.wikipedia.org/wiki/ANSI_escape_code"><span class="ascii">ANSI</span>エスケープコード</a>を文字列から取り除く、ただそれだけです。<br />
使い方も極めてシンプル<span class="ascii">:</span></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1">ghci<span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">Data.String.AnsiEscapeCodes.Strip.Text</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="co">-- 現状Text型向けにしか作っていないため、OverloadedStringsを有効にした方が使いやすい</span></a>
<a class="sourceLine" id="cb1-4" title="4">ghci<span class="op">&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XOverloadedStrings</span></a>
<a class="sourceLine" id="cb1-5" title="5">ghci<span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">Data.Text</span></a>
<a class="sourceLine" id="cb1-6" title="6"></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="co">-- 出力すると下線付きで &quot;hello&quot; と表示されるANSIエスケープコード付きの文字列</span></a>
<a class="sourceLine" id="cb1-8" title="8">ghci<span class="op">&gt;</span> <span class="st">&quot;\x001B[4mhello\x001B[0m&quot;</span></a>
<a class="sourceLine" id="cb1-9" title="9"><span class="st">&quot;\ESC[4mhello\ESC[0m&quot;</span></a>
<a class="sourceLine" id="cb1-10" title="10"></a>
<a class="sourceLine" id="cb1-11" title="11">ghci<span class="op">&gt;</span> stripAnsiEscapeCodes <span class="st">&quot;\x001B[4mhello\x001B[0m&quot;</span></a>
<a class="sourceLine" id="cb1-12" title="12"><span class="st">&quot;hello&quot;</span></a></code></pre></div>
<h1 id="なぜ作ったか"><span class="link-to-here-outer"><a href="#なぜ作ったか" title="なぜ作ったか"><span class="link-to-here">Link to<br />
here</span></a></span>なぜ作ったか</h1>
<p>通常我々が<span class="ascii">ANSI</span>エスケープコードを扱うときは、<strong>ユーザーのために</strong>端末に文字列を分かりやすく表示したいときで、それをプログラムで再利用することは想定していません。<br />
そのため<span class="ascii">ANSI</span>エスケープコードを出力できるアプリケーションは、大抵の場合出力しないよう設定できる<small>（あるいは、出力先が<span class="ascii">tty</span>でないことを検出して出力しない）</small>ようになっています。<br />
なので、プログラムが<span class="ascii">ANSI</span>エスケープコードの混ざった文字列を扱わざるを得ない、という事態は、何かがおかしい事態だと言えるでしょう。</p>
<p>一体どういう事態なのかというと、それは私がずっと開発中の、対話的<span class="ascii">Haskell</span>入門コンテンツ — <a href="https://github.com/haskell-jp/makeMistakesToLearnHaskell">「失敗しながら学ぶ<span class="ascii">Haskell</span>入門」</a> — で出遭った事態でした。<br />
「失敗しながら学ぶ<span class="ascii">Haskell</span>入門」（以下、英語名を略して「<span class="ascii">mmlh</span>」と呼びます）では、ユーザーが書いた<span class="ascii">Haskell</span>のソースコードを受け取って、<span class="ascii">GHC</span>にコンパイルさせることで、型エラーなどのエラーメッセージを取得しています。<br />
当初から<span class="ascii">mmlh</span>はそれを簡単にパースしてユーザーへのヒントを出すのに使ったり、ユーザーにそのまま表示したりするのに使うため、<code>-fdiagnostics-color=always</code>というオプションを<span class="ascii">GHC</span>に渡していました。<br />
これは、エラーメッセージに色を着けるようになった<span class="ascii">GHC 8.2</span>から導入されたオプションで、「エラーメッセージに必ず<small>（<span class="ascii">ANSI</span>エスケープコードを使って）</small>色を着ける」というものです。<br />
<span class="ascii">GHC</span>が出すエラーメッセージを「簡単にパース」しつつ「ユーザーにそのまま表示」する、という<span class="ascii">2</span>つの要件を満たすためには、このオプションを利用して、強制的にエラーメッセージに色を着ける必要がありました。</p>
<p>さらに最近、<span class="ascii">GHC</span>が出したエラーメッセージをファイルに保存して、<a href="https://github.com/haskell-jp/makeMistakesToLearnHaskell/issues/101"><span class="ascii">GitHub</span>で閲覧できるようにする</a><small>（正確には、閲覧して各行にコメントできるようにする）</small>、という機能も追加した結果、<span class="ascii">ANSI</span>エスケープコードを取り除かざるを得なくなってしまったのです。<br />
というのも、<code>-fdiagnostics-color=always</code>を有効にしている限り、<span class="ascii">GHC</span>は必ず<span class="ascii">ANSI</span>エスケープコードをエラーメッセージに混ぜるので、ファイルに保存して<span class="ascii">GitHub</span>上で表示する際、下記のように余計な文字として混ざってしまい、エラーメッセージが読みづらくなってしまうためです。</p>
<pre><code>�[;1m16.hs:19:18: �[;1m�[31merror:�[0m�[0m�[;1m�[0m�[0m�[;1m
    • No instance for (Num ([Char], String))
        arising from a use of ‘countWords’
    • In the expression: countWords (concat wordsList)
      In an equation for ‘countMap’:
          countMap = countWords (concat wordsList)
      In the expression:
        do paths &lt;- getArgs
           wordsList &lt;- for paths scrapeWords
           let countMap = countWords (concat wordsList)
           for_ (toList countMap) catCount�[0m�[0m
�[;1m�[34m   |�[0m�[0m
�[;1m�[34m19 |�[0m�[0m   let countMap = �[;1m�[31mcountWords (concat wordsList)�[0m�[0m
�[;1m�[34m   |�[0m�[0m�[;1m�[31m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^�[0m�[0m
�[0m�[0m�[0m</code></pre>
<p><code>-fdiagnostics-color=always</code>を有効にしなければこんな問題は起こらないのですが、そうすると今度はユーザーにエラーメッセージを表示させる際、色が着かなくなってしまいます。<br />
せっかく<span class="ascii">GHC 8.2</span>以降を使っているのに色つきのエラーメッセージが見られないのは残念ですよね。<br />
<span class="ascii">GHC</span>を<span class="ascii">2</span>回実行することで、ユーザーに表示する用のエラーメッセージとファイルに保存する用のエラーメッセージを分けることもできますが、それでは効率が悪いでしょうし。</p>
<p>そんなわけで、<span class="ascii">GHC</span>が出力するエラーメッセージを<strong>ユーザーに端末上で表示する用途と、<span class="ascii">ANSI</span>エスケープコードを解釈しない箇所で表示する用途</strong>、両方に使用したくなったため、今回敢えて<span class="ascii">ANSI</span>エスケープコードを取り除くライブラリーを作りました。<br />
もし他に同じような事態に出遭った方がいらっしゃいましたら、試してみてください🙏</p>
<h1 id="最近のmmlh"><span class="link-to-here-outer"><a href="#最近のmmlh" title="最近のmmlh"><span class="link-to-here">Link to<br />
here</span></a></span>最近の<span class="ascii">mmlh</span></h1>
<p>ついでにここ数ヶ月弊社でやっている、<span class="ascii">mmlh</span>を使った社内勉強会のお話も書こうかと思いましたが、やっぱり社内でのことなんで、<a href="https://eng-blog.iij.ad.jp/">会社のブログ</a>に書くことにします。<br />
多分今週中には上げますので乞うご期待！</p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/asterius.html" style="margin-left: auto;" lang="ja">AsteriusでHaskellの関数をJSから呼べるようにしてみた（けど失敗）（拡大版）</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>AsteriusでHaskellの関数をJSから呼べるようにしてみた（けど失敗）（拡大版）</title>
    <link href="https://haskell.jp/blog/posts/2019/asterius.html" />
    <id>https://haskell.jp/blog/posts/2019/asterius.html</id>
    <published>2019-05-04T00:00:00Z</published>
    <updated>2019-05-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>先日、<a href="https://emsn.connpass.com/event/121028/"><span class="ascii">Emscripten &amp; WebAssembly night !! #7</span></a>というイベントにて、<a href="https://tweag.github.io/asterius/"><span class="ascii">Asterius</span></a>という<span class="ascii">Haskell</span>を<span class="ascii">WebAssembly</span>にコンパイルするツールについて紹介いたしました。<br />
資料はこちら👇です。</p>
<p><a href="https://the.igreque.info/slides/2019-04-19-asterius.html#(1)"><span class="ascii">Asterius</span>で<span class="ascii">Haskell</span>の関数を<span class="ascii">JS</span>から呼べるようにしてみた（けど失敗）</a></p>
<p>本日は、スライドの英語で書いていた箇所を和訳しつつ、いろいろ捕捉してブログ記事の形で共有します。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#asteriusとは何か" title="asteriusとは何か">🔍<span class="ascii">Asterius</span>とは何か</a></li>
<li><a href="#asteriusのいいところ" title="asteriusのいいところ">👍<span class="ascii">Asterius</span>のいいところ</a></li>
<li><a href="#asteriusのイマイチなところ" title="asteriusのイマイチなところ">👎<span class="ascii">Asterius</span>のイマイチなところ</a></li>
<li><a href="#asteriusの仕組み" title="asteriusの仕組み">⚙️<span class="ascii">Asterius</span>の仕組み</a></li>
<li><a href="#asteriusでhaskell製の関数を実行してみた" title="asteriusでhaskell製の関数を実行してみた"><span class="ascii">Asterius</span>で<span class="ascii">Haskell</span>製の関数を実行してみた</a>
<ul>
<li><a href="#結果" title="結果">結果</a></li>
</ul></li>
<li><a href="#おわりに" title="おわりに">✅おわりに</a></li>
</ul>
</div>
</div>
<h1 id="asteriusとは何か"><span class="link-to-here-outer"><a href="#asteriusとは何か" title="asteriusとは何か"><span class="link-to-here">Link to<br />
here</span></a></span>🔍<span class="ascii">Asterius</span>とは何か</h1>
<p>冒頭でも触れたとおり、<a href="https://tweag.github.io/asterius/"><span class="ascii">Asterius</span></a>は<span class="ascii">Haskell</span>のソースを<a href="https://developer.mozilla.org/ja/docs/WebAssembly"><span class="ascii">WebAssembly</span></a>にコンパイルするコンパイラーです。<br />
<span class="ascii">GHC</span>の<span class="ascii">HEAD</span><small>（開発中のバージョン）</small>を都度フォークして、現在活発に開発中です。<br />
<span class="ascii">Template Haskell</span>と、<span class="ascii">GHC</span>標準における<span class="ascii">IO</span>を行う関数（の大半）を除いた、すべての機能が利用できるようになっています。<br />
現状の<span class="ascii">WebAssembly</span>を実用する上で必要不可欠であろう、<span class="ascii">FFI</span>もサポートされています。<br />
つまり、<span class="ascii">JavaScript</span>から<span class="ascii">WebAssembly</span>にコンパイルされた<span class="ascii">Haskell</span>の関数を呼んだり、<span class="ascii">Haskell</span>から<span class="ascii">JavaScript</span>の関数を呼ぶことができます！<br />
何かしらの<span class="ascii">IO</span>処理を行う場合は、基本的にこの<span class="ascii">FFI</span>を使って<span class="ascii">JavaScript</span>の関数を呼ぶことになります。</p>
<p>加えて、<code>ahc-cabal</code>という名前のコマンドで、<span class="ascii">cabal</span>パッケージを利用することもできます。<br />
こちらは<code>cabal</code>コマンドの単純なラッパーです。<code>ahc-cabal new-build</code>などと実行すれば、外部のパッケージに依存したアプリケーションも、まとめて<span class="ascii">WebAssembly</span>にコンパイルできます。<br />
本格的に開発する上では欠かせないツールでしょう。</p>
<h1 id="asteriusのいいところ"><span class="link-to-here-outer"><a href="#asteriusのいいところ" title="asteriusのいいところ"><span class="link-to-here">Link to<br />
here</span></a></span>👍<span class="ascii">Asterius</span>のいいところ</h1>
<p><span class="ascii">Asterius</span>は、“<span class="ascii">A linker which performs aggressive dead-code elimination, producing as small WebAssembly binary as possible.</span>”と謳っているとおり、<span class="ascii">GHC</span>のランタイムを抱えているにしては、比較的小さい<span class="ascii">WASM</span>ファイルを生成するそうです。<br />
というわけで手元で試してみたところ、下記のような結果になりました。</p>
<ul>
<li>空っぽのプログラム（<code>main = return ()</code>しかしないソース）<span class="ascii">:</span>
<ul>
<li><span class="ascii">36KB</span>（<code>.wasm</code>ファイルのみ）。なかなかいい感じですね。</li>
<li><span class="ascii">168KB</span>（実行時に必要な<code>.mjs</code>ファイルを含めた合計）。未圧縮でこれなら確かに十分軽いでしょう。<span class="ascii">Webpack</span>などで結合・<span class="ascii">minify</span>するともっと軽くできますし。</li>
</ul></li>
<li>今回私が移植を試みたアプリ（詳細は後ほど）<span class="ascii">:</span>
<ul>
<li><span class="ascii">1.9MB</span>（<code>.wasm</code>ファイルのみ）。うーん、ちょっと苦しいような…😥。</li>
<li><span class="ascii">2.1MB</span>（実行時に必要な<code>.mjs</code>ファイルを含めた合計）。<code>.mjs</code>ファイルの内容は特に変わりませんでした。</li>
</ul></li>
</ul>
<p>ちなみに、移植前の元のソースを含むアプリを、<span class="ascii">Linux 64bit</span>向けの<span class="ascii">ELF</span>ファイルとしてビルドして比較してみたところ、<code>.wasm</code>ファイルよりも少し小さいぐらいでした。<br />
詳細な内訳が気にはなりますが、今のソースですと大体これぐらいが限界なのかも知れません<small>（でも<span class="ascii">WASM</span>は現状<span class="ascii">32bit</span>バイナリー相当のはずだし、もう少し小さくならないものか…）</small>。</p>
<p>加えて、<span class="ascii">Asterius</span>を利用して開発すると、ほぼ最新の<span class="ascii">GHC</span>の開発版が使える、というところも、新しもの好きな<span class="ascii">Haskeller</span>をわくわくさせるところですね！<small>（今回はあいにく新しい機能について調べる余裕もなかったので、特に恩恵は受けてませんが…😅）</small><br />
<span class="ascii">Asterius</span>は、<span class="ascii">GHC</span>をフォークしていくつかの機能を追加して作られているものです。<br />
しかし幸いオリジナルとの差分が十分に小さく、作者が定期的に<span class="ascii">rebase</span>することができています。<br />
詳細な違いは<a href="https://tweag.github.io/asterius/custom-ghc/"><span class="ascii">About the custom GHC fork</span></a>にまとまっています。近い将来<span class="ascii">GHC</span>本体に取り込まれそうな修正ばかりではないかと。</p>
<p>それからこれは、ブラウザーで<span class="ascii">Haskell</span>を動かすことができるという点で<span class="ascii">Asterius</span>の競合に当たる、<span class="ascii">GHCJS</span>と比較した場合の話ですが、<span class="ascii">FFI</span>を利用して、<span class="ascii">JavaScript</span>から<strong>直接</strong><span class="ascii">Haskell</span>を呼ぶことができるようになっているのも、優れた点と言えるでしょう。<br />
<span class="ascii">GHCJS</span>は<a href="https://github.com/ghcjs/ghcjs/blob/3959a9321a2d3e2ad4b8d4c9cc436fcfece99237/doc/foreign-function-interface.md#calling-haskell-from-javascript">こちらのドキュメント曰く</a>、<span class="ascii">JavaScript</span>から<span class="ascii">Haskell</span>を呼ぶ機能は備えてはいるものの、簡単ではないためドキュメントも書かれておらず、推奨されていません。<br />
これでは状況によってはかなり使いづらいでしょう。<br />
今回私が試したように、コアとなる処理だけを<span class="ascii">Haskell</span>の関数として書いて、それを<span class="ascii">JavaScript</span>から呼び出すということができないのです。</p>
<p>一方<span class="ascii">Asterius</span>では、例えば👇のように書くことで、<span class="ascii">WASM</span>がエクスポートする関数として、<code>func</code>を<span class="ascii">JavaScript</span>から呼べるようにすることができます！</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1">foreign export javascript <span class="st">&quot;func&quot;</span><span class="ot"> func ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a></code></pre></div>
<p>ただし、実際に今回試してみたところ、<span class="ascii">Asterius</span>ではまだバグがあったので、この用途では依然使いにくいという状況ではありますが…（詳細は後で触れます）。</p>
<h1 id="asteriusのイマイチなところ"><span class="link-to-here-outer"><a href="#asteriusのイマイチなところ" title="asteriusのイマイチなところ"><span class="link-to-here">Link to<br />
here</span></a></span>👎<span class="ascii">Asterius</span>のイマイチなところ</h1>
<p><span class="ascii">Asterius</span>は、やっぱりまだまだ開発中で、バグが多いです。<br />
今回の目的もバグのために果たせませんでした😢。</p>
<p>先ほども触れたとおり、特に未完成なのが、<span class="ascii">IO</span>と<span class="ascii">Template Haskell</span>です。<br />
<span class="ascii">GHC</span>なら使えるはずの<code>IO</code>な関数の多くが使えませんし、<span class="ascii">Template Haskell</span>に至っては一切利用できません。</p>
<p><span class="ascii">IO</span>については、現状、<small>（<code>putStrLn</code>などのよく使われる）</small>一部を除き、<span class="ascii">FFI</span><small>（<code>foreign import javascript</code>）</small>を使って<span class="ascii">JavaScript</span>の関数経由でよばなけれなりません。<br />
これは、入出力関連の<span class="ascii">API</span>を一切持たないという現状の<span class="ascii">WebAssembly</span>の事情を考えれば、致し方ない仕様だとも言えます。<br />
<a href="https://github.com/WebAssembly/WASI"><span class="ascii">WASI</span></a>の策定によってこの辺の事情が変わるまでの間に、すべて<code>foreign import javascript</code>で賄うというのも、なかなか面倒なことでしょうし。</p>
<p><span class="ascii">Template Haskell</span>に関しては、現在<a href="https://github.com/tweag/asterius/pull/81">こちらのブランチ</a>で開発中です。…と、思ったらこの<span class="ascii">Pull request</span>、<span class="ascii">Close</span>されてますね…。<br />
これに関して詳しい事情はわかりません。いずれにしても、<span class="ascii">Template Haskell</span>を実装するには、コンパイル時にその場で<span class="ascii">Haskell</span>を評価するためのインタープリターが別途必要だったりして、結構ハードルが高いのです。</p>
<p>加えて、<span class="ascii">RTS</span><small>（この場合、コンパイルした<span class="ascii">Haskell</span>を動かすのに必要な<span class="ascii">WASM</span>や<span class="ascii">JavaScript</span>ファイル）</small>が<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/BigInt"><code>BigInt</code></a>に依存している関係で、<span class="ascii">V8</span>や<span class="ascii">SpiderMonkey</span>でないと動かない点もまだまだ、という感じです。<br />
ブラウザーで言うと、<span class="ascii">2019</span>年<span class="ascii">5</span>月<span class="ascii">3</span>日時点で<span class="ascii">Chrome</span>か、<span class="ascii">Firefox</span>の<span class="ascii">Beta</span>版以降でないと使用できません<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>。</p>
<h1 id="asteriusの仕組み"><span class="link-to-here-outer"><a href="#asteriusの仕組み" title="asteriusの仕組み"><span class="link-to-here">Link to<br />
here</span></a></span>⚙️<span class="ascii">Asterius</span>の仕組み</h1>
<p><span class="ascii">Asterius</span>のドキュメント「<a href="https://tweag.github.io/asterius/ir/"><span class="ascii">IR types and transformation passes</span></a>」をざっくり要約してみると、<span class="ascii">Asterius</span>は以下のような流れで動くそうです。<br />
実際には<code>ahc-link</code>というコマンドがこれらの手順をまとめて実行するので、ユーザーの皆さんはあまり意識する必要はないでしょう。</p>
<ol type="1">
<li><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/extending_ghc.html#frontend-plugins">フロントエンドプラグイン</a>という仕組みでラップした<span class="ascii">GHC</span><small>（のフォーク）</small>を使い、<span class="ascii">GHC</span>が生成した<span class="ascii">Cmm</span>という中間言語で書かれたコードを、<code>AsteriusModule</code>という独自のオブジェクトに変換します。</li>
<li><code>ahc-ld</code>という専用のリンカーで、<span class="ascii">WASM</span>向けにリンクします。</li>
<li>最後に、<code>ahc-dist</code>というコマンドで、リンクしたモジュールを実行できる状態にします。
<ul>
<li><a href="https://github.com/WebAssembly/binaryen"><span class="ascii">binaryen</span></a>か、<a href="https://github.com/tweag/asterius/tree/master/wasm-toolkit"><span class="ascii">wasm-toolkit</span></a>という<span class="ascii">Haskell</span>で<span class="ascii">WASM</span>を書く言語内<span class="ascii">DSL</span>を利用して、<code>ahc-ld</code>がリンクしたモジュールを検証し、<code>.wasm</code>ファイルに変換して、</li>
<li>実行時に必要な<span class="ascii">JavaScript</span>ファイルをコピーして、</li>
<li><span class="ascii">Haskell</span>のソースにおける<code>main</code>関数を実行する、エントリーモジュールを作ります。<br />
あとはこれを<span class="ascii">HTML</span>ファイルから<code>&lt;script&gt;</code>タグで参照すれば、ブラウザー上で<span class="ascii">Haskell</span>が動きます。</li>
</ul></li>
</ol>
<h1 id="asteriusでhaskell製の関数を実行してみた"><span class="link-to-here-outer"><a href="#asteriusでhaskell製の関数を実行してみた" title="asteriusでhaskell製の関数を実行してみた"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Asterius</span>で<span class="ascii">Haskell</span>製の関数を実行してみた</h1>
<p>ここからは、私が以前作った<a href="https://github.com/igrep/igrep-cashbook/tree/master/hs2">アプリケーション</a>のコアに当たる関数を<span class="ascii">Asterius</span>でコンパイルすることで、ブラウザー上で動かせるようチャレンジした時の体験談を紹介します。</p>
<p>今回試みたアプリケーションは、単純なコマンドラインアプリケーションです。<br />
詳細は省きますが、行単位で書かれたファイルをパースして、項目ごとの合計を計算するだけの、ありふれたものです。<br />
パーサーは<a href="http://hackage.haskell.org/package/megaparsec"><span class="ascii">megaparsec</span></a>を使って作り、整数の四則演算ができるようなっているのも特徴です。<br />
そのアプリケーションの処理のほとんどすべてに当たる、ファイル名とその中身を受け取って、計算結果を文字列で返す関数（<code>FilePath -&gt; Text -&gt; Text</code>）を、<span class="ascii">FFI</span>でエクスポート<small>（<code>foreign export javascript</code>）</small>し、<span class="ascii">JavaScript</span>から呼べるようにしてみました。</p>
<p>アプリケーション自体の書き換えはほとんど必要なかったものの、依存関係を減らしたり、依存するパッケージを書き換えたりするのが大変でした。<br />
というのも、先ほど触れたとおり、<span class="ascii">Asterius</span>は現状「<span class="ascii">Template Haskell</span>と、<span class="ascii">GHC</span>標準における<span class="ascii">IO</span>を行う関数（の大半）」が一切使用できないので、取り除かなければコンパイルエラーになってしまいます。<br />
<span class="ascii">template-haskell</span>パッケージに間接的に依存しているだけで依存関係の解決すらできないのはなかなかつらいものでした。<br />
<a href="https://docs.haskellstack.org/en/stable/dependency_visualization/"><code>stack dot</code></a>コマンドを使って依存関係のツリーを作り、それを見て<span class="ascii">template-haskell</span>パッケージに間接的に依存しているパッケージを割り出し、そのパッケージの必要な関数のみを切り出すことでどうにか回避できました。<br />
<a href="http://hackage.haskell.org/package/monoidal-containers"><span class="ascii">monoidal-containers</span></a>パッケージと<a href="http://hackage.haskell.org/package/foldl"><span class="ascii">foldl</span></a>パッケージがそれでした。<br />
幸い、どちらも依存しているのはごく一部だったで、必要な部分だけをコピペして使うことにしました。<br />
それから、<code>IO</code>への依存もなくすために、<a href="http://hackage.haskell.org/package/text"><span class="ascii">text</span></a>パッケージから<code>*.IO</code>なモジュールを取り除いたりもしました。</p>
<p>当然、元々のアプリケーションも<span class="ascii">text</span>パッケージの<code>*.IO</code>なモジュールを使ってはいたので、それを使わないよう修正する必要がありました。<br />
しかしそこは<span class="ascii">Haskell</span>。そうした<code>IO</code>に依存した関数から純粋な関数を切り出すのは、型システムのおかげで大変楽ちんでした！😤<br />
入出力をするのに<span class="ascii">JavaScript</span>の<span class="ascii">FFI</span>を使わないといけない、という現状の<span class="ascii">WebAssembly</span>の制約が、偶然にもマッチしたわけですね！<br />
純粋じゃない関数はときめかないので捨て去ってしまいましょう✨</p>
<h2 id="結果"><span class="link-to-here-outer"><a href="#結果" title="結果"><span class="link-to-here">Link to<br />
here</span></a></span>結果</h2>
<p>ここまで頑張った結果、目的の関数を<code>foreign export javascript</code>してコンパイルを通すことはできました🎉<br />
しかし、実際にブラウザー上で動かしてみたところ、<a href="https://github.com/tweag/asterius/issues/105"><span class="ascii">Asterius</span>の<span class="ascii">FFI</span>のバグ</a>にハマってしまいました…😢 肝心の<code>foreign export javascript</code>した関数が、返すべき値を返してくれないのです！<br />
恐らく<code>foreign export javascript</code>を使わずに、<span class="ascii">Haskell</span>側から<span class="ascii">JavaScript</span>の関数を呼ぶようにしていれば、今回の問題は回避できたのではないかと思います。<br />
しかし、それは今回のゴールではありませんし、あまり便利ではないのでひとまず移植は見送ることにしました。残念！</p>
<h1 id="おわりに"><span class="link-to-here-outer"><a href="#おわりに" title="おわりに"><span class="link-to-here">Link to<br />
here</span></a></span>✅おわりに</h1>
<p>今回<span class="ascii">Asterius</span>を試したことで、ブラウザー上で<span class="ascii">Haskell</span>を動かす、もう一つの可能性を知ることができました。<br />
とは言え、バグが多かったり依存関係から<span class="ascii">IO</span>や<span class="ascii">Template Haskell</span>を抜き出さなければならなかったりで、まだまだ実用的とは言い難いでしょう。<br />
しかし、今回報告したバグが直れば、ブラウザーによる処理のコアに当たる部分を<span class="ascii">Haskell</span>で書く、という応用が利きそうです。<br />
例えば<span class="ascii">Pandoc</span>など<span class="ascii">Haskell</span>製アプリケーションをブラウザーから操作する、なんてアプリケーション作りが捗りそうですね！</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="https://caniuse.com/#feat=bigint"><span class="ascii">Can I use</span></a>曰く安定版でも<code>about:config</code>を書き換えればすでに使えるとのことなんですが、なぜか手元の<span class="ascii">Firefox</span> 安定版ではうまくいきませんでした。確かに<code>about:config</code>にそれらしき設定はあるものの、<code>true</code>にしても何も変わらず…😰。<br />
ついでに細かいことを言うと、<span class="ascii">Firefox Nightly</span>は<code>about:config</code>を書き換えなくても使え、<span class="ascii">Beta</span>版では<code>about:config</code>を書き換えると使えました。<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/strip-ansi-escape.html" lang="ja">strip-ansi-escapeというパッケージをリリースしました</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/stack-ghc8.8.html" style="margin-left: auto;" lang="ja">GHC 8.8.1 alphaをstackでダウンロードして手持ちのパッケージをビルドする</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>GHC 8.8.1 alphaをstackでダウンロードして手持ちのパッケージをビルドする</title>
    <link href="https://haskell.jp/blog/posts/2019/stack-ghc8.8.html" />
    <id>https://haskell.jp/blog/posts/2019/stack-ghc8.8.html</id>
    <published>2019-05-02T00:00:00Z</published>
    <updated>2019-05-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>先日、我らが<span class="ascii">Haskell</span>のデファクトスタンダードなコンパイラー、<a href="https://mail.haskell.org/pipermail/ghc-devs/2019-April/017550.html"><span class="ascii">GHC</span>のバージョン<span class="ascii">8.8.1-alpha1</span>がリリースされました</a>。<br />
このリリースはまだアルファ版であることからわかるとおり、主にテスト目的で使用するためのものです。<br />
なのでいち早く試してみて、<span class="ascii">GHC</span>のデバッグに貢献してみましょう。</p>
<p>そこで今回は、最近<span class="ascii">Haskell</span>を始めた方なら使っている方も多いであろう、<span class="ascii">stack</span>を使ってこの新しい<span class="ascii">GHC</span>をインストールし、あなたのライブラリー・アプリケーションでテストする方法を紹介いたします。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#tldr-cabal-installでやったほうがよさそう" title="tldr-cabal-installでやったほうがよさそう"><span class="ascii">TL;DR cabal-install</span>でやったほうがよさそう</a></li>
<li><a href="#setup-infoを作る" title="setup-infoを作る"><span class="ascii">1.</span> <code>setup-info</code>を作る</a></li>
<li><a href="#必要ならallow-newerを有効にする" title="必要ならallow-newerを有効にする"><span class="ascii">2.</span> （必要なら）<span class="ascii">allow-newer</span>を有効にする</a></li>
<li><a href="#package-indicesを設定してhead.hackageを利用できるようにする" title="package-indicesを設定してhead.hackageを利用できるようにする"><span class="ascii">3. package-indices</span>を設定して、<span class="ascii">head.hackage</span>を利用できるようにする</a></li>
<li><a href="#stack-buildを実行しつつひたすらextra-depsを追加編集" title="stack-buildを実行しつつひたすらextra-depsを追加編集"><span class="ascii">4. stack build</span>を実行しつつ、ひたすら<span class="ascii">extra-deps</span>を追加・編集</a>
<ul>
<li><a href="#それでもうまくいかない場合-extra-depsを使い倒す" title="それでもうまくいかない場合-extra-depsを使い倒す">それでもうまくいかない場合<span class="ascii">:</span> <code>extra-deps</code>を使い倒す</a>
<ul>
<li><a href="#自分以外の人が対象のパッケージを修正した場合" title="自分以外の人が対象のパッケージを修正した場合">自分以外の人が対象のパッケージを修正した場合<span class="ascii">:</span></a></li>
<li><a href="#自分で対象のパッケージを修正するという場合" title="自分で対象のパッケージを修正するという場合">自分で対象のパッケージを修正する、という場合<span class="ascii">:</span></a></li>
<li><a href="#対象のパッケージがgitリポジトリーで管理されてない場合は" title="対象のパッケージがgitリポジトリーで管理されてない場合は">対象のパッケージが<span class="ascii">Git</span>リポジトリーで管理されてない場合は？</a></li>
</ul></li>
</ul></li>
<li><a href="#番外編-operation-vanguard" title="番外編-operation-vanguard">番外編<span class="ascii">: Operation Vanguard</span></a></li>
</ul>
</div>
</div>
<h1 id="tldr-cabal-installでやったほうがよさそう"><span class="link-to-here-outer"><a href="#tldr-cabal-installでやったほうがよさそう" title="tldr-cabal-installでやったほうがよさそう"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">TL;DR cabal-install</span>でやったほうがよさそう</h1>
<p>いきなりやろうとすることを真っ向から否定するようで恐縮ですが…😅<br />
実際に私が試しにビルドしてみた感じ、普通に<a href="https://www.haskell.org/cabal/download.html"><span class="ascii">cabal-install</span>をこちらから</a>インストールして、<code>cabal new-build --with-ghc=ghc-8.8.0.20190424</code>などと実行した方がいいんじゃないかという気がしました…。<br />
<span class="ascii">cabal-install</span>には<span class="ascii">GHC</span>をインストールする機能はないので、その場合は<span class="ascii">GHC</span>は別途インストールすることになります<small>（<a href="https://github.com/haskell/ghcup"><code>ghcup</code></a>が使える？）</small>。<br />
<a href="../2017/06-ghc-install.html"><span class="ascii">@takenobu-hs</span>さんが書いてくれた、こちらの記事</a>を参考にどうぞ！</p>
<p>なお、<span class="ascii">stack</span>でやると面倒な理由についての詳細はこれから述べる手順で適宜触れます…。</p>
<h1 id="setup-infoを作る"><span class="link-to-here-outer"><a href="#setup-infoを作る" title="setup-infoを作る"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">1.</span> <code>setup-info</code>を作る</h1>
<p>まずはじめに、<span class="ascii">stack</span>が<span class="ascii">GHC</span>をインストールする際に参照する、<a href="https://docs.haskellstack.org/en/stable/yaml_configuration/#setup-info"><code>setup-info</code></a>という<span class="ascii">YAML</span>を作りましょう。<br />
<code>setup-info</code>は<code>stack setup</code>や<code>stack build</code>を実行したとき、<span class="ascii">GHC</span>などの必要なソフトウェアがインストールされていなかった際、自動で<span class="ascii">GHC</span>をインストールするために必要な情報です。<br />
<span class="ascii">GHC</span>のバージョンや対象となるプラットフォームごとに、<span class="ascii">GHC</span>のビルド済み<span class="ascii">tarball</span>への<span class="ascii">URL</span>やそのチェックサムが書いてあります。<br />
<span class="ascii">stack</span>はここに書かれた<span class="ascii">URL</span>にアクセスすることで、<span class="ascii">GHC</span>をインストールしているんですね。</p>
<p>デフォルトでは、<span class="ascii">stack</span>は<a href="https://raw.githubusercontent.com/commercialhaskell/stackage-content/master/stack/stack-setup-2.yaml">こちらの<span class="ascii">YAML</span></a>ファイルを<code>setup-info</code>として扱っています。<br />
この<span class="ascii">YAML</span>には<a href="https://www.stackage.org/"><span class="ascii">Stackage</span></a>が参照している、安定版の<span class="ascii">GHC</span>については書いてあるものの、<span class="ascii">LTS Haskell</span>にも<span class="ascii">Stackage Nightly</span>にもまだ採用されていない<span class="ascii">GHC</span>については、書かれていません。<br />
当然アルファ版である<span class="ascii">GHC 8.8.1-alpha1</span>が書かれることはないため、<span class="ascii">GHC 8.8.1-alpha1</span>用の<code>setup-info</code>を作る必要があります。</p>
<p>それでは書いてみましょう… と、言いたいところですが、この<code>setup-info</code>、実際のところ自分で直接書く必要はなく、<span class="ascii">YAML</span>ファイルへの<span class="ascii">URL</span>やパスを指定するだけで<span class="ascii">stack</span>は参照しに行ってくれます！<br />
と、言うわけで、<a href="https://gist.github.com/igrep/7298e1e2515059ae332feaf5501c41a4">こちらに<span class="ascii">GHC 8.8.1-alpha1</span>向けの<code>setup-info</code></a>を作ってアップロードしておきました！<br />
<small>（申し訳なくも<span class="ascii">Linux</span>についてはどう書けばいいかわからず、<span class="ascii">macOS</span>と<span class="ascii">Windows 64bit</span>のみ対応いたしました… あしからず。🙇）</small></p>
<p>ひとまずみなさんは、下記のいずれかの方法で指定するだけでこの手順はクリアできます。</p>
<ul>
<li><p><code>stack.yaml</code>に記載する<span class="ascii">:</span></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb1-1" title="1"><span class="fu">resolver:</span><span class="at"> ghc-8.8</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="fu">setup-info:</span><span class="at"> </span><span class="st">&quot;https://gist.githubusercontent.com/igrep/7298e1e2515059ae332feaf5501c41a4/raw/d69cc0b75d9be6735bdfcca6aa3eb6398d98983f/stack-setup-info.yaml&quot;</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="co"># ... 以下略 ...</span></a></code></pre></div>
<ul>
<li>ビルドしたいプロジェクトや、<span class="ascii">GHC 8.8</span>を試す用のディレクトリーを作って、そこに👆の内容が書かれた<code>stack.yaml</code>を置きましょう。<br />
ちょっと試したいだけならそのディレクトリーで<code>stack exec ghci</code>などと実行すれば<span class="ascii">OK</span>です！</li>
</ul></li>
<li><p><code>stack setup</code>コマンドのオプションとして渡す<span class="ascii">:</span></p>
<pre><code>stack setup 8.8.0.20190424 --setup-info-yaml https://gist.github.com/igrep/7298e1e2515059ae332feaf5501c41a4/raw/d69cc0b75d9be6735bdfcca6aa3eb6398d98983f/stack-setup-info.yaml</code></pre>
<ul>
<li><code>--setup-info-yaml</code>オプションを指定した上で<code>8.8.0.20190424</code>という引数を与えるのがポイントです。<br />
<span class="ascii">GHC</span>の開発版の慣習上、<code>8.8.1-alpha1</code><strong>ではなく</strong><code>8.8.0.20190424</code>となっている点に注意してください！</li>
</ul></li>
</ul>
<p>「<span class="ascii">8.8.1-alpha1</span>じゃなくて、自分でビルドした<span class="ascii">GHC</span>を<code>stack</code>でインストールできるようにしたい！」というマニアなあなたは、<a href="https://gist.github.com/igrep/7298e1e2515059ae332feaf5501c41a4">今回私が作った<code>setup-info</code></a>をどうぞ参考にしてください！🙇</p>
<h1 id="必要ならallow-newerを有効にする"><span class="link-to-here-outer"><a href="#必要ならallow-newerを有効にする" title="必要ならallow-newerを有効にする"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">2.</span> （必要なら）<span class="ascii">allow-newer</span>を有効にする</h1>
<p>ここからは、何かしら依存するパッケージがあるライブラリー・アプリケーションを<span class="ascii">GHC 8.8.1-alpha1</span>で試しにビルドしたいという方向けです。<br />
<span class="ascii">GHC 8.8.1-alpha1</span>をちょっと試したいだけという方はこれ以降を読む必要はありません。</p>
<p>まずは、ひとまず対象となるプロジェクトの<code>stack.yaml</code>に</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb3-1" title="1"><span class="fu">allow-newer:</span><span class="at"> </span><span class="ch">true</span></a></code></pre></div>
<p>を追記しましょう。<br />
これは、依存している<span class="ascii">Cabal</span>パッケージのバージョンの、上限を取っ払うというものです。<br />
依存パッケージのバージョンの上限は、パッケージの開発者が自身のパッケージを確実にビルドできるよう、「このパッケージはあのパッケージのバージョン<span class="ascii">N.M</span><strong>以下</strong>じゃないとビルドできないよ！」と<span class="ascii">Cabal</span>の依存関係リゾルバーに教えてあげるためのものです。<br />
<span class="ascii">cabal-install</span><small>（と、恐らく<span class="ascii">stack</span>も必要に応じて）</small>は、通常であればこの上限を見て、どのバージョンのパッケージをインストールするか決めます。<br />
その上限により、残念ながら依存関係の解決に失敗することがあるのです。<br />
そこでそうしたエラーを避けるためにも<code>allow-newer: true</code>と設定して、上限を無視してみましょう。</p>
<p>というのも、このバージョンの上限はしばしば、予防のために実際より厳しめに設定されることがあるためです<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>。<br />
そりゃそうですよね。今作っているパッケージが依存している<span class="ascii">API</span>が、どのバージョンで使用できなくなるかなんて、大抵のパッケージではわかりませんし。<br />
<span class="ascii">Haskell</span>の世界には<a href="https://pvp.haskell.org/"><span class="ascii">PVP</span></a>という、<a href="https://semver.org/lang/ja/"><span class="ascii">Semantic Versioning</span></a>と似た思想のバージョン変更ポリシーがありまして、<span class="ascii">API</span>の互換性がなくなるような修正が含まれる場合、次のバージョンでは<code>A.B.C</code>の<code>A.B</code>の箇所を変更することになっています。<br />
これを信じて依存バージョンの上限（と下限）を設定してみても、実際にあなたが依存している<span class="ascii">API</span>が使用できなくなるとは限らないのです。</p>
<p>したがって、依存パッケージのバージョンの上限は、実際には無視してもよい場合がしばしばあります。<br />
もちろん、自分で依存パッケージのバージョンを正しく書き換えて対応するというのもアリですし、将来的にはそうした方がより望ましいやり方です。<br />
また、<code>allow-newer: true</code>を設定することにより、<strong><span class="ascii">GHC 8.8</span>とは関係のない原因でビルドが失敗</strong>する可能性がある点にも注意してください。<br />
とは言え、今回は手っ取り早くビルドしてみるために、敢えて<code>allow-newer: true</code>を設定することと致しました。<br />
「私はバージョンの上限を直してみたいんだー！」という方は、是非チャレンジしてみてください。</p>
<h1 id="package-indicesを設定してhead.hackageを利用できるようにする"><span class="link-to-here-outer"><a href="#package-indicesを設定してhead.hackageを利用できるようにする" title="package-indicesを設定してhead.hackageを利用できるようにする"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">3. package-indices</span>を設定して、<span class="ascii">head.hackage</span>を利用できるようにする</h1>
<p><code>stack.yaml</code>に書いておいた方が良い設定がもう一つあります。<br />
それは、<a href="http://head.hackage.haskell.org/"><span class="ascii">HEAD.hackage</span></a>の設定です。</p>
<p>これからビルドするあなたのパッケージは、きっとたくさんのパッケージに依存していることでしょう。<br />
残念ながら、その中には<span class="ascii">GHC 8.8</span>に対応できていないものも数多くあるでしょう😰。<br />
特に今回は<a href="https://scrapbox.io/haskell-shoen/MonadFail"><code>MonadFail</code> <span class="ascii">Proposal</span></a>による、<code>Monad</code>型クラスの仕様変更を適切に周知できていなかったこともあり、まだ多くのパッケージが対応できていないようです。</p>
<p>しかし、まだ希望はあります。<br />
あなたの依存パッケージに対する必要な修正は、すでに<span class="ascii">master</span>ブランチにマージされているかも知れませんし、すでに誰かが<span class="ascii">Pull request</span>を送っているかも知れません。<br />
さらにラッキーな場合、<span class="ascii">HEAD.hackage</span>にパッチを当てたバージョンが上がっていることでしょう！</p>
<p><span class="ascii">HEAD.hackage</span>は、今回のように<span class="ascii">GHC</span>の開発版をいち早く試したい人が、新しい<span class="ascii">GHC</span>に向けて修正を加えたパッケージを、いち早くアップロードするサイトです。<br />
<a href="https://github.com/hvr/head.hackage">こちらのリポジトリー</a>にパッチをアップロードすることで、<span class="ascii">cabal-install</span>や<span class="ascii">stack</span>から、普通の<span class="ascii">hackage</span>にあるパッケージとしてダウンロードできるようにしてくれます。</p>
<p><span class="ascii">HEAD.hackage</span>を<span class="ascii">stack</span>で利用するには、下記のように、<code>package-indices:</code>という設定を、<code>stack.yaml</code>に加えてください。<br />
下記のように記載することで、<span class="ascii">stack</span>は、<span class="ascii">HEAD.hackage</span>にある修正済みのパッケージを優先して取得してくれるようになります<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb4-1" title="1"><span class="fu">package-indices:</span></a>
<a class="sourceLine" id="cb4-2" title="2">  <span class="kw">-</span> <span class="fu">name:</span><span class="at"> head.hackage</span></a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="fu">download-prefix:</span><span class="at"> http://head.hackage.haskell.org/package/</span></a>
<a class="sourceLine" id="cb4-4" title="4">    <span class="fu">http:</span><span class="at"> http://head.hackage.haskell.org/01-index.tar.gz</span></a>
<a class="sourceLine" id="cb4-5" title="5">  <span class="kw">-</span> <span class="fu">name:</span><span class="at"> Hackage</span></a>
<a class="sourceLine" id="cb4-6" title="6">    <span class="fu">download-prefix:</span><span class="at"> https://hackage.haskell.org/package/</span></a>
<a class="sourceLine" id="cb4-7" title="7">    <span class="fu">http:</span><span class="at"> https://hackage.haskell.org/01-index.tar.gz</span></a></code></pre></div>
<p>これで<span class="ascii">GHC 8.8</span>対応済みのパッケージを、簡単に取得できるようになります！</p>
<h1 id="stack-buildを実行しつつひたすらextra-depsを追加編集"><span class="link-to-here-outer"><a href="#stack-buildを実行しつつひたすらextra-depsを追加編集" title="stack-buildを実行しつつひたすらextra-depsを追加編集"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">4. stack build</span>を実行しつつ、ひたすら<span class="ascii">extra-deps</span>を追加・編集</h1>
<p>ここまで設定できたら、いよいよ<code>stack build</code>してみましょう<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>！<br />
とは言え、この状態ではほぼ間違いなく失敗が続くので、<code>stack build --file-watch</code>と、<strong><code>--file-watch</code>オプションを付けて、<code>stack.yaml</code>を編集する度に再度</strong>ビルドが実行されるようにするのをおすすめします。</p>
<p>と、言うのも、恐らく次👇のようなエラーがたくさん出ると思われるからです。</p>
<pre><code>...
In the dependencies for wss-client-0.2.1.1:
    http-client must match &gt;=0.5.13, but the stack configuration has no specified version  (latest
                matching version is 0.6.4)
    http-client-tls needed, but the stack configuration has no specified version  (latest matching
                    version is 0.3.5.3)
    network-uri needed, but the stack configuration has no specified version  (latest matching
                version is 2.6.1.0)
    websockets must match &gt;=0.12.0 &amp;&amp; &lt;0.13, but the stack configuration has no specified version
               (latest matching version is 0.12.5.3)
needed since wss-client is a build target.

Some different approaches to resolving this:

  * Consider trying &#39;stack solver&#39;, which uses the cabal-install solver to attempt to find some
    working build configuration. This can be convenient when dealing with many complicated
    constraint errors, but results may be unpredictable.

  * Recommended action: try adding the following to your extra-deps
    in C:\Users\igrep\Downloads\direct-hs\stack-ghc-8.8.yaml:

attoparsec-0.13.2.2@sha256:6a0baba19991e84ef939056e7b411ad3a1ea0fb5e1e8fce7ca50e96c84b206c8
base-compat-0.10.5@sha256:d49e174ed0daecd059c52d13d4f4de87b5609c81212a22adbb92431f9cd58fff
...</code></pre>
<p>このエラー、見かけたことがある人も多いでしょう。<br />
そう、指定した<span class="ascii">resolver</span><small>（<span class="ascii">stack</span>が使用するパッケージのバージョンの一覧。<span class="ascii">Stackage</span>に登録されている<code>lts-13.12</code>などもその一つ）</small>に、必要なバージョンのパッケージが登録されていない場合に起こるエラーです。<br />
みなさんが普段利用する<code>lts-13.12</code>などの<span class="ascii">resolver</span>では、数多くのパッケージが登録されています<small>（<a href="https://www.stackage.org/lts-13.19">最新版の<span class="ascii">LTS Haskell 13.19</span></a>で<span class="ascii">2346</span>件。<span class="ascii">Stackage</span>をメンテしている皆さんのおかげですね）</small>。</p>
<p>一方、最初の手順で我々が指定した<span class="ascii">resolver</span>、すなわち<code>resolver: ghc-8.8</code>は、<span class="ascii">GHC 8.8</span>に添付されたパッケージ<small>（<code>base</code>パッケージや、<code>array</code>パッケージなど）</small>しか入っていない、実質空っぽな<span class="ascii">resolver</span>なのです<small>（<a href="https://docs.haskellstack.org/en/stable/yaml_configuration/#resolver">参考</a>）</small>。<br />
そのため、あなたが必要なほとんどのパッケージはないため、<span class="ascii">stack</span>はやむなく「<code>extra-deps</code>にこれらのパッケージを追加してね！」というエラーを出すことになります。<br />
これでは<span class="ascii">stack</span>の良さを生かせません…。<span class="ascii">cabal-install</span>で<code>cabal new-build</code>していれば、<span class="ascii">cabal-install</span>は黙って必要なパッケージのバージョンを決定し、あとは<code>cabal new-freeze</code>でもすれば、完全にビルドを再現可能な状態にしてくれます。<br />
やっぱり<span class="ascii">stack</span>はあくまでも<span class="ascii">Stackage</span>を活かすためのツールと捉えた方がいいのかも知れません😥。</p>
<p><code>extra-deps</code>へのパッケージの追記を何度か繰り返すと、ようやくパッケージのビルドが始まります。<br />
<span class="ascii">HEAD.hackage</span>に収録されたパッケージを正しく取得できていれば、現在<span class="ascii">Hackage</span>にアップロードされているバージョンではビルドできない依存パッケージも、無事ビルドできることでしょう。<br />
依存するパッケージの数にもよりますが、やっぱり時間がかかるかと思います。待ちましょう☕️。</p>
<h2 id="それでもうまくいかない場合-extra-depsを使い倒す"><span class="link-to-here-outer"><a href="#それでもうまくいかない場合-extra-depsを使い倒す" title="それでもうまくいかない場合-extra-depsを使い倒す"><span class="link-to-here">Link to<br />
here</span></a></span>それでもうまくいかない場合<span class="ascii">:</span> <code>extra-deps</code>を使い倒す</h2>
<p>しかしやっぱり、必要な変更が施されたパッケージが、<span class="ascii">HEAD.hackage</span>にもアップロードされていない場合はあります。<br />
そうした場合、自分で修正して<small>（<span class="ascii">Pull request</span>を送りつつ）</small>パッチを<a href="https://github.com/hvr/head.hackage"><span class="ascii">HEAD.hackage</span>のリポジトリー</a>にアップロードすることもできますが、<code>stack.yaml</code>の<code>extra-deps</code>を次のように使えば、もっと手っ取り早く修正したバージョンのビルドを試すことができます。</p>
<h3 id="自分以外の人が対象のパッケージを修正した場合"><span class="link-to-here-outer"><a href="#自分以外の人が対象のパッケージを修正した場合" title="自分以外の人が対象のパッケージを修正した場合"><span class="link-to-here">Link to<br />
here</span></a></span>自分以外の人が対象のパッケージを修正した場合<span class="ascii">:</span></h3>
<p>自分以外の人が対象のパッケージを修正したので、すでにどこかのリポジトリーに<span class="ascii">push</span>済みのコミットがある、という場合、下記👇のように書くと、<span class="ascii">Git</span>リポジトリーの特定のコミットを直接参照した状態で、依存関係に加えることができます。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb6-1" title="1"><span class="fu">extra-deps:</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="kw">-</span> <span class="fu">git:</span><span class="at"> https://github.com/github_user/repository_name.git</span></a>
<a class="sourceLine" id="cb6-3" title="3">  <span class="fu">commit:</span><span class="at"> &lt;修正したコミットのSHA&gt;</span></a></code></pre></div>
<h3 id="自分で対象のパッケージを修正するという場合"><span class="link-to-here-outer"><a href="#自分で対象のパッケージを修正するという場合" title="自分で対象のパッケージを修正するという場合"><span class="link-to-here">Link to<br />
here</span></a></span>自分で対象のパッケージを修正する、という場合<span class="ascii">:</span></h3>
<p>そうでない場合、対象のパッケージのリポジトリーを一旦<code>git submodule add</code>して、自分のリポジトリーの一部に含めてしまいましょう。<br />
その上で、<code>extra-deps</code>には下記のように書けば、<span class="ascii">stack</span>はローカルのファイルシステムに置かれたディレクトリーも、直接依存するパッケージとして追加してくれます。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb7-1" title="1"><span class="fu">extra-deps:</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="kw">-</span> ./path/to/package</a></code></pre></div>
<p>逐一別のディレクトリーに<code>git clone</code>して<code>git commit</code>して<code>git push</code>して作られたコミットの<span class="ascii">SHA</span>を参照して… なんてのを繰り返していたら、面倒だからです。</p>
<h3 id="対象のパッケージがgitリポジトリーで管理されてない場合は"><span class="link-to-here-outer"><a href="#対象のパッケージがgitリポジトリーで管理されてない場合は" title="対象のパッケージがgitリポジトリーで管理されてない場合は"><span class="link-to-here">Link to<br />
here</span></a></span>対象のパッケージが<span class="ascii">Git</span>リポジトリーで管理されてない場合は？</h3>
<p>臨機応変に対応しましょう…😰<br />
ちなみに、<a href="https://docs.haskellstack.org/en/stable/yaml_configuration/#git-and-mercurial-repos"><span class="ascii">extra-deps</span>のドキュメント</a>いわく<span class="ascii">stack</span>は<span class="ascii">Mercurial</span>もサポートしています。</p>
<h1 id="番外編-operation-vanguard"><span class="link-to-here-outer"><a href="#番外編-operation-vanguard" title="番外編-operation-vanguard"><span class="link-to-here">Link to<br />
here</span></a></span>番外編<span class="ascii">: Operation Vanguard</span></h1>
<p>以上が<span class="ascii">stack</span>を使った<span class="ascii">GHC 8.8-alpha1</span>のインストール方法や、それを利用したパッケージのビルド手順です。自分で<span class="ascii">GHC</span>をビルドしたときなども参考にしてみてください。<br />
これで終わり…！と、言いたいところですが、<span class="ascii">GHC 8.8</span>に関連して、非常に意欲的なプロジェクト💪を紹介させてください。</p>
<p>それは、<a href="https://github.com/haskell-vanguard/haskell-vanguard"><span class="ascii">Operation Vanguard</span></a>です。<br />
<a href="https://github.com/fumieval/"><span class="ascii">@fumieval</span></a>さんが始めた、「エコシステムの主要なパッケージの最新版を一挙に<span class="ascii">GHC 8.8</span>に対応させる」プロジェクトです。<br />
一旦<span class="ascii">submodule</span>として対象のパッケージのリポジトリーを<span class="ascii">clone</span>する、という方法は、<span class="ascii">Operation Vanguard</span>のリポジトリーを見ていて知りました💡。</p>
<p>すでに対応のほとんどが終了したとのことですが、<span class="ascii">GHC 8.8</span>に対応していないパッケージは恐らくまだたくさんあります。<br />
ゴールデンウィークももう半分が終わりましたが、時間をとって<span class="ascii">Operation Vanguard</span>のようにチャレンジしてみるのはいかがでしょうか💪💪💪</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>もっとも、私のようにものぐさな人間が作るパッケージには、そもそも上限も何も書いてないことが多いのですが…😰<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>本来であれば<span class="ascii">Hackage Security</span>の設定も必要なはずなんですが、なぜかうまくいかず…😱。<a href="https://github.com/commercialhaskell/stack/issues/3844">こちら</a>で紹介された<span class="ascii">workaround</span>にしたがって、関連する設定を除くことにしました…。<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p><code>stack solver</code>コマンドを使えば、この節で紹介するエラーは簡単にクリアできそうだということを聞いて試した<small>（<span class="ascii">Thanks,</span> <a href="https://github.com/mizunashi-mana"><span class="ascii">@mizunashi-mana</span></a>さん！）</small>のですが、手元のパッケージでは依存関係を解決できず、エラーになってしまいました…。<a href="#fnref3" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/asterius.html" lang="ja">AsteriusでHaskellの関数をJSから呼べるようにしてみた（けど失敗）（拡大版）</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/string-gap-for-heredoc-like.html" style="margin-left: auto;" lang="ja">Haskell でも heredoc がしたい</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>Haskell でも heredoc がしたい</title>
    <link href="https://haskell.jp/blog/posts/2019/string-gap-for-heredoc-like.html" />
    <id>https://haskell.jp/blog/posts/2019/string-gap-for-heredoc-like.html</id>
    <published>2019-04-17T00:00:00Z</published>
    <updated>2019-04-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>多くの言語では， <span class="ascii">here document (heredoc)</span> という言語機能が搭載されています．これは，複数行の文字列をコード中に文字列リテラルとして埋め込める機能です．今日は <span class="ascii">heredoc</span> ほど使い勝手がよくないものの，長い文字列を埋め込める， <span class="ascii">Haskell</span> 標準の <span class="ascii">string gap</span> という機能を紹介したいと思います．</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#string-gap" title="string-gap"><span class="ascii">string gap</span></a></li>
<li><a href="#cpp-下での注意事項" title="cpp-下での注意事項"><span class="ascii">CPP</span> 下での注意事項</a></li>
<li><a href="#まとめ" title="まとめ">まとめ</a></li>
</ul>
</div>
</div>
<h2 id="string-gap"><span class="link-to-here-outer"><a href="#string-gap" title="string-gap"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">string gap</span></h2>
<p><span class="ascii">bash</span> では，複数行の文字列を，次の記法で埋め込むことができます<span class="ascii">:</span></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" title="1"><span class="bu">echo</span> <span class="st">&quot;</span><span class="va">$(</span><span class="fu">cat</span> <span class="op">&lt;&lt;EOS</span></a>
<a class="sourceLine" id="cb1-2" title="2">some text</a>
<a class="sourceLine" id="cb1-3" title="3">is multilined</a>
<a class="sourceLine" id="cb1-4" title="4"><span class="op">EOS</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="va">)</span><span class="st">&quot;</span></a></code></pre></div>
<p>これは，</p>
<pre class="text"><code>some text
is multilined</code></pre>
<p>という文字列が出力されます．多くの言語では似たような構文で <span class="ascii">heredoc</span> が採用されていて，特殊な記号の後に終端記号を書いて，その後の終端記号までを文字列リテラルとして扱われます． <span class="ascii">Haskell</span> では残念ながらこのような機能は搭載されていませんが，代わりに次の記法が提供されています<span class="ascii">:</span></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb3-2" title="2">main <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="st">&quot;\</span></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="st">  \some text\n\</span></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="st">  \is multilined\</span></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="st">\&quot;</span></a></code></pre></div>
<p>この実行結果は，前の <span class="ascii">bash</span> スクリプトの結果と同じになります． <span class="ascii">heredoc</span> より色々ごちゃごちゃしてますが，複数行の文字列リテラルを書けます．この機能は， <span class="ascii">Haskell</span> の複数行文字列リテラルまたは <span class="ascii">Haskell</span> 標準では <span class="ascii">gap</span> と呼ばれています <a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>．記法はかなり単純で，文字列中のバックスラッシュ <code>\</code> で囲まれた空白が無視されるだけです．改行も空白に含まれます．なので，上のプログラムは以下のプログラムと同じです<span class="ascii">:</span></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-2" title="2">main <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="st">&quot;some text\nis multilined&quot;</span></a></code></pre></div>
<p>なお， <span class="ascii">gap</span> を使わないで複数行の文字列リテラルを書くことはできません．また， <span class="ascii">gap</span> は空白を全て無視するため，改行を含まない長い文字列を複数行に渡って埋め込むのにも使えます<span class="ascii">:</span></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb5-2" title="2">main <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="st">&quot;This is very very very \</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="st">  \long long long long long long long long text.&quot;</span></a></code></pre></div>
<p>なお， <span class="ascii">gap</span> は <span class="ascii">Haskell</span> 標準でレイアウトルールの処理から除外されているため<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>，インデントを考慮する必要はありません<span class="ascii">:</span></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb6-2" title="2">main <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-3" title="3">  <span class="fu">putStrLn</span> <span class="st">&quot;one line&quot;</span></a>
<a class="sourceLine" id="cb6-4" title="4">  <span class="fu">putStrLn</span> <span class="st">&quot;\</span></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="st">\multiline\n\</span></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="st">\text\</span></a>
<a class="sourceLine" id="cb6-7" title="7"><span class="st">\&quot;</span></a></code></pre></div>
<h2 id="cpp-下での注意事項"><span class="link-to-here-outer"><a href="#cpp-下での注意事項" title="cpp-下での注意事項"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">CPP</span> 下での注意事項</h2>
<p>ただ， <span class="ascii">GHC</span> の <code>CPP</code> 拡張を使用する際注意が必要です． <code>CPP</code> では，バックスラッシュで終わる行は，バックスラッシュを除いて次の行と繋げる処理が行われます<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>．この処理のため， <span class="ascii">gap</span> を使用した以下のコードは，</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="ot">{-# LANGUAGE CPP #-}</span></a>
<a class="sourceLine" id="cb7-2" title="2"></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb7-4" title="4">main <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="st">&quot;This is very very very \</span></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="st">  \long long long long long long long long text.&quot;</span></a></code></pre></div>
<p><code>cpp</code> により次のように変換されてしまいます<span class="ascii">:</span></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb8-2" title="2">main <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="st">&quot;This is very very very   \long long long long long long long long text.&quot;</span></a></code></pre></div>
<p>このため，結果的にコンパイルエラーになってしまいます．このため， <code>CPP</code> を使う際は， <span class="ascii">gap</span> を使わず <code>CPP</code> の機能を使う必要があります．例えば，上記のプログラムは，</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="ot">{-# LANGUAGE CPP #-}</span></a>
<a class="sourceLine" id="cb9-2" title="2"></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb9-4" title="4">main <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="st">&quot;This is very very very \</span></a>
<a class="sourceLine" id="cb9-5" title="5"><span class="st">\ \long long long long long long long long text.&quot;</span></a></code></pre></div>
<p>と書くと <span class="ascii">gap</span> をそのまま使った時のプログラムと同じになります．一番最初の <code>\</code> は <code>CPP</code> のためのもの，次の <span class="ascii">2</span> つは <span class="ascii">gap</span> になります．</p>
<h2 id="まとめ"><span class="link-to-here-outer"><a href="#まとめ" title="まとめ"><span class="link-to-here">Link to<br />
here</span></a></span>まとめ</h2>
<p><span class="ascii">string gap</span> は，昔から <span class="ascii">Haskell</span> 標準で付いている機能なので，ぜひ使ってみてください．</p>
<p>ただ， <span class="ascii">heredoc</span> より使い勝手は良くないです．変数展開やもう少し見栄えの良い <span class="ascii">heredoc</span> が欲しい場合は， <a href="http://hackage.haskell.org/package/here"><span class="ascii">here</span> パッケージ</a> や <a href="http://hackage.haskell.org/package/shakespeare"><span class="ascii">Shakespeare</span></a> などの <span class="ascii">TemplateHaskell</span> を使ったテンプレートエンジンの使用を検討してみるといいかもしれませんね．</p>
<p>では，今日はこれでノシ</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-200002.6"><span class="ascii">Haskell2010</span> の <span class="ascii">2.6</span> 節</a>の最後の方で紹介されています．<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p><a href="https://www.haskell.org/onlinereport/haskell2010/haskellch10.html#x17-17800010.3"><span class="ascii">Haskell2010</span> の <span class="ascii">10.3</span> 節</a> で触れられています．<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p><a href="https://gcc.gnu.org/onlinedocs/cpp/Initial-processing.html#index-continued-lines"><span class="ascii">CPP</span> の仕様の <span class="ascii">1.2</span> 節</a> で触れられています．<a href="#fnref3" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/stack-ghc8.8.html" lang="ja">GHC 8.8.1 alphaをstackでダウンロードして手持ちのパッケージをビルドする</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/hourly-antenna.html" style="margin-left: auto;" lang="ja">DroneでHaskell Antennaを毎時更新する</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>DroneでHaskell Antennaを毎時更新する</title>
    <link href="https://haskell.jp/blog/posts/2019/hourly-antenna.html" />
    <id>https://haskell.jp/blog/posts/2019/hourly-antenna.html</id>
    <published>2019-01-25T00:00:00Z</published>
    <updated>2019-01-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p><span class="ascii">Haskell-jp</span>のコンテンツの一つとして<a href="https://haskell.jp/antenna/"><span class="ascii">Haskell Antenna</span></a>という <span class="ascii">Web</span> ページの開発・運用をしております。</p>
<p><img src="../../img/2019/hourly-antenna/antenna-page.jpg" style="width: 100%;"></p>
<p>この<span class="ascii">Web</span>ページは<a href="https://github.com/haskell-jp/antenna"><span class="ascii">Haskell-jp</span>のリポジトリ</a>で開発し、<span class="ascii">GitHub Pages</span>として公開しています。 更新は<a href="https://travis-ci.org/"><span class="ascii">TravisCI</span></a>の<span class="ascii">Daily Cron</span>を使って行なっていましたが、なんとかして <strong>毎時更新を実現したい</strong> と思案していました。 ひょんなことから<a href="https://cloud.drone.io/"><span class="ascii">Drone Cloud</span></a>という<span class="ascii">CI</span>サービスを見つけ、このサービスでは<span class="ascii">Hourly Cron</span>が可能だったので試しに更新の部分だけ移行してみました。 という話です。</p>
<p>ちなみに、本稿は全く<span class="ascii">Haskell</span>のコードが出て来ません <span class="ascii">;)</span></p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#drone.io" title="drone.io"><span class="ascii">Drone.io</span></a></li>
<li><a href="#毎時更新を実現するために" title="毎時更新を実現するために">毎時更新を実現するために</a>
<ul>
<li><a href="#antennaのdockerイメージ化" title="antennaのdockerイメージ化"><span class="ascii">Antenna</span>の<span class="ascii">Docker</span>イメージ化</a></li>
<li><a href="#dockerイメージの自動更新" title="dockerイメージの自動更新"><span class="ascii">Docker</span>イメージの自動更新</a></li>
<li><a href="#drone-cloudの設定" title="drone-cloudの設定"><span class="ascii">Drone Cloud</span>の設定</a></li>
<li><a href="#personal-tokenからdeploy-keyに移行" title="personal-tokenからdeploy-keyに移行"><span class="ascii">Personal Token</span>から<span class="ascii">Deploy Key</span>に移行</a></li>
<li><a href="#slackの通知回りを整理" title="slackの通知回りを整理"><span class="ascii">Slack</span>の通知回りを整理</a></li>
</ul></li>
<li><a href="#今後やりたいこと" title="今後やりたいこと">今後やりたいこと</a></li>
</ul>
</div>
</div>
<h1 id="drone.io"><span class="link-to-here-outer"><a href="#drone.io" title="drone.io"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Drone.io</span></h1>
<p><span class="ascii">Drone Cloud</span>はパブリックリポジトリであれば無料で利用できる<span class="ascii">CI</span>サービスです。 内部では<a href="https://drone.io/"><span class="ascii">Drone</span></a>という<span class="ascii">OSS</span>の<span class="ascii">CI</span>プラットフォームを利用しています。 <span class="ascii">Drone</span>は以下のような特徴を持っています<span class="ascii">:</span></p>
<ul>
<li><span class="ascii">Jenkins</span>のような<span class="ascii">OSS</span>である<span class="ascii">(Go</span>言語製<span class="ascii">)</span></li>
<li><span class="ascii">TravisCI</span>や<span class="ascii">CircleCI</span>のようなパイプラインによる設定を行う<span class="ascii">(YAML</span>形式<span class="ascii">)</span></li>
<li><span class="ascii">Docker</span>との親和性が高く<span class="ascii">k8s</span>などでの動作もサポートしている</li>
<li><span class="ascii">Plugin</span>システムによって外部サービスとの連携が可能</li>
</ul>
<p><span class="ascii">OSS</span>のためお好みのクラウドサービスなどで自前運用も可能ですし、<span class="ascii">Drone Enterprise</span>という有料のクラウドサービスも提供しています。</p>
<h1 id="毎時更新を実現するために"><span class="link-to-here-outer"><a href="#毎時更新を実現するために" title="毎時更新を実現するために"><span class="link-to-here">Link to<br />
here</span></a></span>毎時更新を実現するために</h1>
<p>単純に<span class="ascii">Drone</span>の設定ファイルを記述するだけではなく、次のような作業を行いました<span class="ascii">:</span></p>
<ul>
<li><span class="ascii">Haskell Antenna</span>の<span class="ascii">Docker</span>イメージ化</li>
<li><span class="ascii">Antenna</span>の<span class="ascii">Docker</span>イメージを自動更新</li>
<li><span class="ascii">Drone Cloud</span>の設定</li>
<li><span class="ascii">Personal Token</span>から<span class="ascii">Deploy Key</span>に移行</li>
<li><span class="ascii">Slack</span>の通知回りを整理</li>
</ul>
<p>順に説明していきましょう。</p>
<h2 id="antennaのdockerイメージ化"><span class="link-to-here-outer"><a href="#antennaのdockerイメージ化" title="antennaのdockerイメージ化"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Antenna</span>の<span class="ascii">Docker</span>イメージ化</h2>
<p><span class="ascii">Drone Cloud</span>では無償でキャッシュを利用することができません<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>。 <span class="ascii">Haskell(</span>というか<span class="ascii">Stack)</span>の<span class="ascii">CI</span>をしている方ならわかると思いますが、キャッシュなしにビルドするとすごい時間がかかります。 なので、<span class="ascii">Haskell Antenna</span>の静的ページの生成を行う <code>antenna</code> コマンドを<span class="ascii">Docker</span>イメージとしておき、<span class="ascii">Drone</span>内ではこのイメージを利用して静的ページの生成を行う方針でいきます。</p>
<p>もちろん<span class="ascii">Docker</span>イメージの生成には、<span class="ascii">Stack</span>の<span class="ascii">Docker</span>インテグレーションを使います。 以下のような設定を<span class="ascii">stack.yaml</span>に追記し<span class="ascii">:</span></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb1-1" title="1"><span class="co"># stack.yaml</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="fu">docker:</span></a>
<a class="sourceLine" id="cb1-3" title="3">  <span class="fu">repo:</span><span class="at"> fpco/stack-build</span></a>
<a class="sourceLine" id="cb1-4" title="4">  <span class="fu">enable:</span><span class="at"> </span><span class="ch">false</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="fu">image:</span></a>
<a class="sourceLine" id="cb1-6" title="6">  <span class="fu">container:</span></a>
<a class="sourceLine" id="cb1-7" title="7">    <span class="fu">name:</span><span class="at"> antenna</span></a>
<a class="sourceLine" id="cb1-8" title="8">    <span class="fu">base:</span><span class="at"> fpco/ubuntu-with-libgmp</span></a></code></pre></div>
<p>次のようなコマンドを実行するだけで<code>antenna</code>という<span class="ascii">Docker</span>イメージが生成されます<span class="ascii">:</span></p>
<pre><code>stack docker pull
stack --docker image container</code></pre>
<p><span class="ascii">Docker Hub</span>に<a href="https://hub.docker.com/r/haskelljp/antenna/"><code>haskelljp/antenna</code></a>というネームスペースを確保した<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>のでここにプッシュしました<span class="ascii">:</span></p>
<pre><code>docker tag antenna haskelljp/antenna
docker push haskelljp/antenna</code></pre>
<p>ちなみに、<code>haskell-jp</code> ではなく <code>haskelljp</code> なのは、<span class="ascii">Docker Hub</span>の組織アカウント名には <code>-</code> が使えなかったからです。</p>
<h2 id="dockerイメージの自動更新"><span class="link-to-here-outer"><a href="#dockerイメージの自動更新" title="dockerイメージの自動更新"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Docker</span>イメージの自動更新</h2>
<p><span class="ascii">Docker Hub</span>には<span class="ascii">Automated builds</span>と呼ばれる<span class="ascii">GitHub</span>などのプッシュによって行う自動ビルドがありますが、<span class="ascii">Stack</span>の<span class="ascii">Docker Integration</span>を使うと、その機能を利用することができません。 そこで、<span class="ascii">TravisCI</span>を使って自動ビルドすることにしました。 この辺りは「<a href="https://matsubara0507.github.io/posts/2018-12-02-stack-docker-travici.html"><span class="ascii">Stack</span> の <span class="ascii">Docker Integration</span> とイメージの自動更新 <span class="ascii">-</span> ひげメモ</a>」で記事にしてあるので、細かい話は割愛します。</p>
<p>今回は次のような設定をして、<span class="ascii">master</span> ブランチにプッシュがあった時にのみ<span class="ascii">Docker Hub</span>にプッシュします<span class="ascii">:</span></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb4-1" title="1"><span class="co"># .travis.yml</span></a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="co"># ...</span></a>
<a class="sourceLine" id="cb4-4" title="4"></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="fu">install:</span></a>
<a class="sourceLine" id="cb4-6" title="6"><span class="kw">-</span> mkdir -p ~/.local/bin</a>
<a class="sourceLine" id="cb4-7" title="7"><span class="kw">-</span> export PATH=$HOME/.local/bin:$PATH</a>
<a class="sourceLine" id="cb4-8" title="8"><span class="kw">-</span> travis_retry curl -L https://www.stackage.org/stack/linux-x86_64 | tar xz --wildcards --strip-components=1 -C ~/.local/bin <span class="st">&#39;*/stack&#39;</span></a>
<a class="sourceLine" id="cb4-9" title="9"><span class="kw">-</span> stack docker pull</a>
<a class="sourceLine" id="cb4-10" title="10"><span class="fu">jobs:</span></a>
<a class="sourceLine" id="cb4-11" title="11">  <span class="fu">include:</span></a>
<a class="sourceLine" id="cb4-12" title="12">    <span class="kw">-</span> <span class="fu">stage:</span><span class="at"> build dependencies</span></a>
<a class="sourceLine" id="cb4-13" title="13">      <span class="fu">script:</span><span class="at"> stack --no-terminal --docker --install-ghc test --bench --only-dependencies</span></a>
<a class="sourceLine" id="cb4-14" title="14">    <span class="kw">-</span> <span class="fu">stage:</span><span class="at"> build antenna</span></a>
<a class="sourceLine" id="cb4-15" title="15">      <span class="fu">script:</span><span class="at"> stack --no-terminal --docker build --bench --no-run-benchmarks --no-haddock-deps --pedantic</span></a>
<a class="sourceLine" id="cb4-16" title="16">    <span class="kw">-</span> <span class="fu">stage:</span><span class="at"> push docker image</span></a>
<a class="sourceLine" id="cb4-17" title="17">      <span class="fu">if:</span><span class="at"> branch = master AND type = push</span></a>
<a class="sourceLine" id="cb4-18" title="18">      <span class="fu">script:</span></a>
<a class="sourceLine" id="cb4-19" title="19">      <span class="kw">-</span> stack --docker image container</a>
<a class="sourceLine" id="cb4-20" title="20">      <span class="kw">-</span> docker tag antenna haskelljp/antenna</a>
<a class="sourceLine" id="cb4-21" title="21">      <span class="kw">-</span> echo <span class="st">&quot;$DOCKER_PASSWORD&quot;</span> | docker login -u <span class="st">&quot;$DOCKER_USERNAME&quot;</span> --password-stdin</a>
<a class="sourceLine" id="cb4-22" title="22">      <span class="kw">-</span> docker push haskelljp/antenna</a></code></pre></div>
<p><span class="ascii">Docker</span>で<span class="ascii">Haskell</span>のビルドもするために毎回<span class="ascii">Docker Pull</span>が走るようになり少し遅くなったのが辛いですね<span class="ascii">(</span>今後要検討<span class="ascii">)</span>。</p>
<h2 id="drone-cloudの設定"><span class="link-to-here-outer"><a href="#drone-cloudの設定" title="drone-cloudの設定"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Drone Cloud</span>の設定</h2>
<p>いよいよ<span class="ascii">Drone</span>による <code>antenna</code> コマンドの実行を設定します。 元々は <span class="ascii">TravisCI</span> でこんな感じでした<span class="ascii">:</span></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb5-1" title="1"><span class="fu">jobs:</span></a>
<a class="sourceLine" id="cb5-2" title="2">  <span class="fu">include:</span></a>
<a class="sourceLine" id="cb5-3" title="3">    <span class="kw">-</span> <span class="fu">stage:</span><span class="at"> install anttena</span></a>
<a class="sourceLine" id="cb5-4" title="4">      <span class="fu">script:</span><span class="at"> stack --no-terminal install</span></a>
<a class="sourceLine" id="cb5-5" title="5">    <span class="kw">-</span> <span class="fu">stage:</span><span class="at"> exec antenna</span></a>
<a class="sourceLine" id="cb5-6" title="6">      <span class="fu">script:</span><span class="at"> git clone -b gh-pages &quot;https://${GH_TOKEN}@github.com/${TRAVIS_REPO_SLUG}.git&quot; temp</span></a>
<a class="sourceLine" id="cb5-7" title="7">      <span class="fu">if:</span><span class="at"> branch = master AND type IN (push, cron)</span></a>
<a class="sourceLine" id="cb5-8" title="8">      <span class="fu">after_success:</span></a>
<a class="sourceLine" id="cb5-9" title="9">        <span class="kw">-</span> cp sites.yaml temp/sites.yaml</a>
<a class="sourceLine" id="cb5-10" title="10">        <span class="kw">-</span> cp -r image/* temp/image</a>
<a class="sourceLine" id="cb5-11" title="11">        <span class="kw">-</span> cd temp</a>
<a class="sourceLine" id="cb5-12" title="12">        <span class="kw">-</span> stack exec -- antenna sites.yaml</a>
<a class="sourceLine" id="cb5-13" title="13">        <span class="kw">-</span> git config user.name <span class="st">&quot;${GIT_NAME}&quot;</span></a>
<a class="sourceLine" id="cb5-14" title="14">        <span class="kw">-</span> git status</a>
<a class="sourceLine" id="cb5-15" title="15">        <span class="kw">-</span> git add -A</a>
<a class="sourceLine" id="cb5-16" title="16">        <span class="kw">-</span> git diff --quiet &amp;&amp; git diff --staged --quiet || git commit -am <span class="st">&quot;[skip ci] Update planet haskell. See https://haskell.jp/antenna/ for new entries!&quot;</span></a>
<a class="sourceLine" id="cb5-17" title="17">        <span class="kw">-</span> git push origin gh-pages</a></code></pre></div>
<p><code>stack install</code> で <code>antenna</code> コマンドの実行ファイルを生成し<span class="ascii">(</span>これはキャッシュされるので早い<span class="ascii">)</span>、<code>gh-pages</code> ブランチへページの更新をプッシュするために<span class="ascii">GitHub</span>の<span class="ascii">Personal Token</span>を使って再度クローンしていました。 更新の有無は <code>git diff</code> を使って確認しています。</p>
<p>まずはこれをこのまま<span class="ascii">Drone</span>に移植します<span class="ascii">:</span></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb6-1" title="1"><span class="co"># .drone.yml</span></a>
<a class="sourceLine" id="cb6-2" title="2"></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="fu">kind:</span><span class="at"> pipeline</span></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="fu">name:</span><span class="at"> default</span></a>
<a class="sourceLine" id="cb6-5" title="5"></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="fu">steps:</span></a>
<a class="sourceLine" id="cb6-7" title="7"><span class="kw">-</span> <span class="fu">name:</span><span class="at"> exec antenna</span></a>
<a class="sourceLine" id="cb6-8" title="8">  <span class="fu">image:</span><span class="at"> matsubara0507/antenna</span></a>
<a class="sourceLine" id="cb6-9" title="9">  <span class="fu">environment:</span></a>
<a class="sourceLine" id="cb6-10" title="10">    <span class="fu">GH_TOKEN:</span></a>
<a class="sourceLine" id="cb6-11" title="11">      <span class="fu">from_secret:</span><span class="at"> github_api_token</span></a>
<a class="sourceLine" id="cb6-12" title="12">    <span class="fu">GIT_NAME:</span><span class="at"> BOT</span></a>
<a class="sourceLine" id="cb6-13" title="13">  <span class="fu">commands:</span></a>
<a class="sourceLine" id="cb6-14" title="14">  <span class="kw">-</span> git clone -b gh-pages <span class="st">&quot;https://${GH_TOKEN}@github.com/haskell-jp/antenna.git&quot;</span> temp</a>
<a class="sourceLine" id="cb6-15" title="15">  <span class="kw">-</span> cp sites.yaml temp/sites.yaml</a>
<a class="sourceLine" id="cb6-16" title="16">  <span class="kw">-</span> cp -r image/* temp/image</a>
<a class="sourceLine" id="cb6-17" title="17">  <span class="kw">-</span> cd temp</a>
<a class="sourceLine" id="cb6-18" title="18">  <span class="kw">-</span> antenna sites.yaml</a>
<a class="sourceLine" id="cb6-19" title="19">  <span class="kw">-</span> git config user.name <span class="st">&quot;${GIT_NAME}&quot;</span></a>
<a class="sourceLine" id="cb6-20" title="20">  <span class="kw">-</span> git status</a>
<a class="sourceLine" id="cb6-21" title="21">  <span class="kw">-</span> git add -A</a>
<a class="sourceLine" id="cb6-22" title="22">  <span class="kw">-</span> git diff --quiet &amp;&amp; git diff --staged --quiet || git commit -am <span class="st">&quot;[skip ci] Update planet haskell. See https://haskell.jp/antenna/ for new entries!&quot;</span></a>
<a class="sourceLine" id="cb6-23" title="23">  <span class="kw">-</span> git push origin gh-pages</a>
<a class="sourceLine" id="cb6-24" title="24">  <span class="fu">when:</span></a>
<a class="sourceLine" id="cb6-25" title="25">    <span class="fu">branch:</span></a>
<a class="sourceLine" id="cb6-26" title="26">    <span class="kw">-</span> master</a>
<a class="sourceLine" id="cb6-27" title="27">    <span class="fu">event:</span></a>
<a class="sourceLine" id="cb6-28" title="28">      <span class="fu">exclude:</span></a>
<a class="sourceLine" id="cb6-29" title="29">      <span class="kw">-</span> pull_request</a></code></pre></div>
<p>記法は違うもののそのまま移植ができました。 条件<span class="ascii">(</span><code>if</code>や<code>when</code><span class="ascii">)</span>のところですが、<span class="ascii">Drone</span>で<code>cron</code>のイベントを指定する方法がわからなかったので、動作しては困る<code>pull_request</code>だけ弾くようにしました。</p>
<p><span class="ascii">Cron</span>の設定は<span class="ascii">Web UI</span>上で行います<span class="ascii">:</span></p>
<p><img src="../../img/2019/hourly-antenna/drone-cron-setting.jpg" style="width: 100%;"></p>
<p>これで毎時間<code>master</code>ブランチのビルドが実行されます。</p>
<h2 id="personal-tokenからdeploy-keyに移行"><span class="link-to-here-outer"><a href="#personal-tokenからdeploy-keyに移行" title="personal-tokenからdeploy-keyに移行"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Personal Token</span>から<span class="ascii">Deploy Key</span>に移行</h2>
<p><span class="ascii">Personal Token</span>は他の個人のリポジトリも操作できてしまうので、兼ねてからできれば使いたくないなと思っていました<span class="ascii">(</span>特に個人プロジェクトじゃない<span class="ascii">Haskell-jp</span>のプロジェクトでは<span class="ascii">)</span>。 なので、これを機にリポジトリ固有の<span class="ascii">Deploy Key</span>に移行しました。</p>
<p><span class="ascii">CircleCI</span>のような書き込み用の<span class="ascii">SSH Key</span>を登録する機能は<span class="ascii">Drone</span>にはありません。 代わりに次のように書くと良いです<span class="ascii">:</span></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb7-1" title="1"><span class="fu">steps:</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="kw">-</span> <span class="fu">name:</span><span class="at"> clone gh-pages</span></a>
<a class="sourceLine" id="cb7-3" title="3">  <span class="fu">image:</span><span class="at"> docker:git</span></a>
<a class="sourceLine" id="cb7-4" title="4">  <span class="fu">environment:</span></a>
<a class="sourceLine" id="cb7-5" title="5">    <span class="fu">SSH_KEY:</span></a>
<a class="sourceLine" id="cb7-6" title="6">      <span class="fu">from_secret:</span><span class="at"> deploy_key</span></a>
<a class="sourceLine" id="cb7-7" title="7">  <span class="fu">commands:</span></a>
<a class="sourceLine" id="cb7-8" title="8">  <span class="kw">-</span> mkdir /root/.ssh &amp;&amp; echo <span class="st">&quot;$SSH_KEY&quot;</span> &gt; /root/.ssh/id_rsa &amp;&amp; chmod 0600 /root/.ssh/id_rsa</a>
<a class="sourceLine" id="cb7-9" title="9">  <span class="kw">-</span> echo -e <span class="st">&quot;Host github.com</span><span class="sc">\n\t</span><span class="st">StrictHostKeyChecking no</span><span class="sc">\n</span><span class="st">&quot;</span> &gt; /root/.ssh/config</a>
<a class="sourceLine" id="cb7-10" title="10">  <span class="kw">-</span> git clone -b gh-pages git@github.com:haskell-jp/antenna.git temp</a></code></pre></div>
<p><span class="ascii">Secret</span>というのは<span class="ascii">Drone</span>側で保持・秘匿できる環境変数のような機能です<span class="ascii">(</span>名前が違うだけでだいたいどの<span class="ascii">CI</span>プラットフォームにもありますね<span class="ascii">)</span>。 今回はせっかくなので、これを<span class="ascii">Drone Plugin</span>として自作した<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>、<a href="https://github.com/matsubara0507/drone-git-with-ssh"><code>matsubara0507/git-with-ssh</code></a> というのを使います<span class="ascii">:</span></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb8-1" title="1"><span class="co"># .drone.yml</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="fu">kind:</span><span class="at"> pipeline</span></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="fu">name:</span><span class="at"> default</span></a>
<a class="sourceLine" id="cb8-4" title="4"></a>
<a class="sourceLine" id="cb8-5" title="5"><span class="fu">steps:</span></a>
<a class="sourceLine" id="cb8-6" title="6"><span class="kw">-</span> <span class="fu">name:</span><span class="at"> clone gh-pages</span></a>
<a class="sourceLine" id="cb8-7" title="7">  <span class="fu">image:</span><span class="at"> matsubara0507/git-with-ssh</span></a>
<a class="sourceLine" id="cb8-8" title="8">  <span class="fu">settings:</span></a>
<a class="sourceLine" id="cb8-9" title="9">    <span class="fu">ssh_private_key:</span></a>
<a class="sourceLine" id="cb8-10" title="10">      <span class="fu">from_secret:</span><span class="at"> deploy_key</span></a>
<a class="sourceLine" id="cb8-11" title="11">    <span class="fu">ssh_hosts:</span></a>
<a class="sourceLine" id="cb8-12" title="12">    <span class="kw">-</span> github.com</a>
<a class="sourceLine" id="cb8-13" title="13">    <span class="fu">commands:</span></a>
<a class="sourceLine" id="cb8-14" title="14">    <span class="kw">-</span> git clone -b gh-pages git@github.com:haskell-jp/antenna.git temp</a>
<a class="sourceLine" id="cb8-15" title="15">  <span class="fu">when:</span></a>
<a class="sourceLine" id="cb8-16" title="16">    <span class="fu">branch:</span></a>
<a class="sourceLine" id="cb8-17" title="17">    <span class="kw">-</span> master</a>
<a class="sourceLine" id="cb8-18" title="18">    <span class="fu">event:</span></a>
<a class="sourceLine" id="cb8-19" title="19">      <span class="fu">exclude:</span></a>
<a class="sourceLine" id="cb8-20" title="20">      <span class="kw">-</span> pull_request</a>
<a class="sourceLine" id="cb8-21" title="21"></a>
<a class="sourceLine" id="cb8-22" title="22"><span class="kw">-</span> <span class="fu">name:</span><span class="at"> exec antenna</span></a>
<a class="sourceLine" id="cb8-23" title="23">  <span class="fu">image:</span><span class="at"> haskelljp/antenna</span></a>
<a class="sourceLine" id="cb8-24" title="24">  <span class="fu">commands:</span></a>
<a class="sourceLine" id="cb8-25" title="25">  <span class="kw">-</span> mkdir -p temp</a>
<a class="sourceLine" id="cb8-26" title="26">  <span class="kw">-</span> cp sites.yaml temp/sites.yaml</a>
<a class="sourceLine" id="cb8-27" title="27">  <span class="kw">-</span> cp -r image/* temp/image</a>
<a class="sourceLine" id="cb8-28" title="28">  <span class="kw">-</span> cd temp</a>
<a class="sourceLine" id="cb8-29" title="29">  <span class="kw">-</span> antenna sites.yaml</a>
<a class="sourceLine" id="cb8-30" title="30"></a>
<a class="sourceLine" id="cb8-31" title="31"><span class="kw">-</span> <span class="fu">name:</span><span class="at"> push gh-pages</span></a>
<a class="sourceLine" id="cb8-32" title="32">  <span class="fu">image:</span><span class="at"> matsubara0507/git-with-ssh</span></a>
<a class="sourceLine" id="cb8-33" title="33">  <span class="fu">settings:</span></a>
<a class="sourceLine" id="cb8-34" title="34">    <span class="fu">ssh_private_key:</span></a>
<a class="sourceLine" id="cb8-35" title="35">      <span class="fu">from_secret:</span><span class="at"> deploy_key</span></a>
<a class="sourceLine" id="cb8-36" title="36">    <span class="fu">ssh_hosts:</span></a>
<a class="sourceLine" id="cb8-37" title="37">    <span class="kw">-</span> github.com</a>
<a class="sourceLine" id="cb8-38" title="38">    <span class="fu">commands:</span></a>
<a class="sourceLine" id="cb8-39" title="39">    <span class="kw">-</span> cd temp &amp;&amp; git config user.name  BOT</a>
<a class="sourceLine" id="cb8-40" title="40">    <span class="kw">-</span> cd temp &amp;&amp; git config user.email bot@example.com</a>
<a class="sourceLine" id="cb8-41" title="41">    <span class="kw">-</span> cd temp &amp;&amp; git status</a>
<a class="sourceLine" id="cb8-42" title="42">    <span class="kw">-</span> cd temp &amp;&amp; git add -A</a>
<a class="sourceLine" id="cb8-43" title="43">    <span class="kw">-</span> cd temp &amp;&amp; git diff --quiet &amp;&amp; git diff --staged --quiet || git commit -am <span class="st">&quot;[skip ci] Update planet haskell. See https://haskell.jp/antenna/ for new entries!&quot;</span></a>
<a class="sourceLine" id="cb8-44" title="44">    <span class="kw">-</span> cd temp &amp;&amp; git push origin gh-pages</a>
<a class="sourceLine" id="cb8-45" title="45">  <span class="fu">when:</span></a>
<a class="sourceLine" id="cb8-46" title="46">    <span class="fu">branch:</span></a>
<a class="sourceLine" id="cb8-47" title="47">    <span class="kw">-</span> master</a>
<a class="sourceLine" id="cb8-48" title="48">    <span class="fu">event:</span></a>
<a class="sourceLine" id="cb8-49" title="49">      <span class="fu">exclude:</span></a>
<a class="sourceLine" id="cb8-50" title="50">      <span class="kw">-</span> pull_request</a></code></pre></div>
<p><code>cd temp &amp;&amp;</code> というのがダサいですが、そこはおいおい直します<span class="ascii">(</span><code>git-with-ssh</code> の方を<span class="ascii">)</span>。</p>
<h2 id="slackの通知回りを整理"><span class="link-to-here-outer"><a href="#slackの通知回りを整理" title="slackの通知回りを整理"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Slack</span>の通知回りを整理</h2>
<p>元々は<span class="ascii">Haskell-jp</span>の <code>#antenna</code> チャンネルに<span class="ascii">GitHub</span>の通知設定をしているだけでした。 今回の開発中、ずっとコミットの通知などが来てうるさかったので次のように分けました<span class="ascii">:</span></p>
<ul>
<li><code>#antenna</code> チャンネルは <code>gh-pages</code> ブランチのコミットだけ通知
<ul>
<li>ついでに<span class="ascii">Haskell Antenna</span>の<span class="ascii">RSS</span>を設定した</li>
</ul></li>
<li><code>#antenna-dev</code> チャンネルを新しく作り<span class="ascii">GitHub</span>の全ての更新はこっちに設定</li>
<li><code>#dockerhub</code> チャンネルもついでに作って <code>haskelljp</code> の更新を通知する</li>
</ul>
<p>最近、<span class="ascii">Docker Hub</span>の大リニューアルがあって、いつのまにか<span class="ascii">Docker Hub</span>と<span class="ascii">Slack</span>を連携できるようになっていました。 なので試しに連携して更新の通知が飛ぶようにしてみました<span class="ascii">:</span></p>
<p><img src="../../img/2019/hourly-antenna/dockerhub-slack.jpg" style="width: 100%;"></p>
<h1 id="今後やりたいこと"><span class="link-to-here-outer"><a href="#今後やりたいこと" title="今後やりたいこと"><span class="link-to-here">Link to<br />
here</span></a></span>今後やりたいこと</h1>
<p>いくつかあります<span class="ascii">:</span></p>
<ul>
<li><span class="ascii">LTS</span>の更新<span class="ascii">(</span>最新<span class="ascii">GHC</span>が<span class="ascii">Windows</span>でも動作したらかな<span class="ascii">)</span></li>
<li><span class="ascii">Feed</span>の改善
<ul>
<li><span class="ascii">Slack</span>の<span class="ascii">RSS</span>でもちゃんと更新が通知されるように</li>
</ul></li>
<li>ないしは更新差分の通知
<ul>
<li><span class="ascii">Haskell-jp Slack</span>の<span class="ascii">App</span>が満杯なので厳しいかも</li>
</ul></li>
</ul>
<p>あと、<span class="ascii">Qiita</span>の<span class="ascii">Feed</span>がコメントや追記などでも更新され、その通知が <code>#antenna</code> チャンネルに飛んで来てうるさいので修正したいです<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>。</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>キャッシュの導入の仕方は記事にしたので興味のある方は是非「<a href="https://matsubara0507.github.io/posts/2019-01-06-use-drone-cache-with-gcs.html"><span class="ascii">GCS</span> で <span class="ascii">Drone 1.0</span> をキャッシュする <span class="ascii">-</span> ひげメモ</a>」<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>もし<span class="ascii">Docker Hub</span>の<span class="ascii">haskelljp</span>組織アカウントのメンバーになりたい場合は<span class="ascii">Haskell-jp Slack</span>で声をかけてください<span class="ascii">(</span>チャンネルはどこでも良いですよ<span class="ascii">)</span>。<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>この話も記事にしておきました「<a href="https://matsubara0507.github.io/posts/2019-01-20-create-drone-git-with-ssh.html"><span class="ascii">Drone Plugin</span> を作ってみた<span class="ascii">: git-with-ssh -</span> ひげメモ</a>」<a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p>この修正は <code>haskell-jp/antenna</code> ではなく、<a href="https://github.com/matsubara0507/scrapbook"><code>matsubara0507/scrapbook</code></a> からやる必要があります。<a href="#fnref4" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/string-gap-for-heredoc-like.html" lang="ja">Haskell でも heredoc がしたい</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/tidalcycles-stack.html" style="margin-left: auto;" lang="ja">TidalCyclesをstackで確実にインストールする</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>TidalCyclesをstackで確実にインストールする</title>
    <link href="https://haskell.jp/blog/posts/2019/tidalcycles-stack.html" />
    <id>https://haskell.jp/blog/posts/2019/tidalcycles-stack.html</id>
    <published>2019-01-17T00:00:00Z</published>
    <updated>2019-01-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#背景" title="背景">背景</a></li>
<li><a href="#実行した環境" title="実行した環境">実行した環境</a></li>
<li><a href="#各種依存パッケージのインストール" title="各種依存パッケージのインストール">各種依存パッケージのインストール</a>
<ul>
<li><a href="#tidalcycles公式のwikiそのままの手順" title="tidalcycles公式のwikiそのままの手順"><span class="ascii">TidalCycles</span>公式の<span class="ascii">Wiki</span>そのままの手順</a></li>
<li><a href="#tidalcycles公式のwikiとは異なる手順" title="tidalcycles公式のwikiとは異なる手順"><span class="ascii">TidalCycles</span>公式の<span class="ascii">Wiki</span>とは異なる手順</a>
<ul>
<li><a href="#stackでのtidalcyclesのビルド" title="stackでのtidalcyclesのビルド"><span class="ascii">stack</span>での<span class="ascii">TidalCycles</span>のビルド</a></li>
<li><a href="#atomのプラグインの設定" title="atomのプラグインの設定"><span class="ascii">Atom</span>のプラグインの設定</a></li>
</ul></li>
</ul></li>
<li><a href="#使い方動作確認" title="使い方動作確認">使い方・動作確認</a>
<ul>
<li><a href="#tidalcyclesを起動する度に必要になる手順" title="tidalcyclesを起動する度に必要になる手順"><span class="ascii">TidalCycles</span>を起動する度に必要になる手順</a></li>
</ul></li>
<li><a href="#ハマったこと" title="ハマったこと">ハマったこと</a>
<ul>
<li><a href="#superdirtが見つからないという趣旨のエラーが出た" title="superdirtが見つからないという趣旨のエラーが出た">「<span class="ascii">SuperDirt</span>が見つからない！」という趣旨のエラーが出た</a></li>
<li><a href="#atom上でtidalcyclesを起動した際parse-error" title="atom上でtidalcyclesを起動した際parse-error"><span class="ascii">Atom</span>上で<span class="ascii">TidalCycles</span>を起動した際、<code>parse error</code></a></li>
<li><a href="#superdirtを起動し忘れていても何もエラーが起きない" title="superdirtを起動し忘れていても何もエラーが起きない"><span class="ascii">SuperDirt</span>を起動し忘れていても何もエラーが起きない</a></li>
</ul></li>
<li><a href="#おわりに-haskell開発者として見たtidalcycles" title="おわりに-haskell開発者として見たtidalcycles">おわりに<span class="ascii">: Haskell</span>開発者として見た<span class="ascii">TidalCycles</span></a></li>
</ul>
</div>
</div>
<h1 id="背景"><span class="link-to-here-outer"><a href="#背景" title="背景"><span class="link-to-here">Link to<br />
here</span></a></span>背景</h1>
<p>先日<span class="ascii">teratail</span>の<span class="ascii">Haskell</span>タグを眺めていたところ、下記のような質問がありました。</p>
<p><a href="https://teratail.com/questions/167461?rss"><span class="ascii">Haskell - network</span>パッケージがうまく機能しない｜<span class="ascii">teratail</span></a></p>
<p><a href="https://tidalcycles.org/index.php/Welcome"><span class="ascii">TidalCycles</span></a>という、<span class="ascii">Haskell</span>製の内部<span class="ascii">DSL</span>でシンセサイザーの演奏ができるライブラリーのインストールがうまくいかない、という質問です。<br />
<span class="ascii">network</span>パッケージがインストールできていない、ということなので<span class="ascii">cabal hell</span>にでもハマったのかな、と思ったのですが、<a href="https://github.com/tidalcycles/tidal-chocolatey/issues/1">類似しているとおぼしき報告</a>（と、<a href="https://qiita.com/yoppa/items/fe21d7136f8f3aafd55c#comment-b568fc7ecb423b9bc2ce">こちら</a>）を読む限り、どうも<span class="ascii">GHC</span>のインストール自体に何か問題があるように見えました。</p>
<p>もう当の質問者は<span class="ascii">Haskell Platform</span>をインストールすることで解決したそうですが、いずれにしても、我々<span class="ascii">Haskeller</span>としては、<span class="ascii">stack</span>なり<span class="ascii">cabal new-install</span>なりといった、慣れた方法でインストールできた方がサポートしやすいですし、きっと確実です。<br />
というわけで今回は<span class="ascii">stack</span>でのインストールに挑戦してみました。<br />
すでに<span class="ascii">stack</span>をインストールしているという<span class="ascii">Haskell</span>開発者は多いでしょうし、そうした方が<span class="ascii">TidalCycles</span>を使いたくなったときの参考になれば幸いです。</p>
<p>結論から言うとほとんど問題なくできたんですが、以下の<span class="ascii">tweet</span>で述べたポイントにご注意ください。</p>
<blockquote class="twitter-tweet" data-lang="ja">
<p lang="ja" dir="ltr">
<span class="ascii">TidalCycles, Atom</span>の<span class="ascii">package</span>の設定で<span class="ascii">stack exec ghci</span>を使うよう設定したら普通に<span class="ascii">stack</span>で入れた<span class="ascii">GHC</span>から使えましたわ。<br>ポイントは、<br><span class="ascii">- hosc-0.17</span>の<span class="ascii">stack.yaml</span>の<span class="ascii">extra-deps</span>に加えないといけない<br><span class="ascii">- Windows</span>で<span class="ascii">GHC 8.6.3</span>は地雷なので<span class="ascii">LTS 12.26</span>を使う<br><span class="ascii">- ~/.ghci</span>で<span class="ascii">:set +m</span>してるとうまく動かない<br>ぐらいか。
</p>
— <span class="ascii">Yuji Yamamoto:</span> 山本悠滋 <span class="ascii">(</span><span class="citation" data-cites="igrep"><span class="ascii">@igrep</span></span><span class="ascii">)</span> <a href="https://twitter.com/igrep/status/1082475580753207296?ref_src=twsrc%5Etfw"><span class="ascii">2019</span>年<span class="ascii">1</span>月<span class="ascii">8</span>日</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<h1 id="実行した環境"><span class="link-to-here-outer"><a href="#実行した環境" title="実行した環境"><span class="link-to-here">Link to<br />
here</span></a></span>実行した環境</h1>
<ul>
<li><span class="ascii">Windows 10 Pro 64bit ver. 1809</span></li>
<li><code>stack --version</code><span class="ascii">: Version 1.9.1, Git revision f9d0042c141660e1d38f797e1d426be4a99b2a3c (6168 commits) x86_64 hpack-0.31.0</span></li>
<li><span class="ascii">TidalCycles:</span> <a href="http://hackage.haskell.org/package/tidal-1.0.6"><span class="ascii">1.0.6</span></a></li>
<li><span class="ascii">SuperCollider: 3.10.0, 64bit</span></li>
<li><span class="ascii">Atom: 1.34.0</span></li>
<li><span class="ascii">Atom</span>の<span class="ascii">tidalcycles</span>プラグイン<span class="ascii">: 0.14.0</span></li>
</ul>
<h1 id="各種依存パッケージのインストール"><span class="link-to-here-outer"><a href="#各種依存パッケージのインストール" title="各種依存パッケージのインストール"><span class="link-to-here">Link to<br />
here</span></a></span>各種依存パッケージのインストール</h1>
<p>冒頭に挙げた質問をされた方が参考にしたページ <a href="https://qiita.com/yoppa/items/fe21d7136f8f3aafd55c"><span class="ascii">TidalCycles</span>のインストール<span class="ascii">2018</span>年版 <span class="ascii">- Qiita</span></a> では、<span class="ascii">Chocolatey</span>を使ったインストール方法を紹介していますが、この方法では、直接<span class="ascii">GHC</span>の<span class="ascii">Windows</span>向け<span class="ascii">tarball</span>をダウンロードしてインストールしているようです。<br />
私が知る限り特にその方法でも問題はないはずなんですが、なぜか質問者が挙げたようなエラーが発生してしまいます。<br />
また、<span class="ascii">TidalCycles</span>が実行時に依存している<span class="ascii">SuperCollider</span>や<span class="ascii">SuperDirt</span>といったソフトウェアを、別の<span class="ascii">Chocolatey</span>のパッケージに分けることなく、<span class="ascii">TidalCycles</span>のインストールスクリプトで直接インストールしているようです<small>（詳細は<a href="https://chocolatey.org/packages/TidalCycles"><span class="ascii">Chocolatey</span>のパッケージ情報</a>に書かれた<span class="ascii">chocolateyinstall.ps1</span>を参照されたし）</small>。<br />
そのため、<span class="ascii">Chocolatey</span>で<span class="ascii">TidalCycles</span>をインストールしようとすると、問題のある<span class="ascii">GHC</span>と、<span class="ascii">SuperCollider</span>などの依存パッケージを一緒にインストールしなければなりませんし、<span class="ascii">SuperCollider</span>や<span class="ascii">SuperDirt</span>だけを<span class="ascii">Chocolatey</span>でインストールすることもできません。</p>
<p>なので、ここは素直に<a href="https://tidalcycles.org/index.php/Windows_installation"><span class="ascii">TidalCycles</span>公式の<span class="ascii">Wiki</span></a>に書かれた方法に従って<span class="ascii">SuperCollider</span>や<span class="ascii">SuperDirt</span>をインストールしつつ、<span class="ascii">Haskell</span>関連のものだけ<span class="ascii">stack</span>でインストールしようと思います。</p>
<h2 id="tidalcycles公式のwikiそのままの手順"><span class="link-to-here-outer"><a href="#tidalcycles公式のwikiそのままの手順" title="tidalcycles公式のwikiそのままの手順"><span class="link-to-here">Link to<br />
here</span></a></span><a href="https://tidalcycles.org/index.php/Windows_installation"><span class="ascii">TidalCycles</span>公式の<span class="ascii">Wiki</span></a>そのままの手順</h2>
<p><strong>⚠️行く先々で<span class="ascii">Windows</span>のファイアウォールの警告が出るかと思います。適当に承認しちゃってください！⚠️</strong></p>
<ol type="1">
<li><a href="https://supercollider.github.io/download"><span class="ascii">SuperCollider</span>を公式サイトからインストール</a>します。<br />
今回は「<span class="ascii">Windows</span>」の箇所に書いてある「<span class="ascii">3.10.0, 64-bit (no SuperNova)</span>」というリンクをクリックしてダウンロードされた実行ファイルでインストールしました。</li>
<li><a href="https://atom.io/"><span class="ascii">Atom</span></a>も公式サイトからインストールしました。<br />
後で触れます<span class="ascii">TidalCycles</span>の対話環境を、<span class="ascii">Atom</span>上で呼び出すためのプラグインがあるためです。他のエディタ向けのプラグインもありますが、公式サイトで紹介していたのは<span class="ascii">Atom</span>なので、一番これがサポートされているのでしょう。</li>
<li><span class="ascii">Git</span>も<span class="ascii">Prerequisites</span>として挙げられていますが、すでに私の環境に入っているので今回は特に何もしていません。なければ普通に<a href="https://gitforwindows.org/"><span class="ascii">Git for Windows</span></a>を入れるのが無難かと思います。</li>
<li><span class="ascii">SuperDirt</span>のインストール
<ol type="1">
<li><span class="ascii">SuperCollider</span>をスタートメニューから起動します。</li>
<li>ウィンドウの左側にある「<span class="ascii">Untitled</span>」と書かれた箇所の下が<span class="ascii">SuperCollider</span>のエディタになっているようです<small>（色がわかりづらい！）</small>。<br />
そこに<code>include("SuperDirt")</code>と書いて、「<span class="ascii">Shift + Enter</span>」を押せば、<span class="ascii">SuperDirt</span>のインストールが始まります。</li>
<li>次のセクションで<span class="ascii">SuperDirt</span>を起動する前に、<strong>一旦<span class="ascii">SuperCollider</span>を終了</strong>させましょう。</li>
</ol></li>
<li><span class="ascii">Atom</span>向け<span class="ascii">tidalcycles</span>プラグインのインストール
<ul>
<li>面倒なので省略します。他のプラグインと変わらないはずなので適当に検索してください！</li>
</ul></li>
</ol>
<h2 id="tidalcycles公式のwikiとは異なる手順"><span class="link-to-here-outer"><a href="#tidalcycles公式のwikiとは異なる手順" title="tidalcycles公式のwikiとは異なる手順"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">TidalCycles</span>公式の<span class="ascii">Wiki</span>とは異なる手順</h2>
<p>ここからはこの記事特有の手順です。<br />
最近の<span class="ascii">Haskell</span>開発者は、<a href="https://docs.haskellstack.org/en/stable/README/"><span class="ascii">stack</span></a>というツールを使って開発環境を整えることが多いですので、冒頭の予告通りここでは<span class="ascii">stack</span>を使います。<br />
ちなみに、現在は<span class="ascii">Haskell Platform</span>にも<span class="ascii">stack</span>が添付されていますが、<span class="ascii">Haskell Platform</span>に含まれる、<span class="ascii">GHC</span>は<span class="ascii">stack</span>を使うことでも簡単にインストールできるため、<span class="ascii">stack</span>のみをインストールすれば十分です。<br />
なお、<span class="ascii">stack</span>自体のインストール方法については拙作の<a href="https://github.com/haskell-jp/makeMistakesToLearnHaskell#%E3%81%BE%E3%81%A0stack%E3%82%84haskell-platform%E3%82%92%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB%E3%81%97%E3%81%A6%E3%81%84%E3%81%AA%E3%81%84%E5%A0%B4%E5%90%88%E3%81%AF">「失敗しながら学ぶ<span class="ascii">Haskell</span>入門」の<span class="ascii">README</span></a>をご覧ください。<br />
<span class="ascii">Windows</span>ではインストーラーをダウンロードして実行するだけで十分でしょう。</p>
<p><span class="ascii">stack</span>のインストールが終わったら、次の手順を踏んでください。</p>
<h3 id="stackでのtidalcyclesのビルド"><span class="link-to-here-outer"><a href="#stackでのtidalcyclesのビルド" title="stackでのtidalcyclesのビルド"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">stack</span>での<span class="ascii">TidalCycles</span>のビルド</h3>
<p><span class="ascii">stack</span>で<span class="ascii">TidalCycles</span>のビルドをするには、<code>C:\sr\global-project\stack.yaml</code>というファイルを、下記でコメントしたように書き換えてください。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb1-1" title="1"><span class="co"># ... 省略 ...</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="fu">packages:</span><span class="at"> </span><span class="kw">[]</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="fu">resolver:</span><span class="at"> lts-12.26 </span><span class="co"># &lt;= ここを編集</span></a>
<a class="sourceLine" id="cb1-4" title="4"></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="fu">extra-deps:</span><span class="at">         </span><span class="co"># &lt;= この行と、</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="kw">-</span> hosc-0.17         <span class="co"># &lt;= この行を追記</span></a></code></pre></div>
<p>簡単に編集した内容について解説させてください。</p>
<p>まず、<code>resolver:</code>で始まる行ですが、これは「<span class="ascii">LTS Haskell</span>」という、パッケージの一覧のバージョンを指定するものです。<br />
「<span class="ascii">LTS Haskell</span>」は、「確実にビルドできるバージョンのパッケージをまとめた一覧」です。<br />
<span class="ascii">LTS Haskell</span>のメンテナーの方々は、毎日登録された大量のパッケージをまとめてビルド・テストしてみることで、実際に登録されたバージョンのパッケージのビルドとテストが成功することを確認しています。<br />
なので、この<span class="ascii">LTS Haskell</span>に登録されているバージョンのパッケージを使う限りは、私たちは安心してビルドができると言うことです。</p>
<p>なぜ<span class="ascii">LTS Haskell</span>のバージョンを書き換えたのかというと、それは、<span class="ascii">LTS Haskell</span>には実際にはパッケージの一覧だけでなく、それらをビルドできる<span class="ascii">GHC</span>のバージョンも含まれているからです。<br />
したがって、<span class="ascii">LTS Haskell</span>のバージョンを指定する、ということは、そのままインストールする<span class="ascii">GHC</span>のバージョンも指定することになります<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>。<br />
実は特に今回の場合、インストールする<span class="ascii">GHC</span>のバージョンを指定しなければ、ビルドできない可能性が高かったのです。<br />
現在の最新の<span class="ascii">LTS Haskell</span>に登録されている<span class="ascii">GHC</span>のバージョンは「<span class="ascii">8.6.3</span>」ですが、残念ながらこのバージョンの<span class="ascii">GHC</span>には、<a href="https://ghc.haskell.org/trac/ghc/ticket/16057"><span class="ascii">Windows</span>版のみにおいて深刻なバグ</a>があります。<br />
実際に<span class="ascii">TidalCycles</span>をビルドする際にこのバグに遭遇するかは確かめてませんが、内容からして遭遇する確率が高そうであるという点と、遭遇するとビルドができないという点を考慮して、念のため確実にビルドできるバージョンの<span class="ascii">GHC</span>を指定しておきました。</p>
<p>そして、<code>extra-deps</code>という項目は、ビルドしようとしているパッケージ<small>（今回の場合<code>tidal</code>パッケージ）</small>が依存しているパッケージが、<span class="ascii">LTS Haskell</span>に登録されていない場合に指定するものです。<br />
<a href="http://hackage.haskell.org/package/tidal-1.0.6"><span class="ascii">tidal</span>パッケージ <span class="ascii">ver. 1.0.6</span>のパッケージ情報</a>を確認すると、確かに<span class="ascii">hosc</span>というパッケージに依存していると書かれていますね！<br />
残念ながらこの<span class="ascii">hosc</span>パッケージは今回指定した、<span class="ascii">LTS Haskell</span>の<span class="ascii">ver. 12.26</span>には登録されていないので、上記のとおり<code>extra-deps</code>に明記しておいてください。</p>
<p><code>C:\sr\global-project\stack.yaml</code>の編集が終わったら、</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" title="1"><span class="ex">stack</span> build tidal</a></code></pre></div>
<p>と実行しましょう。<br />
初回は<span class="ascii">GHC</span>のインストールも含めて行われるので、結構時間がかかると思います。</p>
<p>ちなみに、<code>stack install tidal</code>と実行してもいいですが、<span class="ascii">stack</span>の仕様上、特に結果は変わりません。<br />
<code>stack install</code>は、実行ファイルがついたパッケージをビルドして<code>PATH</code>にインストールするためのコマンドなので、<code>tidal</code>のように実行ファイルがないパッケージでは意味がありません。</p>
<h3 id="atomのプラグインの設定"><span class="link-to-here-outer"><a href="#atomのプラグインの設定" title="atomのプラグインの設定"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Atom</span>のプラグインの設定</h3>
<p>続いて、<span class="ascii">Atom</span>の<span class="ascii">tidalcycles</span>プラグインの設定をしましょう。<br />
<span class="ascii">stack</span>は使用する<span class="ascii">GHC</span>を、前述の<span class="ascii">stack.yaml</span>に書いた<span class="ascii">LTS Haskell</span>のバージョンに応じて切り替える関係上、<code>PATH</code>の通ったところに<span class="ascii">GHC</span>をインストールしません。<br />
そのため、<span class="ascii">Atom</span>の<span class="ascii">tidalcycles</span>プラグインに、<span class="ascii">stack</span>がインストールした<span class="ascii">GHC</span>を認識させるには、下記のように設定を書き換える必要があります。</p>
<ol type="1">
<li><span class="ascii">Atom</span>を起動し、「<span class="ascii">File</span>」 <span class="ascii">-&gt;</span> 「<span class="ascii">Settings</span>」の順にメニューをクリックして、<span class="ascii">Atom</span>の設定画面を開きます。</li>
<li>画面左側の「📦<span class="ascii">Packages</span>」と書かれた箇所をクリックすると、インストールした<span class="ascii">Atom</span>のプラグインの一覧が表示されるはずです。</li>
<li>一覧から「<span class="ascii">tidalcycles</span>」を探して、「⚙️<span class="ascii">Settings</span>」をクリックします。</li>
<li>「<span class="ascii">Ghci Path</span>」という設定項目があるので、それを<code>stack exec ghci</code>に書き換えてください。</li>
</ol>
<h1 id="使い方動作確認"><span class="link-to-here-outer"><a href="#使い方動作確認" title="使い方動作確認"><span class="link-to-here">Link to<br />
here</span></a></span>使い方・動作確認</h1>
<h2 id="tidalcyclesを起動する度に必要になる手順"><span class="link-to-here-outer"><a href="#tidalcyclesを起動する度に必要になる手順" title="tidalcyclesを起動する度に必要になる手順"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">TidalCycles</span>を起動する度に必要になる手順</h2>
<p>※<a href="https://tidalcycles.org/index.php/Start_tidalcycles_and_superdirt_for_the_first_time">公式サイトのこちらのページ</a>に対応しています。</p>
<ol type="1">
<li><span class="ascii">SuperDirt</span>の起動
<ol type="1">
<li><span class="ascii">SuperCollider</span>をスタートメニューから起動します。</li>
<li>先ほど<code>include("SuperDirt")</code>と入力した、<span class="ascii">SuperCollider</span>のエディタに、今度は<code>SuperDirt.start</code>と入力して、同じく「<span class="ascii">Shift + Enter</span>」しましょう。<br />
<span class="ascii">SuperDirt</span>が起動します。</li>
</ol></li>
<li><span class="ascii">Atom</span>上での<span class="ascii">TidalCycles</span>の起動
<ol type="1">
<li><span class="ascii">Atom</span>を起動して、拡張子が<code>.tidal</code>なファイルを開くか作成します。</li>
<li>メニューを「<span class="ascii">Packages</span>」 <span class="ascii">-&gt;</span> 「<span class="ascii">TidalCycles</span>」 <span class="ascii">-&gt;</span> 「<span class="ascii">Boot TidalCycles</span>」の順に選択してください。</li>
<li>画面下部で<span class="ascii">GHCi</span>が起動し、<span class="ascii">TidalCycles</span>の式を実行するのに必要なパッケージの<code>import</code>や、<code>import</code>では賄いきれない関数の定義などが自動的に行われます。
<ul>
<li><a href="https://github.com/tidalcycles/Tidal/blob/master/BootTidal.hs"><span class="ascii">BootTidal.hs</span></a>というファイルの中身を<span class="ascii">GHCi</span>に貼り付けているみたいです。</li>
</ul></li>
</ol></li>
<li>動作確認のために、適当な<span class="ascii">TidalCycles</span>の式 — 例えば公式サイトの<span class="ascii">Wiki</span>どおり<code>d1 $ sound "bd sn"</code> — を入力して、入力した行にカーソルを置き、「<span class="ascii">Shift + Enter</span>」を押しましょう。
<ol type="1">
<li>入力した式が画面下部で起動した<span class="ascii">GHCi</span>に送信され、実行されます。うまくいっていれば音が鳴るはずです。</li>
<li>停止させたいときは、<code>d1 silence</code>と入力して同じく「<span class="ascii">Shift + Enter</span>」を押してください。</li>
</ol></li>
<li>より詳しい<span class="ascii">TidalCycles</span>の使い方は、<a href="https://qiita.com/mk668a/items/6e8e0151817f484a526c"><span class="ascii">TidalCycles</span>のチュートリアル<span class="ascii">1 - Qiita</span></a>など、他の方が書いた記事を検索してみてください。</li>
</ol>
<h1 id="ハマったこと"><span class="link-to-here-outer"><a href="#ハマったこと" title="ハマったこと"><span class="link-to-here">Link to<br />
here</span></a></span>ハマったこと</h1>
<h2 id="superdirtが見つからないという趣旨のエラーが出た"><span class="link-to-here-outer"><a href="#superdirtが見つからないという趣旨のエラーが出た" title="superdirtが見つからないという趣旨のエラーが出た"><span class="link-to-here">Link to<br />
here</span></a></span>「<span class="ascii">SuperDirt</span>が見つからない！」という趣旨のエラーが出た</h2>
<p>正確なエラーメッセージは申し訳なくも忘れてしまったのですが、<span class="ascii">SuperCollider</span>上で<code>SuperDirt.start</code>と入力した際、エラーになることがあります。<br />
この場合、<span class="ascii">SuperCollider</span>を再起動するのを忘れている可能性がありますので、再起動してみてください。<br />
<span class="ascii">SuperDirt</span>のインストールを終えた直後では、まだ<span class="ascii">SuperDirt</span>は利用できないのです。</p>
<h2 id="atom上でtidalcyclesを起動した際parse-error"><span class="link-to-here-outer"><a href="#atom上でtidalcyclesを起動した際parse-error" title="atom上でtidalcyclesを起動した際parse-error"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Atom</span>上で<span class="ascii">TidalCycles</span>を起動した際、<code>parse error</code></h2>
<p>先ほどの「<span class="ascii">Atom</span>上での<span class="ascii">TidalCycles</span>の起動」という手順で、<code>parse error (possibly incorrect indentation or mismatched brackets)</code>というエラーに出遭うことがあります。<br />
そのまま<span class="ascii">TidalCycles</span>の式を入力して「<span class="ascii">Shift + Enter</span>」しても、<code>Variable not in scope: d1 :: ControlPattern -&gt; t</code>などというエラーになってしまうでしょう。<br />
これは、前のセクションで触れた<span class="ascii">BootTidal.hs</span>というファイルを<span class="ascii">GHCi</span>が読み込む際に、エラーになってしまったからです。</p>
<p>原因はいろいろあり得るかと思いますが、私の場合、<code>~/.ghci</code>という<span class="ascii">GHCi</span>の設定ファイルに<code>:set +m</code>という行を加えていたためでした。<br />
まず、<code>~/.ghci</code>は、<span class="ascii">GHCi</span>が起動するときに必ず読み込まれるファイルです。<br />
必ず有効にしたい言語拡張や、<code>:set +m</code>のような<span class="ascii">GHCi</span>の設定を記載しておくファイルとなっています。要するに<code>~/.vimrc</code>などと似たようなものですね。<br />
そして<code>:set +m</code>は、<span class="ascii">GHCi</span>で複数行の入力を有効にするためのものです。<br />
<span class="ascii">GHCi</span>上で<code>:set +m</code>と実行すると、<span class="ascii">GHCi</span>は入力した行を見て「あっ、この入力はまだ続きがありそうだな」と判断したとき、次の行を自動で前の行の続きとして扱うようになります。<br />
そして、その場合入力の終了を<span class="ascii">GHCi</span>に伝えたい場合は、空行を入力しなければなりません。<br />
結果、<span class="ascii">BootTidal.hs</span>を読み込む際に、空行が入力されないため、意図しない行が「前の行の続き」と<span class="ascii">GHCi</span>に認識されてしまい、<code>parse error (possibly incorrect indentation or mismatched brackets)</code>となってしまうようです。</p>
<p>仕方ないので、直すために<code>~/.ghci</code>を開いて<code>:set +m</code>と書いた行をコメントアウトするか削除しちゃいましょう。<br />
再び<span class="ascii">Atom</span>で「<span class="ascii">Packages</span>」 <span class="ascii">-&gt;</span> 「<span class="ascii">TidalCycles</span>」 <span class="ascii">-&gt;</span> 「<span class="ascii">Boot TidalCycles</span>」の順にメニューをクリックすれば、今度は該当のエラーがなく起動するかと思います😌。</p>
<p>このエラーは、特にすでに<span class="ascii">Haskell</span>の開発環境を導入している方で遭遇するケースが多いかと思います。ご注意ください。</p>
<h2 id="superdirtを起動し忘れていても何もエラーが起きない"><span class="link-to-here-outer"><a href="#superdirtを起動し忘れていても何もエラーが起きない" title="superdirtを起動し忘れていても何もエラーが起きない"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">SuperDirt</span>を起動し忘れていても何もエラーが起きない</h2>
<p>表題の通りです。<br />
困ったことに<span class="ascii">SuperDirt</span>を起動し忘れた状態で<code>d1 $ sound "bd sn"</code>などの式を実行しても、特に何のエラーもなく、音も鳴りません。<br />
<small>（サーバーとして起動しているべき）</small><span class="ascii">SuperDirt</span>に接続し損ねたんだから、何かしらエラーが表示されてもいいはずなんですが、困ったことにウンともスンとも言いません😰。<br />
と、言うわけで、何のエラーもなく音も出なかった場合は、<span class="ascii">SuperDirt</span>を起動し忘れてないか確認しましょう。</p>
<h1 id="おわりに-haskell開発者として見たtidalcycles"><span class="link-to-here-outer"><a href="#おわりに-haskell開発者として見たtidalcycles" title="おわりに-haskell開発者として見たtidalcycles"><span class="link-to-here">Link to<br />
here</span></a></span>おわりに<span class="ascii">: Haskell</span>開発者として見た<span class="ascii">TidalCycles</span></h1>
<p><strong>※ここから先はおまけ <span class="ascii">+</span> 宣伝です。<span class="ascii">TidalCycles</span>をインストールしたいだけの方は適当に読み飛ばしてください</strong></p>
<p>ここまで、<span class="ascii">stack</span>という、昨今の<span class="ascii">Haskeller</span>の多くが好んで利用するツールで、<span class="ascii">TidalCycles</span>を利用する方法を説明しました。<br />
<span class="ascii">TidalCycles</span>の公式サイトの<span class="ascii">Wiki</span>にはこの方法は書かれてませんが、より確実なインストール方法として、覚えておいていただけると幸いです。<br />
すでに<span class="ascii">Haskell</span>の開発環境をインストールしている方にも参考になるかと思います。</p>
<p>ところで、ここまで<span class="ascii">TidalCycles</span>を自分でインストールしてみて、<span class="ascii">Haskeller</span>としていくつか気になった点があります。<br />
<span class="ascii">TidalCycles</span>は、<span class="ascii">Haskell</span>製の内部<span class="ascii">DSL</span>としては、ちょっと変わっているように感じました。</p>
<p>それは、<span class="ascii">TidalCycles</span>が「標準」として提供している関数を実行する際、<span class="ascii">tidal</span>パッケージに含まれるモジュールを<code>import</code>するだけでなく、<span class="ascii">BootTidal.hs</span>というファイルを読んで、追加の関数を定義する必要がある、という点です。<br />
大抵の<span class="ascii">Haskell</span>製の内部<span class="ascii">DSL</span>は、そんなことしなくてもモジュールを<code>import</code>するだけで使えるようになっています<small>（<a href="http://hspec.github.io/"><span class="ascii">Hspec</span></a>とか<a href="https://github.com/chrisdone/lucid"><span class="ascii">lucid</span></a>とか<a href="http://hackage.haskell.org/package/clay"><span class="ascii">clay</span></a>とか<a href="http://khibino.github.io/haskell-relational-record/"><span class="ascii">relational-record</span></a>とか）</small>。<br />
つまり本来ならばわざわざ、<span class="ascii">BootTidal.hs</span>のような、<span class="ascii">GHCi</span>が読み込む専用のファイルを用意しなくとも良いはずなのです。<br />
この<span class="ascii">BootTidal.hs</span>は<span class="ascii">Atom</span>のプラグインの設定で簡単に切り替えることができるものなので、もし間違ったファイルに設定してしまったら、言語の標準にあたる関数がおかしな動作をすることになりかねませんし、あまり良いやり方だとは思えません。本来なら設定に混ぜて書くべきものではないでしょう。</p>
<p>なぜ<span class="ascii">TidalCycles</span>はこんな仕様になっているかというと、それにはある意味<span class="ascii">Haskell</span>らしい制約が絡んでいると推測されます。<br />
<span class="ascii">Atom</span>上で<span class="ascii">TidalCycles</span>を起動する、というのは、実際には<span class="ascii">GHCi</span>を起動して、<a href="https://github.com/tidalcycles/Tidal/blob/master/BootTidal.hs"><span class="ascii">BootTidal.hs</span></a>というファイルを読み込ませる、ということなのでした<small>（事実、<span class="ascii">Atom</span>などのエディターを介さなくとも、お使いのターミナルエミュレーターから<code>ghci</code>コマンドを起動して<span class="ascii">BootTidal.hs</span>ファイルの中身をコピペするだけで、<span class="ascii">TidalCycles</span>は利用できます）</small>。<br />
その<span class="ascii">BootTidal.hs</span>の中身を見てみると、サンプルで実行した<code>d1</code>という関数が、下記のように定義されていることがわかります。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="co">-- ... 省略 ...</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="kw">import</span> <span class="dt">Sound.Tidal.Context</span></a>
<a class="sourceLine" id="cb3-3" title="3"></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="co">-- total latency = oLatency + cFrameTimespan</span></a>
<a class="sourceLine" id="cb3-5" title="5">tidal <span class="ot">&lt;-</span> startTidal (superdirtTarget {oLatency <span class="ot">=</span> <span class="fl">0.1</span>, oAddress <span class="ot">=</span> <span class="st">&quot;127.0.0.1&quot;</span>, oPort <span class="ot">=</span> <span class="dv">57120</span>}) (defaultConfig {cFrameTimespan <span class="ot">=</span> <span class="dv">1</span><span class="op">/</span><span class="dv">20</span>})</a>
<a class="sourceLine" id="cb3-6" title="6"></a>
<a class="sourceLine" id="cb3-7" title="7"><span class="kw">let</span> p <span class="ot">=</span> streamReplace tidal</a>
<a class="sourceLine" id="cb3-8" title="8"></a>
<a class="sourceLine" id="cb3-9" title="9"><span class="co">-- ... 省略 ...</span></a>
<a class="sourceLine" id="cb3-10" title="10"></a>
<a class="sourceLine" id="cb3-11" title="11"><span class="kw">let</span> d1 <span class="ot">=</span> p <span class="dv">1</span></a>
<a class="sourceLine" id="cb3-12" title="12"><span class="kw">let</span> d2 <span class="ot">=</span> p <span class="dv">2</span></a>
<a class="sourceLine" id="cb3-13" title="13"><span class="kw">let</span> d3 <span class="ot">=</span> p <span class="dv">3</span></a>
<a class="sourceLine" id="cb3-14" title="14"><span class="co">-- ...</span></a></code></pre></div>
<p><code>tidal &lt;- startTidal</code>で始まる行で、<span class="ascii">TidalCycles</span>の初期化を行っていると思われます。<br />
初期化の際には、サーバーとして起動している<span class="ascii">SuperDirt</span>への接続設定<small>（この場合<code>127.0.0.1</code>の<code>57120</code>番ポートへ接続している）</small>を渡しているようです。<br />
恐らくこの<code>startTidal</code>関数が、<span class="ascii">SuperDirt</span>へ接続し、代入した<code>tidal</code>という変数に、<span class="ascii">SuperDirt</span>への接続を含んでいるんでしょう。<br />
そして、<code>let p = streamReplace tidal</code>という行で、その<code>tidal</code>を<code>streamReplace</code>関数に<a href="http://capm-network.com/?tag=Haskell-%E9%83%A8%E5%88%86%E9%81%A9%E7%94%A8">部分適用</a>することで、<code>p</code>が<span class="ascii">SuperDirt</span>への接続を参照できるようにしています。<br />
さらに、<code>let d1 = p 1</code>などの行で、前の行で定義した<code>p</code>に整数<small>（シンセサイザーの番号だそうです）</small>を部分適用することで、結果、<code>d1</code>、<code>d2</code>などの関数へ、間接的に<code>tidal</code>を渡すことになります。</p>
<p>つまり<code>d1</code>や<code>d2</code>などの関数は、何らかの形で、<span class="ascii">SuperDirt</span>への接続情報を持っているのです。<br />
<span class="ascii">DSL</span>として、<code>d1</code>や<code>d2</code>などの関数に毎回接続情報を渡すのは煩雑だと考えたためでしょう。<br />
残念ながら、通常の<span class="ascii">Haskell</span>がそうであるように、外部のサーバーに接続した結果取得されるものを、関数が暗黙に参照できるようにしたい場合、 — つまり、今回のようにユーザーが接続情報を明示的に渡すことなく使えるようにしたい場合 — 少なくともパッケージを<code>import</code>するだけではうまくいきません<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>。<br />
<span class="ascii">BootTidal.hs</span>のように、<span class="ascii">SuperDirt</span>のような外部に接続する処理を、<span class="ascii">GHCi</span>の実行時に書かなければならないのです。</p>
<p>しかし、<code>tidal &lt;- startTidal</code>の行で作られる<span class="ascii">SuperDirt</span>への接続情報を<code>d1</code>などの関数が暗黙に利用できるようにすることは、実際には<span class="ascii">BootTidal.hs</span>で行っているような方法を使わなくともできます。<br />
そうすることで、<span class="ascii">BootTidal.hs</span>を変なファイルに切り替えてしまって、<code>d1</code>などの関数の定義が間違ったものになってしまう<small>（あるいはそもそも定義されなくなってしまう）</small>リスクを回避できます。<br />
具体的には、下記のような方法が考えられます。<br />
申し訳なくも私はこれ以上<span class="ascii">TidalCycles</span>に入れ込むつもりもないので、誰か<span class="ascii">TidalCycles</span>を気に入った方が適当に提案するなりパッチを送るなりしてみてください<small>（他力本願😰）</small>。</p>
<ul>
<li><span class="ascii">GHCi</span>の中で<code>ReaderT</code>を使う
<ul>
<li><span class="ascii">Haskell</span>で「関数に渡した引数を暗黙に利用できるようにする」といえば、やはり<code>ReaderT</code>モナドトランスフォーマーが一番オーソドックスな方法でしょう。<br />
実は<span class="ascii">GHCi</span>上では、<code>IO</code>以外のモナドのアクションで<code>print</code>することができます。<br />
<a href="https://www.reddit.com/r/haskell/comments/87otrn/you_can_override_the_monad_that_ghci_uses/"><span class="ascii">You can override the monad that GHCi uses</span></a>という<span class="ascii">Reddit</span>のスレッドでは、<code>ReaderT</code>を使ったサンプルが紹介されています。<br />
これと同じ要領で、<span class="ascii">GHCi</span>の<code>-interactive-print</code>というオプションに、<code>tidal</code>を<code>ReaderT</code>経由で渡してから結果を<code>print</code>する関数を設定しましょう。<br />
あとは<code>d1</code>などを<code>ReaderT</code>のアクションにするだけで、それらを<span class="ascii">BootTidal.hs</span>から消し去ることができます。<br />
残念ながらこの方法を使うと、<span class="ascii">GHCi</span>に与えた式の結果がすべて当該のモナドのアクションになっていなければならなくなるため、例えば単純な計算結果でさえ<code>return</code>をいちいち書かないといけなくなります。しかし、<span class="ascii">TidalCycles</span>の利用方法を見る限り、大きな問題にはならないだろうと思います。</li>
</ul></li>
<li><code>ImplicitParams</code>という<span class="ascii">GHC</span>の言語拡張を使う
<ul>
<li><span class="ascii">GHC</span>には、<code>ImplicitParams</code>という、もっと直接的にこれを実現する言語拡張があります。文字通り、暗黙の引数を実現するための拡張です<small>（<a href="https://qiita.com/philopon/items/e6d2522f5b514c219a5f">参考</a>）</small>。<br />
これを利用して、例えば<code>d1</code>を<code>?tidal :: Stream =&gt; ControlPattern -&gt; IO ()</code>のように型宣言しておき、<code>?tidal</code><small>（頭に<code>?</code>を付けたものが暗黙の引数となります）</small>を暗黙の引数として参照するようにしましょう。後は<span class="ascii">GHCi</span>の起動時に<code>?tidal</code>を定義すれば、<code>?tidal</code>の後に<code>d1</code>などを定義する必要がなくなるので、<span class="ascii">BootTidal.hs</span>はもっとコンパクトに済むはずです。</li>
</ul></li>
<li>その他、<code>unsafePerformIO</code>や<span class="ascii">Template Haskell</span>など、ちょっと危ない手段を使う
<ul>
<li>こちらについては詳細を割愛します。<code>d1</code>などの再利用性が下がるので、おすすめしません。</li>
</ul></li>
</ul>
<p><span class="ascii">TidalCycles</span>の技術的な側面で気になった点は以上です。<br />
ちょっと難しい話になってしまいましたが、これを機会に、<span class="ascii">Haskell</span>そのものへの興味を持っていただけると幸いです。<br />
素晴らしいことに、<span class="ascii">TidalCycles</span>そのものは<span class="ascii">Haskell</span>を知らなくてもそれなりに使えるようになっているようですが、<span class="ascii">Haskell</span>を知った上で使えば、より簡単にトラブルシューティングができるようになりますし、<span class="ascii">TidalCycles</span>をより柔軟に使えるようになるでしょう。</p>
<p>もし、今回の記事や<span class="ascii">TidalCycles</span>をきっかけに<span class="ascii">Haskell</span>を勉強してみたいと思ったら、<a href="https://wiki.haskell.jp/Links"><span class="ascii">Haskell-jp Wiki</span>の日本語のリンク集</a>を読んで、自分に合う入門コンテンツを見つけてみてください！<br />
それから、何か困ったことがあれば<a href="https://haskell-jp.slack.com/messages/C5666B6BB/convo/C4M4TT8JJ-1547294914.091800/"><span class="ascii">Haskell-jp</span>の<span class="ascii">Slack Workspace</span>にある、<span class="ascii">#questions</span>チャンネル</a>で質問してみてください。<br />
<a href="https://join.slack.com/t/haskell-jp/shared_invite/enQtNDY4Njc1MTA5MDQxLTAzZGNkZDlkMWYxZDRlODI3NmNlNTQ1ZDc3MjQxNzg3OTg4YzUzNmUyNmU5YWVkMjFmMjFjYzk1OTE3Yzg4ZTM">登録はこちら</a>からどうぞ！</p>
<p>それでは<span class="ascii">2019</span>年も<span class="ascii">Haskell</span>と<span class="ascii">TidalCycles</span>で<span class="ascii">Happy Hacking!!</span> 🎶🎶🎶</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>どのバージョンの<span class="ascii">LTS Haskell</span>でどのバージョンの<span class="ascii">GHC</span>がインストールされるかは、<span class="ascii">LTS Haskell</span>を管理している<a href="https://www.stackage.org/">「<span class="ascii">Stackage</span>」というウェブサイトのトップページ</a>にある、「<span class="ascii">Latest LTS per GHC version</span>」というセクションをご覧ください。<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>後で軽く触れる、<span class="ascii">Template Haskell</span>という邪悪なテクニックを使わない限りは。<a href="#fnref2" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/hourly-antenna.html" lang="ja">DroneでHaskell Antennaを毎時更新する</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2018/super-precure-monad.html" style="margin-left: auto;" lang="ja">モナドの新しい力！スーパープリキュアモナド！</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>モナドの新しい力！スーパープリキュアモナド！</title>
    <link href="https://haskell.jp/blog/posts/2018/super-precure-monad.html" />
    <id>https://haskell.jp/blog/posts/2018/super-precure-monad.html</id>
    <published>2018-12-27T00:00:00Z</published>
    <updated>2018-12-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#この記事は" title="この記事は">この記事は</a></li>
<li><a href="#課題-プリキュアに変身していない状態で浄化技を使おうとした場合型エラーにしたい" title="課題-プリキュアに変身していない状態で浄化技を使おうとした場合型エラーにしたい">課題<span class="ascii">:</span> プリキュアに変身していない状態で浄化技を使おうとした場合、型エラーにしたい</a></li>
<li><a href="#実現方法-indexed-monadと型レベル連想配列を使う" title="実現方法-indexed-monadと型レベル連想配列を使う">実現方法<span class="ascii">: Indexed Monad</span>と型レベル連想配列を使う</a></li>
<li><a href="#できたもの" title="できたもの">できたもの</a>
<ul>
<li><a href="#super-precure-monadを試す方法" title="super-precure-monadを試す方法">✨<span class="ascii">Super PreCure Monad</span>✨を試す方法</a></li>
</ul></li>
</ul>
</div>
</div>
<h1 id="この記事は"><span class="link-to-here-outer"><a href="#この記事は" title="この記事は"><span class="link-to-here">Link to<br />
here</span></a></span>この記事は</h1>
<p>この記事は<a href="https://qiita.com/advent-calendar/2018/haskell2"><span class="ascii">Haskell Advent Calendar</span> その<span class="ascii">2</span></a>兼<a href="https://adventar.org/calendars/2984">プリキュア<span class="ascii">Advent Calendar 2018</span></a><span class="ascii">5</span>日目の記事です。<br />
毎度同時投稿で失礼します。<br />
今年は私用で忙しかったので、のんびり書いてできあがったら空いてる日に投稿する、という楽なスタイルで書かせていただきました。なのでタイムスリップして<span class="ascii">5</span>日目の記事と言うことにします<small>（それにしてもずいぶん時間かかってしまってすみません、もうクリスマスも過ぎたし…😥）</small>。</p>
<p>今回も例年の私の<span class="ascii">Advent Calendar</span>どおり、<a href="https://github.com/igrep/typesafe-precure">タイプセーフプリキュア！</a>に、最近追加しようとした機能と、その際使用したもろもろの要素技術についての記事です。<br />
タイプセーフプリキュア！そのものについては<a href="https://haskell.jp/blog/posts/2018/substring-parser.html">今年<span class="ascii">9</span>月の記事</a>や、そこで言及しているもっと古い記事をご覧ください。</p>
<h1 id="課題-プリキュアに変身していない状態で浄化技を使おうとした場合型エラーにしたい"><span class="link-to-here-outer"><a href="#課題-プリキュアに変身していない状態で浄化技を使おうとした場合型エラーにしたい" title="課題-プリキュアに変身していない状態で浄化技を使おうとした場合型エラーにしたい"><span class="link-to-here">Link to<br />
here</span></a></span>課題<span class="ascii">:</span> プリキュアに変身していない状態で浄化技を使おうとした場合、型エラーにしたい</h1>
<p>従来より、タイプセーフプリキュア！には、<code>PreCureMonad</code>と呼ばれる、プリキュアの台詞を<code>do</code>記法で組み立てる機能があります。<br />
例えば<span class="ascii">GHCi</span>上で下記のように書くだけで、<a href="https://www.youtube.com/watch?v=oQLIyIZ2vk0">「<span class="ascii">Go!</span> プリンセスプリキュア」のあの名シーン</a>を再現できます<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="op">&gt;</span> <span class="op">:</span>m <span class="dt">ACME.PreCure</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="op">&gt;</span> <span class="op">:</span>{</a>
<a class="sourceLine" id="cb1-3" title="3"><span class="op">&gt;</span> <span class="kw">let</span> scene <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="op">&gt;</span>       say <span class="st">&quot;この罪を抱いたまま、もう一度、グランプリンセスを目指す！&quot;</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="op">&gt;</span>       scarlet <span class="ot">&lt;-</span> transform <span class="dt">Towa</span> (<span class="dt">PrincessPerfume</span> <span class="dt">DressUpKeyScarlet</span>)</a>
<a class="sourceLine" id="cb1-6" title="6"><span class="op">&gt;</span>       scarletModeElegant <span class="ot">&lt;-</span> transform scarlet (<span class="dt">PrincessPerfume</span> <span class="dt">DressUpKeyPhoenix</span>)</a>
<a class="sourceLine" id="cb1-7" title="7"><span class="op">&gt;</span>       purify scarletModeElegant (<span class="dt">ScarletViolin</span> <span class="dt">DressUpKeyPhoenix</span>)</a>
<a class="sourceLine" id="cb1-8" title="8"><span class="op">&gt;</span> <span class="op">:</span>}</a></code></pre></div>
<p>名シーンを単純な文字列のリストとして使いたい場合はこう👇しましょう<small>（出力は手で見やすく加工しています）</small>。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1">ghci<span class="op">&gt;</span> composeEpisode scene</a>
<a class="sourceLine" id="cb2-2" title="2">[ <span class="st">&quot;この罪を抱いたまま、もう一度、グランプリンセスを目指す！&quot;</span></a>
<a class="sourceLine" id="cb2-3" title="3">, <span class="st">&quot;プリキュア！プリンセスエンゲージ！&quot;</span></a>
<a class="sourceLine" id="cb2-4" title="4">, <span class="st">&quot;深紅の炎のプリンセス！キュアスカーレット！&quot;</span></a>
<a class="sourceLine" id="cb2-5" title="5">, <span class="st">&quot;冷たい檻に閉ざされた夢、返していただきますわ。&quot;</span></a>
<a class="sourceLine" id="cb2-6" title="6">, <span class="st">&quot;お覚悟を決めなさい！&quot;</span></a>
<a class="sourceLine" id="cb2-7" title="7">, <span class="st">&quot;エクスチェンジ！モードエレガント！&quot;</span></a>
<a class="sourceLine" id="cb2-8" title="8">, <span class="st">&quot;スカーレット・バイオリン！フェニックス！&quot;</span></a>
<a class="sourceLine" id="cb2-9" title="9">, <span class="st">&quot;羽ばたけ炎の翼！&quot;</span></a>
<a class="sourceLine" id="cb2-10" title="10">, <span class="st">&quot;プリキュア！ フェニックス・ブレイズ！&quot;</span></a>
<a class="sourceLine" id="cb2-11" title="11">, <span class="st">&quot;ごきげんよう。&quot;</span></a>
<a class="sourceLine" id="cb2-12" title="12">]</a></code></pre></div>
<p>さらに<code>printEpisode</code>という関数で実行すれば、<span class="ascii">1</span>行ごとに間隔を置いてあの台詞を再生できます。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1">ghci<span class="op">&gt;</span> printEpisode scene</a>
<a class="sourceLine" id="cb3-2" title="2">この罪を抱いたまま、もう一度、グランプリンセスを目指す！</a>
<a class="sourceLine" id="cb3-3" title="3">プリキュア！プリンセスエンゲージ！</a>
<a class="sourceLine" id="cb3-4" title="4">深紅の炎のプリンセス！キュアスカーレット！</a>
<a class="sourceLine" id="cb3-5" title="5">冷たい檻に閉ざされた夢、返していただきますわ。</a>
<a class="sourceLine" id="cb3-6" title="6">お覚悟を決めなさい！</a>
<a class="sourceLine" id="cb3-7" title="7">エクスチェンジ！モードエレガント！</a>
<a class="sourceLine" id="cb3-8" title="8">スカーレット・バイオリン！フェニックス！</a>
<a class="sourceLine" id="cb3-9" title="9">羽ばたけ炎の翼！</a>
<a class="sourceLine" id="cb3-10" title="10">プリキュア！ フェニックス・ブレイズ！</a>
<a class="sourceLine" id="cb3-11" title="11">ごきげんよう。</a></code></pre></div>
<p>そんな<code>PreCureMonad</code>ですが、先ほどのコードをよく読めばわかるとおり、ちょっと不格好ですよね。<br />
具体的には下記の<span class="ascii">2</span>行です。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1">scarlet <span class="ot">&lt;-</span> transform <span class="dt">Towa</span> (<span class="dt">PrincessPerfume</span> <span class="dt">DressUpKey_Scarlet</span>)</a>
<a class="sourceLine" id="cb4-2" title="2">scarletModeElegant <span class="ot">&lt;-</span> transform scarlet (<span class="dt">PrincessPerfume</span> <span class="dt">DressUpKeyPhoenix</span>)</a></code></pre></div>
<p><span class="ascii">1</span>行目の<code>transform</code>関数が、変身する女の子である<code>Towa</code>（赤城トワ）と変身アイテムを受け取って<code>CureScarlet</code>を返し、さらにその<code>CureScarlet</code>を<span class="ascii">2</span>行目の<code>transform</code>関数に渡すことでキュアスカーレットのモード・エレガント（<code>CureScarlet_ModeElegant</code>）を取得しています。<br />
「<code>transform</code>関数が、変身する女の子である<code>Towa</code>（赤城トワ）と変身アイテムを受け取って<code>CureScarlet</code>を」返すという箇所について、<code>Towa</code>に<strong>加えて</strong><code>CureScarlet</code>を<strong>新しく作っている</strong>ように聞こえます。<br />
本来同一人物であるはずの<code>Towa</code>と<code>CureScarlet</code>を、あたかも別々のものとして扱っているように捉えられかねません。<br />
そう、本来プリキュアの「変身」は女の子自身の状態を書き換えるものとして表現した方が自然なのです。</p>
<p><span class="ascii">Haskell</span>でそうした「状態」を表現する場合、名前のとおり<code>State</code> <span class="ascii">Monad</span>を使うのが割と一般的な方法です<small>（プログラム全体で状態を管理する場合、<code>IORef</code>や<code>TVar</code>などを使う方が例外に強く安全ではありますが、それはさておき）</small>。<br />
しかし、従来の<code>State</code> <span class="ascii">Monad</span>でプリキュアの変身や浄化技を表現する場合、<strong>女の子が変身していない状態で浄化技<span class="ascii">(</span><code>purify</code><span class="ascii">)</span>を使おうとした場合をどのように扱うか</strong>、という問題があります。<br />
先ほどの例で言うところの</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1">purify scarletModeElegant (<span class="dt">ScarletViolin</span> <span class="dt">DressUpKeyPhoenix</span>)</a></code></pre></div>
<p>という行でまさにその「浄化技」を実行しているのですが、プリキュアの設定上、特定の浄化技を使うには、特定のプリキュアのフォームに、専用のアイテムを渡さなければなりません。<br />
タイプセーフプリキュア！ではこの点に強くこだわり、浄化技が使用できる組み合わせごとに型クラスのインスタンスを定義することで、間違った組み合わせを<code>purify</code>関数に渡すと、型エラーになります<small>（詳しくは<a href="https://qiita.com/igrep/items/5496fa405fae00b5a737">タイプセーフプリキュア！を最初に技術的に解説した記事</a>をご覧ください）</small>。<br />
当然、まだ変身していない状態の女の子を<code>purify</code>関数に渡しても、エラーになってしまいます。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="op">&gt;</span> scene <span class="ot">=</span> purify <span class="dt">Towa</span> (<span class="dt">ScarletViolin</span> <span class="dt">DressUpKeyPhoenix</span>)</a>
<a class="sourceLine" id="cb6-2" title="2"></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">4</span><span class="op">:</span><span class="dv">9</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span></a>
<a class="sourceLine" id="cb6-4" title="4">    • <span class="dt">No</span> <span class="kw">instance</span> for (<span class="dt">Purification</span></a>
<a class="sourceLine" id="cb6-5" title="5">                         <span class="dt">Towa</span> (<span class="dt">ScarletViolin</span> <span class="dt">DressUpKeyPhoenix</span>))</a>
<a class="sourceLine" id="cb6-6" title="6">        arising from a use <span class="kw">of</span> ‘purify’</a>
<a class="sourceLine" id="cb6-7" title="7">    • <span class="dt">In</span> the expression<span class="op">:</span> purify <span class="dt">Towa</span> (<span class="dt">ScarletViolin</span> <span class="dt">DressUpKeyPhoenix</span>)</a>
<a class="sourceLine" id="cb6-8" title="8">      <span class="dt">In</span> an equation for ‘scene’<span class="op">:</span></a>
<a class="sourceLine" id="cb6-9" title="9">          scene <span class="ot">=</span> purify <span class="dt">Towa</span> (<span class="dt">ScarletViolin</span> <span class="dt">DressUpKeyPhoenix</span>)</a></code></pre></div>
<p>プリキュア実装の大先輩である<a href="https://github.com/sue445/rubicure"><span class="ascii">rubicure</span></a>では、同じようなケースで実行時エラーを出すようにしていますし、<span class="ascii">PreCure Monad</span>においても、<code>ExceptT</code>を使ってエラーにする、という方法が採れるでしょう。<br />
しかしそこは「タイプセーフプリキュア！」。どうにかして、変身していない状態での<code>purify</code>関数の実行を型エラーにして、従来のこの振る舞いと一貫させたいところですよね。<br />
というのが今回の課題です。</p>
<h1 id="実現方法-indexed-monadと型レベル連想配列を使う"><span class="link-to-here-outer"><a href="#実現方法-indexed-monadと型レベル連想配列を使う" title="実現方法-indexed-monadと型レベル連想配列を使う"><span class="link-to-here">Link to<br />
here</span></a></span>実現方法<span class="ascii">: Indexed Monad</span>と型レベル連想配列を使う</h1>
<p>今回の課題のとおり、「変身していない状態での<code>purify</code>関数の実行を型エラー」としつつ、「変身した状態での<code>purify</code>を型エラーとしない」ためには、<code>purify</code>や<code>transform</code>を実行する前後で、<code>State</code> <span class="ascii">Monad</span>内で共有している値の型を変更できるようにする必要があります。<br />
残念ながら、これは従来の<code>State</code> <span class="ascii">Monad</span>では不可能です。<br />
<code>State s</code>に対する<code>&gt;&gt;=</code>の型が<code>(&gt;&gt;=) :: State s a -&gt; (a -&gt; State s b) -&gt; State s b</code>となっていることから察せられるとおり、<code>State</code> <span class="ascii">Monad</span>の中で共有する型は、アクションの実行前後にかかわらず同じ<code>s</code>でないといけないためです。<br />
これはそもそも従来の<span class="ascii">Monad</span>の仕様上やむを得ないことです。<br />
従来の<span class="ascii">Monad</span>はそもそもアクションの実行前後で、アクションの実行結果以外の型を変えることができないようになっています。<br />
<code>&gt;&gt;=</code>の型が<code>(&gt;&gt;=) :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b</code>となっていることからしても、アクションの実行前後で<code>m</code>は<code>m</code>のままであることがわかります。</p>
<p>この、「アクションの実行前後で、<code>m</code>の型を変えることができる」ようにしたのが<span class="ascii">Indexed Monad</span>です。<br />
<span class="ascii">Indexed Monad</span>は次のような型宣言にすることで、アクションの実行前後で異なる型の “<span class="ascii">index</span>” を挟めるようになっています。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">class</span> <span class="dt">IxApplicative</span> m <span class="ot">=&gt;</span> <span class="dt">IxMonad</span> m <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="ot">  ibind ::</span> (a <span class="ot">-&gt;</span> m j k b) <span class="ot">-&gt;</span> m i j a <span class="ot">-&gt;</span> m i k b</a></code></pre></div>
<p><code>IxApplicative</code>は名前のとおり<code>IxMonad</code>と同様に“<span class="ascii">index</span>”が付いた<code>Applicative</code>となっています。<a href="http://hackage.haskell.org/package/indexed-0.1/docs/Control-Monad-Indexed.html">詳しい定義はドキュメント</a>をご覧ください。</p>
<p>唯一のメソッドである<code>ibind</code>が、普通の<span class="ascii">Monad</span>における<code>&gt;&gt;=</code>の引数をひっくり返して“<span class="ascii">index</span>”を追加したものです。<br />
<code>(&gt;&gt;=) :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b</code>の<code>m</code>に、型引数が<span class="ascii">2</span>つ追加されていますね？これが“<span class="ascii">index</span>”です。<br />
ある<code>IxMonad</code> <code>m</code>が<code>m i j a</code>という形で型引数を渡されている時、<code>i</code>がアクションを実行する<strong>前</strong>の型、<code>j</code>がアクションを実行した<strong>後</strong>の型を表します。<br />
<code>a</code>は普通の<code>Monad</code>と同様、アクションの実行結果となっています。</p>
<p>さらに<span class="ascii">Indexed</span>な<code>State</code> <span class="ascii">Monad (</span><code>IxState</code><span class="ascii">)</span>で使えるアクションの型宣言を見れば、<code>IxState</code>で共有している状態の型が、アクションの実行前後で変更できることがよりはっきりとわかるでしょう。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="ot">iget ::</span>      <span class="dt">IxState</span> i i i</a>
<a class="sourceLine" id="cb8-2" title="2"><span class="co">-- ^ igetしてもIxStateが管理している状態は変わらないため、型もやはり変わらず。</span></a>
<a class="sourceLine" id="cb8-3" title="3"></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="ot">iput ::</span> j <span class="ot">-&gt;</span> <span class="dt">IxState</span> i j ()</a>
<a class="sourceLine" id="cb8-5" title="5"><span class="co">-- ^ iputするとIxStateが管理している状態は、引数で渡した値の型に変わる。</span></a></code></pre></div>
<p>こちらもおなじみ<a href="http://hackage.haskell.org/package/mtl"><span class="ascii">mtl</span>パッケージ</a>にある<code>State</code> <span class="ascii">Monad</span>に、単純に “<span class="ascii">index</span>” を加えただけのものとなっています。</p>
<p><a href="http://fumieval.hatenablog.com/entry/2013/05/04/144840"><span class="ascii">Indexed Monad</span>の世界 <span class="ascii">-</span> モナドとわたしとコモナド</a>で紹介された際の<span class="ascii">Indexed Monad</span>は、<code>ido</code>という<span class="ascii">Quasi Quote</span>を使って<code>do</code>記法を無理矢理シミュレートしていましたが、現在は<span class="ascii">GHC</span>の<code>RebindableSyntax</code>という拡張を使うことで、普通の<code>do</code>記法をそのまま利用することができるようになりました<small>（例は後で紹介します）</small>。<br />
さらに、現在は<code>RebindableSyntax</code>を使った場合の諸々の問題を回避するべく、<a href="https://github.com/jbracker/supermonad"><span class="ascii">Indexed Monad</span>を一般化した<span class="ascii">Super Monad</span>と、それを簡単に使えるようにした<span class="ascii">GHC</span>の型チェッカープラグイン</a>が作られたり、<a href="https://github.com/isovector/do-notation"><span class="ascii">do-notation</span>という、<span class="ascii">Indexed Monad</span>と普通の<span class="ascii">Monad</span>を型クラスで抽象化したパッケージ</a>が作られたりしています。<br />
今回は純粋に<span class="ascii">Indexed Monad</span>を使うだけで十分だったので、<span class="ascii">Super Monad</span>や<span class="ascii">do-notation</span>は使用しませんでしたが、今後<span class="ascii">Indexed Monad</span>をもっと実践的に使用する機会があれば、使用してみたいと思います。</p>
<p><span class="ascii">Indexed Monad</span>を使用することで、<code>State</code> <span class="ascii">Monad</span>で共有している状態の型を、アクションの実行前後で変更できるようになりました。<br />
続いて、各女の子の状態を、<code>State</code> <span class="ascii">Monad</span>で共有している状態の型として、どのように管理するかを検討しましょう。<br />
というのも、タイプセーフプリキュア！には最新の<span class="ascii">master</span>の時点で<span class="ascii">59</span>人の女の子が収録されている<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>のですが、それらすべてを変身前と変身後に分けて管理するだけでも、<span class="ascii">2 ^ 59</span>通りの状態を型として表現できなければなりません。<br />
これを直感的に表現できるようにするために、ちょっと型レベルプログラミングの力を借りましょう。そこで登場するのが「型レベル連想配列」です。<br />
「型レベル連想配列」という言い方はあまりしないのでピンとこないかも知れませんが、要するに型<small>（タイプセーフプリキュア！の場合、プリキュアに変身する女の子一人一人に個別の型を割り当てているので、その個別の型）</small>と、それに対応する値のペアを含んだ型レベルリストです。<br />
大雑把に言うと、下記👇のような内容となります<small>（実際にはもう少し違う型で構成されています）</small>。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1">[ (<span class="dt">Hana</span>,   <span class="dt">HasTransformed</span> <span class="dt">&#39;True</span>)</a>
<a class="sourceLine" id="cb9-2" title="2"><span class="co">-- ^ プリキュアに変身する女の子を表す型（この場合「HUGっと！プリキュア」の野乃はな）</span></a>
<a class="sourceLine" id="cb9-3" title="3"></a>
<a class="sourceLine" id="cb9-4" title="4">, (<span class="dt">Saaya</span>,  <span class="dt">HasTransformed</span> <span class="dt">&#39;False</span>)</a>
<a class="sourceLine" id="cb9-5" title="5"><span class="co">--         ^ 対応する女の子が変身しているかどうかを表すsingleton type。</span></a>
<a class="sourceLine" id="cb9-6" title="6"><span class="co">--           DataKindsで型に持ち上げられたBoolを、普通の値として扱えるよう変換するためのラッパー。</span></a>
<a class="sourceLine" id="cb9-7" title="7"><span class="co">--           申し訳なくもsingleton typeについては割愛します。</span></a>
<a class="sourceLine" id="cb9-8" title="8"><span class="co">--           Haskell-jpのSlack Workspaceあたりでリクエストがあったら書こうかな。</span></a>
<a class="sourceLine" id="cb9-9" title="9"></a>
<a class="sourceLine" id="cb9-10" title="10">, (<span class="dt">Homare</span>, <span class="dt">HasTransformed</span> <span class="dt">&#39;False</span>)</a>
<a class="sourceLine" id="cb9-11" title="11">, <span class="op">...</span></a>
<a class="sourceLine" id="cb9-12" title="12">]</a></code></pre></div>
<p>別の視点で見ると、これはいわゆる<span class="ascii">Extensible Record</span>とも似ています。<br />
<a href="http://hackage.haskell.org/package/extensible"><span class="ascii">extensible</span>パッケージ</a>や<a href="https://github.com/chrisdone/labels"><span class="ascii">labels</span>パッケージ</a>、<a href="https://www.athiemann.net/2017/07/02/superrecord.html"><span class="ascii">superrecord</span>パッケージ</a>がそうしているように、<span class="ascii">Extensible Record</span>は、フィールドのラベルを表す<small>（型レベルの、静的な）</small>文字列をキーとして、それに対応する値を含んだ連想配列として見なすことができるためです。<br />
事実私は今回、<span class="ascii">extensible</span>を使ってこの機能を実装しました。他の<span class="ascii">Extensible Record</span>の実装でも良かったのですが、これ以外のものを全く使ったことがないので😅。</p>
<h1 id="できたもの"><span class="link-to-here-outer"><a href="#できたもの" title="できたもの"><span class="link-to-here">Link to<br />
here</span></a></span>できたもの</h1>
<p><span class="ascii">Indexed Monad</span>と<span class="ascii">Extensible Record</span>を組み合わせることで、<span class="ascii">PreCureMonad</span>の各種アクションを、次のように置き換えられることがわかりました。</p>
<ul>
<li><code>transform &lt;girl&gt; &lt;item&gt;</code><span class="ascii">:</span>
<ul>
<li><code>IxState</code>（実際にはその<span class="ascii">Monad Transformer</span>版である<code>IxStateT</code>）で共有している型レベル連想配列のキー<code>&lt;girl&gt;</code>に対応する値を「変身した状態」に更新する。</li>
<li><code>&lt;girl&gt;</code>がすでに変身している状態の場合は、型レベル連想配列のキー<code>&lt;girl&gt;</code>に対応する値が「変身した状態」になっているので型エラーとする。</li>
<li><code>IxStateT</code>をかぶせた<code>Writer</code> <span class="ascii">Monad</span>で共有しているリストに、<code>&lt;girl&gt;</code>と<code>&lt;item&gt;</code>に対応した、変身時の台詞（文字列）を追記する。</li>
</ul></li>
<li><code>purify &lt;precure&gt; &lt;item&gt;</code><span class="ascii">:</span>
<ul>
<li><code>IxStateT</code>で共有している型レベル連想配列のキーを取得するため、<code>&lt;precure&gt;</code>にあらかじめ定義しておいた<span class="ascii">Type Family</span> <code>AsGirl</code>を適用する。
<ul>
<li><code>AsGirl</code>で取得した型を、これ以降<code>&lt;girl&gt;</code>と呼びます。</li>
</ul></li>
<li><code>&lt;girl&gt;</code>が「変身した状態」になっていない場合は、型レベル連想配列のキー<code>&lt;girl&gt;</code>に対応する値が「変身していない状態」になっているので型エラーとする。</li>
<li><code>IxStateT</code>をかぶせた<code>Writer</code> <span class="ascii">Monad</span>で共有しているリストに、<code>&lt;precure&gt;</code>と<code>&lt;item&gt;</code>に対応した、浄化技を使用したときの台詞（文字列）を追記する。</li>
</ul></li>
</ul>
<p>このように生まれ変わった<span class="ascii">PreCure Monad</span>を<strong>✨<span class="ascii">Super PreCure Monad</span>✨</strong>と呼ぶこととします💪</p>
<p>下記が<span class="ascii">Super PreCure Monad</span>のサンプルコードです。<br />
野乃はながキュアエールに変身して、「ハート・フォー・ユー」という浄化技を放つまでを表しています。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="ot">cureYell ::</span> <span class="dt">PreCureM</span> (<span class="dt">StatusTable</span> &#39;[]) (<span class="dt">StatusTable</span> &#39;[<span class="dt">Hana</span> <span class="op">&gt;:</span> <span class="dt">HasTransformed</span> <span class="dt">&#39;True</span>]) ()</a>
<a class="sourceLine" id="cb10-2" title="2">cureYell <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-3" title="3">  enter <span class="dt">Hana</span></a>
<a class="sourceLine" id="cb10-4" title="4">  transform <span class="dt">Hana</span> (<span class="dt">PreHeart</span> <span class="dt">MiraiCrystalPink</span>)</a>
<a class="sourceLine" id="cb10-5" title="5">  purify <span class="dt">CureYell</span> (<span class="dt">PreHeart</span> <span class="dt">MiraiCrystalPink</span>)</a></code></pre></div>
<p><code>enter</code>は、旧<span class="ascii">PreCureMonad</span>にはない、<span class="ascii">Super PreCure Monad</span>に新しく追加されたアクションです。<br />
引数で指定された女の子や、女の子が変身したプリキュアを「登場」させます。<br />
具体的には、以下のように振る舞います。</p>
<ul>
<li>引数で指定された値が女の子<code>&lt;girl&gt;</code>であれば、<code>IxStateT</code>で共有している型レベル連想配列のキー<code>&lt;girl&gt;</code>に対応する値を「変身していない状態」で追加する。</li>
<li>引数で指定された値がすでに変身したプリキュア<code>&lt;precure&gt;</code>であれば、<code>&lt;precure&gt;</code>に<span class="ascii">Type Family</span> <code>AsGirl</code>を適用し、女の子を表す値<code>&lt;girl&gt;</code>を取得する。
<ul>
<li><code>IxStateT</code>で共有している型レベル連想配列のキー<code>&lt;girl&gt;</code>に対応する値を「変身した状態」で追加する。</li>
</ul></li>
</ul>
<p>したがって、<code>transform</code>するにしても<code>purify</code>するにしても、事前に変身前の女の子かその変身後のプリキュアが<code>enter</code>していないといけません。<br />
これは単純にその方が実装が簡単だから、という理由もありますし、一旦「登場」させたほうがなんとなくかっこいいかな、と感じたからです。</p>
<h2 id="super-precure-monadを試す方法"><span class="link-to-here-outer"><a href="#super-precure-monadを試す方法" title="super-precure-monadを試す方法"><span class="link-to-here">Link to<br />
here</span></a></span>✨<span class="ascii">Super PreCure Monad</span>✨を試す方法</h2>
<p>ここまで述べたような基本的な仕様は実装できたものの、まだ解決すべき技術的な問題が見つかったので、残念ながらリリースはされていません<small>（その詳細は気が向いたら書きます）</small>。<br />
なので、試す場合は下記のように実行してください。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="op">$</span> chcp <span class="dv">65001</span></a>
<a class="sourceLine" id="cb11-2" title="2"><span class="co">-- ^ Windowsの方は恐らく必要</span></a>
<a class="sourceLine" id="cb11-3" title="3"></a>
<a class="sourceLine" id="cb11-4" title="4"><span class="op">$</span> git clone <span class="op">-</span>b super<span class="op">-</span>precure<span class="op">-</span>monad https<span class="op">://</span>github<span class="op">.</span>com<span class="op">/</span>igrep<span class="op">/</span>typesafe<span class="op">-</span>precure<span class="op">.</span>git</a>
<a class="sourceLine" id="cb11-5" title="5"><span class="op">$</span> cd typesafe<span class="op">-</span>precure</a>
<a class="sourceLine" id="cb11-6" title="6"><span class="op">$</span> stack build</a>
<a class="sourceLine" id="cb11-7" title="7"><span class="op">$</span> stack exec ghci</a>
<a class="sourceLine" id="cb11-8" title="8"><span class="op">&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XRebindableSyntax</span> <span class="op">-</span><span class="dt">XFlexibleContexts</span> <span class="op">-</span><span class="dt">XTypeFamilies</span></a>
<a class="sourceLine" id="cb11-9" title="9"><span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> ((&gt;&gt;), (&gt;&gt;=))</a>
<a class="sourceLine" id="cb11-10" title="10"><span class="op">&gt;</span> <span class="op">:</span>m <span class="op">+</span> <span class="dt">ACME.PreCure</span> <span class="dt">ACME.PreCure.Monad.Super</span></a>
<a class="sourceLine" id="cb11-11" title="11"><span class="op">&gt;</span> <span class="op">:</span>{</a>
<a class="sourceLine" id="cb11-12" title="12"><span class="op">&gt;</span> scene <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-13" title="13"><span class="op">&gt;</span>       enter <span class="dt">Makoto</span></a>
<a class="sourceLine" id="cb11-14" title="14"><span class="op">&gt;</span>       transform <span class="dt">Makoto</span> (<span class="dt">LovelyCommuneDavi</span> <span class="dt">CureLoveads</span>)</a>
<a class="sourceLine" id="cb11-15" title="15"><span class="op">&gt;</span>       purify <span class="dt">CureSword</span> (<span class="dt">LovelyCommuneDavi</span> <span class="dt">CureLoveads</span>)</a>
<a class="sourceLine" id="cb11-16" title="16"><span class="op">&gt;</span> <span class="op">:</span>}</a>
<a class="sourceLine" id="cb11-17" title="17"><span class="op">&gt;</span> printEpisode scene</a>
<a class="sourceLine" id="cb11-18" title="18">(ダビィー！)</a>
<a class="sourceLine" id="cb11-19" title="19">プリキュア！ラブリンク！</a>
<a class="sourceLine" id="cb11-20" title="20">(<span class="dt">L</span><span class="op">!</span> <span class="dt">O</span><span class="op">!</span> <span class="dt">V</span><span class="op">!</span> <span class="dt">E</span><span class="op">!</span>)</a>
<a class="sourceLine" id="cb11-21" title="21">勇気の刃！ キュアソード！</a>
<a class="sourceLine" id="cb11-22" title="22">このキュアソードが 愛の剣で、あなたの野望を断ち切ってみせる！</a>
<a class="sourceLine" id="cb11-23" title="23">閃け！ホーリー・ソード！</a></code></pre></div>
<p>「変身していない状態での<code>purify</code>関数の実行を型エラーとする」といった仕様を試す場合は、<a href="https://github.com/igrep/typesafe-precure/blob/super-precure-monad/gen/AllPreCureM.hs">こちらに置いた、全プリキュアの変身と浄化技を列挙したテスト用ファイル</a>を<span class="ascii">ghci</span>で読んでみるといいでしょう。<br />
先ほど👆の手順で<code>git clone</code>したディレクトリーにおいて、あらかじめ<code>stack build</code>を実行しておくのをお忘れなく。</p>
<pre><code>$ stack build
$ stack exec ghci gen/AllPreCureM.hs</code></pre>
<p>適当に<code>gen/AllPreCureM.hs</code>を書き換えて<code>:r</code>してみれば、概ねいい感じに動いていることがわかるはずです。</p>
<p>例えば冒頭付近にある、</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1">act_CureDiamond_LovelyCommuneRaquel_CureLoveads <span class="ot">=</span> printEpisode <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb13-2" title="2">  enter <span class="dt">Rikka</span></a>
<a class="sourceLine" id="cb13-3" title="3">  transform <span class="dt">Rikka</span> (<span class="dt">LovelyCommuneRaquel</span> <span class="dt">CureLoveads</span>)</a>
<a class="sourceLine" id="cb13-4" title="4">  purify <span class="dt">CureDiamond</span> (<span class="dt">LovelyCommuneRaquel</span> <span class="dt">CureLoveads</span>)</a></code></pre></div>
<p>という<span class="ascii">Super PreCure Monad</span>によるアクションから、<code>transform Rikka (LovelyCommuneRaquel CureLoveads)</code>という行を削除した上で<code>:r</code>してみると、次のようなエラーになります。</p>
<pre><code>&gt; :r
[1 of 1] Compiling AllPreCureM      ( gen\AllPreCureM.hs, interpreted )

gen\AllPreCureM.hs:22:3: error:
    • Couldn&#39;t match type ‘&#39;False’ with ‘&#39;True’
        arising from a use of ‘purify’
    • In a stmt of a &#39;do&#39; block:
        purify CureDiamond (LovelyCommuneRaquel CureLoveads)
      In the second argument of ‘($)’, namely
        ‘do enter Rikka
            purify CureDiamond (LovelyCommuneRaquel CureLoveads)’
      In the expression:
        printEpisode
          $ do enter Rikka
               purify CureDiamond (LovelyCommuneRaquel CureLoveads)
   |
22 |   purify CureDiamond (LovelyCommuneRaquel CureLoveads)
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.</code></pre>
<p>ちゃんと、変身していない状態で<code>purify</code>することを型エラーにできていますね！</p>
<p>ここまでできていながら残念ですが、リリースは、来年のプリキュアハッカソンか<span class="ascii">Advent Calendar</span>あたりに乞うご期待と言うことで！💦<br />
それでは<span class="ascii">2019</span>年も<span class="ascii">Haskell</span>で<span class="ascii">Super PreCure Hacking</span>を❣️❣️❣️</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>リンク先の動画をご覧になればわかるとおり、実際のそのシーンより大幅に省略されているところは突っ込まないでいただきたい…🙏。<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>「この間の映画に出ていた人数より多くない？」と思った方へ<span class="ascii">:</span> 「プリキュアオールスターズ」に出てくる女の子たちに加え、坂上あゆみ、ペコリン、若宮アンリ、はぐたんの<span class="ascii">4</span>人が、タイプセーフプリキュア！の分類上<code>Girl</code>として収録されています。ちなみにキュアモフルンも収録されていますが、モフルンはあくまでも変身アイテム<span class="ascii">(</span><code>SpecialItem</code><span class="ascii">)</span>という扱いです。<a href="#fnref2" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/tidalcycles-stack.html" lang="ja">TidalCyclesをstackで確実にインストールする</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2018/haskell-day-2018.html" style="margin-left: auto;" lang="ja">Haskell Day 2018 開催レポート</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>Haskell Day 2018 開催レポート</title>
    <link href="https://haskell.jp/blog/posts/2018/haskell-day-2018.html" />
    <id>https://haskell.jp/blog/posts/2018/haskell-day-2018.html</id>
    <published>2018-11-20T00:00:00Z</published>
    <updated>2018-11-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <p>こんにちは<span class="ascii">kakkun61</span>こと岡本和樹です。</p>
<p>去る<span class="ascii">11</span>月<span class="ascii">10</span>日に<span class="ascii">Haskell Day 2018</span>が開催されましたので、そのイベントレポートをお送りします。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#haskell-day-2018とは" title="haskell-day-2018とは"><span class="ascii">Haskell Day 2018</span>とは</a></li>
<li><a href="#セッション" title="セッション">セッション</a>
<ul>
<li><a href="#作りながら学ぶhaskell入門を使ったハンズオン" title="作りながら学ぶhaskell入門を使ったハンズオン">「作りながら学ぶ<span class="ascii">Haskell</span>入門」を使ったハンズオン</a></li>
<li><a href="#haskellを導入した話とhrrの紹介" title="haskellを導入した話とhrrの紹介"><span class="ascii">Haskell</span>を導入した話と<span class="ascii">HRR</span>の紹介</a></li>
<li><a href="#servantで実現する高速かつ安全なapi開発" title="servantで実現する高速かつ安全なapi開発"><span class="ascii">Servant</span>で実現する高速かつ安全な<span class="ascii">API</span>開発</a></li>
<li><a href="#並列並行言語haskell" title="並列並行言語haskell">並列並行言語<span class="ascii">Haskell</span></a></li>
<li><a href="#dhall-haskellの新たなキラーアプリ" title="dhall-haskellの新たなキラーアプリ"><span class="ascii">Dhall: Haskell</span>の新たなキラーアプリ</a></li>
<li><a href="#semigroupとはmonoid環" title="semigroupとはmonoid環"><span class="ascii">Semigroup</span>とは？<span class="ascii">Monoid</span>？環？</a></li>
<li><a href="#haskellでcli" title="haskellでcli"><span class="ascii">Haskell</span>で<span class="ascii">CLI</span></a></li>
<li><a href="#gloss-動かして遊んで学ぶhaskell" title="gloss-動かして遊んで学ぶhaskell"><span class="ascii">gloss:</span> 動かして遊んで学ぶ<span class="ascii">Haskell</span></a></li>
<li><a href="#lisztあるいは永続データ構造を真に永続させる方法" title="lisztあるいは永続データ構造を真に永続させる方法"><span class="ascii">Liszt</span>あるいは永続データ構造を真に永続させる方法</a></li>
<li><a href="#懇親会" title="懇親会">懇親会</a></li>
</ul></li>
<li><a href="#アンケート" title="アンケート">アンケート</a>
<ul>
<li><a href="#haskellを始めてどれくらい経ちますか" title="haskellを始めてどれくらい経ちますか"><span class="ascii">Haskell</span>を始めてどれくらい経ちますか？</a></li>
<li><a href="#読んだことのある日本語のhaskell本は" title="読んだことのある日本語のhaskell本は">読んだことのある日本語の<span class="ascii">Haskell</span>本は？</a></li>
</ul></li>
<li><a href="#終わりに" title="終わりに">終わりに</a></li>
</ul>
</div>
</div>
<h1 id="haskell-day-2018とは"><span class="link-to-here-outer"><a href="#haskell-day-2018とは" title="haskell-day-2018とは"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Haskell Day 2018</span>とは</h1>
<p><img src="../../img/2018/haskell-day-2018/connpass.png" alt="Connpass" style="width: 100%; max-width: 600px;"></p>
<p><a href="https://haskell-jp.connpass.com/event/92617/"><span class="ascii">https://haskell-jp.connpass.com/event/92617/</span></a></p>
<p><span class="ascii">Haskell Day</span>は<span class="ascii">2012</span>年<span class="ascii">2016</span>年と不定期に開催しており今回で<span class="ascii">3</span>度目となります。</p>
<p><span class="ascii">2018</span>年の今回は「<span class="ascii">Haskell</span>ちょっと興味あるからちょっとできるまで」というテーマで開催されました。</p>
<p><img src="../../img/2018/haskell-day-2018/_DSC1173.jpg" alt="受付" style="width: 100%; max-width: 600px;"></p>
<h1 id="セッション"><span class="link-to-here-outer"><a href="#セッション" title="セッション"><span class="link-to-here">Link to<br />
here</span></a></span>セッション</h1>
<h2 id="作りながら学ぶhaskell入門を使ったハンズオン"><span class="link-to-here-outer"><a href="#作りながら学ぶhaskell入門を使ったハンズオン" title="作りながら学ぶhaskell入門を使ったハンズオン"><span class="link-to-here">Link to<br />
here</span></a></span>「作りながら学ぶ<span class="ascii">Haskell</span>入門」を使ったハンズオン</h2>
<p>開発中の対話的チュートリアル<a href="https://github.com/haskell-jp/makeMistakesToLearnHaskell">「作りながら学ぶ<span class="ascii">Haskell</span>入門」</a>を使って、参加者の皆さんにもくもくと入門していただきました。「作りながら学ぶ<span class="ascii">Haskell</span>入門」では、簡単な課題を解くことで、<span class="ascii">Haskell</span>の初歩的な使い方を学びつつ、学んだ知識をその場でテストできます。</p>
<p><a href="https://github.com/haskell-jp/makeMistakesToLearnHaskell"><span class="ascii">https://github.com/haskell-jp/makeMistakesToLearnHaskell</span></a></p>
<p><img src="../../img/2018/haskell-day-2018/_DSC1176.jpg" alt="ハンズオン" style="width: 100%; max-width: 600px;"></p>
<hr />
<h2 id="haskellを導入した話とhrrの紹介"><span class="link-to-here-outer"><a href="#haskellを導入した話とhrrの紹介" title="haskellを導入した話とhrrの紹介"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Haskell</span>を導入した話と<span class="ascii">HRR</span>の紹介</h2>
<p><a href="https://htmlpreview.github.io/?https://github.com/khibino/haskell-day-2018/blob/master/presentation.html"><img src="../../img/2018/haskell-day-2018/khibino.png" alt="Haskell を導入した話と HRR の紹介" style="width: 100%; max-width: 600px;"></a></p>
<p><img src="../../img/2018/haskell-day-2018/_DSC1177.jpg" alt="khibino" style="width: 100%; max-width: 600px;"></p>
<hr />
<h2 id="servantで実現する高速かつ安全なapi開発"><span class="link-to-here-outer"><a href="#servantで実現する高速かつ安全なapi開発" title="servantで実現する高速かつ安全なapi開発"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Servant</span>で実現する高速かつ安全な<span class="ascii">API</span>開発</h2>
<script async class="speakerdeck-embed" data-id="413d120b6bee433c985c1d2b3395ff0e" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>
<p><img src="../../img/2018/haskell-day-2018/_DSC1193.jpg" alt="nakaji-dayo" style="width: 100%; max-width: 600px;"></p>
<hr />
<h2 id="並列並行言語haskell"><span class="link-to-here-outer"><a href="#並列並行言語haskell" title="並列並行言語haskell"><span class="link-to-here">Link to<br />
here</span></a></span>並列並行言語<span class="ascii">Haskell</span></h2>
<script async class="speakerdeck-embed" data-id="07d92af9d7aa40bca6cc3959d3f56b28" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>
<p><img src="../../img/2018/haskell-day-2018/_DSC1178.jpg" alt="syocy" style="width: 100%; max-width: 600px;"></p>
<hr />
<h2 id="dhall-haskellの新たなキラーアプリ"><span class="link-to-here-outer"><a href="#dhall-haskellの新たなキラーアプリ" title="dhall-haskellの新たなキラーアプリ"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Dhall: Haskell</span>の新たなキラーアプリ</h2>
<script async class="speakerdeck-embed" data-id="7a16b1e09882433ca2dac9a6a81eb236" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>
<hr />
<h2 id="semigroupとはmonoid環"><span class="link-to-here-outer"><a href="#semigroupとはmonoid環" title="semigroupとはmonoid環"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Semigroup</span>とは？<span class="ascii">Monoid</span>？環？</h2>
<p><a href="https://aiya000.github.io/Maid/haskell-day-2018-algebra/#/"><img src="../../img/2018/haskell-day-2018/aiya000.png" alt="Semigroup とは？Monoid？環？" style="width: 100%; max-width: 600px;"></a></p>
<p><img src="../../img/2018/haskell-day-2018/_DSC1179.jpg" alt="aiya000" style="width: 100%; max-width: 600px;"></p>
<hr />
<h2 id="haskellでcli"><span class="link-to-here-outer"><a href="#haskellでcli" title="haskellでcli"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Haskell</span>で<span class="ascii">CLI</span></h2>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/FQE1QxbCST8kYi" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen>
</iframe>
<div style="margin-bottom:5px">
<strong> <a href="//www.slideshare.net/noob00/haskell-cli" title="Haskell で CLI" target="_blank"><span class="ascii">Haskell</span> で <span class="ascii">CLI</span></a> </strong> <span class="ascii">from</span> <strong><a href="https://www.slideshare.net/noob00" target="_blank"><span class="ascii">Nobutada Matsubara</span></a></strong>
</div>
<p><img src="../../img/2018/haskell-day-2018/_DSC1183.jpg" alt="matsubara0507" style="width: 100%; max-width: 600px;"></p>
<hr />
<h2 id="gloss-動かして遊んで学ぶhaskell"><span class="link-to-here-outer"><a href="#gloss-動かして遊んで学ぶhaskell" title="gloss-動かして遊んで学ぶhaskell"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">gloss:</span> 動かして遊んで学ぶ<span class="ascii">Haskell</span></h2>
<p><a href="https://qiita.com/lotz/items/bdb04c771efc8919b79c"><img src="../../img/2018/haskell-day-2018/lotz.png" alt="動かして遊んで学ぶ Haskell" style="width: 100%; max-width: 600px;"></a></p>
<p><img src="../../img/2018/haskell-day-2018/_DSC1186.jpg" alt="lotz" style="width: 100%; max-width: 600px;"></p>
<hr />
<h2 id="lisztあるいは永続データ構造を真に永続させる方法"><span class="link-to-here-outer"><a href="#lisztあるいは永続データ構造を真に永続させる方法" title="lisztあるいは永続データ構造を真に永続させる方法"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Liszt</span>あるいは永続データ構造を真に永続させる方法</h2>
<p><a href="https://shared-assets.adobe.com/link/353213c2-281a-4a53-6cff-a52bff1314c1"><img src="../../img/2018/haskell-day-2018/fumieval.png" alt="Liszt あるいは永続データ構造を真に永続させる方法" style="width: 100%; max-width: 600px; border: solid 1px black;"></a></p>
<p><img src="../../img/2018/haskell-day-2018/_DSC1191.jpg" alt="fumieval" style="width: 100%; max-width: 600px;"></p>
<h2 id="懇親会"><span class="link-to-here-outer"><a href="#懇親会" title="懇親会"><span class="link-to-here">Link to<br />
here</span></a></span>懇親会</h2>
<p>スポンサーとして<span class="ascii">IIJ</span>に飲食物の提供をしていただきました。</p>
<p><img src="../../img/2018/haskell-day-2018/_DSC1194.jpg" alt="懇親会" style="width: 100%; max-width: 600px;"></p>
<h1 id="アンケート"><span class="link-to-here-outer"><a href="#アンケート" title="アンケート"><span class="link-to-here">Link to<br />
here</span></a></span>アンケート</h1>
<p>約<span class="ascii">110</span>名の方が出席し約<span class="ascii">40</span>名の方が回答してくださいました。</p>
<p>参加できなくなった約<span class="ascii">40</span>名の方は事前のキャンセルをよろしくお願いします。</p>
<h2 id="haskellを始めてどれくらい経ちますか"><span class="link-to-here-outer"><a href="#haskellを始めてどれくらい経ちますか" title="haskellを始めてどれくらい経ちますか"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Haskell</span>を始めてどれくらい経ちますか？</h2>
<p><img src="../../img/2018/haskell-day-2018/questionnaire1.png" alt="Haskell を始めてどれくらい経ちますか？" style="width: 100%; max-width: 600px;"></p>
<p>ここ<span class="ascii">1</span>年以内に始めた方が全体の<span class="ascii">21.4</span>％、<span class="ascii">1</span>年以上<span class="ascii">5</span>年未満前に始めた方がちょうど半分程度となりました。<span class="ascii">1</span>年以上<span class="ascii">5</span>年未満前に始めた方の<span class="ascii">57%</span>の方は今でも<span class="ascii">Haskell</span>を使い続けているようです。</p>
<p><span class="ascii">5</span>年以上前に始めた方は全体の<span class="ascii">1/4</span>となりました。</p>
<h2 id="読んだことのある日本語のhaskell本は"><span class="link-to-here-outer"><a href="#読んだことのある日本語のhaskell本は" title="読んだことのある日本語のhaskell本は"><span class="link-to-here">Link to<br />
here</span></a></span>読んだことのある日本語の<span class="ascii">Haskell</span>本は？</h2>
<p><img src="../../img/2018/haskell-day-2018/questionnaire2.png" alt="Haskell を始めてどれくらい経ちますか？" style="width: 100%; max-width: 600px;"></p>
<p>項目は下記となります。</p>
<ul>
<li>すごい <span class="ascii">Haskell</span> たのしく学ぼう！</li>
<li>プログラミング <span class="ascii">Haskell</span></li>
<li><span class="ascii">Haskell</span> による並列・並行プログラミング</li>
<li>関数プログラミング実践入門 ── 完結で正しいコードを書くために</li>
<li>関数プログラミング入門 ── <span class="ascii">Haskell</span> で学ぶ原理と技法</li>
<li><span class="ascii">Real World Haskell</span></li>
<li>関数プログラミング ── 珠玉のアルゴリズムデザイン</li>
<li>簡約！λカ娘</li>
<li><span class="ascii">Haskell</span> ── 教養としての関数型プログラミング</li>
<li>その他（自由記述）</li>
</ul>
<p>この項目にはアンケートの途中で追加したものもあるので、結果があまり厳密でないことに注意してください。</p>
<p>その他の選択肢で自由記述では次の票がありました。</p>
<ul>
<li><span class="ascii">Haskell</span>入門 <span class="ascii">10</span>票</li>
<li>ふつうの<span class="ascii">Haskell 1</span>票</li>
<li><span class="ascii">Haskell</span>による関数プログラミングの思考法 <span class="ascii">1</span>票</li>
</ul>
<h1 id="終わりに"><span class="link-to-here-outer"><a href="#終わりに" title="終わりに"><span class="link-to-here">Link to<br />
here</span></a></span>終わりに</h1>
<p>参加者の発表者、スタッフのみなさんのおかげで無事開催することができました。ありがとうございました。</p>
<p>今後とも<span class="ascii">Haskell-jp</span>をよろしくお願いします。</p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2018/super-precure-monad.html" lang="ja">モナドの新しい力！スーパープリキュアモナド！</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2018/tech-book-fest-5.html" style="margin-left: auto;" lang="ja">技術書典 5 での Haskell 関連サークルのまとめ</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>技術書典 5 での Haskell 関連サークルのまとめ</title>
    <link href="https://haskell.jp/blog/posts/2018/tech-book-fest-5.html" />
    <id>https://haskell.jp/blog/posts/2018/tech-book-fest-5.html</id>
    <published>2018-10-05T00:00:00Z</published>
    <updated>2018-10-05T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <p>こんにちは<span class="ascii">kakkun61</span>こと岡本和樹です。</p>
<p>来たる<span class="ascii">10</span>月<span class="ascii">8</span>日（月・祝）に池袋にて技術系同人誌即売会「技術書典<span class="ascii">5</span>」が開催されます。</p>
<p><span class="ascii">Haskell</span>を題材にした同人誌もいくつかあるようですのでまとめてみました。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#技術書典とは" title="技術書典とは">技術書典とは？</a></li>
<li><a href="#か36-鴨川書房" title="か36-鴨川書房">か<span class="ascii">36</span> — 鴨川書房</a>
<ul>
<li><a href="#data-a-la-carte-vol.-1" title="data-a-la-carte-vol.-1"><span class="ascii">Data A la carte vol. 1</span></a></li>
</ul></li>
<li><a href="#か38-だめぽラボ" title="か38-だめぽラボ">か<span class="ascii">38</span> — だめぽラボ</a>
<ul>
<li><a href="#代数的数を作る-多項式の根と因数分解のアルゴリズム" title="代数的数を作る-多項式の根と因数分解のアルゴリズム">代数的数を作る 多項式の根と因数分解のアルゴリズム</a></li>
</ul></li>
<li><a href="#か61-趣味はデバッグ" title="か61-趣味はデバッグ">か<span class="ascii">61</span> — 趣味はデバッグ……</a>
<ul>
<li><a href="#手続きhaskell" title="手続きhaskell">手続き<span class="ascii">Haskell</span></a></li>
<li><a href="#haskellで作るwebアプリケーション-遠回りして学ぶyesod入門" title="haskellで作るwebアプリケーション-遠回りして学ぶyesod入門"><span class="ascii">Haskell</span>で作る<span class="ascii">Web</span>アプリケーション 遠回りして学ぶ<span class="ascii">Yesod</span>入門</a></li>
</ul></li>
<li><a href="#か74-大宇宙銀河no.1-haskeller-にこにー" title="か74-大宇宙銀河no.1-haskeller-にこにー">か<span class="ascii">74</span> — 大宇宙銀河<span class="ascii">No.1-Haskeller-</span>にこにー</a>
<ul>
<li><a href="#矢澤にこ先輩といっしょに代数" title="矢澤にこ先輩といっしょに代数">矢澤にこ先輩といっしょに代数！</a></li>
</ul></li>
<li><a href="#それでは当日に" title="それでは当日に">それでは当日に</a></li>
</ul>
</div>
</div>
<h1 id="技術書典とは"><span class="link-to-here-outer"><a href="#技術書典とは" title="技術書典とは"><span class="link-to-here">Link to<br />
here</span></a></span>技術書典とは？</h1>
<p><img src="../../img/2018/tech-book-fest-5-banner.png" alt="技術書典 5 バナー" style="width: 100%;"></p>
<p>（バナー画像は技術書典<span class="ascii">5</span>サイトよりの引用です。）</p>
<p>技術書典とは技術系同人誌即売会としておそらく日本最大のもので、今回で<span class="ascii">6</span>回目の開催となります。（ニコニコ超会議内での超技術書典があったのでナンバリングがずれています。）</p>
<ul>
<li><a href="https://techbookfest.org/event/tbf05">サイト</a></li>
<li><a href="https://blog.techbookfest.org/">ブログ</a></li>
<li><a href="https://twitter.com/techbookfest"><span class="ascii">Twitter</span></a></li>
</ul>
<p>これまでは秋葉原での開催でしたが、今回はなんと場所を<span class="ascii">3</span>倍の広さに拡張して池袋で開催されます。</p>
<p>それにともないサークル数もどどんと<span class="ascii">470</span>超となり、<span class="ascii">1</span>サークル<span class="ascii">45</span>秒で回っても全サークルは見て回れないことになります。</p>
<p>事前準備の重要性が高まった今回、<span class="ascii">Haskeller</span>向けに<span class="ascii">Haskell</span>サークルをまとめてみました。</p>
<h1 id="か36-鴨川書房"><span class="link-to-here-outer"><a href="#か36-鴨川書房" title="か36-鴨川書房"><span class="link-to-here">Link to<br />
here</span></a></span>か<span class="ascii">36</span> — 鴨川書房</h1>
<p><a href="https://techbookfest.org/event/tbf05/circle/32370012">カタログ</a></p>
<h2 id="data-a-la-carte-vol.-1"><span class="link-to-here-outer"><a href="#data-a-la-carte-vol.-1" title="data-a-la-carte-vol.-1"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Data A la carte vol. 1</span></h2>
<blockquote class="twitter-tweet" data-lang="ja">
<p lang="ja" dir="ltr">
あと技術書典<span class="ascii">5</span>に、鴨川書房というサークル名で合同本を出品します。<span class="ascii">Haskell</span>による<span class="ascii">NN</span>実装<span class="ascii">(</span><a href="https://twitter.com/lotz84_?ref_src=twsrc%5Etfw"><span class="citation" data-cites="lotz84_"><span class="ascii">@lotz84_</span></span></a><span class="ascii">)</span> や、<span class="ascii">FPGA</span>での<span class="ascii">auto encoder</span>実装に関する苦労話等が掲載される予定です。ぜひに🙏……
</p>
— ✨🤩😝🤪パリピ🤭🤢🤮✨ <span class="ascii">(</span><span class="citation" data-cites="chaoticCats"><span class="ascii">@chaoticCats</span></span><span class="ascii">)</span> <a href="https://twitter.com/chaoticCats/status/1027501210494853120?ref_src=twsrc%5Etfw"><span class="ascii">2018</span>年<span class="ascii">8</span>月<span class="ascii">9</span>日</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<blockquote class="twitter-tweet" data-lang="ja">
<p lang="ja" dir="ltr">
形態素解析ライブラリ<span class="ascii">nagisa</span>については，技術書典の合同本に寄稿してもらえるよう作成者に依頼中なので興味ある方は是非<span class="ascii">(</span>表紙は鋭意作成中<span class="ascii">)</span>。 <a href="https://t.co/zUtngAS23t"><span class="ascii">pic.twitter.com/zUtngAS23t</span></a>
</p>
— ✨🤩😝🤪パリピ🤭🤢🤮✨ <span class="ascii">(</span><span class="citation" data-cites="chaoticCats"><span class="ascii">@chaoticCats</span></span><span class="ascii">)</span> <a href="https://twitter.com/chaoticCats/status/1042018372207108099?ref_src=twsrc%5Etfw"><span class="ascii">2018</span>年<span class="ascii">9</span>月<span class="ascii">18</span>日</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<h1 id="か38-だめぽラボ"><span class="link-to-here-outer"><a href="#か38-だめぽラボ" title="か38-だめぽラボ"><span class="link-to-here">Link to<br />
here</span></a></span>か<span class="ascii">38</span> — だめぽラボ</h1>
<p><a href="https://techbookfest.org/event/tbf05/circle/37190001">カタログ</a></p>
<h2 id="代数的数を作る-多項式の根と因数分解のアルゴリズム"><span class="link-to-here-outer"><a href="#代数的数を作る-多項式の根と因数分解のアルゴリズム" title="代数的数を作る-多項式の根と因数分解のアルゴリズム"><span class="link-to-here">Link to<br />
here</span></a></span>代数的数を作る 多項式の根と因数分解のアルゴリズム</h2>
<ul>
<li>同人誌</li>
<li><span class="ascii">268</span>ページ</li>
<li><span class="ascii">¥2500</span></li>
</ul>
<p><a href="https://blog.miz-ar.info/2018/09/techbookfest5/">ブログの告知記事</a></p>
<blockquote>
<p>代数的数（整数係数多項式の根として表される数）を実装するためのアルゴリズムを解説します。代数的数を使うと、ルートを含むような数に関して、浮動小数点数の誤差に煩わされることなく正確な演算が行えます。<span class="ascii">Haskell</span>によるサンプルコードを掲載しています。</p>
<p>この本は、<span class="ascii">Web</span>連載していた「週刊 代数的実数を作る」 <span class="ascii">https://miz-ar.info/math/algebraic-real/</span> の書籍化です。本文の加筆修正の他、「付録<span class="ascii">A</span> ユークリッドの互除法と拡張された互除法」「付録<span class="ascii">B</span> 部分分数分解」を追加しています。</p>
<p><a href="https://techbookfest.org/event/tbf05/circle/37190001">カタログ</a>より</p>
</blockquote>
<blockquote class="twitter-tweet" data-lang="ja">
<p lang="ja" dir="ltr">
技術書典<span class="ascii">5</span> か<span class="ascii">38</span>で「代数的数を作る 多項式の根と因数分解のアルゴリズム」を頒布します。よろしくお願いします。 <a href="https://t.co/HkLF1YFDuN"><span class="ascii">https://t.co/HkLF1YFDuN</span></a> <a href="https://t.co/V17ZIj2Iub"><span class="ascii">pic.twitter.com/V17ZIj2Iub</span></a>
</p>
— だめぽラボ<span class="ascii">@</span>技術書典<span class="ascii">5</span> か<span class="ascii">38 (</span><span class="citation" data-cites="mod_poppo"><span class="ascii">@mod_poppo</span></span><span class="ascii">)</span> <a href="https://twitter.com/mod_poppo/status/1045885679232737281?ref_src=twsrc%5Etfw"><span class="ascii">2018</span>年<span class="ascii">9</span>月<span class="ascii">29</span>日</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<h1 id="か61-趣味はデバッグ"><span class="link-to-here-outer"><a href="#か61-趣味はデバッグ" title="か61-趣味はデバッグ"><span class="link-to-here">Link to<br />
here</span></a></span>か<span class="ascii">61</span> — 趣味はデバッグ……</h1>
<p>私のサークルです。新刊落としました……</p>
<h2 id="手続きhaskell"><span class="link-to-here-outer"><a href="#手続きhaskell" title="手続きhaskell"><span class="link-to-here">Link to<br />
here</span></a></span>手続き<span class="ascii">Haskell</span></h2>
<p><a href="https://techbookfest.org/event/tbf05/circle/45000003">カタログ</a></p>
<ul>
<li>同人誌</li>
<li><span class="ascii">28</span>ページ</li>
<li><span class="ascii">¥500</span></li>
<li><a href="http://doujin.kakkun61.com/procedural-haskell"><span class="ascii">http://doujin.kakkun61.com/procedural-haskell</span></a></li>
</ul>
<blockquote>
<p><span class="ascii">Haskell</span>での手続きプログラミングの側面について解説します。</p>
<p>対象読者 <span class="ascii">- Haskell</span>入門書程度が読める <span class="ascii">-</span> 特に読めるが書こうとすると悩む人に読んでほしいです <span class="ascii">-</span> 手続きプログラミングのプログラマー <span class="ascii">-</span> 厳密に本書を読むためには<span class="ascii">Haskell</span>を読めた方がよいですが、手続きプログラミングですのでプログラマーなら雰囲気で読めると思います</p>
<p>書かれてあること <span class="ascii">-</span> 書き換え可能な変数 <span class="ascii">-</span> 手続きプログラミング的な制御構造 <span class="ascii">-</span> 配列 <span class="ascii">-</span> サンプルプログラム <span class="ascii">-</span> 手続き的な実装と<span class="ascii">Haskell</span>的な実装の対比</p>
<p>電子版（<span class="ascii">PDF</span>）はこちらで販売中です。 <span class="ascii">https://kakkun61.booth.pm/items/829369</span></p>
<p><a href="https://techbookfest.org/event/tbf05/circle/45000003">カタログ</a>より</p>
</blockquote>
<h2 id="haskellで作るwebアプリケーション-遠回りして学ぶyesod入門"><span class="link-to-here-outer"><a href="#haskellで作るwebアプリケーション-遠回りして学ぶyesod入門" title="haskellで作るwebアプリケーション-遠回りして学ぶyesod入門"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Haskell</span>で作る<span class="ascii">Web</span>アプリケーション 遠回りして学ぶ<span class="ascii">Yesod</span>入門</h2>
<ul>
<li>商業誌</li>
<li><span class="ascii">76</span>ページ</li>
<li><span class="ascii">¥1500</span></li>
<li><a href="https://nextpublishing.jp/book/9979.html"><span class="ascii">https://nextpublishing.jp/book/9979.html</span></a></li>
</ul>
<blockquote>
<p>【<span class="ascii">Haskell</span>のウェブアプリケーションフレームワーク<span class="ascii">Yesod</span>の入門書！】</p>
<p>本書は、<span class="ascii">Haskell</span>の入門書レベルの知識をもつ読者を対象とした、ウェブアプリケーションフレームワーク<span class="ascii">Yesod</span>の入門書です。比較的学習コストの高い<span class="ascii">Yesod</span>ですが、本書を通じて<span class="ascii">Yesod</span>の基本的な知識と<span class="ascii">Haskell</span>でのウェブアプリケーション開発に挑んで見ましょう！ 〈本書の対象読者〉 <span class="ascii">Haskell</span>の入門書は既に読みこなしているプログラマ <span class="ascii">Haskell</span>でウェブアプリを作ってみたいプログラマ</p>
<p><a href="https://nextpublishing.jp/book/9979.html">出版社ページ</a>より</p>
</blockquote>
<p>ちなみにこんな本を作るつもりでした。欲しい方いらっしゃったら次で書けとお伝えください。はげみになります。</p>
<blockquote class="twitter-tweet" data-lang="ja">
<p lang="ja" dir="ltr">
技術書典<span class="ascii">5</span>にサークル「趣味はデバッグ……」として参加申込をしました！ <span class="ascii">|</span> 技術書典 <a href="https://t.co/nD4eBo9622"><span class="ascii">https://t.co/nD4eBo9622</span></a> 「自作静的型付け言語を作ってそれに対して型推論する方法を解説する」書籍を作るぞ！
</p>
— <span class="ascii">kakkun61@</span>技術書典<span class="ascii">5</span> か<span class="ascii">61 (</span><span class="citation" data-cites="kakkun61"><span class="ascii">@kakkun61</span></span><span class="ascii">)</span> <a href="https://twitter.com/kakkun61/status/1009271813107474432?ref_src=twsrc%5Etfw"><span class="ascii">2018</span>年<span class="ascii">6</span>月<span class="ascii">20</span>日</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<h1 id="か74-大宇宙銀河no.1-haskeller-にこにー"><span class="link-to-here-outer"><a href="#か74-大宇宙銀河no.1-haskeller-にこにー" title="か74-大宇宙銀河no.1-haskeller-にこにー"><span class="link-to-here">Link to<br />
here</span></a></span>か<span class="ascii">74</span> — 大宇宙銀河<span class="ascii">No.1-Haskeller-</span>にこにー</h1>
<p><a href="https://techbookfest.org/event/tbf05/circle/43260001">カタログ</a></p>
<h2 id="矢澤にこ先輩といっしょに代数"><span class="link-to-here-outer"><a href="#矢澤にこ先輩といっしょに代数" title="矢澤にこ先輩といっしょに代数"><span class="link-to-here">Link to<br />
here</span></a></span>矢澤にこ先輩といっしょに代数！</h2>
<ul>
<li>同人誌</li>
<li><span class="ascii">84</span>ページ</li>
<li><span class="ascii">¥1000</span></li>
</ul>
<p><a href="http://aiya000.github.io/posts/2018-09-12-techbookfest5.html">ブログの告知記事</a></p>
<blockquote>
<p>ゆるふわにこまき数学！</p>
<p>以下のような人に向けて、頒布します。</p>
<ul>
<li>数学・代数の雰囲気をゆるく知りたい</li>
<li>軽い<span class="ascii">Haskell</span>を知りたい</li>
<li>なんでもいいから技術系にこまきが読みたい</li>
</ul>
<p><a href="https://techbookfest.org/event/tbf05/circle/43260001">カタログ</a>より</p>
</blockquote>
<blockquote class="twitter-tweet" data-lang="ja">
<p lang="ja" dir="ltr">
技術書典<span class="ascii">5</span>の「か<span class="ascii">74</span>」で、矢澤にこ先輩が簡単な<span class="ascii">Haskell</span>で代数（半群・モノイド・群・環・体）を教えてくれる本を頒布します。<br>よろしくお願いします🐕<a href="https://t.co/KBFxqX69m3"><span class="ascii">https://t.co/KBFxqX69m3</span></a><br>☝サークルページ<a href="https://twitter.com/hashtag/%E6%8A%80%E8%A1%93%E6%9B%B8%E5%85%B8?src=hash&amp;ref_src=twsrc%5Etfw"><span class="ascii">#</span>技術書典</a> <a href="https://twitter.com/hashtag/%E6%8A%80%E8%A1%93%E6%9B%B8%E5%85%B85?src=hash&amp;ref_src=twsrc%5Etfw"><span class="ascii">#</span>技術書典<span class="ascii">5</span></a> <a href="https://t.co/HvD5ql4gFl"><span class="ascii">pic.twitter.com/HvD5ql4gFl</span></a>
</p>
— あいや🤘🙄🤘技術書典<span class="ascii">5@</span>か<span class="ascii">74 (</span><span class="citation" data-cites="public_ai000ya"><span class="ascii">@public_ai000ya</span></span><span class="ascii">)</span> <a href="https://twitter.com/public_ai000ya/status/1045946096327962624?ref_src=twsrc%5Etfw"><span class="ascii">2018</span>年<span class="ascii">9</span>月<span class="ascii">29</span>日</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<h1 id="それでは当日に"><span class="link-to-here-outer"><a href="#それでは当日に" title="それでは当日に"><span class="link-to-here">Link to<br />
here</span></a></span>それでは当日に</h1>
<p>当日は安全に配慮しつつ楽しんでいきましょう！！</p>
<p><span class="ascii">1000</span>円札と<span class="ascii">500</span>円玉の準備はしっかりとね。</p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2018/haskell-day-2018.html" lang="ja">Haskell Day 2018 開催レポート</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2018/substring-parser.html" style="margin-left: auto;" lang="ja">substring-parserで「タイプセーフプリキュア！」を移行した話</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>substring-parserで「タイプセーフプリキュア！」を移行した話</title>
    <link href="https://haskell.jp/blog/posts/2018/substring-parser.html" />
    <id>https://haskell.jp/blog/posts/2018/substring-parser.html</id>
    <published>2018-09-04T00:00:00Z</published>
    <updated>2018-09-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>先日私は<a href="https://cure-hack.connpass.com/event/91157/">プリキュアハッカソン <span class="ascii">NewStage</span></a>というちょっと変わったイベントで、「<a href="https://github.com/igrep/typesafe-precure">タイプセーフプリキュア！</a>」の最近の更新について発表いたしました。<br />
今回は<a href="http://the.igreque.info/slides/2018-08-18-substring-parser.html">その際使用したスライド</a>を、ブログ記事として拡大して共有させていただきたいと思います！</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#予告編はじめにまとめ" title="予告編はじめにまとめ">予告編（はじめにまとめ）</a></li>
<li><a href="#これまでのあらすじ" title="これまでのあらすじ">これまでのあらすじ</a>
<ul>
<li><a href="#タイプセーフプリキュアとは" title="タイプセーフプリキュアとは">「タイプセーフプリキュア！」とは？</a></li>
<li><a href="#cure-index.jsonとは" title="cure-index.jsonとは"><span class="ascii">cure-index.json</span>とは？</a></li>
</ul></li>
<li><a href="#今回のプリキュアハッカソンに向けて行ったこと" title="今回のプリキュアハッカソンに向けて行ったこと">今回のプリキュアハッカソンに向けて行ったこと</a>
<ul>
<li><a href="#修正前の書式" title="修正前の書式">🔴修正<strong>前</strong>の書式</a></li>
<li><a href="#修正後の書式" title="修正後の書式">🔵修正<strong>後</strong>の書式</a></li>
<li><a href="#どうやって修正する" title="どうやって修正する">どうやって修正する？</a>
<ul>
<li><a href="#パーサーコンビネーターとは" title="パーサーコンビネーターとは">パーサーコンビネーターとは</a></li>
<li><a href="#パーサーコンビネーターが正規表現より良いところ悪いところ" title="パーサーコンビネーターが正規表現より良いところ悪いところ">パーサーコンビネーターが正規表現より良いところ・悪いところ</a>
<ul>
<li><a href="#パーツとしてパーサーを組み合わせるのが簡単" title="パーツとしてパーサーを組み合わせるのが簡単">👍パーツとしてパーサーを組み合わせるのが簡単</a></li>
<li><a href="#パースした結果を文字列から複雑なデータ構造に割り当てるのが簡単" title="パースした結果を文字列から複雑なデータ構造に割り当てるのが簡単">👍パースした結果を、文字列から複雑なデータ構造に割り当てるのが簡単</a></li>
<li><a href="#パースした結果に基づいてパーサーの挙動を変えることができる" title="パースした結果に基づいてパーサーの挙動を変えることができる">👍パースした結果に基づいて、パーサーの挙動を変えることができる</a></li>
<li><a href="#記述が冗長" title="記述が冗長">👎記述が冗長</a></li>
<li><a href="#ユーザーからの入力として直接受け取ることは難しい" title="ユーザーからの入力として直接受け取ることは難しい">👎ユーザーからの入力として直接受け取ることは難しい。</a></li>
<li><a href="#正規表現でいうところの-にあたるmanyが必ず強欲なマッチになる" title="正規表現でいうところの-にあたるmanyが必ず強欲なマッチになる">👎正規表現でいうところの <code>*</code> にあたる<code>many</code>が、必ず強欲なマッチになる</a></li>
<li><a href="#文字列の先頭からのマッチしかできない" title="文字列の先頭からのマッチしかできない">👎文字列の先頭からのマッチしかできない</a></li>
</ul></li>
<li><a href="#ソースコードの書き換えとsubstring-parser" title="ソースコードの書き換えとsubstring-parser">ソースコードの書き換えと<span class="ascii">substring-parser</span></a>
<ul>
<li><a href="#substring-parserの仕組み" title="substring-parserの仕組み"><span class="ascii">substring-parser</span>の仕組み</a></li>
</ul></li>
</ul></li>
<li><a href="#結果できたもの" title="結果できたもの">結果、できたもの</a></li>
</ul></li>
<li><a href="#その他の似たソリューション" title="その他の似たソリューション">その他の似たソリューション</a>
<ul>
<li><a href="#codemod" title="codemod"><span class="ascii">codemod</span></a></li>
<li><a href="#jscodeshift" title="jscodeshift"><span class="ascii">jscodeshift</span></a></li>
<li><a href="#refactorio" title="refactorio"><span class="ascii">refactorio</span></a></li>
</ul></li>
<li><a href="#次のゴール" title="次のゴール">次のゴール</a></li>
<li><a href="#まとめ" title="まとめ">まとめ</a></li>
</ul>
</div>
</div>
<h1 id="予告編はじめにまとめ"><span class="link-to-here-outer"><a href="#予告編はじめにまとめ" title="予告編はじめにまとめ"><span class="link-to-here">Link to<br />
here</span></a></span>予告編（はじめにまとめ）</h1>
<ul>
<li><span class="ascii">Haskell</span>界に伝わる伝説のアイテム「パーサーコンビネーター」を応用して、「タイプセーフプリキュア！」の古いソースコードを半自動で変換しました。</li>
<li>「パーサーコンビネーター」は正規表現よりいいところたくさんですが、文字列の先頭からのマッチしかできないのがつらいです。
<ul>
<li><a href="https://gitlab.com/igrep/substring-parser"><span class="ascii">substring-parser</span></a>というライブラリーを書いて、対応しました。</li>
</ul></li>
<li>パーサーコンビネーター最高！ ✌️😆✌️</li>
</ul>
<h1 id="これまでのあらすじ"><span class="link-to-here-outer"><a href="#これまでのあらすじ" title="これまでのあらすじ"><span class="link-to-here">Link to<br />
here</span></a></span>これまでのあらすじ</h1>
<h2 id="タイプセーフプリキュアとは"><span class="link-to-here-outer"><a href="#タイプセーフプリキュアとは" title="タイプセーフプリキュアとは"><span class="link-to-here">Link to<br />
here</span></a></span>「タイプセーフプリキュア！」とは？</h2>
<p><a href="https://github.com/sue445/rubicure"><span class="ascii">rubicure</span></a>や<a href="https://github.com/kan/p5-acme-prettycure"><span class="ascii">ACME::PrettyCure</span></a>のような「<a href="https://qiita.com/sue445/items/b41a4f5bdca46f1736c3">プリキュア実装</a>」の<span class="ascii">1</span>つです。<br />
詳しくはこれから挙げる過去の記事をご覧ください、と言いたいところですが、よくよく見たら「プリキュア実装」が何かを明記してる記事ではないようなので😅、ここで軽く説明しましょう。<br />
「プリキュア実装」とは一言で言うと「プリキュアやプリキュアに変身する女の子たち、変身時の台詞など諸々のプリキュアの設定をソースコードに収録したライブラリー」です。</p>
<p>例えば、今回取り上げます私の「タイプセーフプリキュア！」は（もちろん）<span class="ascii">Haskell</span>で書かれたプリキュア実装で、次のように書くことで、キュアアンジュが変身する際の台詞を取得することができます。<br />
<small>（出力されるリストは、手で整形しています）</small></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">ACME.PreCure</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="co">-- キュアアンジュには、薬師寺さあやが「ミライクリスタル・ブルー」を</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="co">-- セットした「プリハート」を使うことで変身します。</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="op">&gt;</span> transformationSpeech <span class="dt">Saaya</span> (<span class="dt">PreHeart</span> <span class="dt">MiraiCrystalBlue</span>)</a>
<a class="sourceLine" id="cb1-5" title="5">[ <span class="st">&quot;ミライクリスタル！&quot;</span></a>
<a class="sourceLine" id="cb1-6" title="6">, <span class="st">&quot;ハートキラっと！&quot;</span></a>
<a class="sourceLine" id="cb1-7" title="7">, <span class="st">&quot;は～ぎゅ～～！&quot;</span></a>
<a class="sourceLine" id="cb1-8" title="8">, <span class="st">&quot;ぎゅ～！&quot;</span></a>
<a class="sourceLine" id="cb1-9" title="9">, <span class="st">&quot;ぎゅ～～！&quot;</span></a>
<a class="sourceLine" id="cb1-10" title="10">, <span class="st">&quot;輝く未来をー、抱きしめて！&quot;</span></a>
<a class="sourceLine" id="cb1-11" title="11">, <span class="st">&quot;みんなを癒す！知恵のプリキュア！キュアアンジュ！&quot;</span></a>
<a class="sourceLine" id="cb1-12" title="12">]</a></code></pre></div>
<p><span class="ascii">GHCi</span>で上記のコードを試す場合は、下記のコードで<span class="ascii">typesafe-precure</span>と<a href="https://github.com/haskell-jp/unicode-show"><span class="ascii">unicode-show</span></a>をインストールした上で起動するとよいでしょう。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" title="1">$ <span class="ex">stack</span> build typesafe-precure unicode-show</a>
<a class="sourceLine" id="cb2-2" title="2">$ <span class="ex">stack</span> exec ghci -- -interactive-print=<span class="st">&quot;Text.Show.Unicode.uprint&quot;</span></a></code></pre></div>
<p>その他の機能や、使っている<span class="ascii">GHC</span>の拡張などについては下記の記事をご覧ください。</p>
<ul>
<li><a href="http://the.igreque.info/posts/2016/06-type-safe-precure.html"><span class="ascii">igreque : Info -&gt; Haskell</span>でプリキュアを作ってみた</a></li>
<li><a href="https://qiita.com/igrep/items/5496fa405fae00b5a737">「タイプセーフプリキュア！」を支える技術 <span class="ascii">- Qiita</span></a></li>
</ul>
<h2 id="cure-index.jsonとは"><span class="link-to-here-outer"><a href="#cure-index.jsonとは" title="cure-index.jsonとは"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">cure-index.json</span>とは？</h2>
<p>そんな「タイプセーフプリキュア！」ですが、前述の<span class="ascii">Qiita</span>の記事の最後で「<span class="ascii">typesafe-precure</span>は現状非常に冗長で、非実用的な実装になってしまっています」と述べているとおり、ほかのプリキュア実装と異なり、<del>実用性を度外視して</del>「設定の正しさ」を最優先事項とした結果、変身時の台詞や浄化技（「必殺技」ともしばしば呼ばれます）の台詞を取得するのに、非常に冗長なコードが必要になってしまいました。<br />
それではせっかく<span class="ascii">YouTube</span>やら<span class="ascii">Wikipedia</span>やら<span class="ascii">Blu-ray</span>やらを見直してせっせと集めた情報が勿体ないので、集めた情報を、コンパイル時に<span class="ascii">JSON</span>として出力することにしました。<br />
そうして生まれたのが<a href="https://github.com/igrep/typesafe-precure/blob/master/gen/cure-index.json"><span class="ascii">cure-index.json</span></a>とそれをプリティープリントした<a href="https://github.com/igrep/typesafe-precure/blob/master/gen/pretty-cure-index.json"><span class="ascii">pretty-cure-index.json</span></a>です。<br />
将来的には、<a href="http://the.igreque.info/posts/2014-12-25-unite-precure.vim.html">かつて<span class="ascii">rubicure</span>で作ったユナイトプリキュア</a>を書き直すのに使用しようかと考えています。</p>
<p>作るに当たって新たに「タイプセーフプリキュア！」のソースコードに仕込んだ仕組みについては、<a href="https://haskell.jp/blog/posts/2017/typesafe-precure2.html">去年の<span class="ascii">Haskell Advent Calendar</span>の記事</a>をご覧ください。<br />
<span class="ascii">Template Haskell</span>や<span class="ascii">GHC</span>の<code>ANN</code>という機能を濫用することで達成しました。😎</p>
<h1 id="今回のプリキュアハッカソンに向けて行ったこと"><span class="link-to-here-outer"><a href="#今回のプリキュアハッカソンに向けて行ったこと" title="今回のプリキュアハッカソンに向けて行ったこと"><span class="link-to-here">Link to<br />
here</span></a></span>今回のプリキュアハッカソンに向けて行ったこと</h1>
<p>従来の<span class="ascii">cure-index.json</span>には、最新作である「<span class="ascii">HUG</span>っと！プリキュア」と、その一つ前の作品である「キラキラ☆プリキュアアラモード」の情報しか収録されていませんでした。<br />
前述の<a href="https://haskell.jp/blog/posts/2017/typesafe-precure2.html">去年の<span class="ascii">Haskell Advent Calendar</span>の記事</a>でも触れましたが、収録のためにはプリキュアの設定の書式を大幅に変更しなければならず、面倒なのでひとまず後回しにしていたのです。</p>
<p>そこで今年のプリキュアハッカソンにて発表するのによいネタだろうと思い、あの手この手を使って、全シリーズを<span class="ascii">cure-index.json</span>に含める対応を行いました<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>🎉。</p>
<h2 id="修正前の書式"><span class="link-to-here-outer"><a href="#修正前の書式" title="修正前の書式"><span class="link-to-here">Link to<br />
here</span></a></span>🔴修正<strong>前</strong>の書式</h2>
<p>それでは、具体的にどんな修正を行ったのか紹介しましょう。<br />
修正前は、プリキュアの設定を収録した各モジュール（<code>ACME.PreCure.Textbook</code>以下にあるので、今後は「<strong>各<code>Textbook</code>モジュール</strong>」と呼びます）には<a href="https://github.com/igrep/typesafe-precure/blob/73948fb4a82baaf4e33900d77326791c7703f786/src/ACME/PreCure/Textbook/MahoGirls/Types.hs#L71">👇こんな感じの<span class="ascii">Types.hs</span>がたくさん</a>ありました。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">data</span> <span class="dt">CureMiracle</span> <span class="ot">=</span> <span class="dt">CureMiracle</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb3-2" title="2"></a>
<a class="sourceLine" id="cb3-3" title="3">transformedInstance</a>
<a class="sourceLine" id="cb3-4" title="4">  [t| CureMiracle |]</a>
<a class="sourceLine" id="cb3-5" title="5">  cureName_Miracle</a>
<a class="sourceLine" id="cb3-6" title="6">  introducesHerselfAs_Miracle</a>
<a class="sourceLine" id="cb3-7" title="7">  variation_Dia</a></code></pre></div>
<p>上記はキュアミラクルを表す型の定義と、その日本語での名前、変身時の名乗りといったプロフィールを設定しているコードです。<br />
このほかにも、プリキュアに変身する女の子の設定や、変身の際に必要な変身アイテムなどの型定義がたくさんあります。<br />
<code>transformedInstance</code>で始まる行は、<span class="ascii">Template Haskell</span>を使った、型クラスのインスタンス宣言です。<br />
<a href="https://github.com/igrep/typesafe-precure/blob/477fc23a018020fe67895e79361520016fd844bf/src/ACME/PreCure/Types/TH.hs#L151-L158"><code>transformedInstance</code>というマクロ</a>が、<a href="https://github.com/igrep/typesafe-precure/blob/477fc23a018020fe67895e79361520016fd844bf/src/ACME/PreCure/Types.hs#L15-L19"><code>Transformed</code>という型クラス</a>のインスタンスを生成することで、プリキュアを表す型と、日本語での名前、変身時の名乗りを実際に紐付けているのです。<br />
<small>（実際の日本語での名前はご覧のとおり<code>cureName_Miracle</code>といった変数に束縛されております。<a href="https://github.com/igrep/typesafe-precure/blob/73948fb4a82baaf4e33900d77326791c7703f786/src/ACME/PreCure/Textbook/MahoGirls/Words.hs#L18"><span class="ascii">Words.hs</span></a>というファイルから参照しています）</small></p>
<p>修正前はこのように、あくまでも<span class="ascii">Haskell</span>のソースコードとして、プリキュアの設定を書いていたため、このままでは<span class="ascii">cure-index.json</span>のデータとして扱うのが難しい状態でした。</p>
<h2 id="修正後の書式"><span class="link-to-here-outer"><a href="#修正後の書式" title="修正後の書式"><span class="link-to-here">Link to<br />
here</span></a></span>🔵修正<strong>後</strong>の書式</h2>
<p>そのため、今回修正した後の各<code>Textbook</code>モジュールでは、<a href="https://github.com/igrep/typesafe-precure/blob/fd5f89797372f616a551e07251c0fcd2ca1531c2/src/ACME/PreCure/Textbook/MahoGirls/Profiles.hs#L20">👇こんな感じの<span class="ascii">Profiles.hs</span></a>で、各種の設定を宣言することにしました。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="ot">transformees ::</span> [<span class="dt">Transformee</span>]</a>
<a class="sourceLine" id="cb4-2" title="2">transformees <span class="ot">=</span></a>
<a class="sourceLine" id="cb4-3" title="3">  [ mkTransformee</a>
<a class="sourceLine" id="cb4-4" title="4">      <span class="st">&quot;Cure Miracle&quot;</span></a>
<a class="sourceLine" id="cb4-5" title="5">      <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb4-6" title="6">      cureName_Miracle</a>
<a class="sourceLine" id="cb4-7" title="7">      variation_Dia</a>
<a class="sourceLine" id="cb4-8" title="8">      introducesHerselfAs_Miracle</a>
<a class="sourceLine" id="cb4-9" title="9">  , <span class="op">...</span></a>
<a class="sourceLine" id="cb4-10" title="10">  ]</a></code></pre></div>
<p><code>mkTransformee</code>関数で作っている<code>Transformee</code>型の値は、<span class="ascii">cure-index.json</span>の一部として、<span class="ascii">JSON</span>に変換する中間データです。もちろん<code>ToJSON</code>のインスタンスになっております。<br />
このように新しい各<code>Textbook</code>モジュールでは、直接<span class="ascii">Haskell</span>のソースコードとしてプリキュアの設定を書く代わりに、<strong>一旦<span class="ascii">JSON</span>に変換する用の中間データを設けることで、<span class="ascii">cure-index.json</span>に収録しやすい状態に</strong>しています。</p>
<p>こうして作られた<code>Transformee</code>などの中間データ用の値は、各<code>Textbook</code>モジュールのルートに当たるモジュールで、型クラスのインスタンス宣言を行ったり、<code>ANN</code>という機能でモジュールに紐付けられます。<br />
以下は「魔法つかいプリキュア！」のルートに当たるモジュール<a href="https://github.com/igrep/typesafe-precure/blob/477fc23a018020fe67895e79361520016fd844bf/src/ACME/PreCure/Textbook/MahoGirls.hs"><code>MahoGirls.hs</code></a>からの抜粋です。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">module</span> <span class="dt">ACME.PreCure.Textbook.MahoGirls</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" title="2"></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="kw">import</span> <span class="dt">ACME.PreCure.Textbook.MahoGirls.Profiles</span></a>
<a class="sourceLine" id="cb5-4" title="4"></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="op">...</span></a>
<a class="sourceLine" id="cb5-6" title="6"></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="ot">{-# ANN module transformees #-}</span></a>
<a class="sourceLine" id="cb5-8" title="8"><span class="op">$</span>(declareTransformees transformees)</a>
<a class="sourceLine" id="cb5-9" title="9"></a>
<a class="sourceLine" id="cb5-10" title="10"><span class="op">...</span></a></code></pre></div>
<p><code>Profiles.hs</code>で定義した<code>transformees</code>というリストを、<code>ANN</code>で<code>MahoGirls</code>モジュールに紐付け、<code>declareTransformees</code>という<span class="ascii">Template Haskell</span>のマクロで型宣言やインスタンス宣言を生成するのに使っています。<br />
<code>ANN</code>については<a href="https://haskell.jp/blog/posts/2017/typesafe-precure2.html">前回の「タイプセーフプリキュア！を支える技術」</a>をご覧ください<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>。</p>
<p>修正前との違いにおける要点を繰り返しましょう。修正後の各<code>Textbook</code>モジュールでは、</p>
<ul>
<li>プリキュアの情報を、
<ul>
<li><span class="ascii">cure-index.json</span>として書き出すためのデータ</li>
<li><span class="ascii">Template Haskell</span>で型や型クラスのインスタンスとして生成するためのデータ</li>
</ul></li>
<li><strong>両方で扱えるようにするために、専用の型の値として保存</strong></li>
</ul>
<p>するようにしています。</p>
<h2 id="どうやって修正する"><span class="link-to-here-outer"><a href="#どうやって修正する" title="どうやって修正する"><span class="link-to-here">Link to<br />
here</span></a></span>どうやって修正する？</h2>
<p>それではここからは、各<code>Textbook</code>モジュールの書式を、どうやって前節で説明したような、「修正前」から「修正後」の書式に移行したのか説明します。</p>
<p>当然、手で修正するには大変な量です。<br />
従来より「タイプセーフプリキュア！」では<span class="ascii">TV</span>シリーズ<span class="ascii">15</span>作品に加えてキュアエコーが出てくる映画もサポートしているため、各<code>Textbook</code>モジュールは<span class="ascii">16</span>作品分存在しています。<br />
すでに「修正後」の書式に移行済みの「<span class="ascii">HUG</span>っと！プリキュア」と「キラキラ☆プリキュアアラモード」を除いても、<span class="ascii">14</span>作品分書き換えないといけません。<br />
シリーズごとに定義されている型やインスタンス宣言の数にはばらつきがありますが、すべて移行してから数えてみたところ、型の数だけで<span class="ascii">313</span>個、変身や浄化技のインスタンス宣言だけで<span class="ascii">211</span>個ありました。<br />
プリキュアやプリキュアに変身する女の子、変身アイテムだけでなく、それぞれの変種も別の型として定義しているため、実際のプリキュアの数よりも遙かに多いのです😵。<br />
<span class="ascii">Vim</span>のマクロなどを駆使すれば決して人間の手でも移行できない規模ではありませんが、そこは「タイプセーフプリキュア！」です。<br />
始まって以来私が<span class="ascii">GHC</span>の拡張を始めいろいろな技術を試すための実験場としても機能していたので、ここは是非ちょっと凝ったことをしてぱーっと書き換えてみたいものでしょう😏。<br />
そこで思いついたのがパーサーコンビネーター、並びに拙作のライブラリー<a href="https://gitlab.com/igrep/substring-parser"><span class="ascii">substring-parser</span></a>だったのです💡！</p>
<h3 id="パーサーコンビネーターとは"><span class="link-to-here-outer"><a href="#パーサーコンビネーターとは" title="パーサーコンビネーターとは"><span class="link-to-here">Link to<br />
here</span></a></span>パーサーコンビネーターとは</h3>
<p><span class="ascii">substring-parser</span>の紹介の前に、パーサーコンビネーターについて簡単に紹介しておきましょう。<br />
<small>（「すでに知ってるよ！」という方はこの節は飛ばした方が良いかと思います）</small><br />
パーサーコンビネーターは、例えば正規表現のような、文字列を解析する技術の一つです。<br />
<span class="ascii">Haskell</span>の<a href="http://hackage.haskell.org/package/megaparsec"><span class="ascii">megaparsec</span></a>や<a href="http://hackage.haskell.org/package/attoparsec"><span class="ascii">attoparsec</span></a>をはじめ、多くのプログラミング言語にライブラリーとして提供されています。</p>
<p>実装はいろいろありますが、本質的にパーサーコンビネーターは「文字列を受け取って『文字列を解析した結果』と、『残りの文字列』を返す関数」として表現されます。<br />
加えて、それらを簡単に組み合わせるための<span class="ascii">API</span>を提供することで、複雑な文字列から複雑なデータ構造を抽出できるようにしてくれます。</p>
<p>実際のパーサーコンビネーターのライブラリーを単純化して例を挙げましょう。<br />
例えば、通例パーサーコンビネーターのライブラリーは<code>decimal</code>という、「<span class="ascii">10</span>進数の文字列を受け取って、整数を返すパーサー」を提供していることが多いです。</p>
<p><code>parse</code>関数に、解析したい文字列と一緒に渡すことで、「文字列を解析した結果」と、「残りの文字列」を取得することができます。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="op">&gt;</span> parse decimal <span class="st">&quot;123abc&quot;</span></a>
<a class="sourceLine" id="cb6-2" title="2">(<span class="dv">123</span>, <span class="st">&quot;abc&quot;</span>)</a></code></pre></div>
<p>👆上記の例では「解析したい文字列」として<code>123abc</code>を渡したので、パースした結果の整数<code>123</code>と、その残りの文字列<code>"abc"</code>を返しています。</p>
<p>これだけではつまらないので、ほかのパーサーの例も挙げましょう。<br />
👇今度は「文字 セミコロン <code>;</code> を受け取って、そのまま返すパーサー」です。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="op">&gt;</span> parse (char <span class="ch">&#39;;&#39;</span>) <span class="st">&quot;;aaa&quot;</span></a>
<a class="sourceLine" id="cb7-2" title="2">(<span class="ch">&#39;;&#39;</span>, <span class="st">&quot;aaa&quot;</span>)</a></code></pre></div>
<p>「パースした結果」がセミコロン <code>;</code> で、「残りの文字列」が<code>"aaa"</code>となっていますね。</p>
<p>それでは以上<span class="ascii">2</span>つのパーサーを組み合わせて、<strong><span class="ascii">10</span>進数の文字列を受け取った後、セミコロンを受け取り、整数を返すパーサー</strong>を作ってみましょう。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="op">&gt;</span> decimalAndSemicolon <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-2" title="2">    n <span class="ot">&lt;-</span> decimal</a>
<a class="sourceLine" id="cb8-3" title="3">    char <span class="ch">&#39;;&#39;</span></a>
<a class="sourceLine" id="cb8-4" title="4">    <span class="fu">return</span> n</a>
<a class="sourceLine" id="cb8-5" title="5"></a>
<a class="sourceLine" id="cb8-6" title="6"><span class="op">&gt;</span> parse decimalAndSemicolon <span class="st">&quot;123;abc&quot;</span></a>
<a class="sourceLine" id="cb8-7" title="7">(<span class="dv">123</span>, <span class="st">&quot;abc&quot;</span>) <span class="co">-- 結果にセミコロンが含まれてない点に注意</span></a></code></pre></div>
<p><span class="ascii">Haskell</span>におけるパーサーコンビネーターのライブラリーは、パーサーを<code>Monad</code>として提供することで、上記のように<code>do</code>記法でパーサーを組み合わせることができるようになっています。<br />
ここでは詳細は割愛しますが、</p>
<ol type="1">
<li><code>decimal</code>で整数をパースしたあと、</li>
<li><code>char ';'</code> で文字セミコロン <code>;</code>をパース（でも結果は無視）し</li>
<li>パースした結果として「<code>decimal</code>がパースした整数」<code>n</code>を返す</li>
</ol>
<p>という処理を行っているのがわかるでしょうか？</p>
<p>ちなみに、パーサーコンビネーターに慣れた読者の方なら、いわゆる<span class="ascii">Applicative</span>スタイルを使って、次のようにも書けると気づくでしょう。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1">decimalAndSemicolon <span class="ot">=</span> decimal <span class="op">&lt;*</span> char <span class="ch">&#39;;&#39;</span></a></code></pre></div>
<p>これならパースした結果をいちいち変数に束縛する必要もなく、より簡潔に書くことができますね！</p>
<p>パーサーコンビネーターのパワーを実感していただくために、もう一つ例を紹介します。<br />
<code>many</code>という関数にパーサーコンビネーターを渡すと、「受け取ったパーサーコンビネーターで失敗するまで繰り返しパースして、その結果をリストとして返す」パーサーが作れます。<br />
例えば先ほどの「<span class="ascii">10</span>進数の文字列を受け取った後、セミコロンを受け取り、整数を返すパーサー」から、「セミコロンが末尾に着けられた整数のリストを返すパーサー」を作ることができます。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1">parse (many decimalAndSemicolon) <span class="st">&quot;12;34;56;&quot;</span></a>
<a class="sourceLine" id="cb10-2" title="2">([<span class="dv">12</span>, <span class="dv">34</span>, <span class="dv">56</span>], <span class="st">&quot;&quot;</span>)</a></code></pre></div>
<p>このようにパーサーコンビネーターは、小さなパーサーをどんどん組み合わせることで、複雑な文字列から複雑なデータ構造を取り出すパーサーを、クールに作れるようにしてくれます。</p>
<h3 id="パーサーコンビネーターが正規表現より良いところ悪いところ"><span class="link-to-here-outer"><a href="#パーサーコンビネーターが正規表現より良いところ悪いところ" title="パーサーコンビネーターが正規表現より良いところ悪いところ"><span class="link-to-here">Link to<br />
here</span></a></span>パーサーコンビネーターが正規表現より良いところ・悪いところ</h3>
<p>そんなパーサーコンビネーターについて、正規表現と比べた場合の長所短所を明確にしておきましょう。<br />
まずはよいところから。</p>
<h4 id="パーツとしてパーサーを組み合わせるのが簡単"><span class="link-to-here-outer"><a href="#パーツとしてパーサーを組み合わせるのが簡単" title="パーツとしてパーサーを組み合わせるのが簡単"><span class="link-to-here">Link to<br />
here</span></a></span>👍パーツとしてパーサーを組み合わせるのが簡単</h4>
<p>前節で示したように、複雑なパーサーも、小さなパーサーの組み合わせからコツコツと作れるようになっています。</p>
<h4 id="パースした結果を文字列から複雑なデータ構造に割り当てるのが簡単"><span class="link-to-here-outer"><a href="#パースした結果を文字列から複雑なデータ構造に割り当てるのが簡単" title="パースした結果を文字列から複雑なデータ構造に割り当てるのが簡単"><span class="link-to-here">Link to<br />
here</span></a></span>👍パースした結果を、文字列から複雑なデータ構造に割り当てるのが簡単</h4>
<p>さっきの<code>decimal</code>は、パースした結果を直接整数<span class="ascii">(</span><code>Int</code><span class="ascii">)</span>として返していたことにお気づきでしょうか？<br />
正規表現で欲しい文字列からデータ構造を取り出したい際は、通常グルーピング機能を使うことになりますが、必ず一旦文字列として取り出すことになります。<br />
それに対してパーサーコンビネーターには、取り出した文字列を対象のデータ構造に変換する仕組みが組み込まれています。<br />
再帰的なパーサーを書いて再帰的なデータ構造に割り当てるのも楽ちんです。</p>
<h4 id="パースした結果に基づいてパーサーの挙動を変えることができる"><span class="link-to-here-outer"><a href="#パースした結果に基づいてパーサーの挙動を変えることができる" title="パースした結果に基づいてパーサーの挙動を変えることができる"><span class="link-to-here">Link to<br />
here</span></a></span>👍パースした結果に基づいて、パーサーの挙動を変えることができる</h4>
<p>今回の例にはありませんでしたが、例えばパースして取り出した整数の数だけ、続きの文字列を繰り返しパースする、といったことも簡単にできます。</p>
<p>一方、正規表現と比べて悪いところもあります。</p>
<h4 id="記述が冗長"><span class="link-to-here-outer"><a href="#記述が冗長" title="記述が冗長"><span class="link-to-here">Link to<br />
here</span></a></span>👎記述が冗長</h4>
<p>正規表現はいわゆる「外部<span class="ascii">DSL</span>」、すなわちプログラミング言語から独立した構文で提供されています。<br />
<span class="ascii">Perl</span>や<span class="ascii">Ruby</span>などの構文で言えば、<code>/.../</code>の中は別世界ですよね。<br />
パーサーコンビネーターは、本質的に「文字列を受け取って『文字列を解析した結果』と、『残りの文字列』を返す関数」であるとおり、あくまでプログラミング言語標準の関数<small>（のうち、文字列の解析に特化したもの）</small>として提供されます。「内部<span class="ascii">DSL</span>」なんて呼ばれることもあります。</p>
<p>そのため、正規表現とは異なり、あくまでもプログラミング言語の構文の中で使えなければならないため、使用できる文字列に限りがあり、必然的に長くなります。<br />
例えば先ほどの<code>many</code>は正規表現で言うところの<code>*</code><small>（<span class="ascii">0</span>回以上の量指定子）</small>とちょっと似てますが、正規表現の方が<span class="ascii">3</span>文字も短いですよね。</p>
<p>しかしながら、冗長であることはメリットにもなり得ます👍。<br />
<code>*</code>をはじめ、正規表現の特殊な機能を使うには、専用の記号（メタキャラクター）をその数だけ覚えなければなりません。<br />
片やパーサーコンビネーターは<code>many</code>のような機能も普通の関数として提供されるため、冗長である分分かりやすい名前をつけやすいのです。</p>
<h4 id="ユーザーからの入力として直接受け取ることは難しい"><span class="link-to-here-outer"><a href="#ユーザーからの入力として直接受け取ることは難しい" title="ユーザーからの入力として直接受け取ることは難しい"><span class="link-to-here">Link to<br />
here</span></a></span>👎ユーザーからの入力として直接受け取ることは難しい。</h4>
<p>パーサーコンビネーターは先ほども触れた「内部<span class="ascii">DSL</span>」です。<br />
つまり、プログラミング言語の普通の関数として使用されるものです。<br />
したがって、例えば正規表現をエディターの検索機能に利用すると言ったような、「ユーザーからの入力として受け取る」と言ったことは、不可能ではないものの、正規表現に比べれば難しいです。</p>
<h4 id="正規表現でいうところの-にあたるmanyが必ず強欲なマッチになる"><span class="link-to-here-outer"><a href="#正規表現でいうところの-にあたるmanyが必ず強欲なマッチになる" title="正規表現でいうところの-にあたるmanyが必ず強欲なマッチになる"><span class="link-to-here">Link to<br />
here</span></a></span>👎正規表現でいうところの <code>*</code> にあたる<code>many</code>が、必ず強欲なマッチになる</h4>
<p>こちらについてはちょっと難しいので後述します。</p>
<h4 id="文字列の先頭からのマッチしかできない"><span class="link-to-here-outer"><a href="#文字列の先頭からのマッチしかできない" title="文字列の先頭からのマッチしかできない"><span class="link-to-here">Link to<br />
here</span></a></span>👎文字列の先頭からのマッチしかできない</h4>
<p>この問題は、パーサーコンビネーターをベター正規表現として使おうと思った場合に、しばしばパーサー作りを面倒くさくします。<br />
パーサーコンビネーターは、原理上必ず文字列の先頭から解析するよう作られています。<br />
例えば先ほど紹介したパーサー<code>decimal</code>の場合、</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="op">&gt;</span> parse decimal <span class="st">&quot;abc123&quot;</span></a></code></pre></div>
<p>と書いても、<code>"abc123"</code>は先頭が「<span class="ascii">10</span>進数の文字列」ではないので、失敗してしまいます<small>（実際の戻り値はライブラリーによって異なります。試してみましょう！）</small>。</p>
<p>パーサーコンビネーターはそもそもの用途が<span class="ascii">0</span>からプログラミング言語などのマシンリーダブルな構文を作るところにあるので、妥当と言えば妥当な制限です。<br />
その場合は必ず、文字列を頭から読んでパースすることになるでしょうから。</p>
<p>とはいえ、これは正規表現で例えるなら、常に先頭に<code>\A</code> <span class="ascii">(</span>あるいは <code>^</code><span class="ascii">)</span>を付けなければならない、あるいは自動的に付いてしまう、というような制限です。<br />
正規表現は行の中にある一部の文字列を抽出したり置換したりするのによく使われるので、役に立たないケースがたくさん出てきてしまいます。</p>
<p>パーサーコンビネーターでこの問題に対応するには、マッチさせたい文字列に到達するまで、スキップするための処理を書かないといけません。<br />
残念ながらこれは、正規表現で言うところの <code>\A.*(本当にマッチさせたい文字列)</code> と書けばよい話<strong>ではありません</strong>。<br />
<code>\A(マッチさせたくない文字列)*(本当にマッチさせたい文字列)</code> という書き方をしなければならないのです。<br />
なぜなら、先ほど触れた「正規表現でいうところの <code>*</code> にあたる<code>many</code>が強欲なマッチになる」という問題があるためです。<br />
正規表現で言うところの<code>\A.*(本当にマッチさせたい文字列)</code>を書くと、<code>.*</code>が「マッチさせたくない文字列」だけでなく「本当にマッチさせたい文字列」までマッチしてしまい、結果肝心の「本当にマッチさせたい文字列」を扱うことができなくなってしまうのです。</p>
<h3 id="ソースコードの書き換えとsubstring-parser"><span class="link-to-here-outer"><a href="#ソースコードの書き換えとsubstring-parser" title="ソースコードの書き換えとsubstring-parser"><span class="link-to-here">Link to<br />
here</span></a></span>ソースコードの書き換えと<span class="ascii">substring-parser</span></h3>
<p>さて、今回の目的は「『タイプセーフプリキュア！』のソースコードの書式を書き換えることで、全シリーズのプリキュアの情報を<span class="ascii">cure-index.json</span>に収録する」ことでした。<br />
そのためには、各<code>Textbook</code>モジュールのソースコードにおいて<strong>途中</strong>に含まれている、プリキュアを表す型の定義や、型クラスのインスタンス宣言を集める必要があります。<br />
しかもそれらは、一つの定義が行をまたいでいたりまたいでなかったりするので、よくある行単位で処理するツールを使うのも、なかなか難しいと思います。<br />
また、抽出したいデータ構造も多様かつそこそこに複雑で、中には再帰的なデータ構造もあります。正規表現を用いてのパースも、かなり困難なことでしょう。<br />
とはいえパーサーコンビネーターを通常のとおりに使うと、これまでに述べたとおり、「文字列の先頭からしかマッチできない」という制限が、考えることを複雑にします。</p>
<p>こうした状況は今回の問題に限らず、このように、ソースコードの多くの類似箇所を書き換える場面において、しばしば発生するでしょう。<br />
そこで今回は<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>こうした問題全般に対応するライブラリーとして、<a href="https://gitlab.com/igrep/substring-parser"><span class="ascii">substring-parser</span></a>というライブラリーを作りました。</p>
<p><span class="ascii">substring-parser</span>を使えば、任意のパーサーコンビネーター<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>を<strong>文字列の中間でも</strong>マッチさせることができます。<br />
残念ながらドキュメントらしいドキュメントが全く書けてない状況ではありますが、一応動きます。<br />
<a href="https://gitlab.com/igrep/substring-parser/blob/master/test/Spec.hs"><span class="ascii">Spec.hs</span></a>が動作を知る際の参考になるかも知れません。</p>
<h4 id="substring-parserの仕組み"><span class="link-to-here-outer"><a href="#substring-parserの仕組み" title="substring-parserの仕組み"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">substring-parser</span>の仕組み</h4>
<p><span class="ascii">substring-parser</span>はどのようにして、任意のパーサーコンビネーターを文字列の中間でもマッチできるようにしているのでしょう？<br />
仕組みは単純です。<br />
引数として受け取ったパーサーを、</p>
<ol type="1">
<li>とりあえず先頭からマッチさせてみる。</li>
<li>失敗したら先頭の一文字をスキップして、次の文字からまたマッチさせてみる。</li>
</ol>
<p>という手順を繰り返すだけです。 結果として文字列の先頭にある「マッチさせたくない文字列」をスキップすることができるのです。</p>
<p>⚠️残念ながら決して効率のいい方法ではないので、真面目なパーサーを書くときはおすすめしません！<br />
あくまでも今回のような、書き捨てだけど、それなりに複雑な文字列を解析する必要がある場合のみ使うべきでしょう。</p>
<h2 id="結果できたもの"><span class="link-to-here-outer"><a href="#結果できたもの" title="結果できたもの"><span class="link-to-here">Link to<br />
here</span></a></span>結果、できたもの</h2>
<p>ここまで説明した<span class="ascii">substring-parser</span>を駆使することで、私は無事、各<code>Textbook</code>モジュールを半自動で古い書式から新しい書式に書き換えることに成功しました。<br />
<small>（残念ながら古い<code>Textbook</code>モジュールには存在しない情報を補ったり、体裁を整えたりする必要があったため、完全に自動で書き換えられたわけではありません）</small><br />
<a href="https://github.com/igrep/typesafe-precure/pull/25"><span class="ascii">typesafe-precure#25</span></a>という大きな<span class="ascii">Pull request</span>に、移行したもののほぼすべてが刻まれています。</p>
<p>なお、上記の<span class="ascii">Pull request</span>では消してしまってますが、実際に実行した、移行用スクリプトは<a href="https://github.com/igrep/typesafe-precure/blob/ed038aa57a4df6b1fcc23fb071253888ebd7d477/app/migrate2cure-index.hs"><span class="ascii">typesafe-precure/app/migrate2cure-index.hs</span></a>にあります。<br />
ご興味のある方はご覧になってみてください。</p>
<p>また、もう少し小さいサンプルとして、プリキュアハッカソンの成果発表でデモをした時点のコミットも載せておきます。<br />
👇のコマンドを実行すれば、<a href="https://github.com/igrep/typesafe-precure/blob/73948fb4a82baaf4e33900d77326791c7703f786/app/migrate2cure-index.hs#L101-L118">こちらのコミット時点のパーサー</a>で、<a href="https://github.com/igrep/typesafe-precure/blob/73948fb4a82baaf4e33900d77326791c7703f786/src/ACME/PreCure/Textbook/Dokidoki/Types.hs#L19-L23">同時点の<span class="ascii">Types.hs</span></a>から、<span class="ascii">cure-index.json</span>で使用する<a href="https://github.com/igrep/typesafe-precure/blob/73948fb4a82baaf4e33900d77326791c7703f786/src/ACME/PreCure/Index/Types.hs#L44-L46"><code>Girl</code></a>という型の値を取り出すことができます！</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="op">&gt;</span> git clone https<span class="op">://</span>github<span class="op">.</span>com<span class="op">/</span>igrep<span class="op">/</span>typesafe<span class="op">-</span>precure</a>
<a class="sourceLine" id="cb12-2" title="2"><span class="op">&gt;</span> cd typesafe<span class="op">-</span>precure</a>
<a class="sourceLine" id="cb12-3" title="3"><span class="op">&gt;</span> git checkout 73948fb4a82baaf4e33900d77326791c7703f786</a>
<a class="sourceLine" id="cb12-4" title="4"><span class="op">&gt;</span> stack build <span class="op">:</span>migrate2cure<span class="op">-</span><span class="fu">index</span></a>
<a class="sourceLine" id="cb12-5" title="5"><span class="op">&gt;</span> stack exec migrate2cure<span class="op">-</span><span class="fu">index</span></a>
<a class="sourceLine" id="cb12-6" title="6"></a>
<a class="sourceLine" id="cb12-7" title="7"><span class="op">...</span> 略 <span class="op">...</span></a>
<a class="sourceLine" id="cb12-8" title="8"></a>
<a class="sourceLine" id="cb12-9" title="9"><span class="co">-- src/ACME/PreCure/Textbook/Dokidoki --</span></a>
<a class="sourceLine" id="cb12-10" title="10"><span class="dt">Girl</span> {girlId <span class="ot">=</span> <span class="st">&quot;\&quot;Mana\&quot;&quot;</span>, girlNameEn <span class="ot">=</span> <span class="st">&quot;\&quot;Mana\&quot; ++ error \&quot;Need family name!\&quot;&quot;</span>, girlNameJa <span class="ot">=</span> <span class="st">&quot;girlName&quot;</span>}</a>
<a class="sourceLine" id="cb12-11" title="11"><span class="dt">Girl</span> {girlId <span class="ot">=</span> <span class="st">&quot;\&quot;Rikka\&quot;&quot;</span>, girlNameEn <span class="ot">=</span> <span class="st">&quot;\&quot;Rikka\&quot; ++ error \&quot;Need family name!\&quot;&quot;</span>, girlNameJa <span class="ot">=</span> <span class="st">&quot;girlName&quot;</span>}</a>
<a class="sourceLine" id="cb12-12" title="12"><span class="dt">Girl</span> {girlId <span class="ot">=</span> <span class="st">&quot;\&quot;Alice\&quot;&quot;</span>, girlNameEn <span class="ot">=</span> <span class="st">&quot;\&quot;Alice\&quot; ++ error \&quot;Need family name!\&quot;&quot;</span>, girlNameJa <span class="ot">=</span> <span class="st">&quot;girlName&quot;</span>}</a>
<a class="sourceLine" id="cb12-13" title="13"><span class="dt">Girl</span> {girlId <span class="ot">=</span> <span class="st">&quot;\&quot;Makoto\&quot;&quot;</span>, girlNameEn <span class="ot">=</span> <span class="st">&quot;\&quot;Makoto\&quot; ++ error \&quot;Need family name!\&quot;&quot;</span>, girlNameJa <span class="ot">=</span> <span class="st">&quot;girlName&quot;</span>}</a>
<a class="sourceLine" id="cb12-14" title="14"><span class="dt">Girl</span> {girlId <span class="ot">=</span> <span class="st">&quot;\&quot;Aguri\&quot;&quot;</span>, girlNameEn <span class="ot">=</span> <span class="st">&quot;\&quot;Aguri\&quot; ++ error \&quot;Need family name!\&quot;&quot;</span>, girlNameJa <span class="ot">=</span> <span class="st">&quot;girlName&quot;</span>}</a></code></pre></div>
<h1 id="その他の似たソリューション"><span class="link-to-here-outer"><a href="#その他の似たソリューション" title="その他の似たソリューション"><span class="link-to-here">Link to<br />
here</span></a></span>その他の似たソリューション</h1>
<p>今回は、自前で作ったライブラリーと一から書いたパーサーを組み合わせることで「ソースコードの多くの類似箇所を書き換える」問題に対応しましたが、似たようなことを行うツールはほかにもあります。<br />
いずれも私はほぼ使ったことがないので詳しい解説はできませんが、軽く紹介しておきます。</p>
<h2 id="codemod"><span class="link-to-here-outer"><a href="#codemod" title="codemod"><span class="link-to-here">Link to<br />
here</span></a></span><a href="https://github.com/facebook/codemod"><span class="ascii">codemod</span></a></h2>
<p><span class="ascii">Facebook</span>製の一括置換ツールです。指定したディレクトリーのファイル群を、正規表現で一括置換できます。<br />
ここまで書くと<code>perl</code>や<code>sed</code>、<code>awk</code>などで十分できそうにも聞こえますが、修正前後の状態を色つきで見ながら対話的に修正できるそうです。<br />
正規表現での単純な修正が気に入らなければ、その場で該当箇所だけをエディタで修正できるとのこと。<br />
<span class="ascii">Python 2</span>に依存しているのがちょっとつらいところでしょうか…😨。</p>
<h2 id="jscodeshift"><span class="link-to-here-outer"><a href="#jscodeshift" title="jscodeshift"><span class="link-to-here">Link to<br />
here</span></a></span><a href="https://github.com/facebook/jscodeshift"><span class="ascii">jscodeshift</span></a></h2>
<p>同じく<span class="ascii">Facebook</span>が作った、名前のとおり<span class="ascii">JavaScript</span>に特化したソースコードの修正ツールです。<br />
こちらは正規表現は使用せず、「<span class="ascii">Transform module</span>」と呼ばれる、<span class="ascii">JavaScript</span>の<span class="ascii">AST</span>を変換するための専用のスクリプトを実行することで修正するそうです。<br />
様々な状況に特化した「<span class="ascii">Transform module</span>」を別パッケージとしても提供しているようです。</p>
<p>📝以上の<span class="ascii">2</span>つについては「<a href="https://www.webprofessional.jp/getting-started-with-codemods/"><span class="ascii">JavaScript</span>疲れに効く！ <span class="ascii">codemod</span>と<span class="ascii">JSCodeshift</span>でリファクタリングが捗る <span class="ascii">- WPJ</span></a>」も参考にしました。</p>
<h2 id="refactorio"><span class="link-to-here-outer"><a href="#refactorio" title="refactorio"><span class="link-to-here">Link to<br />
here</span></a></span><a href="https://github.com/SuperpowersCorp/refactorio"><span class="ascii">refactorio</span></a></h2>
<p><a href="https://www.superpowerscorp.com/"><span class="ascii">SuperPowers Corp</span></a>という会社が開発中の、<span class="ascii">lens</span>をはじめとする<span class="ascii">Haskell</span>のパワーを集大成させた、ソースコードの一括置換ツールです。<br />
<code>ByteString -&gt; ByteString</code>という型の<span class="ascii">Haskell</span>の関数を渡すことで、指定したディレクトリーのファイルすべてに対して関数を適用し、書き換えます。</p>
<p>加えて、<code>--haskell</code>や<code>--html</code>、<code>--javascript</code>など、各言語に特化したオプションを渡すと、各言語のソースコードを修正する<span class="ascii">lens</span>ベースの<span class="ascii">module</span>を<span class="ascii">import</span>した状態で、関数を作れるようにしてくれます。<br />
具体的には、例えば<code>--haskell</code>オプションを渡すと、<a href="https://hackage.haskell.org/package/haskell-src-exts"><span class="ascii">haskell-src-exts</span></a>と<a href="https://hackage.haskell.org/package/haskell-src-exts-prisms"><span class="ascii">haskell-src-exts-prisms</span></a>パッケージのモジュールを<span class="ascii">import</span>することで、<span class="ascii">Haskell</span>の<span class="ascii">AST</span>の各トークンに対応した<code>Prism</code>などが使えるようになります。</p>
<p>後は<a href="https://www.stackage.org/haddock/lts-12.8/lens-4.16.1/Data-Data-Lens.html#v:biplate"><code>biplate</code></a>など<span class="ascii">lens</span>ライブラリーのコンビネーターと組み合わせれば、一気に<span class="ascii">Haskell</span>のソースコードを編集することができます。 「任意のデータ構造に対する<span class="ascii">jQuery</span>」とも言われる<span class="ascii">lens</span>ライブラリーのパワーを存分に生かしたツールなのです。</p>
<p>残念なところは、今でも開発中である点と、<span class="ascii">lens</span>ライブラリーに習熟していなければ使いこなせないという点でしょうか。<br />
よく使う<code>Lens</code>型や<code>Prism</code>型だけでなく、<code>Traversal</code>も使えなければなりません。<br />
特に<a href="https://github.com/SuperpowersCorp/refactorio#haskell-via-haskell-src-exts-and-haskell-src-exts-prisms">サンプル</a>で紹介されているような<a href="https://www.stackage.org/haddock/lts-12.8/lens-4.16.1/Data-Data-Lens.html#v:biplate"><code>biplate</code></a>を使った場合において、指定した<code>Prism</code>がマッチしなかった場合、何事もなかったかのようにソースが書き換えられないため、デバッグが面倒なところもつらいです。</p>
<h1 id="次のゴール"><span class="link-to-here-outer"><a href="#次のゴール" title="次のゴール"><span class="link-to-here">Link to<br />
here</span></a></span>次のゴール</h1>
<p>「タイプセーフプリキュア！」の開発は、これからもプリキュアハッカソンの前後とプリキュア<span class="ascii">Advent Calendar</span>の前後を中心に、今後も続ける予定です。<br />
先にも触れましたが、次回は今回完成させた<span class="ascii">cure-index.json</span>を使用することで、<a href="http://the.igreque.info/posts/2014-12-25-unite-precure.vim.html">かつて<span class="ascii">rubicure</span>で作ったユナイトプリキュア</a>を「ユナイトプリキュア」を「ディナイトプリキュア」として書き直すかも知れません。<br />
ただ、それ以外にももうちょっと<span class="ascii">Haskell</span>で遊びたいことがあるので、後回しにするかも知れません。<br />
<span class="ascii">Vim script</span>、あんまり書きたくないんですよね…😥</p>
<h1 id="まとめ"><span class="link-to-here-outer"><a href="#まとめ" title="まとめ"><span class="link-to-here">Link to<br />
here</span></a></span>まとめ</h1>
<ul>
<li><span class="ascii">Haskell</span>界に伝わる伝説のアイテム「パーサーコンビネーター」を応用して、「タイプセーフプリキュア！」の古いソースコードを半自動で変換しました。</li>
<li>「パーサーコンビネーター」は正規表現よりいいところたくさんですが、文字列の先頭からのマッチしかできないのがつらいです。
<ul>
<li><a href="https://gitlab.com/igrep/substring-parser"><span class="ascii">substring-parser</span></a>というライブラリーを書いて、対応しました。</li>
</ul></li>
<li>パーサーコンビネーター最高！ ✌️😆✌️</li>
</ul>
<p>それではこの秋もパーサーコンビネーターで<span class="ascii">Happy Haskell Hacking!!</span>✌️✌️✌️</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>プリキュアハッカソンは「ハッカソン」の名を冠してはいるものの、実態としてはプリキュアの映画を観ながら好き勝手に開発するというゆるい会です。<br />
また、そもそもそれほど時間もないので、私は当日の<span class="ascii">3</span>～<span class="ascii">4</span>週間ほど前から今回の対応を始めておりました。「今回のプリキュアハッカソンに<strong>向けて</strong>行ったこと」なる見出しなのは、そのためです。<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>当時は各<code>Textbook</code>モジュールの<code>Types.hs</code>というファイルで<code>ANN</code>や<code>declareTransformees</code>などを使っていましたが、現在は「ルートに当たるモジュール」で行うことにしました。ファイル数を減らすのと、<span class="ascii">export</span>する識別子を型に絞ることで、<code>transformeesHugtto</code>のような、あまりかっこよくない識別子を隠す、というのがその目的です。<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>実際には、前職時代に同様の問題に遭遇した際作成しました。今後も必要になったときにちょっとずつ開発していく予定です。<a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p>一応<a href="http://hackage.haskell.org/package/parsers"><code>parsers</code></a>パッケージを使って様々なパーサーコンビネーターのライブラリーをサポートするように作りましたが、現状<a href="http://hackage.haskell.org/package/attoparsec"><code>attoparsec</code></a>でのみテストしています。用途を考えれば多分十分じゃないかと思っています。<a href="#fnref4" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2018/tech-book-fest-5.html" lang="ja">技術書典 5 での Haskell 関連サークルのまとめ</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2018/derive-json-no-prefix.html" style="margin-left: auto;" lang="ja">deriveJsonNoPrefixをリリースしました</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>

</feed>
